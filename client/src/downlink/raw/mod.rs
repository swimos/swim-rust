// Copyright 2015-2020 SWIM.AI inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use super::*;
use common::sink::item::ItemSender;
use futures::task::{Context, Poll};
use futures::StreamExt;
use std::sync::Arc;

#[cfg(test)]
pub mod tests;

#[derive(Debug, Clone)]
pub struct Sender<S> {
    /// A sink for local actions (sets, insertions, etc.)
    set_sink: S,
    /// The task running the downlink.
    task: Arc<DownlinkTask>,
}

impl<S> Sender<S> {
    pub(in crate::downlink) fn new(set_sink: S, task: Arc<DownlinkTask>) -> Sender<S> {
        Sender { set_sink, task }
    }

    pub fn same_sender(&self, other: &Self) -> bool {
        Arc::ptr_eq(&self.task, &other.task)
    }
}

impl<T> Sender<mpsc::Sender<T>> {
    pub async fn send(&mut self, value: T) -> Result<(), mpsc::error::SendError<T>> {
        self.set_sink.send(value).await
    }
}

impl<'a, T> ItemSink<'a, T> for Sender<mpsc::Sender<T>>
where
    T: Send + 'static,
{
    type Error = DownlinkError;
    type SendFuture = MpscSend<'a, T, DownlinkError>;

    fn send_item(&'a mut self, value: T) -> Self::SendFuture {
        let send: MpscSend<'a, T, DownlinkError> = MpscSend::new(&mut self.set_sink, value);
        send
    }
}

impl<T> Sender<watch::Sender<T>> {
    pub fn send(&mut self, value: T) -> Result<(), watch::error::SendError<T>> {
        self.set_sink.broadcast(value)
    }
}

pub struct Receiver<R> {
    /// A stream of events generated by the downlink.
    pub(in crate::downlink) event_stream: R,
    _task: Arc<DownlinkTask>,
}

impl<R: Unpin> Unpin for Receiver<R> {}

impl<R: Stream + Unpin> Stream for Receiver<R> {
    type Item = R::Item;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        self.get_mut().event_stream.poll_next_unpin(cx)
    }
}

/// Type containing the components of a running downlink.
pub struct RawDownlink<S, R> {
    pub(in crate::downlink) sender: S,
    pub(in crate::downlink) receiver: R,
    pub(in crate::downlink) task: DownlinkTask,
}

impl<S, R> RawDownlink<S, R> {
    //Private as downlinks should only be created by methods in this module and its children.
    pub(in crate::downlink) fn new(
        set_sink: S,
        event_stream: R,
        task: DownlinkTask,
    ) -> RawDownlink<S, R> {
        RawDownlink {
            receiver: event_stream,
            sender: set_sink,
            task,
        }
    }

    pub fn split(self) -> (Sender<S>, Receiver<R>) {
        let RawDownlink {
            sender,
            receiver,
            task,
        } = self;
        let send_part = Sender {
            set_sink: sender,
            task: Arc::new(task),
        };
        let receive_part = Receiver {
            event_stream: receiver,
            _task: send_part.task.clone(),
        };
        (send_part, receive_part)
    }
}

/// Asynchronously create a new downlink from a stream of input events, writing to a sink of
/// commands.
pub(in crate::downlink) fn create_downlink<Err, M, A, State, Updates, Commands>(
    init: State,
    update_stream: Updates,
    cmd_sink: Commands,
    buffer_size: usize,
) -> RawDownlink<mpsc::Sender<A>, mpsc::Receiver<Event<State::Ev>>>
where
    M: Send + 'static,
    A: Send + 'static,
    State: StateMachine<M, A> + Send + 'static,
    State::Ev: Send + 'static,
    State::Cmd: Send + 'static,
    Err: Into<DownlinkError> + Send + 'static,
    Updates: Stream<Item = Message<M>> + Send + 'static,
    Commands: ItemSender<Command<State::Cmd>, Err> + Send + 'static,
{
    let model = Model::new(init);
    let (act_tx, act_rx) = mpsc::channel::<A>(buffer_size);
    let (event_tx, event_rx) = mpsc::channel::<Event<State::Ev>>(buffer_size);

    let event_sink = item::for_mpsc_sender::<_, DownlinkError>(event_tx);

    let (stopped_tx, stopped_rx) = watch::channel(None);

    // The task that maintains the internal state of the lane.
    let lane_task = make_downlink_task(
        model,
        make_operation_stream(update_stream),
        act_rx.fuse(),
        cmd_sink,
        event_sink,
        stopped_tx,
    );

    let join_handle = tokio::task::spawn(lane_task);

    let dl_task = DownlinkTask {
        join_handle,
        stop_await: stopped_rx,
    };

    RawDownlink::new(act_tx, event_rx, dl_task)
}

#[derive(Debug)]
pub(in crate::downlink) struct DownlinkTask {
    join_handle: JoinHandle<Result<(), DownlinkError>>,
    pub(in crate::downlink) stop_await: watch::Receiver<Option<Result<(), DownlinkError>>>,
}

impl DownlinkTask {
    pub(in crate::downlink) fn new(
        join_handle: JoinHandle<Result<(), DownlinkError>>,
        stop_await: watch::Receiver<Option<Result<(), DownlinkError>>>,
    ) -> DownlinkTask {
        DownlinkTask {
            join_handle,
            stop_await,
        }
    }
}

/// A task that consumes the operations applied to the downlink, updates the state and
/// forwards events and commands to a pair of output sinks.
pub(in crate::downlink) async fn make_downlink_task<
    State,
    EC,
    EE,
    M,
    A,
    Ops,
    Acts,
    Commands,
    Events,
>(
    mut model: Model<State>,
    ops: Ops,
    acts: Acts,
    mut cmd_sink: Commands,
    mut ev_sink: Events,
    stop_event: watch::Sender<Option<Result<(), DownlinkError>>>,
) -> Result<(), DownlinkError>
where
    EC: Into<DownlinkError>,
    EE: Into<DownlinkError>,
    State: StateMachine<M, A>,
    Ops: FusedStream<Item = Operation<M, A>> + Send + 'static,
    Acts: FusedStream<Item = A> + Send + 'static,
    Commands: for<'b> ItemSink<'b, Command<State::Cmd>, Error = EC>,
    Events: for<'b> ItemSink<'b, Event<State::Ev>, Error = EE>,
{
    pin_mut!(ops);
    pin_mut!(acts);
    let mut ops_str: Pin<&mut Ops> = ops;
    let mut act_str: Pin<&mut Acts> = acts;

    let mut read_act = false;

    let result = loop {
        let next_op = if model.state == DownlinkState::Synced {
            if read_act {
                read_act = false;
                select_biased! {
                    act_op = act_str.next() => act_op.map(Operation::Action),
                    upd_op = ops_str.next() => upd_op,
                }
            } else {
                read_act = true;
                select_biased! {
                    upd_op = ops_str.next() => upd_op,
                    act_op = act_str.next() => act_op.map(Operation::Action),
                }
            }
        } else {
            ops_str.next().await
        };

        if let Some(op) = next_op {
            let Response {
                event,
                command,
                error,
                terminate,
            } = StateMachine::handle_operation(&mut model, op);
            let result = match (event, command) {
                (Some(ev), Some(cmd)) => match ev_sink.send_item(ev).await {
                    Ok(()) => cmd_sink.send_item(cmd).await.map_err(|e| e.into()),
                    Err(e) => Err(e.into()),
                },
                (Some(event), _) => ev_sink.send_item(event).await.map_err(|e| e.into()),
                (_, Some(command)) => cmd_sink.send_item(command).await.map_err(|e| e.into()),
                _ => Ok(()),
            };

            if error.is_some() {
                break Err(DownlinkError::TransitionError); //TODO Handle this properly.
            } else if terminate || result.is_err() {
                break result;
            }
        } else {
            break Err(DownlinkError::OperationStreamEnded);
        }
    };
    let _ = stop_event.broadcast(Some(result));
    result
}

/// Combines together updates received from the Warp connection  and the stop signal
/// into a single stream.
pub(in crate::downlink) fn make_operation_stream<M, A, Upd>(
    updates: Upd,
) -> impl FusedStream<Item = Operation<M, A>> + Send + 'static
where
    M: Send + 'static,
    A: Send + 'static,
    Upd: Stream<Item = Message<M>> + Send + 'static,
{
    let upd_operations = updates.map(Operation::Message);

    let init = stream::once(future::ready(Operation::Start));

    init.chain(upd_operations).fuse()
}
