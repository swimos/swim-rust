#![feature(prelude_import)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
extern crate proc_macro;
extern crate proc_macro2;
#[macro_use]
extern crate quote;
#[macro_use]
extern crate syn;
use proc_macro::TokenStream;
use syn::DeriveInput;
use crate::parser::{Context, Parser};
#[allow(dead_code, unused_imports, unused_variables)]
mod parser {
    use std::cell::RefCell;
    use std::fmt::Display;
    use proc_macro2::{Ident, Span, TokenStream};
    use quote::ToTokens;
    use syn;
    use syn::DeriveInput;
    use syn::punctuated::Punctuated;
    use syn::spanned::Spanned;
    use syn::token::Token;
    use std::process::id;
    pub struct Parser<'a> {
        pub ident: syn::Ident,
        pub data: TypeContents<'a>,
        pub original: &'a DeriveInput,
    }
    pub struct Variant<'a> {
        pub ident: syn::Ident,
        pub style: CompoundType,
        pub fields: Vec<Field<'a>>,
        pub original: &'a syn::Variant,
    }
    pub struct Field<'a> {
        pub member: syn::Member,
        pub ty: &'a syn::Type,
        pub original: &'a syn::Field,
        pub name: String,
        pub ident: Ident,
    }
    impl<'p> ToTokens for Field<'p> {
        fn to_tokens(&self, tokens: &mut TokenStream) {
            let ident = self.ident.to_string();
            let r = {
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                    &["", ": ref ", ","],
                    &match (&self.name, &ident) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                        ],
                    },
                ));
                res
            };
            ident.to_tokens(tokens);
        }
    }
    pub enum TypeContents<'a> {
        Enum(Vec<Variant<'a>>),
        Struct(CompoundType, Vec<Field<'a>>),
    }
    pub enum CompoundType {
        Struct,
        Tuple,
        NewType,
        Unit,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for CompoundType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&CompoundType::Struct,) => {
                    let mut debug_trait_builder = f.debug_tuple("Struct");
                    debug_trait_builder.finish()
                }
                (&CompoundType::Tuple,) => {
                    let mut debug_trait_builder = f.debug_tuple("Tuple");
                    debug_trait_builder.finish()
                }
                (&CompoundType::NewType,) => {
                    let mut debug_trait_builder = f.debug_tuple("NewType");
                    debug_trait_builder.finish()
                }
                (&CompoundType::Unit,) => {
                    let mut debug_trait_builder = f.debug_tuple("Unit");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CompoundType {
        #[inline]
        fn clone(&self) -> CompoundType {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for CompoundType {}
    pub struct Context {
        errors: RefCell<Option<Vec<syn::Error>>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for Context {
        #[inline]
        fn default() -> Context {
            Context {
                errors: ::core::default::Default::default(),
            }
        }
    }
    pub enum Fragment {
        Expr(TokenStream),
        Block(TokenStream),
    }
    pub struct TokenBlock(pub Fragment);
    impl ToTokens for TokenBlock {
        fn to_tokens(&self, out: &mut TokenStream) {
            match &self.0 {
                Fragment::Expr(expr) => expr.to_tokens(out),
                Fragment::Block(block) => block.to_tokens(out),
            }
        }
    }
    impl Context {
        pub fn error_spanned_by<A: ToTokens, T: Display>(&self, obj: A, msg: T) {
            self.errors
                .borrow_mut()
                .as_mut()
                .unwrap()
                .push(syn::Error::new_spanned(obj.into_token_stream(), msg));
        }
        pub fn new() -> Context {
            Context {
                errors: RefCell::new(Some(Vec::new())),
            }
        }
        pub fn check(self) -> Result<(), Vec<syn::Error>> {
            let errors = self.errors.borrow_mut().take().unwrap();
            match errors.len() {
                0 => Ok(()),
                _ => Err(errors),
            }
        }
    }
    impl<'p> Parser<'p> {
        pub fn from_ast(context: &Context, input: &'p syn::DeriveInput) -> Option<Parser<'p>> {
            let data = match &input.data {
                syn::Data::Enum(data) => {
                    context.error_spanned_by(input, "Enums not implemented yet");
                    return None;
                }
                syn::Data::Struct(data) => {
                    let (style, fields) = struct_from_ast(context, &data.fields);
                    TypeContents::Struct(style, fields)
                }
                syn::Data::Union(_) => {
                    context.error_spanned_by(input, "Unions not implemented yet");
                    return None;
                }
            };
            let item = Parser {
                ident: input.ident.clone(),
                data,
                original: input,
            };
            Some(item)
        }
        pub fn field_assertions(self) -> Vec<Field<'p>> {
            match self.data {
                TypeContents::Struct(CompoundType::Struct, fields) => fields,
                _ => ::std::rt::begin_panic("not implemented"),
            }
        }
        pub fn gen(self) -> Fragment {
            match &self.data {
                TypeContents::Enum(variants) => ::std::rt::begin_panic("not implemented"),
                TypeContents::Struct(CompoundType::Struct, fields) => {
                    let result: TokenStream = fields
                        .iter()
                        .map(|field| {
                            let span = field.original.clone().span();
                            let func = {
                                let mut _s = ::quote::__private::TokenStream::new();
                                let _span: ::quote::__private::Span = span;
                                ::quote::__private::push_ident(&mut _s, _span, "_serde");
                                ::quote::__private::push_colon2(&mut _s, _span);
                                ::quote::__private::push_ident(&mut _s, _span, "ser");
                                ::quote::__private::push_colon2(&mut _s, _span);
                                ::quote::__private::push_ident(&mut _s, _span, "SerializeStruct");
                                ::quote::__private::push_colon2(&mut _s, _span);
                                ::quote::__private::push_ident(&mut _s, _span, "serialize_field");
                                _s
                            };
                            let key_expr = field.original.clone().ident.unwrap().to_string();
                            let field_expr: Option<&syn::ExprPath> = None;
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                let _span: ::quote::__private::Span =
                                    ::quote::__private::Span::call_site();
                                ::quote::__private::push_ident(&mut _s, _span, "try");
                                ::quote::__private::push_bang(&mut _s, _span);
                                _s.extend({
                                    let mut g = ::quote::__private::Group::new(
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            let _span: ::quote::__private::Span = _span;
                                            ::quote::ToTokens::to_tokens(&func, &mut _s);
                                            _s.extend({
                                                let mut g = ::quote::__private::Group::new(
                                                    ::quote::__private::Delimiter::Parenthesis,
                                                    {
                                                        let mut _s =
                                                            ::quote::__private::TokenStream::new();
                                                        let _span: ::quote::__private::Span = _span;
                                                        ::quote::__private::push_and(
                                                            &mut _s, _span,
                                                        );
                                                        ::quote::__private::push_ident(
                                                            &mut _s, _span, "mut",
                                                        );
                                                        ::quote::__private::push_ident(
                                                            &mut _s,
                                                            _span,
                                                            "__serde_state",
                                                        );
                                                        ::quote::__private::push_comma(
                                                            &mut _s, _span,
                                                        );
                                                        ::quote::ToTokens::to_tokens(
                                                            &key_expr, &mut _s,
                                                        );
                                                        ::quote::__private::push_comma(
                                                            &mut _s, _span,
                                                        );
                                                        ::quote::ToTokens::to_tokens(
                                                            &field_expr,
                                                            &mut _s,
                                                        );
                                                        _s
                                                    },
                                                );
                                                g.set_span(_span);
                                                Some(::quote::__private::TokenTree::from(g))
                                            });
                                            _s
                                        },
                                    );
                                    g.set_span(_span);
                                    Some(::quote::__private::TokenTree::from(g))
                                });
                                ::quote::__private::push_semi(&mut _s, _span);
                                _s
                            }
                        })
                        .collect();
                    Fragment::Block(result)
                }
                TypeContents::Struct(CompoundType::Tuple, fields)
                | TypeContents::Struct(CompoundType::NewType, fields) => {
                    ::std::rt::begin_panic("not implemented")
                }
                TypeContents::Struct(CompoundType::Unit, _) => {
                    ::std::rt::begin_panic("not implemented")
                }
            }
        }
    }
    fn struct_from_ast<'a>(
        context: &Context,
        fields: &'a syn::Fields,
    ) -> (CompoundType, Vec<Field<'a>>) {
        match fields {
            syn::Fields::Named(fields) => (
                CompoundType::Struct,
                fields_from_ast(context, &fields.named),
            ),
            syn::Fields::Unnamed(fields) if fields.unnamed.len() == 1 => (
                CompoundType::NewType,
                fields_from_ast(context, &fields.unnamed),
            ),
            syn::Fields::Unnamed(fields) => (
                CompoundType::Tuple,
                fields_from_ast(context, &fields.unnamed),
            ),
            syn::Fields::Unit => (CompoundType::Unit, Vec::new()),
        }
    }
    fn fields_from_ast<'a>(
        context: &Context,
        fields: &'a Punctuated<syn::Field, ::syn::token::Comma>,
    ) -> Vec<Field<'a>> {
        fields
            .iter()
            .enumerate()
            .map(|(index, original_field)| {
                let field = Field {
                    member: match &original_field.ident {
                        Some(ident) => syn::Member::Named(ident.clone()),
                        None => syn::Member::Unnamed(index.into()),
                    },
                    ty: &original_field.ty,
                    original: original_field,
                    name: match &original_field.ident {
                        Some(ident) => ident.to_string().trim_start_matches("r#").to_owned(),
                        None => index.to_string(),
                    },
                    ident: Ident::new(
                        &{
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["__self_0_"],
                                &match (&index,) {
                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                        arg0,
                                        ::core::fmt::Display::fmt,
                                    )],
                                },
                            ));
                            res
                        },
                        Span::call_site(),
                    ),
                };
                field
            })
            .collect()
    }
}
#[proc_macro_derive(Form)]
pub fn derive_form(input: TokenStream) -> TokenStream {
    let input = match ::syn::parse_macro_input::parse::<DeriveInput>(input) {
        ::syn::export::Ok(data) => data,
        ::syn::export::Err(err) => {
            return ::syn::export::TokenStream::from(err.to_compile_error());
        }
    };
    expand_derive_serialize(&input)
        .unwrap_or_else(to_compile_errors)
        .into()
}
fn expand_derive_serialize(
    input: &syn::DeriveInput,
) -> Result<proc_macro2::TokenStream, Vec<syn::Error>> {
    let context = Context::new();
    let parser = match Parser::from_ast(&context, input) {
        Some(cont) => cont,
        None => return Err(context.check().unwrap_err()),
    };
    context.check()?;
    let ident = parser.ident.clone();
    let field_assertions = parser.field_assertions();
    let q = {
        let mut _s = ::quote::__private::TokenStream::new();
        let _span: ::quote::__private::Span = ::quote::__private::Span::call_site();
        ::quote::__private::push_ident(&mut _s, _span, "use");
        ::quote::__private::push_ident(&mut _s, _span, "common");
        ::quote::__private::push_ident(&mut _s, _span, "as");
        ::quote::__private::push_ident(&mut _s, _span, "_common");
        ::quote::__private::push_semi(&mut _s, _span);
        ::quote::__private::push_pound(&mut _s, _span);
        _s.extend({
            let mut g = ::quote::__private::Group::new(::quote::__private::Delimiter::Bracket, {
                let mut _s = ::quote::__private::TokenStream::new();
                let _span: ::quote::__private::Span = _span;
                ::quote::__private::push_ident(&mut _s, _span, "automatically_derived");
                _s
            });
            g.set_span(_span);
            Some(::quote::__private::TokenTree::from(g))
        });
        ::quote::__private::push_pound(&mut _s, _span);
        _s.extend({
            let mut g = ::quote::__private::Group::new(::quote::__private::Delimiter::Bracket, {
                let mut _s = ::quote::__private::TokenStream::new();
                let _span: ::quote::__private::Span = _span;
                ::quote::__private::push_ident(&mut _s, _span, "allow");
                _s.extend({
                    let mut g = ::quote::__private::Group::new(
                        ::quote::__private::Delimiter::Parenthesis,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            let _span: ::quote::__private::Span = _span;
                            ::quote::__private::push_ident(&mut _s, _span, "unused_qualifications");
                            _s
                        },
                    );
                    g.set_span(_span);
                    Some(::quote::__private::TokenTree::from(g))
                });
                _s
            });
            g.set_span(_span);
            Some(::quote::__private::TokenTree::from(g))
        });
        ::quote::__private::push_ident(&mut _s, _span, "impl");
        ::quote::__private::push_ident(&mut _s, _span, "form_model");
        ::quote::__private::push_colon2(&mut _s, _span);
        ::quote::__private::push_ident(&mut _s, _span, "Form");
        ::quote::__private::push_ident(&mut _s, _span, "for");
        ::quote::ToTokens::to_tokens(&ident, &mut _s);
        _s . extend ( { let mut g = :: quote :: __private :: Group :: new ( :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new ( ) ; let _span : :: quote :: __private :: Span = _span ; :: quote :: __private :: push_ident ( & mut _s , _span , "fn" ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "__assert_receiver_is_total_form" ) ; _s . extend ( { let mut g = :: quote :: __private :: Group :: new ( :: quote :: __private :: Delimiter :: Parenthesis , { let mut _s = :: quote :: __private :: TokenStream :: new ( ) ; let _span : :: quote :: __private :: Span = _span ; :: quote :: __private :: push_and ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "self" ) ; _s } ) ; g . set_span ( _span ) ; Some ( :: quote :: __private :: TokenTree :: from ( g ) ) } ) ; _s . extend ( { let mut g = :: quote :: __private :: Group :: new ( :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new ( ) ; let _span : :: quote :: __private :: Span = _span ; :: quote :: __private :: push_ident ( & mut _s , _span , "match" ) ; :: quote :: __private :: push_star ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "self" ) ; _s . extend ( { let mut g = :: quote :: __private :: Group :: new ( :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new ( ) ; let _span : :: quote :: __private :: Span = _span ; :: quote :: ToTokens :: to_tokens ( & ident , & mut _s ) ; _s . extend ( { let mut g = :: quote :: __private :: Group :: new ( :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new ( ) ; let _span : :: quote :: __private :: Span = _span ; { use :: quote :: __private :: ext :: * ; let has_iter = :: quote :: __private :: ThereIsNoIteratorInRepetition ; # [ allow ( unused_mut ) ] let ( mut field_assertions , i ) = field_assertions . quote_into_iter ( ) ; let has_iter = has_iter | i ; let _ : :: quote :: __private :: HasIterator = has_iter ; while true { let field_assertions = match field_assertions . next ( ) { Some ( _x ) => :: quote :: __private :: RepInterp ( _x ) , None => break , } ; :: quote :: ToTokens :: to_tokens ( & field_assertions , & mut _s ) ; :: quote :: __private :: push_comma ( & mut _s , _span ) ; } } ; _s } ) ; g . set_span ( _span ) ; Some ( :: quote :: __private :: TokenTree :: from ( g ) ) } ) ; :: quote :: __private :: push_fat_arrow ( & mut _s , _span ) ; _s . extend ( { let mut g = :: quote :: __private :: Group :: new ( :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new ( ) ; let _span : :: quote :: __private :: Span = _span ; :: quote :: __private :: push_ident ( & mut _s , _span , "println" ) ; :: quote :: __private :: push_bang ( & mut _s , _span ) ; _s . extend ( { let mut g = :: quote :: __private :: Group :: new ( :: quote :: __private :: Delimiter :: Parenthesis , { let mut _s = :: quote :: __private :: TokenStream :: new ( ) ; let _span : :: quote :: __private :: Span = _span ; :: quote :: __private :: parse ( & mut _s , _span , "\"Hello\"" ) ; _s } ) ; g . set_span ( _span ) ; Some ( :: quote :: __private :: TokenTree :: from ( g ) ) } ) ; _s } ) ; g . set_span ( _span ) ; Some ( :: quote :: __private :: TokenTree :: from ( g ) ) } ) ; _s } ) ; g . set_span ( _span ) ; Some ( :: quote :: __private :: TokenTree :: from ( g ) ) } ) ; _s } ) ; g . set_span ( _span ) ; Some ( :: quote :: __private :: TokenTree :: from ( g ) ) } ) ; :: quote :: __private :: push_pound ( & mut _s , _span ) ; _s . extend ( { let mut g = :: quote :: __private :: Group :: new ( :: quote :: __private :: Delimiter :: Bracket , { let mut _s = :: quote :: __private :: TokenStream :: new ( ) ; let _span : :: quote :: __private :: Span = _span ; :: quote :: __private :: push_ident ( & mut _s , _span , "inline" ) ; _s } ) ; g . set_span ( _span ) ; Some ( :: quote :: __private :: TokenTree :: from ( g ) ) } ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "fn" ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "try_into_value" ) ; _s . extend ( { let mut g = :: quote :: __private :: Group :: new ( :: quote :: __private :: Delimiter :: Parenthesis , { let mut _s = :: quote :: __private :: TokenStream :: new ( ) ; let _span : :: quote :: __private :: Span = _span ; :: quote :: __private :: push_and ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "self" ) ; _s } ) ; g . set_span ( _span ) ; Some ( :: quote :: __private :: TokenTree :: from ( g ) ) } ) ; :: quote :: __private :: push_rarrow ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "Result" ) ; :: quote :: __private :: push_lt ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "_common" ) ; :: quote :: __private :: push_colon2 ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "model" ) ; :: quote :: __private :: push_colon2 ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "Value" ) ; :: quote :: __private :: push_comma ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "_common" ) ; :: quote :: __private :: push_colon2 ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "structure" ) ; :: quote :: __private :: push_colon2 ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "form" ) ; :: quote :: __private :: push_colon2 ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "FormParseErr" ) ; :: quote :: __private :: push_gt ( & mut _s , _span ) ; _s . extend ( { let mut g = :: quote :: __private :: Group :: new ( :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new ( ) ; let _span : :: quote :: __private :: Span = _span ; :: quote :: __private :: push_ident ( & mut _s , _span , "unimplemented" ) ; :: quote :: __private :: push_bang ( & mut _s , _span ) ; _s . extend ( { let mut g = :: quote :: __private :: Group :: new ( :: quote :: __private :: Delimiter :: Parenthesis , { let mut _s = :: quote :: __private :: TokenStream :: new ( ) ; let _span : :: quote :: __private :: Span = _span ; _s } ) ; g . set_span ( _span ) ; Some ( :: quote :: __private :: TokenTree :: from ( g ) ) } ) ; _s } ) ; g . set_span ( _span ) ; Some ( :: quote :: __private :: TokenTree :: from ( g ) ) } ) ; :: quote :: __private :: push_pound ( & mut _s , _span ) ; _s . extend ( { let mut g = :: quote :: __private :: Group :: new ( :: quote :: __private :: Delimiter :: Bracket , { let mut _s = :: quote :: __private :: TokenStream :: new ( ) ; let _span : :: quote :: __private :: Span = _span ; :: quote :: __private :: push_ident ( & mut _s , _span , "inline" ) ; _s } ) ; g . set_span ( _span ) ; Some ( :: quote :: __private :: TokenTree :: from ( g ) ) } ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "fn" ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "try_from_value" ) ; _s . extend ( { let mut g = :: quote :: __private :: Group :: new ( :: quote :: __private :: Delimiter :: Parenthesis , { let mut _s = :: quote :: __private :: TokenStream :: new ( ) ; let _span : :: quote :: __private :: Span = _span ; :: quote :: __private :: push_ident ( & mut _s , _span , "value" ) ; :: quote :: __private :: push_colon ( & mut _s , _span ) ; :: quote :: __private :: push_and ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "_common" ) ; :: quote :: __private :: push_colon2 ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "model" ) ; :: quote :: __private :: push_colon2 ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "Value" ) ; _s } ) ; g . set_span ( _span ) ; Some ( :: quote :: __private :: TokenTree :: from ( g ) ) } ) ; :: quote :: __private :: push_rarrow ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "Result" ) ; :: quote :: __private :: push_lt ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "Self" ) ; :: quote :: __private :: push_comma ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "_common" ) ; :: quote :: __private :: push_colon2 ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "structure" ) ; :: quote :: __private :: push_colon2 ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "form" ) ; :: quote :: __private :: push_colon2 ( & mut _s , _span ) ; :: quote :: __private :: push_ident ( & mut _s , _span , "FormParseErr" ) ; :: quote :: __private :: push_gt ( & mut _s , _span ) ; _s . extend ( { let mut g = :: quote :: __private :: Group :: new ( :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new ( ) ; let _span : :: quote :: __private :: Span = _span ; :: quote :: __private :: push_ident ( & mut _s , _span , "unimplemented" ) ; :: quote :: __private :: push_bang ( & mut _s , _span ) ; _s . extend ( { let mut g = :: quote :: __private :: Group :: new ( :: quote :: __private :: Delimiter :: Parenthesis , { let mut _s = :: quote :: __private :: TokenStream :: new ( ) ; let _span : :: quote :: __private :: Span = _span ; _s } ) ; g . set_span ( _span ) ; Some ( :: quote :: __private :: TokenTree :: from ( g ) ) } ) ; _s } ) ; g . set_span ( _span ) ; Some ( :: quote :: __private :: TokenTree :: from ( g ) ) } ) ; _s } ) ; g . set_span ( _span ) ; Some ( :: quote :: __private :: TokenTree :: from ( g ) ) } ) ;
        _s
    };
    Ok(q)
}
fn to_compile_errors(errors: Vec<syn::Error>) -> proc_macro2::TokenStream {
    let compile_errors = errors.iter().map(syn::Error::to_compile_error);
    {
        let mut _s = ::quote::__private::TokenStream::new();
        let _span: ::quote::__private::Span = ::quote::__private::Span::call_site();
        {
            use ::quote::__private::ext::*;
            let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
            #[allow(unused_mut)]
            let (mut compile_errors, i) = compile_errors.quote_into_iter();
            let has_iter = has_iter | i;
            let _: ::quote::__private::HasIterator = has_iter;
            while true {
                let compile_errors = match compile_errors.next() {
                    Some(_x) => ::quote::__private::RepInterp(_x),
                    None => break,
                };
                ::quote::ToTokens::to_tokens(&compile_errors, &mut _s);
            }
        };
        _s
    }
}
const _: () = {
    extern crate proc_macro;
    #[rustc_proc_macro_decls]
    #[allow(deprecated)]
    static _DECLS: &[proc_macro::bridge::client::ProcMacro] =
        &[proc_macro::bridge::client::ProcMacro::custom_derive(
            "Form",
            &[],
            derive_form,
        )];
};
