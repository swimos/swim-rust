// Copyright 2015-2021 SWIM.AI inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::byte_routing::routing::router::error::RouterError;
use crate::byte_routing::routing::RawRoute;
use crate::error::{ConnectionError, NoAgentAtRoute, Unresolvable};
use crate::remote::table::BidirectionalRegistrator;
use crate::routing::{RoutingAddr, TaggedSender};
use std::any::Any;
use std::collections::HashSet;
use std::sync::Arc;
use swim_model::path::Addressable;
use swim_utilities::future::request::Request;
use swim_utilities::routing::uri::RelativeUri;
use swim_warp::envelope::ResponseEnvelope;
use tokio::sync::mpsc;
use url::Url;

type AgentRequest = Request<Result<Arc<dyn Any + Send + Sync>, NoAgentAtRoute>>;
type EndpointRequest = Request<Result<RawRoute, RouterError>>;
type RoutesRequest = Request<HashSet<RelativeUri>>;
type PlaneResolutionRequest = Request<Result<RoutingAddr, RouterError>>;
type ClientResolutionRequest = Request<Result<RoutingAddr, RouterError>>;
type BidirectionalRequest = Request<Result<BidirectionalRegistrator, RouterError>>;
pub type ConnectionChannel = (ConnectionSender, Option<ConnectionReceiver>);
pub(crate) type ConnectionReceiver = mpsc::Receiver<RouterEvent>;
pub(crate) type ConnectionSender = TaggedSender;

/// Requests that can be serviced by the plane event loop.
#[derive(Debug)]
pub enum PlaneRoutingRequest {
    /// Get a handle to an agent (starting it where necessary).
    Agent {
        name: RelativeUri,
        request: AgentRequest,
    },
    /// Get channel to route messages to a specified routing address.
    Endpoint {
        addr: RoutingAddr,
        request: EndpointRequest,
    },
    /// Resolve the routing address for an agent.
    Resolve {
        host: Option<Url>,
        uri: RelativeUri,
        request: PlaneResolutionRequest,
    },
    /// Get all of the active routes for the plane.
    Routes(RoutesRequest),
}

#[derive(Debug)]
pub enum DownlinkRoutingRequest<Path: Addressable> {
    /// Obtain a connection.
    Connect {
        target: Path,
        request: Request<Result<ConnectionChannel, ConnectionError>>,
        conn_type: ConnectionType,
    },
    /// Get channel to route messages to a specified routing address.
    Endpoint {
        addr: RoutingAddr,
        request: Request<Result<RawRoute, RouterError>>,
    },
}

/// Requests that are generated by the remote router to be serviced by the connection manager.
#[derive(Debug)]
pub enum RemoteRoutingRequest {
    /// Get channel to route messages to a specified routing address.
    Endpoint {
        addr: RoutingAddr,
        request: EndpointRequest,
    },
    /// Resolve the routing address for a host.
    ResolveUrl {
        host: Url,
        request: ClientResolutionRequest,
    },
    /// Establish a bidirectional connection.
    Bidirectional {
        host: Url,
        request: BidirectionalRequest,
    },
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConnectionType {
    /// A connection type that can both send and receive messages.
    Full,
    /// A connection type that can only send messages.
    Outgoing,
}

/// The Router events are emitted by the connection streams of the router and indicate
/// messages or errors from the remote host.
#[derive(Debug, Clone, PartialEq)]
pub enum RouterEvent {
    /// Incoming message from a remote host.
    Message(ResponseEnvelope),
    /// There was an error in the connection. If a retry strategy exists this will trigger it.
    ConnectionClosed,
    /// The remote host is unreachable. This will not trigger the retry system.
    Unreachable(String),
    /// The router is stopping.
    Stopping,
}
