// Copyright 2015-2021 Swim Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

mod addresses;
pub mod config;
pub mod net;
mod pending;
pub(crate) mod router;
mod state;
pub mod table;
mod task;

#[cfg(test)]
mod tests;

use std::net::SocketAddr;
use std::sync::Arc;

use crate::error::ConnectionDropped;
use crate::error::Unresolvable;
use crate::error::{ConnectionError, HttpError};
use crate::remote::config::RemoteConnectionsConfig;
use crate::remote::pending::{PendingClient, PendingRequest};
use crate::remote::state::{DeferredResult, Event, RemoteConnections, RemoteTasksState};
use crate::remote::table::SchemeHostPort;
use crate::routing::{CloseReceiver, RouterFactory, RoutingAddr, TaggedEnvelope, UnroutableClient};
use crate::ws::WsConnections;
use futures::future::BoxFuture;
use futures::stream::FusedStream;
use std::convert::TryFrom;
use std::fmt::{Display, Formatter};
use std::io;
use std::io::Error;
use swim_utilities::future::request::Request;
use swim_utilities::future::task::Spawner;
use swim_utilities::trigger::promise;
use thiserror::Error;
use tokio::sync::mpsc;
use tracing::{event, Level};
use url::Url;

use ratchet::WebSocketStream;
pub use router::{RemoteRouter, RemoteRouterFactory};
use swim_model::Text;
use swim_tracing::request::{RequestExt, TryRequestExt};
use swim_utilities::routing::uri::RelativeUri;

#[cfg(test)]
pub mod test_fixture;

#[derive(Clone, Debug)]
pub struct RawOutRoute {
    pub sender: mpsc::Sender<TaggedEnvelope>,
    pub on_drop: promise::Receiver<ConnectionDropped>,
}

impl RawOutRoute {
    pub fn new(
        sender: mpsc::Sender<TaggedEnvelope>,
        on_drop: promise::Receiver<ConnectionDropped>,
    ) -> Self {
        RawOutRoute { sender, on_drop }
    }
}

type EndpointRequest = Request<Result<RawOutRoute, Unresolvable>>;
type ResolutionRequest = Request<Result<RoutingAddr, ConnectionError>>;
type ClientRequest = Request<Result<UnroutableClient, Unresolvable>>;

#[derive(Debug)]
pub struct AttachClientRequest {
    pub addr: RoutingAddr,
    pub node: RelativeUri,
    pub lane: Text,
    pub request: ClientRequest,
}

impl AttachClientRequest {
    pub fn new(addr: RoutingAddr, node: RelativeUri, lane: Text, request: ClientRequest) -> Self {
        AttachClientRequest {
            addr,
            node,
            lane,
            request,
        }
    }
}

/// Requests that are generated by the remote router to be serviced by the connection manager.
#[derive(Debug)]
pub enum RemoteRoutingRequest {
    /// Get channel to route messages to a specified routing address.
    EndpointOut {
        addr: RoutingAddr,
        request: EndpointRequest,
    },
    /// Resolve the routing address for a host.
    ResolveUrl {
        host: Url,
        request: ResolutionRequest,
    },
    /// Attach a client route to the connection to the specified host.
    AttachClient { request: AttachClientRequest },
}

pub struct RemoteConnectionChannels {
    request_tx: mpsc::Sender<RemoteRoutingRequest>,
    request_rx: mpsc::Receiver<RemoteRoutingRequest>,
    stop_trigger: CloseReceiver,
}

impl RemoteConnectionChannels {
    pub fn new(
        request_tx: mpsc::Sender<RemoteRoutingRequest>,
        request_rx: mpsc::Receiver<RemoteRoutingRequest>,
        stop_trigger: CloseReceiver,
    ) -> RemoteConnectionChannels {
        RemoteConnectionChannels {
            request_tx,
            request_rx,
            stop_trigger,
        }
    }
}

#[derive(Debug)]
pub struct RemoteConnectionsTask<External: ExternalConnections, Ws, DelegateRouterFac, Sp> {
    external: External,
    listener: Option<External::ListenerType>,
    websockets: Ws,
    delegate_router_fac: DelegateRouterFac,
    stop_trigger: CloseReceiver,
    spawner: Sp,
    configuration: RemoteConnectionsConfig,
    remote_tx: mpsc::Sender<RemoteRoutingRequest>,
    remote_rx: mpsc::Receiver<RemoteRoutingRequest>,
}

type SchemeSocketAddrIt = std::vec::IntoIter<SchemeSocketAddr>;

const REQUEST_DROPPED: &str = "The receiver of a routing request was dropped before it completed.";
const FAILED_SERVER_CONN: &str = "Failed to establish a server connection.";
const FAILED_CLIENT_CONN: &str = "Failed to establish a client connection.";
const NOT_IN_TABLE: &str = "A connection closed that was not in the routing table.";
const CLOSED_NO_HANDLES: &str = "A connection closed with no handles remaining.";

/// An event loop that listens for incoming connections and routing requests and opens/accepts
/// remote connections accordingly.
///
/// # Type Parameters
///
/// * `External` - Provides the ability to open sockets.
/// * `Ws` - Negotiates a web socket connection on top of the sockets provided by `External`.
/// * `Sp` - Spawner to run the tasks that manage the connections opened by this state machine.
/// * `Routerfac` - Creates router instances to be provided to the connection management tasks.
impl<External, Ws, DelegateRouterFac, Sp> RemoteConnectionsTask<External, Ws, DelegateRouterFac, Sp>
where
    External: ExternalConnections,
    External::Socket: WebSocketStream,
    Ws: WsConnections<External::Socket> + Send + Sync + 'static,
    DelegateRouterFac: RouterFactory + 'static,
    Sp: Spawner<BoxFuture<'static, (RoutingAddr, ConnectionDropped)>> + Send + Unpin,
{
    pub async fn new_client_task(
        configuration: RemoteConnectionsConfig,
        external: External,
        websockets: Ws,
        delegate_router_fac: DelegateRouterFac,
        spawner: Sp,
        channels: RemoteConnectionChannels,
    ) -> Self {
        let RemoteConnectionChannels {
            request_tx: remote_tx,
            request_rx: remote_rx,
            stop_trigger,
        } = channels;

        RemoteConnectionsTask {
            external,
            listener: None,
            websockets,
            delegate_router_fac,
            stop_trigger,
            spawner,
            configuration,
            remote_tx,
            remote_rx,
        }
    }

    pub async fn new_server_task(
        configuration: RemoteConnectionsConfig,
        external: External,
        bind_addr: SocketAddr,
        websockets: Ws,
        delegate_router_fac: DelegateRouterFac,
        spawner: Sp,
        channels: RemoteConnectionChannels,
    ) -> io::Result<Self> {
        let RemoteConnectionChannels {
            request_tx: remote_tx,
            request_rx: remote_rx,
            stop_trigger,
        } = channels;

        let (_, listener) = external.bind(bind_addr).await?;

        Ok(RemoteConnectionsTask {
            external,
            listener: Some(listener),
            websockets,
            delegate_router_fac,
            stop_trigger,
            spawner,
            configuration,
            remote_tx,
            remote_rx,
        })
    }

    pub fn listener(&self) -> Option<&External::ListenerType> {
        self.listener.as_ref()
    }

    pub async fn run(self) -> Result<(), io::Error> {
        let RemoteConnectionsTask {
            external,
            listener,
            websockets,
            delegate_router_fac,
            stop_trigger,
            spawner,
            configuration,
            remote_tx,
            remote_rx,
        } = self;

        async move {
            let state = RemoteConnections::new(
                &websockets,
                configuration,
                spawner,
                external,
                listener,
                delegate_router_fac,
                RemoteConnectionChannels {
                    request_tx: remote_tx,
                    request_rx: remote_rx,
                    stop_trigger,
                },
            );
            RemoteConnectionsTask::run_loop(state, configuration).await
        }
        .await
    }

    async fn run_loop(
        mut state: RemoteConnections<'_, External, Ws, Sp, DelegateRouterFac>,
        configuration: RemoteConnectionsConfig,
    ) -> Result<(), Error> {
        let mut overall_result = Ok(());
        let mut iteration_count: usize = 0;
        let yield_mod = configuration.yield_after.get();

        while let Some(event) = state.select_next().await {
            if let Some(pending_clients) = update_state(&mut state, &mut overall_result, event) {
                pending_clients.send_attach_requests().await;
            }

            iteration_count += 1;
            if iteration_count % yield_mod == 0 {
                tokio::task::yield_now().await;
            }
        }
        overall_result
    }
}

/// The state transition function for the state machine underlying the task.
fn update_state<State: RemoteTasksState>(
    state: &mut State,
    overall_result: &mut Result<(), io::Error>,
    next: Event<State::Socket, State::WebSocket>,
) -> Option<PendingClient> {
    match next {
        Event::Incoming(Ok((stream, peer_addr))) => {
            state.defer_handshake(stream, peer_addr);
            None
        }
        Event::Incoming(Err(conn_err)) => {
            *overall_result = Err(conn_err);
            state.stop();
            None
        }
        Event::Request(RemoteRoutingRequest::EndpointOut { addr, request }) => {
            let result = if let Some(tx) = state.table_resolve(addr) {
                Ok(tx)
            } else {
                Err(Unresolvable(addr))
            };
            request.send_debug(result, REQUEST_DROPPED);
            None
        }
        Event::Request(RemoteRoutingRequest::AttachClient { request }) => {
            if let Some((route, req_tx)) = state.resolve_client_request(request.addr) {
                Some(PendingClient::new(req_tx.clone(), route, request))
            } else {
                request
                    .request
                    .send_err_debug(Unresolvable(request.addr), REQUEST_DROPPED);
                None
            }
        }
        Event::Request(RemoteRoutingRequest::ResolveUrl { host, request }) => {
            match SchemeHostPort::try_from(&host) {
                Ok(target) => {
                    if let Some(addr) = state.table_try_resolve(&target) {
                        request.send_ok_debug(addr, REQUEST_DROPPED);
                    } else {
                        state.defer_dns_lookup(target, PendingRequest::Resolution(request));
                    }
                }
                _ => {
                    request.send_err_debug(
                        ConnectionError::Http(HttpError::invalid_url(host.to_string(), None)),
                        REQUEST_DROPPED,
                    );
                }
            }
            None
        }
        Event::Deferred(DeferredResult::ServerHandshake {
            result: Ok(ws_stream),
            sock_addr,
        }) => {
            state.spawn_task(sock_addr, ws_stream, None);
            None
        }
        Event::Deferred(DeferredResult::ServerHandshake {
            result: Err(error), ..
        }) => {
            event!(Level::ERROR, FAILED_SERVER_CONN, ?error);
            None
        }
        Event::Deferred(DeferredResult::ClientHandshake {
            result: Ok((ws_stream, sock_addr)),
            host,
        }) => {
            state.spawn_task(sock_addr, ws_stream, Some(host));
            None
        }
        Event::Deferred(DeferredResult::ClientHandshake {
            result: Err(error),
            host,
            ..
        }) => {
            event!(Level::ERROR, FAILED_CLIENT_CONN, ?error);
            state.fail_connection(&host, error);
            None
        }
        Event::Deferred(DeferredResult::FailedConnection {
            error,
            mut remaining,
            host,
        }) => {
            if let Some(sock_addr) = remaining.next() {
                state.defer_connect_and_handshake(host, sock_addr, remaining);
            } else {
                state.fail_connection(&host, error);
            }
            None
        }
        Event::Deferred(DeferredResult::Dns {
            result: Err(err),
            host,
            ..
        }) => {
            state.fail_connection(&host, ConnectionError::Io(err.into()));
            None
        }
        Event::Deferred(DeferredResult::Dns {
            result: Ok(mut addrs),
            host,
        }) => {
            if let Some(sock_addr) = addrs.next() {
                if let Err(host) = state.check_socket_addr(host, sock_addr) {
                    state.defer_connect_and_handshake(host, sock_addr, addrs);
                }
            } else {
                let host_err = host.to_string();

                state.fail_connection(&host, ConnectionError::Resolution(host_err));
            }
            None
        }
        Event::ConnectionClosed(addr, reason) => {
            if let Some(tx) = state.table_remove(addr) {
                if let Err(reason) = tx.provide(reason) {
                    event!(Level::TRACE, CLOSED_NO_HANDLES, ?addr, ?reason);
                }
            } else {
                event!(Level::ERROR, NOT_IN_TABLE, ?addr);
            }
            None
        }
    }
}

#[derive(Debug, PartialEq, Eq, Error)]
pub enum BadUrl {
    #[error("{0} is not a valid Warp scheme.")]
    BadScheme(String),
    #[error("The URL did not contain a valid host.")]
    NoHost,
}

/// Supported websocket schemes
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Scheme {
    Ws,
    Wss,
}

impl TryFrom<&str> for Scheme {
    type Error = BadUrl;

    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "ws" | "swim" | "warp" => Ok(Scheme::Ws),
            "wss" | "swims" | "warps" => Ok(Scheme::Wss),
            _ => Err(BadUrl::BadScheme(value.to_owned())),
        }
    }
}

impl Scheme {
    /// Get the default port for the schemes.
    fn get_default_port(&self) -> u16 {
        match self {
            Scheme::Ws => 80,
            Scheme::Wss => 443,
        }
    }

    /// Return if the scheme is secure.
    #[allow(dead_code)]
    fn is_secure(&self) -> bool {
        match self {
            Scheme::Ws => false,
            Scheme::Wss => true,
        }
    }
}

impl Display for Scheme {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Scheme::Ws => {
                write!(f, "ws")
            }
            Scheme::Wss => {
                write!(f, "wss")
            }
        }
    }
}

type IoResult<T> = io::Result<T>;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct SchemeSocketAddr {
    pub scheme: Scheme,
    pub addr: SocketAddr,
}

impl SchemeSocketAddr {
    pub fn new(scheme: Scheme, addr: SocketAddr) -> SchemeSocketAddr {
        SchemeSocketAddr { scheme, addr }
    }
}

impl Display for SchemeSocketAddr {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}://{}/", self.scheme, self.addr)
    }
}

/// Trait for servers that listen for incoming remote connections. This is primarily used to
/// abstract over [`std::net::TcpListener`] for testing purposes.
pub trait Listener {
    type Socket: Unpin + Send + Sync + 'static;
    type AcceptStream: FusedStream<Item = IoResult<(Self::Socket, SchemeSocketAddr)>>
        + Send
        + Sync
        + Unpin;

    fn into_stream(self) -> Self::AcceptStream;
}

/// Trait for types that can create remote network connections asynchronously. This is primarily
/// used to abstract over [`std::net::TcpListener`] and [`std::net::TcpStream`] for testing purposes.
pub trait ExternalConnections: Clone + Send + Sync + 'static {
    type Socket: Unpin + Send + Sync + 'static;
    type ListenerType: Listener<Socket = Self::Socket> + Send + Sync;

    fn bind(
        &self,
        addr: SocketAddr,
    ) -> BoxFuture<'static, IoResult<(SocketAddr, Self::ListenerType)>>;
    fn try_open(&self, addr: SocketAddr) -> BoxFuture<'static, IoResult<Self::Socket>>;
    fn lookup(&self, host: SchemeHostPort) -> BoxFuture<'static, IoResult<Vec<SchemeSocketAddr>>>;
}

impl<Conn> ExternalConnections for Arc<Conn>
where
    Conn: ExternalConnections,
{
    type Socket = Conn::Socket;

    type ListenerType = Conn::ListenerType;

    fn bind(
        &self,
        addr: SocketAddr,
    ) -> BoxFuture<'static, IoResult<(SocketAddr, Self::ListenerType)>> {
        (**self).bind(addr)
    }

    fn try_open(&self, addr: SocketAddr) -> BoxFuture<'static, IoResult<Self::Socket>> {
        (**self).try_open(addr)
    }

    fn lookup(&self, host: SchemeHostPort) -> BoxFuture<'static, IoResult<Vec<SchemeSocketAddr>>> {
        (**self).lookup(host)
    }
}
