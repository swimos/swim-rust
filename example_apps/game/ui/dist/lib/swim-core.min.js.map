{"version":3,"file":"swim-core.min.js","sources":["../../../../node_modules/tslib/tslib.es6.mjs","../../swim-util/main/Random.ts","../../swim-util/main/ByteOrder.ts","../../swim-util/main/Murmur3.ts","../../swim-util/main/Lazy.ts","../../swim-util/main/Equals.ts","../../swim-util/main/HashCode.ts","../../swim-util/main/Equivalent.ts","../../swim-util/main/Compare.ts","../../swim-util/main/Identity.ts","../../swim-util/main/Booleans.ts","../../swim-util/main/Numbers.ts","../../swim-util/main/Strings.ts","../../swim-util/main/Identifiers.ts","../../swim-util/main/Functions.ts","../../swim-util/main/Constructors.ts","../../swim-util/main/Arrays.ts","../../swim-util/main/Objects.ts","../../swim-util/main/Values.ts","../../swim-util/main/Like.ts","../../swim-util/main/Creatable.ts","../../swim-util/main/Observable.ts","../../swim-util/main/Consumable.ts","../../swim-util/main/Cursor.ts","../../swim-util/main/Mapping.ts","../../swim-util/main/Domain.ts","../../swim-util/main/Range.ts","../../swim-util/main/Interpolate.ts","../../swim-util/main/Interpolator.ts","../../swim-util/main/Timing.ts","../../swim-util/main/Easing.ts","../../swim-util/main/Tweening.ts","../../swim-util/main/Scale.ts","../../swim-util/main/LinearDomain.ts","../../swim-util/main/LinearRange.ts","../../swim-util/main/LinearScale.ts","../../swim-util/main/Assert.ts","../../swim-util/main/Severity.ts","../../swim-codec/main/source/Tag.ts","../../swim-codec/main/source/Mark.ts","../../swim-codec/main/source/Span.ts","../../swim-codec/main/format/OutputStyle.ts","../../swim-codec/main/output/OutputSettings.ts","../../swim-codec/main/input/InputException.ts","../../swim-codec/main/input/InputSettings.ts","../../swim-codec/main/input/Input.ts","../../swim-codec/main/input/InputError.ts","../../swim-codec/main/unicode/StringInput.ts","../../swim-codec/main/output/OutputException.ts","../../swim-codec/main/output/Output.ts","../../swim-codec/main/unicode/StringOutput.ts","../../swim-codec/main/writer/WriterException.ts","../../swim-codec/main/writer/Writer.ts","../../swim-codec/main/unicode/StringWriter.ts","../../swim-codec/main/unicode/Unicode.ts","../../swim-codec/main/format/Format.ts","../../swim-codec/main/number/Base10.ts","../../swim-codec/main/source/Diagnostic.ts","../../swim-codec/main/input/InputEmpty.ts","../../swim-codec/main/input/InputDone.ts","../../swim-codec/main/input/InputBuffer.ts","../../swim-codec/main/input/InputBufferEmpty.ts","../../swim-codec/main/input/InputBufferDone.ts","../../swim-codec/main/input/InputBufferError.ts","../../swim-codec/main/output/OutputFull.ts","../../swim-codec/main/output/OutputDone.ts","../../swim-codec/main/output/OutputError.ts","../../swim-codec/main/output/OutputBuffer.ts","../../swim-codec/main/output/OutputBufferFull.ts","../../swim-codec/main/output/OutputBufferDone.ts","../../swim-codec/main/output/OutputBufferError.ts","../../swim-codec/main/parser/ParserException.ts","../../swim-codec/main/parser/Parser.ts","../../swim-codec/main/parser/ParserDone.ts","../../swim-codec/main/parser/ParserError.ts","../../swim-codec/main/writer/WriterEnd.ts","../../swim-codec/main/writer/WriterDone.ts","../../swim-codec/main/writer/WriterError.ts","../../swim-codec/main/writer/WriterSequence.ts","../../swim-codec/main/binary/ByteOutput.ts","../../swim-codec/main/binary/ByteOutputUint8Array.ts","../../swim-codec/main/binary/ByteOutputBuffer.ts","../../swim-codec/main/binary/Binary.ts","../../swim-codec/main/unicode/UtfErrorMode.ts","../../swim-codec/main/unicode/UtfErrorModeFatal.ts","../../swim-codec/main/unicode/UtfErrorModeReplacement.ts","../../swim-codec/main/number/Base16.ts","../../swim-codec/main/unicode/Utf8DecodedOutput.ts","../../swim-codec/main/unicode/Utf8EncodedOutput.ts","../../swim-codec/main/unicode/Utf8.ts","../../swim-codec/main/number/Base10NumberParser.ts","../../swim-codec/main/number/Base10IntegerWriter.ts","../../swim-codec/main/number/Base16Parser.ts","../../swim-codec/main/number/Base16Writer.ts","../../swim-codec/main/number/Base16IntegerWriter.ts","../../swim-codec/main/number/Base64.ts","../../swim-codec/main/number/Base64Parser.ts","../../swim-codec/main/number/Base64Writer.ts","../../swim-component/main/Affinity.ts","../../swim-component/main/FastenerContext.ts","../../swim-component/main/Fastener.ts","../../swim-component/main/Property.ts","../../swim-component/main/Animator.ts","../../swim-component/main/Timer.ts","../../swim-component/main/EventHandler.ts","../../swim-component/main/EventTimer.ts","../../swim-component/main/Provider.ts","../../swim-component/main/Component.ts","../../swim-component/main/ComponentRelation.ts","../../swim-component/main/ComponentRef.ts","../../swim-component/main/ComponentSet.ts","../../swim-component/main/Service.ts","../../swim-collections/main/NodeCursor.ts","../../swim-collections/main/BTreeContext.ts","../../swim-collections/main/BTree.ts","../../swim-collections/main/BTreePage.ts","../../swim-collections/main/BTreeLeaf.ts","../../swim-collections/main/BTreeNode.ts","../../swim-collections/main/STreeContext.ts","../../swim-collections/main/STree.ts","../../swim-collections/main/STreePage.ts","../../swim-collections/main/STreeLeaf.ts","../../swim-collections/main/STreeNode.ts","../../swim-constraint/main/ConstraintSymbol.ts","../../swim-constraint/main/ConstraintExpression.ts","../../swim-constraint/main/ConstraintSum.ts","../../swim-constraint/main/ConstraintTerm.ts","../../swim-constraint/main/ConstraintProduct.ts","../../swim-constraint/main/ConstraintConstant.ts","../../swim-constraint/main/ConstraintProperty.ts","../../swim-constraint/main/ConstraintAnimator.ts","../../swim-constraint/main/Constraint.ts","../../swim-constraint/main/ConstraintScope.ts","../../swim-constraint/main/ConstraintContext.ts","../../swim-constraint/main/ConstraintRow.ts","../../swim-structure/main/Item.ts","../../swim-structure/main/Field.ts","../../swim-structure/main/Attr.ts","../../swim-structure/main/Slot.ts","../../swim-structure/main/Value.ts","../../swim-structure/main/Record.ts","../../swim-structure/main/RecordMap.ts","../../swim-structure/main/RecordMapView.ts","../../swim-structure/main/Data.ts","../../swim-structure/main/Text.ts","../../swim-structure/main/Num.ts","../../swim-structure/main/Bool.ts","../../swim-structure/main/Extant.ts","../../swim-structure/main/Absent.ts","../../swim-structure/main/Expression.ts","../../swim-structure/main/operator/Operator.ts","../../swim-structure/main/operator/BinaryOperator.ts","../../swim-structure/main/operator/BinaryOperatorInterpolator.ts","../../swim-structure/main/operator/UnaryOperator.ts","../../swim-structure/main/operator/UnaryOperatorInterpolator.ts","../../swim-structure/main/operator/ConditionalOperator.ts","../../swim-structure/main/operator/ConditionalOperatorInterpolator.ts","../../swim-structure/main/interpreter/InterpreterException.ts","../../swim-structure/main/interpreter/InterpreterSettings.ts","../../swim-structure/main/interpreter/Interpreter.ts","../../swim-structure/main/operator/OrOperator.ts","../../swim-structure/main/operator/AndOperator.ts","../../swim-structure/main/operator/BitwiseOrOperator.ts","../../swim-structure/main/operator/BitwiseXorOperator.ts","../../swim-structure/main/operator/BitwiseAndOperator.ts","../../swim-structure/main/operator/LtOperator.ts","../../swim-structure/main/operator/LeOperator.ts","../../swim-structure/main/operator/EqOperator.ts","../../swim-structure/main/operator/NeOperator.ts","../../swim-structure/main/operator/GeOperator.ts","../../swim-structure/main/operator/GtOperator.ts","../../swim-structure/main/operator/PlusOperator.ts","../../swim-structure/main/operator/MinusOperator.ts","../../swim-structure/main/operator/TimesOperator.ts","../../swim-structure/main/operator/DivideOperator.ts","../../swim-structure/main/operator/ModuloOperator.ts","../../swim-structure/main/operator/NotOperator.ts","../../swim-structure/main/operator/BitwiseNotOperator.ts","../../swim-structure/main/operator/NegativeOperator.ts","../../swim-structure/main/operator/PositiveOperator.ts","../../swim-structure/main/operator/InvokeOperator.ts","../../swim-structure/main/operator/InvokeOperatorInterpolator.ts","../../swim-structure/main/selector/Selector.ts","../../swim-structure/main/selector/IdentitySelector.ts","../../swim-structure/main/selector/GetSelector.ts","../../swim-structure/main/selector/GetAttrSelector.ts","../../swim-structure/main/selector/GetItemSelector.ts","../../swim-structure/main/selector/KeysSelector.ts","../../swim-structure/main/selector/ValuesSelector.ts","../../swim-structure/main/selector/ChildrenSelector.ts","../../swim-structure/main/selector/DescendantsSelector.ts","../../swim-structure/main/selector/FilterSelector.ts","../../swim-structure/main/selector/LiteralSelector.ts","../../swim-structure/main/func/Func.ts","../../swim-structure/main/func/LambdaFunc.ts","../../swim-structure/main/func/BridgeFunc.ts","../../swim-structure/main/func/MathModule.ts","../../swim-structure/main/form/FormException.ts","../../swim-structure/main/form/Form.ts","../../swim-structure/main/form/TagForm.ts","../../swim-structure/main/form/UnitForm.ts","../../swim-structure/main/form/StringForm.ts","../../swim-structure/main/form/NumberForm.ts","../../swim-structure/main/form/BooleanForm.ts","../../swim-structure/main/form/AnyForm.ts","../../swim-structure/main/form/ItemForm.ts","../../swim-structure/main/form/ValueForm.ts","../../swim-recon/main/Recon.ts","../../swim-recon/main/parser/BlockParser.ts","../../swim-recon/main/parser/AttrParser.ts","../../swim-recon/main/parser/BlockItemParser.ts","../../swim-recon/main/parser/InlineItemParser.ts","../../swim-recon/main/parser/RecordParser.ts","../../swim-recon/main/parser/MarkupParser.ts","../../swim-recon/main/parser/DataParser.ts","../../swim-recon/main/parser/IdentParser.ts","../../swim-recon/main/parser/StringParser.ts","../../swim-recon/main/parser/RawStringParser.ts","../../swim-recon/main/parser/NumberParser.ts","../../swim-recon/main/parser/LambdaFuncParser.ts","../../swim-recon/main/parser/ConditionalOperatorParser.ts","../../swim-recon/main/parser/OrOperatorParser.ts","../../swim-recon/main/parser/AndOperatorParser.ts","../../swim-recon/main/parser/BitwiseOrOperatorParser.ts","../../swim-recon/main/parser/BitwiseXorOperatorParser.ts","../../swim-recon/main/parser/BitwiseAndOperatorParser.ts","../../swim-recon/main/parser/ComparisonOperatorParser.ts","../../swim-recon/main/parser/AttrExpressionParser.ts","../../swim-recon/main/parser/AdditiveOperatorParser.ts","../../swim-recon/main/parser/MultiplicativeOperatorParser.ts","../../swim-recon/main/parser/PrefixOperatorParser.ts","../../swim-recon/main/parser/InvokeOperatorParser.ts","../../swim-recon/main/parser/PrimaryParser.ts","../../swim-recon/main/parser/LiteralParser.ts","../../swim-recon/main/parser/SelectorParser.ts","../../swim-recon/main/parser/ReconParser.ts","../../swim-recon/main/parser/ReconStructureParser.ts","../../swim-recon/main/writer/AttrWriter.ts","../../swim-recon/main/writer/SlotWriter.ts","../../swim-recon/main/writer/BlockWriter.ts","../../swim-recon/main/writer/PrimaryWriter.ts","../../swim-recon/main/writer/MarkupTextWriter.ts","../../swim-recon/main/writer/DataWriter.ts","../../swim-recon/main/writer/IdentWriter.ts","../../swim-recon/main/writer/StringWriter.ts","../../swim-recon/main/writer/LambdaFuncWriter.ts","../../swim-recon/main/writer/ConditionalOperatorWriter.ts","../../swim-recon/main/writer/InfixOperatorWriter.ts","../../swim-recon/main/writer/PrefixOperatorWriter.ts","../../swim-recon/main/writer/InvokeOperatorWriter.ts","../../swim-recon/main/writer/LiteralSelectorWriter.ts","../../swim-recon/main/writer/GetSelectorWriter.ts","../../swim-recon/main/writer/GetAttrSelectorWriter.ts","../../swim-recon/main/writer/GetItemSelectorWriter.ts","../../swim-recon/main/writer/KeysSelectorWriter.ts","../../swim-recon/main/writer/ValuesSelectorWriter.ts","../../swim-recon/main/writer/ChildrenSelectorWriter.ts","../../swim-recon/main/writer/DescendantsSelectorWriter.ts","../../swim-recon/main/writer/FilterSelectorWriter.ts","../../swim-recon/main/writer/ReconWriter.ts","../../swim-recon/main/writer/ReconStructureWriter.ts","../../swim-uri/main/Uri.ts","../../swim-uri/main/UriScheme.ts","../../swim-uri/main/UriAuthority.ts","../../swim-uri/main/UriUser.ts","../../swim-uri/main/UriHost.ts","../../swim-uri/main/UriPort.ts","../../swim-uri/main/UriPath.ts","../../swim-uri/main/UriQuery.ts","../../swim-uri/main/UriFragment.ts","../../swim-math/main/Length.ts","../../swim-math/main/Angle.ts","../../swim-math/main/R2Vector.ts","../../swim-math/main/R2Shape.ts","../../swim-math/main/R2Point.ts","../../swim-math/main/R2Curve.ts","../../swim-math/main/R2Segment.ts","../../swim-math/main/R2QuadraticCurve.ts","../../swim-math/main/R2CubicCurve.ts","../../swim-math/main/R2EllipticCurve.ts","../../swim-math/main/R2Spline.ts","../../swim-math/main/R2Path.ts","../../swim-math/main/R2Circle.ts","../../swim-math/main/R2Box.ts","../../swim-math/main/R2Group.ts","../../swim-math/main/Transform.ts","../../swim-math/main/IdentityTransform.ts","../../swim-math/main/TranslateTransform.ts","../../swim-math/main/ScaleTransform.ts","../../swim-math/main/RotateTransform.ts","../../swim-math/main/SkewTransform.ts","../../swim-math/main/AffineTransform.ts","../../swim-math/main/TransformList.ts","../../swim-geo/main/GeoProjection.ts","../../swim-geo/main/GeoShape.ts","../../swim-geo/main/GeoPoint.ts","../../swim-geo/main/GeoCurve.ts","../../swim-geo/main/GeoSegment.ts","../../swim-geo/main/GeoSpline.ts","../../swim-geo/main/GeoPath.ts","../../swim-geo/main/GeoTile.ts","../../swim-geo/main/GeoBox.ts","../../swim-geo/main/GeoGroup.ts","../../swim-geo/main/GeoJson.ts","../../swim-time/main/TimeZone.ts","../../swim-time/main/DateTime.ts","../../swim-time/main/DateTimeLocale.ts","../../swim-time/main/DateTimeSpecifiers.ts","../../swim-time/main/DateTimeFormat.ts","../../swim-time/main/TimeInterval.ts","../../swim-time/main/TimeDomain.ts","../../swim-time/main/TimeRange.ts","../../swim-time/main/TimeScale.ts","../../swim-constraint/main/ConstraintGroup.ts","../../swim-constraint/main/ConstraintSolver.ts","../../swim-uri/main/UriCache.ts","../../swim-structure/main/collections/ValueCursor.ts","../../swim-structure/main/collections/ValueEntryCursor.ts"],"sourcesContent":["/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n        if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n        dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n        if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n        dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  function next() {\n    while (env.stack.length) {\n      var rec = env.stack.pop();\n      try {\n        var result = rec.dispose && rec.dispose.call(rec.value);\n        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n      }\n      catch (e) {\n          fail(e);\n      }\n    }\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/** @public */\nexport const Random = {\n  fillBytes: (function () {\n    if (typeof window !== \"undefined\" && window.crypto !== void 0) {\n      return function (array: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array): void {\n        window.crypto.getRandomValues(array);\n      };\n    } else if (typeof window !== \"undefined\" && (window as any).msCrypto !== void 0) {\n      return function (array: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array): void {\n        ((window as any).msCrypto as Crypto).getRandomValues(array);\n      };\n    }\n    return function (array: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array): void {\n      if (array instanceof Int8Array) {\n        for (let i = 0; i < array.length; i += 1) {\n          array[i] = 128 - Math.round(Math.random() * 256);\n        }\n      } else if (array instanceof Uint8Array) {\n        for (let i = 0; i < array.length; i += 1) {\n          array[i] = Math.round(Math.random() * 256);\n        }\n      } else if (array instanceof Int16Array) {\n        for (let i = 0; i < array.length; i += 1) {\n          array[i] = 32768 - Math.round(Math.random() * 65536);\n        }\n      } else if (array instanceof Uint16Array) {\n        for (let i = 0; i < array.length; i += 1) {\n          array[i] = Math.round(Math.random() * 65536);\n        }\n      } else if (array instanceof Int32Array) {\n        for (let i = 0; i < array.length; i += 1) {\n          array[i] = 2147483648 - Math.round(Math.random() * 4294967296);\n        }\n      } else if (array instanceof Uint32Array) {\n        for (let i = 0; i < array.length; i += 1) {\n          array[i] = Math.round(Math.random() * 4294967296);\n        }\n      } else {\n        throw new TypeError(\"\" + array);\n      }\n    };\n  })(),\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Endianness of multi-byte words.\n * @public\n */\nexport type ByteOrder = \"BE\" | \"LE\";\n\n/** @public */\nexport const ByteOrder = {\n  /**\n   * The `ByteOrder` where the most significant byte comes first.\n   */\n  get BigEndian(): ByteOrder {\n    return \"BE\";\n  },\n\n  /**\n   * The `ByteOrder` where the least significant byte comes first.\n   */\n  get LittleEndian(): ByteOrder {\n    return \"LE\";\n  },\n\n  /**\n   * Memoized `NativeOrder`.\n   * @internal\n   */\n  NativeEndian: void 0 as ByteOrder | undefined,\n\n  /**\n   * The `ByteOrder` of the host machine.\n   */\n  get NativeOrder(): ByteOrder {\n    if (this.NativeEndian === void 0) {\n      const bom = new ArrayBuffer(2);\n      new Uint16Array(bom)[0] = 0xfeff;\n      const b = new Uint8Array(bom);\n      if (b[0] === 0xfe && b[1] === 0xff) {\n        this.NativeEndian = this.BigEndian;\n      } else if (b[0] === 0xff && b[1] === 0xfe) {\n        this.NativeEndian = this.LittleEndian;\n      } else {\n        throw new Error();\n      }\n    }\n    return this.NativeEndian;\n  }\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {ByteOrder} from \"./ByteOrder\";\nimport {Strings} from \"./\"; // forward import\n\n/**\n * 32-bit [MurmurHash](https://en.wikipedia.org/wiki/MurmurHash) algorithm,\n * version 3.\n * @public\n */\nexport const Murmur3 = {\n  /**\n   * Mixes a new hash `value` into the accumulated hash `code`,\n   * and returns the accumulated hash value.\n   */\n  mix(code: number, value: number): number {\n    value = ((value & 0xffff) * 0xcc9e2d51) + (((value >>> 16) * 0xcc9e2d51 & 0xffff) << 16) & 0xffffffff;\n    value = this.rotl(value, 15);\n    value = ((value & 0xffff) * 0x1b873593) + (((value >>> 16) * 0x1b873593 & 0xffff) << 16) & 0xffffffff;\n    code ^= value;\n    code = this.rotl(code, 13);\n    code = ((code & 0xffff) * 5) + (((code >>> 16) * 5 & 0xffff) << 16) & 0xffffffff;\n    code = ((code & 0xffff) + 0x6b64) + (((code >>> 16) + 0xe654 & 0xffff) << 16);\n    return code;\n  },\n\n  /**\n   * Mixes each consecutive 4-byte word of `array` into `code`,\n   * and returns the accumulated hash value.\n   */\n  mixUint8Array(code: number, array: Uint8Array): number {\n    if (ByteOrder.NativeOrder === ByteOrder.BigEndian) {\n      return this.mixUint8ArrayBE(code, array);\n    } else if (ByteOrder.NativeOrder === ByteOrder.LittleEndian) {\n      return this.mixUInt8ArrayLE(code, array);\n    }\n    throw new Error();\n  },\n\n  /** @internal */\n  mixUint8ArrayBE(code: number, array: Uint8Array): number {\n    let offset = 0;\n    const limit = array.length;\n    while (offset + 3 < limit) {\n      const word = (array[offset    ]! & 0xff) << 24 | (array[offset + 1]! & 0xff) << 16\n                 | (array[offset + 2]! & 0xff) <<  8 |  array[offset + 3]! & 0xff;\n      code = this.mix(code, word);\n      offset += 4;\n    }\n    if (offset < limit) {\n      let word = (array[offset]! & 0xff) << 24;\n      if (offset + 1 < limit) {\n        word |= (array[offset + 1]! & 0xff) << 16;\n        if (offset + 2 < limit) {\n          word |= (array[offset + 2]! & 0xff) << 8;\n          //assert offset + 3 === limit;\n        }\n      }\n      word = ((word & 0xffff) * 0xcc9e2d51) + (((word >>> 16) * 0xcc9e2d51 & 0xffff) << 16) & 0xffffffff;\n      word = this.rotl(word, 15);\n      word = ((word & 0xffff) * 0x1b873593) + (((word >>> 16) * 0x1b873593 & 0xffff) << 16) & 0xffffffff;\n      code ^= word;\n    }\n    return code ^ limit;\n  },\n\n  /** @internal */\n  mixUInt8ArrayLE(code: number, array: Uint8Array): number {\n    let offset = 0;\n    const limit = array.length;\n    while (offset + 3 < limit) {\n      const word =  array[offset    ]! & 0xff        | (array[offset + 1]! & 0xff) <<  8\n                 | (array[offset + 2]! & 0xff) << 16 | (array[offset + 3]! & 0xff) << 24;\n      code = this.mix(code, word);\n      offset += 4;\n    }\n    if (offset < limit) {\n      let word = array[offset]! & 0xff;\n      if (offset + 1 < limit) {\n        word |= (array[offset + 1]! & 0xff) << 8;\n        if (offset + 2 < limit) {\n          word |= (array[offset + 2]! & 0xff) << 16;\n          //assert offset + 3 === limit;\n        }\n      }\n      word = ((word & 0xffff) * 0xcc9e2d51) + (((word >>> 16) * 0xcc9e2d51 & 0xffff) << 16) & 0xffffffff;\n      word = this.rotl(word, 15);\n      word = ((word & 0xffff) * 0x1b873593) + (((word >>> 16) * 0x1b873593 & 0xffff) << 16) & 0xffffffff;\n      code ^= word;\n    }\n    return code ^ limit;\n  },\n\n  /**\n   * Mixes each consecutive 4-byte word of the UTF-8 encoding of `string`\n   * into `code`, and returns the accumulated hash value.\n   */\n  mixString(code: number, string: string): number {\n    if (ByteOrder.NativeOrder === ByteOrder.BigEndian) {\n      return this.mixStringBE(code, string);\n    } else if (ByteOrder.NativeOrder === ByteOrder.LittleEndian) {\n      return this.mixStringLE(code, string);\n    }\n    throw new Error();\n  },\n\n  /** @internal */\n  mixStringBE(code: number, string: string): number {\n    let word = 0;\n    let k = 32;\n    let i = 0;\n    const n = string.length;\n    let utf8Length = 0;\n    while (i < n) {\n      let c = string.codePointAt(i);\n      if (c === void 0) {\n        c = string.charCodeAt(i);\n      }\n      if (c >= 0 && c <= 0x7f) { // U+0000..U+007F\n        k -= 8;\n        word |= c << k;\n        if (k === 0) { code = this.mix(code, word); word = 0; k = 32; }\n        utf8Length += 1;\n      } else if (c >= 0x80 && c <= 0x7ff) { // U+0080..U+07FF\n        k -= 8;\n        word |= (0xc0 | (c >>> 6)) << k;\n        if (k === 0) { code = this.mix(code, word); word = 0; k = 32; }\n        k -= 8;\n        word |= (0x80 | (c & 0x3f)) << k;\n        if (k === 0) { code = this.mix(code, word); word = 0; k = 32; }\n        utf8Length += 2;\n      } else if (c >= 0x0800 && c <= 0xffff || // U+0800..U+D7FF\n                 c >= 0xe000 && c <= 0xffff) { // U+E000..U+FFFF\n        k -= 8;\n        word |= (0xe0 | (c  >>> 12)) << k;\n        if (k === 0) { code = this.mix(code, word); word = 0; k = 32; }\n        k -= 8;\n        word |= (0x80 | ((c >>>  6) & 0x3f)) << k;\n        if (k === 0) { code = this.mix(code, word); word = 0; k = 32; }\n        k -= 8;\n        word |= (0x80 | (c & 0x3f)) << k;\n        if (k === 0) { code = this.mix(code, word); word = 0; k = 32; }\n        utf8Length += 3;\n      } else if (c >= 0x10000 && c <= 0x10ffff) { // U+10000..U+10FFFF\n        k -= 8;\n        word |= (0xf0 | (c  >>> 18)) << k;\n        if (k === 0) { code = this.mix(code, word); word = 0; k = 32; }\n        k -= 8;\n        word |= (0x80 | ((c >>> 12) & 0x3f)) << k;\n        if (k === 0) { code = this.mix(code, word); word = 0; k = 32; }\n        k -= 8;\n        word |= (0x80 | ((c >>>  6) & 0x3f)) << k;\n        if (k === 0) { code = this.mix(code, word); word = 0; k = 32; }\n        k -= 8;\n        word |= (0x80 | (c & 0x3f)) << k;\n        if (k === 0) { code = this.mix(code, word); word = 0; k = 32; }\n        utf8Length += 4;\n      } else { // surrogate or invalid code point\n        k -= 8;\n        word |= 0xef << k;\n        if (k === 0) { code = this.mix(code, word); word = 0; k = 32; }\n        k -= 8;\n        word |= 0xbf << k;\n        if (k === 0) { code = this.mix(code, word); word = 0; k = 32; }\n        k -= 8;\n        word |= 0xbd << k;\n        if (k === 0) { code = this.mix(code, word); word = 0; k = 32; }\n        utf8Length += 3;\n      }\n      i = Strings.offsetByCodePoints(string, i, 1);\n    }\n    if (k !== 32) {\n      word = ((word & 0xffff) * 0xcc9e2d51) + (((word >>> 16) * 0xcc9e2d51 & 0xffff) << 16) & 0xffffffff;\n      word = this.rotl(word, 15);\n      word = ((word & 0xffff) * 0x1b873593) + (((word >>> 16) * 0x1b873593 & 0xffff) << 16) & 0xffffffff;\n      code ^= word;\n    }\n    return code ^ utf8Length;\n  },\n\n  /** @internal */\n  mixStringLE(code: number, string: string): number {\n    let word = 0;\n    let k = 0;\n    let i = 0;\n    const n = string.length;\n    let utf8Length = 0;\n    while (i < n) {\n      let c = string.codePointAt(i);\n      if (c === void 0) {\n        c = string.charCodeAt(i);\n      }\n      if (c >= 0 && c <= 0x7f) { // U+0000..U+007F\n        word |= c << k;\n        k += 8;\n        if (k === 32) { code = this.mix(code, word); word = 0; k = 0; }\n        utf8Length += 1;\n      } else if (c >= 0x80 && c <= 0x7ff) { // U+0080..U+07FF\n        word |= (0xc0 | (c >>> 6)) << k;\n        k += 8;\n        if (k === 32) { code = this.mix(code, word); word = 0; k = 0; }\n        word |= (0x80 | (c & 0x3f)) << k;\n        k += 8;\n        if (k === 32) { code = this.mix(code, word); word = 0; k = 0; }\n        utf8Length += 2;\n      } else if (c >= 0x0800 && c <= 0xffff || // U+0800..U+D7FF\n                 c >= 0xe000 && c <= 0xffff) { // U+E000..U+FFFF\n        word |= (0xe0 | (c  >>> 12)) << k;\n        k += 8;\n        if (k === 32) { code = this.mix(code, word); word = 0; k = 0; }\n        word |= (0x80 | ((c >>>  6) & 0x3f)) << k;\n        k += 8;\n        if (k === 32) { code = this.mix(code, word); word = 0; k = 0; }\n        word |= (0x80 | (c & 0x3f)) << k;\n        k += 8;\n        if (k === 32) { code = this.mix(code, word); word = 0; k = 0; }\n        utf8Length += 3;\n      } else if (c >= 0x10000 && c <= 0x10ffff) { // U+10000..U+10FFFF\n        word |= (0xf0 | (c  >>> 18)) << k;\n        k += 8;\n        if (k === 32) { code = this.mix(code, word); word = 0; k = 0; }\n        word |= (0x80 | ((c >>> 12) & 0x3f)) << k;\n        k += 8;\n        if (k === 32) { code = this.mix(code, word); word = 0; k = 0; }\n        word |= (0x80 | ((c >>>  6) & 0x3f)) << k;\n        k += 8;\n        if (k === 32) { code = this.mix(code, word); word = 0; k = 0; }\n        word |= (0x80 | (c & 0x3f)) << k;\n        k += 8;\n        if (k === 32) { code = this.mix(code, word); word = 0; k = 0; }\n        utf8Length += 4;\n      } else { // surrogate or invalid code point\n        word |= 0xef << k;\n        k += 8;\n        if (k === 32) { code = this.mix(code, word); word = 0; k = 0; }\n        word |= 0xbf << k;\n        k += 8;\n        if (k === 32) { code = this.mix(code, word); word = 0; k = 0; }\n        word |= 0xbd << k;\n        k += 8;\n        if (k === 32) { code = this.mix(code, word); word = 0; k = 0; }\n        utf8Length += 3;\n      }\n      i = Strings.offsetByCodePoints(string, i, 1);\n    }\n    if (k !== 32) {\n      word = ((word & 0xffff) * 0xcc9e2d51) + (((word >>> 16) * 0xcc9e2d51 & 0xffff) << 16) & 0xffffffff;\n      word = this.rotl(word, 15);\n      word = ((word & 0xffff) * 0x1b873593) + (((word >>> 16) * 0x1b873593 & 0xffff) << 16) & 0xffffffff;\n      code ^= word;\n    }\n    return code ^ utf8Length;\n  },\n\n  /**\n   * Finalizes the given hash `code`.\n   */\n  mash(code: number): number {\n    code ^= code >>> 16;\n    code = ((code & 0xffff) * 0x85ebca6b) + (((code >>> 16) * 0x85ebca6b & 0xffff) << 16) & 0xffffffff;\n    code ^= code >>> 13;\n    code = ((code & 0xffff) * 0xc2b2ae35) + (((code >>> 16) * 0xc2b2ae35 & 0xffff) << 16) & 0xffffffff;\n    code ^= code >>> 16;\n    return code >>> 0;\n  },\n\n  /** @internal */\n  rotl(value: number, distance: number): number {\n    return (value << distance) | (value >>> (32 - distance));\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Decorator that memoizes the computed value of a getter or nullary method.\n * @public\n */\nexport const Lazy: {\n  <F extends () => unknown>(target: F, context?: ClassMethodDecoratorContext<ThisParameterType<F>, F>): F;\n  <T, R>(target: (this: T) => R, context?: ClassGetterDecoratorContext<T, R>): (this: T) => R;\n} = function <T, R>(target: (this: T) => R, context?: ClassMethodDecoratorContext<T, (this: T) => R> | ClassGetterDecoratorContext<T, R>): (this: T) => R {\n  let defined = false;\n  let value: R;\n  return function (this: T): R {\n    if (!defined) {\n      defined = true;\n      value = target.call(this);\n    }\n    return value;\n  };\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Type that implements a universal equality relation.\n * @public\n */\nexport interface Equals {\n  /**\n   * Returns `true` if `this` is equal to `that`, otherwise returns `false`.\n   */\n  equals(that: unknown): boolean;\n}\n\n/** @public */\nexport const Equals = (function () {\n  const Equals = function (x: unknown, y: unknown): boolean {\n    if (Equals[Symbol.hasInstance](x)) {\n      return x.equals(y);\n    }\n    return x === y;\n  } as {\n    /**\n     * Returns `true` if `x` conforms to [[Equals]] and is\n     * [[Equals.equals equal]] to `y`, otherwise returns `x === y`.\n     */\n    (x: unknown, y: unknown): boolean;\n\n    /**\n     * Returns `true` if `instance` appears to conform to the [[Equals]] interface.\n     */\n    [Symbol.hasInstance](instance: unknown): instance is Equals;\n  };\n\n  Object.defineProperty(Equals, Symbol.hasInstance, {\n    value: function (instance: unknown): instance is Equals {\n      if (instance === null || (typeof instance !== \"object\" && typeof instance !== \"function\")) {\n        return false;\n      }\n      return typeof (instance as Equals).equals === \"function\";\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  return Equals;\n})();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Equals} from \"./Equals\";\n\n/**\n * Type that is convertible to a hash value consistent with its universal\n * equality relation.\n * @public\n */\nexport interface HashCode extends Equals {\n  /**\n   * Returns a 32-bit hash value for this object.\n   */\n  hashCode(): number;\n}\n\n/** @public */\nexport const HashCode = (function () {\n  const HashCode = function (x: HashCode | null | undefined): number {\n    if (x === void 0) {\n      return 0;\n    } else if (x === null) {\n      return 1;\n    }\n    return x.hashCode();\n  } as {\n    /**\n     * Returns the [[HashCode.hashCode hash code]] of `x`, if `x` is an object;\n     * otherwise returns `0` or `1` if `x` is `undefined` or `null`, respectively.\n     */\n    (x: HashCode | null | undefined): number;\n\n    /**\n     * Returns `true` if `instance` appears to conform to the [[HashCode]] interface.\n     */\n    [Symbol.hasInstance](instance: unknown): instance is HashCode;\n  };\n\n  Object.defineProperty(HashCode, Symbol.hasInstance, {\n    value: function (instance: unknown): instance is HashCode {\n      if (instance === null || (typeof instance !== \"object\" && typeof instance !== \"function\")) {\n        return false;\n      }\n      return typeof (instance as HashCode).hashCode === \"function\";\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  return HashCode;\n})();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Type that implements a universal equivalence relation.\n * @public\n */\nexport interface Equivalent {\n  /**\n   * Returns `true` if `this` is equivalent to `that` within some optionally\n   * specified error tolerance `epsilon`, otherwise returns `false`.\n   */\n  equivalentTo(that: unknown, epsilon?: number): boolean;\n}\n\n/** @public */\nexport const Equivalent = (function () {\n  const Equivalent = function (x:unknown, y: unknown, epsilon?: number): boolean {\n    if (Equivalent[Symbol.hasInstance](x)) {\n      return x.equivalentTo(y, epsilon);\n    }\n    return x === y;\n  } as {\n    /**\n     * Returns `true` if `x` conforms to [[Equivalent]] and is\n     * [[Equivalent.equivalentTo equivalent to]] `y`, otherwise returns `x === y`.\n     */\n    (x: unknown, y: unknown, epsilon?: number): boolean;\n\n    /**\n     * Returns `true` if `instance` appears to conform to the [[Equivalent]] interface.\n     */\n    [Symbol.hasInstance](instance: unknown): instance is Equivalent;\n\n    /**\n     * Default equivalence tolerance.\n     */\n    readonly Epsilon: number;\n  };\n\n  Object.defineProperty(Equivalent, Symbol.hasInstance, {\n    value: function (instance: unknown): instance is Equivalent {\n      if (instance === null || (typeof instance !== \"object\" && typeof instance !== \"function\")) {\n        return false;\n      }\n      return typeof (instance as Equivalent).equivalentTo === \"function\";\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Object.defineProperty(Equivalent, \"Epsilon\", {\n    value: 1.0e-8,\n    enumerable: true,\n    configurable: true,\n  });\n\n  return Equivalent;\n})();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/** @public */\nexport type Comparator<T> = (a: T, b: T) => number;\n\n/**\n * Type that implements a universal partial order.\n * @public\n */\nexport interface Compare {\n  /**\n   * Returns the relative order of `this` with respect to `that`. Returns `-1`\n   * if `this` orders before `that`; returns `1` if `this` orders after `that`;\n   * returns `0` if `this` and `that` are equivalent; and returns `NaN` if\n   * `this` is not comparable to `that`.\n   */\n  compareTo(that: unknown): number;\n}\n\n/** @public */\nexport const Compare = (function () {\n  const Compare = function (x: unknown, y: unknown): number {\n    if (x === void 0) {\n      if (y === void 0) {\n        return 0;\n      }\n      return 1;\n    } else if (x === null) {\n      if (y === void 0) {\n        return -1;\n      } else if (y === null) {\n        return 0;\n      }\n      return 1;\n    } else if (typeof (x as Compare).compareTo === \"function\") {\n      if (y === void 0 || y === null) {\n        return -1;\n      }\n      return (x as Compare).compareTo(y);\n    }\n    return NaN;\n  } as {\n    /**\n     * Returns the relative order of `x` with respect to `y`. Returns `-1` if `x`\n     * orders before `y`; returns `1` if `x` orders after `y`; returns `0` if `x`\n     * and `y` are equivalent; and returns `NaN` if `x` is not comparable to `y`.\n     * Objects are [[Compare.compareTo compared to]] each other when both are\n     * defined, otherwise defined objects order before `null`, and `null` orders\n     * before `undefined`.\n     */\n    (x: unknown, y: unknown): number;\n\n    /**\n     * Returns `true` if `instance` appears to conform to the [[Compare]] interface.\n     */\n    [Symbol.hasInstance](instance: unknown): instance is Compare;\n  };\n\n  Object.defineProperty(Compare, Symbol.hasInstance, {\n    value: function (instance: unknown): instance is Compare {\n      if (instance === null || (typeof instance !== \"object\" && typeof instance !== \"function\")) {\n        return false;\n      }\n      return typeof (instance as Compare).compareTo === \"function\";\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  return Compare;\n})();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Utilities for comparing and hashing object identities.\n * @public\n */\nexport const Identity = {\n  /**\n   * Returns the relative order of `x` with respect to `y`. Returns `-1` if\n   * the hash code of object `x` is less than the hash code of object `y`;\n   * returns `1` if the hash code of object `x` is greater than the hash code\n   * of object `y`; and returns `0` if `x` and `y` are identical objects.\n   * If either `x` or `y` is `null` or `undefined`, then objects order before\n   * `null`, and `null` orders before `undefined`.\n   */\n  compare(x: object | null | undefined, y: object | null | undefined): number {\n    if (x !== null && typeof x === \"object\") {\n      if (y !== null && typeof y === \"object\") {\n        const xh = Identity.hash(x);\n        const yh = Identity.hash(y);\n        return xh < yh ? -1 : xh > yh ? 1 : 0;\n      }\n      return -1;\n    } else if (x === null) {\n      return y === void 0 ? -1 : y === null ? 0 : 1;\n    } else if (x === void 0) {\n      return y === void 0 ? 0 : 1;\n    }\n    return NaN;\n  },\n\n  /**\n   * Returns a unique 32-bit hash value for a particular object instance.\n   */\n  hash: (function () {\n    let codes: WeakMap<object, number> | null = null;\n    let nextCode = 2;\n    return function hash(x: object | null | undefined): number {\n      if (x !== null && typeof x === \"object\") {\n        if (codes === null) {\n          codes = new WeakMap<object, number>();\n        }\n        let hashCode = codes.get(x);\n        if (hashCode === void 0) {\n          hashCode = ~~nextCode;\n          codes.set(x, hashCode);\n          nextCode += 1;\n        }\n        return hashCode;\n      } else if (x === null) {\n        return 1;\n      } else if (x === void 0) {\n        return 0;\n      }\n      throw new TypeError(\"\" + x);\n    };\n  })(),\n\n  fromLike<T>(value: T): T {\n    return value;\n  },\n\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"./types\";\n\n/**\n * Utilities for comparing and hashing booleans.\n * @public\n */\nexport const Booleans = {\n  /**\n   * Returns the relative order of `x` with respect to `y`. Returns `-1` if\n   * `x` is `true` and `y` is `false`; returns `1` if `x` is `false` and `y`\n   * is `true`; and returns `0` if `x` and `y` are equal booleans. If either\n   * `x` or `y` is `null` or `undefined`, then booleans order before `null`,\n   * and `null` orders before `undefined`.\n   */\n  compare(x: boolean | null | undefined, y: boolean | null | undefined): number {\n    if (typeof x === \"boolean\") {\n      return typeof y === \"boolean\" ? (x && !y ? -1 : !x && y ? 1 : 0) : -1;\n    } else if (x === null) {\n      return y === void 0 ? -1 : y === null ? 0 : 1;\n    } else if (x === void 0) {\n      return y === void 0 ? 0 : 1;\n    }\n    return NaN;\n  },\n\n  /**\n   * Returns a hash code for a number.\n   */\n  hash(x: boolean | null | undefined): number {\n    if (x === true) {\n      return 3;\n    } else if (x === false) {\n      return 2;\n    } else if (x === null) {\n      return 1;\n    } else if (x === void 0) {\n      return 0;\n    }\n    throw new TypeError(\"\" + x);\n  },\n\n  fromLike<T extends boolean | string | number | null | undefined>(value: T): boolean | Uninitable<T> {\n    if (value === void 0 || value === null) {\n      return value as boolean | Uninitable<T>;\n    }\n    return Boolean(value);\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"./types\";\nimport {Equivalent} from \"./Equivalent\";\n\n/**\n * Utilities for comparing and hashing numbers.\n * @public\n */\nexport const Numbers = {\n  /**\n   * Returns `true` if `x` and `y` are equal numbers, or if both are `NaN`;\n   * otherwise returns `x === y` if either `x` or `y` is not defined.\n   */\n  equal(x: number | null | undefined, y: number | null | undefined): boolean {\n    return x === y || typeof x === \"number\" && typeof y === \"number\" && isNaN(x) && isNaN(y);\n  },\n\n  /**\n   * Returns `true` if `x` and `y` are both defined, and the difference between\n   * the two is less than `epsilon`, or if both are `NaN`; otherwise returns\n   * `x === y` if either `x` or `y` is not defined.\n   */\n  equivalent(x: number | null | undefined, y: number | null | undefined, epsilon?: number): boolean {\n    return x === y || typeof x === \"number\" && typeof y === \"number\" && (isNaN(x) && isNaN(y) || Math.abs(y - x) < (epsilon !== void 0 ? epsilon : Equivalent.Epsilon));\n  },\n\n  /**\n   * Returns the relative order of `x` with respect to `y`. Returns `-1` if\n   * the number `x` less than the number `y`; returns `1` if the number `x` is\n   * greater than the number `y`; and returns `0` if `x` and `y` are equal\n   * numbers, or if both are `NaN`. If either `x` or `y` is `NaN`, `null`,\n   * or `undefined`, then numbers order before `NaN`, `NaN` orders before\n   * `null`, and `null` orders before `undefined`.\n   */\n  compare(x: number | null | undefined, y: number | null | undefined): number {\n    if (typeof x === \"number\") {\n      return typeof y === \"number\" ? (x < y ? -1 : x > y ? 1 : isNaN(y) ? (isNaN(x) ? 0 : -1) : isNaN(x) ? 1 : 0) : -1;\n    } else if (x === null) {\n      return y === void 0 ? -1 : y === null ? 0 : 1;\n    } else if (x === void 0) {\n      return y === void 0 ? 0 : 1;\n    }\n    return NaN;\n  },\n\n  /**\n   * Returns a 32-bit hash value for the number `x`, if defined; otherwise\n   * returns `0` or `1` if `x` is `undefined` or `null`, respectively.\n   */\n  hash: (function () {\n    let hashArrayBuffer: ArrayBuffer | null = null;\n    let hashFloat64Array: Float64Array | null = null;\n    let hashInt32Array: Int32Array | null = null;\n    return function hash(x: number | null | undefined): number {\n      if (typeof x === \"number\") {\n        if (x === ~~x) {\n          return ~~x;\n        } else if (hashArrayBuffer === null) {\n          hashArrayBuffer = new ArrayBuffer(8);\n          hashFloat64Array = new Float64Array(hashArrayBuffer);\n          hashInt32Array = new Int32Array(hashArrayBuffer);\n        }\n        hashFloat64Array![0] = x;\n        return hashInt32Array![0]! ^ hashInt32Array![1]!;\n      } else if (x === null) {\n        return 1;\n      } else if (x === void 0) {\n        return 0;\n      }\n      throw new TypeError(\"\" + x);\n    };\n  })(),\n\n  fromLike<T extends number | string | boolean | null | undefined>(value: T): number | Uninitable<T> {\n    if (value === void 0 || value === null) {\n      return value as number | Uninitable<T>;\n    }\n    return Number(value);\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"./types\";\nimport {Murmur3} from \"./Murmur3\";\n\n/**\n * Utilities for comparing and hashing strings.\n * @public\n */\nexport const Strings = {\n  codePointAt(string: string, index: number): number | undefined {\n    const length = string.length;\n    index = index ? Number(index) : 0; // Coerce to number.\n    if (index !== index) { // Convert NaN to zero.\n      index = 0;\n    }\n    if (index >= 0 && index < length) {\n      const c1 = string.charCodeAt(index);\n      if (c1 <= 0xd7ff || c1 >= 0xe000) { // U+0000..U+D7FF | U+E000..U+FFFF\n        return c1;\n      } else if (c1 <= 0xdbff && index + 1 < length) {\n        const c2 = string.charCodeAt(index + 1);\n        if (c2 >= 0xdc00 && c2 <= 0xdfff) { // U+10000..U+10FFFF\n          return ((c1 & 0x03ff) << 10 + c2 & 0x03ff) + 0x10000;\n        }\n      }\n    }\n    return void 0;\n  },\n\n  offsetByCodePoints(string: string, index: number, count: number): number {\n    if (count > 0) {\n      const length = string.length;\n      while (count > 0 && index < length) {\n        const c1 = string.charCodeAt(index);\n        if (c1 <= 0xd7ff || c1 >= 0xe000) { // U+0000..U+D7FF | U+E000..U+FFFF\n          index += 1;\n        } else if (c1 <= 0xdbff && index + 1 < length) {\n          const c2 = string.charCodeAt(index + 1);\n          if (c2 >= 0xdc00 && c2 <= 0xdfff) { // U+10000..U+10FFFF\n            index += 2;\n          } else {\n            index += 1;\n          }\n        } else {\n          index += 1;\n        }\n        count -= 1;\n      }\n    } else if (count < 0) {\n      while (count < 0 && index > 0) {\n        const c2 = string.charCodeAt(index - 1);\n        if (c2 <= 0xd7ff || c2 >= 0xe000) { // U+0000..U+D7FF | U+E000..U+FFFF\n          index -= 1;\n        } else if (c2 >= 0xdc00 && c2 <= 0xdfff && index - 1 > 0) {\n          const c1 = string.charCodeAt(index - 2);\n          if (c1 >= 0xd800 && c1 <= 0xdfff) { // U+10000..U+10FFFF\n            index -= 2;\n          } else {\n            index -= 1;\n          }\n        } else {\n          index -= 1;\n        }\n        count -= 1;\n      }\n    }\n    return index;\n  },\n\n  /**\n   * Returns the relative order of `x` with respect to `y`. Returns `-1` if\n   * the string `x` lexicographically orders before the string `y`; returns `1`\n   * if the string `x` lexicographically orders after the string `y`; and\n   * returns `0` if `x` and `y` are equal strings. If either `x` or `y` is\n   * `null` or `undefined`, then strings order before `null`, and `null` orders\n   * before `undefined`.\n   */\n  compare(x: string | null | undefined, y: string | null | undefined): number {\n    if (typeof x === \"string\") {\n      return typeof y === \"string\" ? (x < y ? -1 : x > y ? 1 : 0) : -1;\n    } else if (x === null) {\n      return y === void 0 ? -1 : y === null ? 0 : 1;\n    } else if (x === void 0) {\n      return y === void 0 ? 0 : 1;\n    }\n    return NaN;\n  },\n\n  /**\n   * Returns a hash code for a string.\n   */\n  hash(x: string | null | undefined): number {\n    if (typeof x === \"string\") {\n      return Murmur3.mash(Murmur3.mixString(0, x));\n    } else if (x === null) {\n      return 1;\n    } else if (x === void 0) {\n      return 0;\n    }\n    throw new TypeError(\"\" + x);\n  },\n\n  fromLike<T extends string | number | boolean | null | undefined>(value: T): string | Uninitable<T> {\n    if (value === void 0 || value === null) {\n      return value as string | Uninitable<T>;\n    }\n    return String(value);\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Strings} from \"./Strings\";\n\n/**\n * Utilities for working with ECMAScript identifiers.\n * @public\n */\nexport const Identifiers = {\n  /** @internal */\n  isStartChar(c: number): boolean {\n    return c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c === 95/*'_'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/\n        || c >= 0xc0 && c <= 0xd6\n        || c >= 0xd8 && c <= 0xf6\n        || c >= 0xf8 && c <= 0x2ff\n        || c >= 0x370 && c <= 0x37d\n        || c >= 0x37f && c <= 0x1fff\n        || c >= 0x200c && c <= 0x200d\n        || c >= 0x2070 && c <= 0x218f\n        || c >= 0x2c00 && c <= 0x2fef\n        || c >= 0x3001 && c <= 0xd7ff\n        || c >= 0xf900 && c <= 0xfdcf\n        || c >= 0xfdf0 && c <= 0xfffd\n        || c >= 0x10000 && c <= 0xeffff;\n  },\n\n  /** @internal */\n  isPartChar(c: number): boolean {\n    return c === 45/*'-'*/\n        || c >= 48/*'0'*/ && c <= 57/*'9'*/\n        || c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c === 95/*'_'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/\n        || c === 0xb7\n        || c >= 0xc0 && c <= 0xd6\n        || c >= 0xd8 && c <= 0xf6\n        || c >= 0xf8 && c <= 0x37d\n        || c >= 0x37f && c <= 0x1fff\n        || c >= 0x200c && c <= 0x200d\n        || c >= 0x203f && c <= 0x2040\n        || c >= 0x2070 && c <= 0x218f\n        || c >= 0x2c00 && c <= 0x2fef\n        || c >= 0x3001 && c <= 0xd7ff\n        || c >= 0xf900 && c <= 0xfdcf\n        || c >= 0xfdf0 && c <= 0xfffd\n        || c >= 0x10000 && c <= 0xeffff;\n  },\n\n  isValid(identifier: string): boolean {\n    let c: number | undefined;\n    if (identifier.length === 0 || (c = identifier.codePointAt(0)) === void 0 || !this.isStartChar(c)) {\n      return false;\n    }\n    let i = Strings.offsetByCodePoints(identifier, 0, 1);\n    while (i < identifier.length && (c = identifier.codePointAt(0)) !== void 0 && this.isPartChar(c)) {\n      i = Strings.offsetByCodePoints(identifier, i, 1);\n    }\n    return i === identifier.length && !this.isReserved(identifier);\n  },\n\n  isReserved(identifier: string): boolean {\n    switch (identifier) {\n      case \"await\":\n      case \"break\":\n      case \"case\":\n      case \"catch\":\n      case \"class\":\n      case \"const\":\n      case \"continue\":\n      case \"debugger\":\n      case \"default\":\n      case \"delete\":\n      case \"do\":\n      case \"else\":\n      case \"enum\":\n      case \"export\":\n      case \"extends\":\n      case \"false\":\n      case \"finally\":\n      case \"for\":\n      case \"function\":\n      case \"if\":\n      case \"import\":\n      case \"in\":\n      case \"instanceof\":\n      case \"new\":\n      case \"null\":\n      case \"return\":\n      case \"super\":\n      case \"switch\":\n      case \"this\":\n      case \"throw\":\n      case \"true\":\n      case \"try\":\n      case \"typeof\":\n      case \"var\":\n      case \"void\":\n      case \"while\":\n      case \"with\":\n      case \"yield\":\n        return true;\n      default:\n        return false;\n    }\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Utilities for comparing and hashing functions.\n * @public\n */\nexport const Functions = {\n  /**\n   * Returns the relative order of `x` with respect to `y`. Returns `-1` if\n   * the hash code of function `x` is less than the hash code of function `y`;\n   * returns `1` if the hash code of function `x` is greater than the hash code\n   * of function `y`; and returns `0` if `x` and `y` are identical functions.\n   * If either `x` or `y` is `null` or `undefined`, then functions order before\n   * `null`, and `null` orders before `undefined`.\n   */\n  compare(x: Function | null | undefined, y: Function | null | undefined): number {\n    if (typeof x === \"function\") {\n      if (typeof y === \"function\") {\n        const xh = Functions.hash(x);\n        const yh = Functions.hash(y);\n        return xh < yh ? -1 : xh > yh ? 1 : 0;\n      }\n      return -1;\n    } else if (x === null) {\n      return y === void 0 ? -1 : y === null ? 0 : 1;\n    } else if (x === void 0) {\n      return y === void 0 ? 0 : 1;\n    }\n    return NaN;\n  },\n\n  /**\n   * Returns a 32-bit hash value for a function.\n   */\n  hash: (function () {\n    let codes: WeakMap<Function, number> | null = null;\n    let nextCode = 2;\n    return function hash(x: Function | null | undefined): number {\n      if (typeof x === \"function\") {\n        if (codes === null) {\n          codes = new WeakMap<Function, number>();\n        }\n        let hashCode = codes.get(x);\n        if (hashCode === void 0) {\n          hashCode = ~~nextCode;\n          codes.set(x, hashCode);\n          nextCode += 1;\n        }\n        return hashCode;\n      } else if (x === null) {\n        return 1;\n      } else if (x === void 0) {\n        return 0;\n      }\n      throw new TypeError(\"\" + x);\n    };\n  })(),\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"./Murmur3\";\n\n/**\n * Utilities for comparing and hashing constructors.\n * @public\n */\nexport const Constructors = {\n  /**\n   * Returns the relative order of `x` with respect to `y`. Returns `-1` if\n   * the hash code of constructor `x` is less than the hash code of constructor\n   * `y`; returns `1` if the hash code of constructor `x` is greater than the\n   * hash code of constructor `y`; and returns `0` if `x` and `y` are identical\n   * constructors. If either `x` or `y` is `null` or `undefined`, then\n   * constructors order before `null`, and `null` orders before `undefined`.\n   */\n  compare(x: Function | null | undefined, y: Function | null | undefined): number {\n    if (typeof x === \"function\") {\n      if (typeof y === \"function\") {\n        const xh = Constructors.hash(x);\n        const yh = Constructors.hash(y);\n        return xh < yh ? -1 : xh > yh ? 1 : 0;\n      }\n      return -1;\n    } else if (x === null) {\n      return y === void 0 ? -1 : y === null ? 0 : 1;\n    } else if (x === void 0) {\n      return y === void 0 ? 0 : 1;\n    }\n    return NaN;\n  },\n\n  /**\n   * Returns a 32-bit hash value for a constructor.\n   */\n  hash: (function () {\n    let codes: WeakMap<Function, number> | null = null;\n    return function hash(x: Function | null | undefined): number {\n      if (typeof x === \"function\") {\n        if (codes === null) {\n          codes = new WeakMap<Function, number>();\n        }\n        let hashCode = codes.get(x);\n        if (hashCode === void 0) {\n          hashCode = Murmur3.mash(Murmur3.mixString(0, x.name));\n          codes.set(x, hashCode);\n        }\n        return hashCode;\n      } else if (x === null) {\n        return 1;\n      } else if (x === void 0) {\n        return 0;\n      }\n      throw new TypeError(\"\" + x);\n    };\n  })(),\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"./Murmur3\";\nimport {Lazy} from \"./Lazy\";\nimport {Values} from \"./\"; // forward import\n\n/**\n * Utilities for immutably updating, comparing, and hashing arrays.\n * @public\n */\nexport const Arrays = {\n  empty: Lazy(function <T>(): readonly T[] {\n    return Object.freeze([]);\n  }) as <T>() => readonly T[],\n\n  /**\n   * Returns a copy of an array with the given element inserted, if the element\n   * is not already present in the array; otherwise returns the input array if\n   * it already contains the specified element.\n   */\n  inserted<T>(newElement: T, oldArray: readonly T[] | null | undefined): readonly T[] {\n    const n = oldArray !== void 0 && oldArray !== null ? oldArray.length : 0;\n    const newArray = new Array<T>(n + 1);\n    for (let i = 0; i < n; i += 1) {\n      const element = oldArray![i]!;\n      if (element === newElement) {\n        return oldArray!;\n      }\n      newArray[i] = element;\n    }\n    newArray[n] = newElement;\n    return newArray;\n  },\n\n  /**\n   * Returns a copy of an array with the given element removed; returns the\n   * input array if it does not contain the specified element.\n   */\n  removed<T>(oldElement: T, oldArray: readonly T[] | null | undefined): readonly T[] {\n    const n = oldArray !== void 0 && oldArray !== null ? oldArray.length : 0;\n    if (n === 0) {\n      return oldArray !== void 0 && oldArray !== null ? oldArray : Arrays.empty();\n    } else if (n === 1) {\n      return oldArray![0]! !== oldElement ? oldArray! : Arrays.empty();\n    }\n    const newArray = new Array<T>(n - 1);\n    let i = 0;\n    while (i < n) {\n      const element = oldArray![i]!;\n      if (element === oldElement) {\n        i += 1;\n        while (i < n) {\n          newArray[i - 1] = oldArray![i]!;\n          i += 1;\n        }\n        return newArray;\n      }\n      newArray[i] = element;\n      i += 1;\n    }\n    return oldArray!;\n  },\n\n  /**\n   * Returns `true` if `x` and `y` are structurally equal arrays; otherwise\n   * returns `x === y` if either `x` or `y` is not an array.\n   */\n  equal(x: ArrayLike<unknown> | null | undefined, y: ArrayLike<unknown> | null | undefined): boolean {\n    if (x === y) {\n      return true;\n    } else if (x !== null && typeof x === \"object\" && y !== null && typeof y === \"object\") {\n      const n = x.length;\n      if (n !== y.length) {\n        return false;\n      }\n      for (let i = 0; i < n; i += 1) {\n        if (!Values.equal(x[i], y[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  },\n\n  /**\n   * Returns `true` if `x` and `y` are structurally [[Equivalent.equivalentTo\n   * equivalent]] arrays; otherwise returns `x === y` if either `x` or `y` is\n   * not an array.\n   */\n  equivalent(x: ArrayLike<unknown> | null | undefined, y: ArrayLike<unknown> | null | undefined, epsilon?: number): boolean {\n    if (x === y) {\n      return true;\n    } else if (x !== null && typeof x === \"object\" && y !== null && typeof y === \"object\") {\n      const n = x.length;\n      if (n !== y.length) {\n        return false;\n      }\n      for (let i = 0; i < n; i += 1) {\n        if (!Values.equivalent(x[i], y[i], epsilon)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  },\n\n  /**\n   * Returns the relative order of `x` with respect to `y`. Returns `-1` if\n   * the elements of array `x` order lexicographically before the elements of\n   * array `y`; returns `1` if the elements of array `x` order lexicographically\n   * after the elements of array `y`; and returns `0` if `x` and `y` are equal\n   * arrays. If either `x` or `y` is `null` or `undefined`, then arrays order\n   * before `null`, and `null` orders before `undefined`.\n   */\n  compare(x: ArrayLike<unknown> | null | undefined, y: ArrayLike<unknown> | null | undefined): number {\n    if (x !== null && typeof x === \"object\") {\n      if (y !== null && typeof y === \"object\") {\n        if (x === y) {\n          return 0;\n        }\n        const p = x.length;\n        const q = y.length;\n        let order = 0;\n        for (let i = 0, n = Math.min(p, q); i < n && order === 0; i += 1) {\n          order = Values.compare(x[i], y[i]);\n        }\n        return order !== 0 ? order : p > q ? 1 : p < q ? -1 : 0;\n      }\n      return -1;\n    } else if (x === null) {\n      return y === void 0 ? -1 : y === null ? 0 : 1;\n    } else if (x === void 0) {\n      return y === void 0 ? 0 : 1;\n    }\n    return NaN;\n  },\n\n  /**\n   * Returns a 32-bit hash value for the elements of array `x`, if defined;\n   * otherwise returns `0` or `1` if `x` is `undefined` or `null`, respectively.\n   */\n  hash(x: ArrayLike<unknown> | null | undefined): number {\n    if (typeof x === \"object\" && x !== null) {\n      let code = 0;\n      for (let i = 0; i < x.length; i += 1) {\n        code = Murmur3.mix(code, Values.hash(x[i]));\n      }\n      return Murmur3.mash(code);\n    } else if (x === null) {\n      return 1;\n    } else if (x === void 0) {\n      return 0;\n    }\n    throw new TypeError(\"\" + x);\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"./Murmur3\";\nimport {Strings} from \"./Strings\";\nimport {Values} from \"./\"; // forward import\n\n/**\n * Utilities for comparing and hashing structural objects.\n * @public\n */\nexport const Objects = {\n  /**\n   * Returns `true` if the given object has no own properties.\n   */\n  isEmpty(x: object | null | undefined): boolean {\n    if (x !== null && typeof x === \"object\") {\n      for (const k in x) {\n        if (Object.prototype.hasOwnProperty.call(x, k)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  },\n\n  /**\n   * Returns `true` if `object` has any of the specified `keys`,\n   * as determined by `key in object`. Returns `false` if `object`\n   * is `undefined` or `null`, or if `typeof object` is neither\n   * `\"object\"` nor `\"function\"`, or if none of the specified `keys`\n   * are present in `object`.\n   */\n  hasAnyKey<O>(object: unknown, ...keys: (keyof O)[]): object is O {\n    if (object === null || (typeof object !== \"object\" && typeof object !== \"function\")) {\n      return false;\n    }\n    for (let i = 0; i < keys.length; i += 1) {\n      if (keys[i]! in object) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Returns `true` if `object` has all of the specified `keys`,\n   * as determined by `key in object`. Returns `false` if `object`\n   * is `undefined` or `null`, or if `typeof object` is neither\n   * `\"object\"` nor `\"function\"`, or if at least one of specified `keys`\n   * are not present in `object`.\n   */\n  hasAllKeys<O>(object: unknown, ...keys: (keyof O)[]): object is O {\n    if (object === null || (typeof object !== \"object\" && typeof object !== \"function\")) {\n      return false;\n    }\n    for (let i = 0; i < keys.length; i += 1) {\n      if (!(keys[i]! in object)) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  /**\n   * Returns a shallow copy of `object` with the given `key`-`value` pair\n   * inserted before the `target` entry value, in traversal order.\n   */\n  inserted<O, K extends keyof O>(object: O, key: K, value: O[K], target: unknown): O {\n    let inserted = false;\n    const newObject = {} as O;\n    for (const oldKey in object) {\n      if (Object.prototype.hasOwnProperty.call(object, oldKey)) {\n        const oldValue = object[oldKey]!;\n        if (!inserted && oldValue === target) {\n          newObject[key as keyof O] = value as O[keyof O];\n          inserted = true;\n        }\n        newObject[oldKey] = oldValue;\n      }\n    }\n    if (!inserted) {\n      newObject[key as keyof O] = value as O[keyof O];\n    }\n    return newObject;\n  },\n\n  getFirstKey<O>(object: O): keyof O | undefined {\n    for (const k in object) {\n      if (Object.prototype.hasOwnProperty.call(object, k)) {\n        return k;\n      }\n    }\n    return void 0;\n  },\n\n  getFirstValue<O>(object: O): O[keyof O] | undefined {\n    for (const k in object) {\n      if (Object.prototype.hasOwnProperty.call(object, k)) {\n        return object[k]!;\n      }\n    }\n    return void 0;\n  },\n\n  getNextKey<O>(object: O, key: keyof O): keyof O | undefined {\n    let mark = false;\n    for (const k in object) {\n      if (Object.prototype.hasOwnProperty.call(object, k)) {\n        if (mark) {\n          return k;\n        } else if (k === key) {\n          mark = true;\n        }\n      }\n    }\n    return void 0;\n  },\n\n  getNextValue<O>(object: O, key: keyof O): O[keyof O] | undefined {\n    let mark = false;\n    for (const k in object) {\n      if (Object.prototype.hasOwnProperty.call(object, k)) {\n        if (mark) {\n          return object[k]!;\n        } else if (k === key) {\n          mark = true;\n        }\n      }\n    }\n    return void 0;\n  },\n\n  /**\n   * Returns `true` if `x` and `y` are structurally equal objects; otherwise\n   * returns `x === y` if either `x` or `y` is not an object.\n   */\n  equal(x: object | null | undefined, y: object | null | undefined): boolean {\n    if (x === y) {\n      return true;\n    } else if (x !== null && typeof x === \"object\" && y !== null && typeof y === \"object\") {\n      const xKeys = Object.keys(x);\n      const yKeys = Object.keys(y);\n      const n = xKeys.length;\n      if (n !== yKeys.length) {\n        return false;\n      }\n      for (let i = 0; i < n; i += 1) {\n        const key = xKeys[i]!;\n        if (key !== yKeys[i] || !Values.equal((x as any)[key], (y as any)[key])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  },\n\n  /**\n   * Returns `true` if `x` and `y` are structurally [[Equivalent.equivalentTo\n   * equivalent]] objects; otherwise returns `x === y` if either `x` or `y` is\n   * not an object.\n   */\n  equivalent(x: object | null | undefined, y: object | null | undefined, epsilon?: number): boolean {\n    if (x === y) {\n      return true;\n    } else if (x !== null && typeof x === \"object\" && y !== null && typeof y === \"object\") {\n      const xKeys = Object.keys(x);\n      const yKeys = Object.keys(y);\n      const n = xKeys.length;\n      if (n !== yKeys.length) {\n        return false;\n      }\n      for (let i = 0; i < n; i += 1) {\n        const key = xKeys[i]!;\n        if (key !== yKeys[i] || !Values.equivalent((x as any)[key], (y as any)[key], epsilon)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  },\n\n  /**\n   * Returns the relative order of `x` with respect to `y`. Returns `-1` if\n   * the entries of object `x` order lexicographically before the entries of\n   * object `y`; returns `1` if the entries of object `x` order\n   * lexicographically after the entries of object `y`; and returns `0` if `x`\n   * and `y` are equal objects. If either `x` or `y` is `null` or `undefined`,\n   * then objects order before `null`, and `null` orders before `undefined`.\n   */\n  compare(x: object | null | undefined, y: object | null | undefined): number {\n    if (x !== null && typeof x === \"object\") {\n      if (y !== null && typeof y === \"object\") {\n        if (x === y) {\n          return 0;\n        }\n        const xKeys = Object.keys(x);\n        const yKeys = Object.keys(y);\n        const p = xKeys.length;\n        const q = yKeys.length;\n        const n = Math.min(p, q);\n        let order = 0;\n        for (let i = 0; i < n && order === 0; i += 1) {\n          const xKey = xKeys[i]!;\n          const yKey = yKeys[i]!;\n          order = Strings.compare(xKey, yKey);\n          if (order === 0) {\n            order = Values.compare((x as any)[xKey], (y as any)[yKey]);\n          }\n        }\n        return order !== 0 ? order : p > q ? 1 : p < q ? -1 : 0;\n      }\n      return -1;\n    } else if (x === null) {\n      return y === void 0 ? -1 : y === null ? 0 : 1;\n    } else if (x === void 0) {\n      return y === void 0 ? 0 : 1;\n    }\n    return NaN;\n  },\n\n  /**\n   * Returns a 32-bit hash value for the entries of object `x`, if defined;\n   * otherwise returns `0` or `1` if `x` is `undefined` or `null`, respectively.\n   */\n  hash(x: object | null | undefined): number {\n    if (typeof x === \"object\" && x !== null) {\n      let code = 0;\n      const keys = Object.keys(x);\n      for (let i = 0; i < keys.length; i += 1) {\n        const key = keys[i]!;\n        code = Murmur3.mix(Murmur3.mix(code, Strings.hash(key)), Values.hash((x as any)[key]));\n      }\n      return Murmur3.mash(code);\n    } else if (x === null) {\n      return 1;\n    } else if (x === void 0) {\n      return 0;\n    }\n    throw new TypeError(\"\" + x);\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Equals} from \"./Equals\";\nimport {HashCode} from \"./HashCode\";\nimport {Equivalent} from \"./Equivalent\";\nimport {Compare} from \"./Compare\";\nimport {Numbers} from \"./Numbers\";\nimport {Strings} from \"./Strings\";\nimport {Functions} from \"./Functions\";\nimport {Arrays} from \"./Arrays\";\nimport {Objects} from \"./Objects\";\n\n/**\n * Utilities for comparing and hashing structural values. A structural value\n * is typed by object structure, rather than by name.\n * @public\n */\nexport const Values = {\n  /**\n   * Returns `true` if `x` and `y` are structurally equal, otherwise returns `false`.\n   */\n  equal(x: unknown, y: unknown): boolean {\n    if (x instanceof Date) {\n      x = x.getTime();\n    }\n    if (y instanceof Date) {\n      y = y.getTime();\n    }\n\n    if (x === y) {\n      return true;\n    } else if (typeof x === \"number\") {\n      if (typeof y === \"number\") {\n        return isNaN(x) && isNaN(y);\n      }\n    } else if (Equals[Symbol.hasInstance](x)) {\n      return x.equals(y);\n    } else if (Array.isArray(x)) {\n      if (Array.isArray(y)) {\n        return Arrays.equal(x, y);\n      }\n    } else if (x !== null && typeof x === \"object\") {\n      if (y !== null && typeof y === \"object\") {\n        return Objects.equal(x, y);\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Returns `true` if `x` and `y` are structurally equivalent, otherwise returns `false`.\n   */\n  equivalent(x: unknown, y: unknown, epsilon: number = Equivalent.Epsilon): boolean {\n    if (x instanceof Date) {\n      x = x.getTime();\n    }\n    if (y instanceof Date) {\n      y = y.getTime();\n    }\n\n    if (x === y) {\n      return true;\n    } else if (typeof x === \"number\") {\n      if (typeof y === \"number\") {\n        return isNaN(x) && isNaN(y) || Math.abs(y - x) < epsilon;\n      }\n    } else if (Equivalent[Symbol.hasInstance](x)) {\n      return x.equivalentTo(y, epsilon);\n    } else if (Array.isArray(x)) {\n      if (Array.isArray(y)) {\n        return Arrays.equivalent(x, y, epsilon);\n      }\n    } else if (typeof x === \"object\" && x !== null) {\n      if (typeof y === \"object\" && y !== null) {\n        return Objects.equivalent(x, y, epsilon);\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Returns `-1` if `x` orders before `y`; returns `1` if `x` orders after `y`;\n   * returns `0` if `x` and `y` are equivalent; and returns `NaN` if `x` is not\n   * comparable to `y`.\n   */\n  compare(x: unknown, y: unknown): number {\n    if (x instanceof Date) {\n      x = x.getTime();\n    }\n    if (y instanceof Date) {\n      y = y.getTime();\n    }\n\n    if (x === void 0) {\n      if (y === void 0) {\n        return 0;\n      }\n      return 1;\n    } else if (x === null) {\n      if (y === void 0) {\n        return -1;\n      } else if (y === null) {\n        return 0;\n      }\n      return 1;\n    } else if (typeof x === \"boolean\") {\n      if (y === void 0 || y === null) {\n        return -1;\n      } else if (typeof y === \"boolean\") {\n        return x && !y ? -1 : !x && y ? 1 : 0;\n      }\n      return 1;\n    } else if (typeof x === \"number\") {\n      if (y === void 0 || y === null || typeof y === \"boolean\") {\n        return -1;\n      } else if (typeof y === \"number\") {\n        return x < y ? -1 : x > y ? 1 : isNaN(y) ? (isNaN(x) ? 0 : -1) : isNaN(x) ? 1 : 0;\n      }\n      return 1;\n    } else if (typeof x === \"string\") {\n      if (y === void 0 || y === null || typeof y === \"boolean\" || typeof y === \"number\") {\n        return -1;\n      } else if (typeof y === \"string\") {\n        return x < y ? -1 : x > y ? 1 : 0;\n      }\n      return 1;\n    } else if (Compare[Symbol.hasInstance](x)) {\n      return x.compareTo(y);\n    } else if (typeof x === \"function\") {\n      if (y === void 0 || y === null || typeof y === \"boolean\" || typeof y === \"number\" || typeof y === \"string\") {\n        return -1;\n      } else if (typeof y === \"function\") {\n        return Functions.compare(x, y);\n      }\n      return 1;\n    } else if (Array.isArray(x)) {\n      if (y === void 0 || y === null || typeof y === \"boolean\" || typeof y === \"number\" || typeof y === \"string\" || typeof y === \"function\") {\n        return -1;\n      } else if (Array.isArray(y)) {\n        return Arrays.compare(x, y);\n      }\n      return 1;\n    } else if (typeof x === \"object\") {\n      if (y === void 0 || y === null || typeof y === \"boolean\" || typeof y === \"number\" || typeof y === \"string\" || typeof y === \"function\" || Array.isArray(y)) {\n        return -1;\n      } else if (typeof y === \"object\") {\n        return Objects.compare(x, y);\n      }\n      return 1;\n    }\n    return NaN;\n  },\n\n  /**\n   * Returns a hash code for a structural value.\n   */\n  hash(x: unknown): number {\n    if (x instanceof Date) {\n      x = x.getTime();\n    }\n\n    if (x === void 0) {\n      return 0;\n    } else if (x === null) {\n      return 1;\n    } else if (x === false) {\n      return 2;\n    } else if (x === true) {\n      return 3;\n    } else if (typeof x === \"number\") {\n      return Numbers.hash(x);\n    } else if (typeof x === \"string\") {\n      return Strings.hash(x);\n    } else if (HashCode[Symbol.hasInstance](x)) {\n      return x.hashCode();\n    } else if (typeof x === \"function\") {\n      return Functions.hash(x);\n    } else if (Array.isArray(x)) {\n      return Arrays.hash(x);\n    } else if (typeof x === \"object\") {\n      return Objects.hash(x);\n    }\n    throw new TypeError(\"\" + x);\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Identity} from \"./Identity\";\nimport {Strings} from \"./Strings\";\nimport {Numbers} from \"./Numbers\";\nimport {Booleans} from \"./Booleans\";\nimport {Objects} from \"./Objects\";\n\n/**\n * Associates a type `T` with a loosely typed representation `L`. Loose type\n * representations are modeled as a phantom method `likeType?(like: L): void`\n * whose argument type is the loosely typed representation of `T`. Because the\n * `likeType` method is optional, values of type `T` are assignable to type\n * `Like<T, L>`, and vice versa.\n *\n * The preferred way to associate loose type representations with a custom\n * class is to declare a `likeType?(like: L): void` method on the class itself.\n * The `Like` type is used to inject a phantom `likeType` method into an\n * existing type. This enables ad hoc loose types to be declared without\n * needing to change the declaration of the strict type.\n *\n * @example Ad hoc number coercion\n *\n * ```ts\n * const NumberLike: FromLike<Like<number, string | boolean>> = {\n *   fromLike(value: number | string | boolean): number {\n *     return Number(value);\n *   },\n * };\n *\n * NumberLike.fromLike(\"42\") // yields 42\n * NumberLike.fromLike(true) // yields 1\n * ```\n *\n * @example Using an ad hoc conversion with a `@Property` fastener\n *\n * ```ts\n * class Person {\n *   @Property({valueType: NumberLike})\n *   readonly age!: Property<Like<number, string | boolean>>;\n * }\n *\n * const person = new Person();\n * person.age.setValue(\"42\");\n * person.age.value // yields 42\n * ```\n *\n * @public\n */\nexport type Like<T, L> = T & {likeType?(like: LikeType<T> | L): void};\n\n/**\n * Extracts the loosely typed representation of a type `T`. `LikeType` is used\n * in conjunction with [[FromLike]] to generically convert loosely typed values\n * to strictly typed instances using only a single generic type parameter to\n * track both strict and loose types.\n * @public\n */\nexport type LikeType<T> = T extends {likeType?(like: infer L): any} ? L : never;\n\n/**\n * Conversion from loosely typed values to a strictly typed instances.\n *\n * @example Generic wrapper class\n *\n * Consider the case of implementing a generic wrapper class. Although the\n * wrapper encapsulates a particular concrete type, the API for the wrapper\n * should accept similarly typed values--but not any value. Two generic types\n * are in play here, the strict type being wrapped, and a loose type that's\n * accepted as arguments and internally converted to the strict type. These\n * types are not independent of each other; each strict type has an associated\n * loose type from which it can be converted. To minimize boilerplate, the\n * wrapper class should only need to be parameterized with a single type.\n *\n * These requirements can be cleanly met with a combination of [[Like]] types\n * and `FromLike` conversions. The generic wrapper class described above can\n * be implemented as follows:\n *\n * ```\n * class GenericWrapper<T> {\n *   valueType: FromLike<T>;\n *   value: T;\n *   constructor(valueType: FromLike<T>, value: T) {\n *     this.valueType = valueType;\n *     this.value = value;\n *   }\n *   set(value: T | LikeType<T>): void {\n *     this.value = this.valueType.fromLike(value);\n *   }\n * }\n * ```\n *\n * When no loose type conversions are needed, `GenericWrapper` can be\n * instantiated with an identity `FromLike` converter.\n *\n * ```\n * const greeting = new GenericWrapper(FromLike<string>(), \"\");\n * greeting.set(\"Hello, world!\");\n * greeting.value // yields \"Hello, world!\";\n * ```\n *\n * A `GenericWrapper` parameterized with a `Like` type and accompanying\n * `FromLike` conversion can be set with any like-typed value.\n *\n * ```\n * const NumberLike: FromLike<Like<number, string | boolean>> = {\n *   fromLike(value: number | string | boolean): number {\n *     return Number(value);\n *   },\n * };\n * export const foo = new GenericWrapper(NumberLike, 0);\n * foo.set(\"42\")\n * foo.value // yields 42\n * ```\n *\n * @public\n */\nexport interface FromLike<T> {\n  /**\n   * Coerces a loosely typed `value` to a strictly typed instance.\n   */\n  fromLike(value: T | LikeType<T>): T;\n}\n\n/** @public */\nexport const FromLike = (function () {\n  const FromLike = function <F>(type?: F, value?: F extends {fromLike(value: infer L): any} ? L : unknown): (F extends {fromLike(...args: any): infer T} ? T : unknown) | FromLike<F extends abstract new (...args: any) => infer T ? T : any> {\n    let likeness: FromLike<any>;\n    if (FromLike[Symbol.hasInstance](type)) {\n      likeness = type;\n    } else if (type === String) {\n      likeness = Strings;\n    } else if (type === Number) {\n      likeness = Numbers;\n    } else if (type === Boolean) {\n      likeness = Booleans;\n    } else {\n      likeness = Identity;\n    }\n    if (arguments.length < 2) {\n      return likeness;\n    }\n    return likeness.fromLike(value);\n  } as {\n    /**\n     * Returns the [[FromLike.fromLike fromLike]] conversion of `value` by `type`,\n     * if `type` conforms to the `FromLike` interface; otherwise returns `value` itself.\n     */\n    <F>(type: F, value: F extends {fromLike(value: infer L): any} ? L : any): F extends {fromLike(...args: any): infer T} ? T : any;\n    /**\n     * Returns a [[FromLike]] converter for the given `type`. Returns `type` itself,\n     * if `type` conforms to the `FromLike` interface; returns a primitive converter,\n     * if `type` is the `String`, `Number`, or `Boolean` constructor; otherwise\n     * returns an identity converter.\n     */\n    <F>(type: F): FromLike<F extends abstract new (...args: any) => infer T ? T : any>;\n    /**\n     * Returns an identity [[FromLike]] converter.\n     */\n    <T>(): FromLike<T>;\n\n    /**\n     * Returns `true` if `instance` appears to conform to the [[FromLike]] interface.\n     */\n    [Symbol.hasInstance]<T>(instance: unknown): instance is FromLike<T>\n  };\n\n  Object.defineProperty(FromLike, Symbol.hasInstance, {\n    value: function <T>(instance: unknown): instance is FromLike<T> {\n      return Objects.hasAllKeys<FromLike<T>>(instance, \"fromLike\");\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  return FromLike;\n})();\n\n/**\n * Conversion to loosely typed values from strictly typed instances.\n * @public\n */\nexport interface ToLike<T> {\n  /**\n   * Returns a loosely typed representation of this instance.\n   */\n  toLike(): LikeType<T>;\n}\n\n/** @public */\nexport const ToLike = (function () {\n  const ToLike = function (value: unknown): unknown {\n    if (ToLike[Symbol.hasInstance](value)) {\n      return value.toLike();\n    }\n    return value;\n  } as {\n    /**\n     * Returns the [[ToLike.toLike toLike]] conversion of `value`, if `value`\n     * conforms to the `ToLike` interface; otherwise returns `value` itself.\n     */\n    <T>(value: ToLike<T>): T;\n    (value: any): any;\n\n    /**\n     * Returns `true` if `instance` appears to conform to the [[ToLike]] interface.\n     */\n    [Symbol.hasInstance]<T>(instance: unknown): instance is ToLike<T>\n  };\n\n  Object.defineProperty(ToLike, Symbol.hasInstance, {\n    value: function <T>(instance: unknown): instance is ToLike<T> {\n      return Objects.hasAllKeys<ToLike<T>>(instance, \"toLike\");\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  return ToLike;\n})();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/** @public */\nexport type Creates<C> =\n  C extends {create(...args: any): infer T} ? T : never;\n\n/** @public */\nexport interface Creatable<T> {\n  create(): T;\n}\n\n/** @public */\nexport const Creatable = {\n  [Symbol.hasInstance]<T>(instance: unknown): instance is Creatable<T> {\n    if (instance === null || (typeof instance !== \"object\" && typeof instance !== \"function\")) {\n      return false;\n    }\n    return typeof (instance as Creatable<T>).create === \"function\";\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Class} from \"./types\";\nimport type {Observer} from \"./Observer\";\n\n/** @public */\nexport type Observes<O> =\n  O extends {readonly observerType?: Class<infer T>} ? T : {};\n\n/** @public */\nexport interface Observable {\n  readonly observerType?: Class<Observer>;\n\n  observe(observer: Observes<this>): void;\n\n  unobserve(observer: Observes<this>): void;\n}\n\n/** @public */\nexport const Observable = {\n  [Symbol.hasInstance](instance: unknown): instance is Observable {\n    if (instance === null || (typeof instance !== \"object\" && typeof instance !== \"function\")) {\n      return false;\n    }\n    return typeof (instance as Observable).observe === \"function\"\n        && typeof (instance as Observable).unobserve === \"function\";\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/** @public */\nexport type Consumer = unknown;\n\n/** @public */\nexport interface Consumable {\n  consume(consumer: Consumer): void;\n\n  unconsume(consumer: Consumer): void;\n}\n\n/** @public */\nexport const Consumable = {\n  [Symbol.hasInstance](instance: unknown): instance is Consumable {\n    if (instance === null || (typeof instance !== \"object\" && typeof instance !== \"function\")) {\n      return false;\n    }\n    return typeof (instance as Consumable).consume === \"function\"\n        && typeof (instance as Consumable).unconsume === \"function\";\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"./Lazy\";\n\n/** @public */\nexport abstract class Cursor<T> implements IterableIterator<T> {\n  abstract isEmpty(): boolean;\n\n  abstract head(): T;\n\n  abstract step(): void;\n\n  abstract skip(count: number): void;\n\n  abstract hasNext(): boolean;\n\n  abstract nextIndex(): number;\n\n  abstract next(): IteratorResult<T>;\n\n  abstract hasPrevious(): boolean;\n\n  abstract previousIndex(): number;\n\n  abstract previous(): IteratorResult<T>;\n\n  set(newValue: T): void {\n    throw new Error(\"immutable\");\n  }\n\n  delete(): void {\n    throw new Error(\"immutable\");\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this;\n  }\n\n  @Lazy\n  static empty<T>(): Cursor<T> {\n    return new EmptyCursor();\n  }\n\n  static unary<T>(value: T): Cursor<T> {\n    return new UnaryCursor<T>(value);\n  }\n\n  static array<T>(array: readonly T[], index?: number, limit?: number): Cursor<T> {\n    if (index === void 0) {\n      index = 0;\n    }\n    if (limit === void 0) {\n      limit = array.length;\n    }\n    return new ArrayCursor<T>(array, index, limit);\n  }\n\n  static keys<K, V>(cursor: Cursor<[K, V]>): Cursor<K> {\n    return new KeysCursor<K, V>(cursor);\n  }\n\n  static values<K, V>(cursor: Cursor<[K, V]>): Cursor<V> {\n    return new ValuesCursor<K, V>(cursor);\n  }\n}\n\n/** @internal */\nexport class EmptyCursor<T> extends Cursor<T> {\n  override isEmpty(): boolean {\n    return true;\n  }\n\n  override head(): T {\n    throw new Error(\"empty\");\n  }\n\n  override step(): void {\n    throw new Error(\"empty\");\n  }\n\n  override skip(count: number): void {\n    // nop\n  }\n\n  override hasNext(): boolean {\n    return false;\n  }\n\n  override nextIndex(): number {\n    return 0;\n  }\n\n  override next(): IteratorResult<T> {\n    return {done: true, value: void 0};\n  }\n\n  override hasPrevious(): boolean {\n    return false;\n  }\n\n  override previousIndex(): number {\n    return -1;\n  }\n\n  override previous(): IteratorResult<T> {\n    return {done: true, value: void 0};\n  }\n}\n\n/** @internal */\nexport class UnaryCursor<T> extends Cursor<T> {\n  constructor(value: T) {\n    super();\n    this.value = value;\n    this.index = 0;\n  }\n\n  /** @internal */\n  readonly value: T;\n\n  /** @internal */\n  index: number;\n\n  override isEmpty(): boolean {\n    return this.index !== 0;\n  }\n\n  override head(): T {\n    if (this.index !== 0) {\n      throw new Error(\"empty\");\n    }\n    return this.value;\n  }\n\n  override step(): void {\n    if (this.index !== 0) {\n      throw new Error(\"empty\");\n    }\n    this.index = 1;\n  }\n\n  override skip(count: number): void {\n    this.index = Math.min(Math.max(0, this.index + count), 1);\n  }\n\n  override hasNext(): boolean {\n    return this.index === 0;\n  }\n\n  override nextIndex(): number {\n    return this.index;\n  }\n\n  override next(): IteratorResult<T> {\n    if (this.index !== 0) {\n      return {done: true, value: void 0};\n    }\n    this.index = 1;\n    return {done: true, value: this.value};\n  }\n\n  override hasPrevious(): boolean {\n    return this.index === 1;\n  }\n\n  override previousIndex(): number {\n    return this.index - 1;\n  }\n\n  override previous(): IteratorResult<T> {\n    if (this.index !== 1) {\n      return {done: true, value: void 0};\n    }\n    this.index = 0;\n    return {done: true, value: this.value};\n  }\n}\n\n/** @internal */\nexport class ArrayCursor<T> extends Cursor<T> {\n  constructor(array: readonly T[], index: number, limit: number) {\n    super();\n    this.array = array;\n    this.index = index;\n    this.limit = limit;\n  }\n\n  /** @internal */\n  readonly array: readonly T[];\n\n  /** @internal */\n  index: number;\n\n  /** @internal */\n  readonly limit: number;\n\n  override isEmpty(): boolean {\n    return this.index >= this.limit;\n  }\n\n  override head(): T {\n    if (this.index >= this.limit) {\n      throw new Error(\"empty\");\n    }\n    return this.array[this.index]!;\n  }\n\n  override step(): void {\n    const index = this.index;\n    if (index >= this.limit) {\n      throw new Error(\"empty\");\n    }\n    this.index += 1;\n  }\n\n  override skip(count: number): void {\n    this.index = Math.min(this.index + count, this.limit);\n  }\n\n  override hasNext(): boolean {\n    return this.index < this.limit;\n  }\n\n  override nextIndex(): number {\n    return this.index;\n  }\n\n  override next(): IteratorResult<T> {\n    const index = this.index;\n    if (index >= this.limit) {\n      this.index = this.limit;\n      return {done: true, value: void 0};\n    }\n    this.index += 1;\n    return {done: this.index === this.limit, value: this.array[index]!};\n  }\n\n  override hasPrevious(): boolean {\n    return this.index > 0;\n  }\n\n  override previousIndex(): number {\n    return this.index - 1;\n  }\n\n  override previous(): IteratorResult<T> {\n    const index = this.index - 1;\n    if (index < 0) {\n      this.index = 0;\n      return {done: true, value: void 0};\n    }\n    this.index = index;\n    return {done: index === 0, value: this.array[index]!};\n  }\n}\n\n/** @internal */\nexport class KeysCursor<K, V> extends Cursor<K> {\n  constructor(cursor: Cursor<[K, V]>) {\n    super();\n    this.cursor = cursor;\n  }\n\n  /** @internal */\n  readonly cursor: Cursor<[K, V]>;\n\n  override isEmpty(): boolean {\n    return this.cursor.isEmpty();\n  }\n\n  override head(): K {\n    return this.cursor.head()[0];\n  }\n\n  override step(): void {\n    this.cursor.step();\n  }\n\n  override skip(count: number): void {\n    this.cursor.skip(count);\n  }\n\n  override hasNext(): boolean {\n    return this.cursor.hasNext();\n  }\n\n  override nextIndex(): number {\n    return this.cursor.nextIndex();\n  }\n\n  override next(): IteratorResult<K> {\n    const next = this.cursor.next();\n    return {done: next.done, value: next.value !== void 0 ? next.value[0] : void 0};\n  }\n\n  override hasPrevious(): boolean {\n    return this.cursor.hasPrevious();\n  }\n\n  override previousIndex(): number {\n    return this.cursor.previousIndex();\n  }\n\n  override previous(): IteratorResult<K> {\n    const previous = this.cursor.previous();\n    return {done: previous.done, value: previous.value !== void 0 ? previous.value[0] : void 0};\n  }\n\n  override delete(): void {\n    this.cursor.delete();\n  }\n}\n\n/** @internal */\nexport class ValuesCursor<K, V> extends Cursor<V> {\n  constructor(cursor: Cursor<[K, V]>) {\n    super();\n    this.cursor = cursor;\n  }\n\n  /** @internal */\n  readonly cursor: Cursor<[K, V]>;\n\n  override isEmpty(): boolean {\n    return this.cursor.isEmpty();\n  }\n\n  override head(): V {\n    return this.cursor.head()[1];\n  }\n\n  override step(): void {\n    this.cursor.step();\n  }\n\n  override skip(count: number): void {\n    this.cursor.skip(count);\n  }\n\n  override hasNext(): boolean {\n    return this.cursor.hasNext();\n  }\n\n  override nextIndex(): number {\n    return this.cursor.nextIndex();\n  }\n\n  override next(): IteratorResult<V> {\n    const next = this.cursor.next();\n    return {done: next.done, value: next.value !== void 0 ? next.value[1] : void 0};\n  }\n\n  override hasPrevious(): boolean {\n    return this.cursor.hasPrevious();\n  }\n\n  override previousIndex(): number {\n    return this.cursor.previousIndex();\n  }\n\n  override previous(): IteratorResult<V> {\n    const previous = this.cursor.previous();\n    return {done: previous.done, value: previous.value !== void 0 ? previous.value[1] : void 0};\n  }\n\n  override delete(): void {\n    this.cursor.delete();\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"./types\";\nimport type {Equals} from \"./Equals\";\nimport type {Equivalent} from \"./Equivalent\";\nimport type {Domain} from \"./Domain\";\nimport type {Range} from \"./Range\";\n\n/** @public */\nexport interface Mapping<X, Y> extends Equals, Equivalent {\n  (x: X): Y;\n\n  readonly domain: Domain<X>;\n\n  readonly range: Range<Y>;\n\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  equivalentTo(that: unknown, epsilon?: number): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const Mapping = (function (_super: typeof Function) {\n  const Mapping = function <X, Y>(domain: Domain<X>, range: Range<Y>): Mapping<X, Y> {\n    const mapping = function (x: X): Y {\n      return mapping.range(mapping.domain(x));\n    } as Mapping<X, Y>;\n    Object.setPrototypeOf(mapping, Mapping.prototype);\n    (mapping as Mutable<typeof mapping>).domain = domain;\n    (mapping as Mutable<typeof mapping>).range = range;\n    return mapping;\n  } as {\n    <X, Y>(domain: Domain<X>, range: Range<Y>): Mapping<X, Y>;\n\n    /** @internal */\n    prototype: Mapping<any, any>;\n  };\n\n  Mapping.prototype = Object.create(_super.prototype);\n  Mapping.prototype.constructor = Mapping;\n\n  Mapping.prototype.canEqual = function <X, Y>(this: Mapping<X, Y>, that: unknown): boolean {\n    return that instanceof Mapping;\n  };\n\n  Mapping.prototype.equals = function <X, Y>(this: Mapping<X, Y>, that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Mapping) {\n      return that.canEqual(this)\n          && this.domain.equals(that.domain)\n          && this.range.equals(that.range);\n    }\n    return false;\n  };\n\n  Mapping.prototype.equivalentTo = function <X, Y>(this: Mapping<X, Y>, that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Mapping) {\n      return this.domain.equivalentTo(that.domain, epsilon)\n          && this.range.equivalentTo(that.range, epsilon);\n    }\n    return false;\n  };\n\n  Mapping.prototype.toString = function <X, Y>(this: Mapping<X, Y>): string {\n    return \"Mapping(\" + this.domain + \", \" + this.range + \")\";\n  };\n\n  return Mapping;\n})(Function);\n\n/** @public */\nexport interface Piecewise<X, Y> extends Mapping<X, Y> {\n  readonly intervals: readonly Mapping<X, Y>[];\n\n  interval(x: X): Mapping<X, Y>;\n\n  /** @override */\n  readonly domain: Domain<X>;\n\n  /** @override */\n  readonly range: Range<Y>;\n\n  /** @override */\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  equivalentTo(that: unknown, epsilon?: number): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const Piecewise = (function (_super: typeof Mapping) {\n  const Piecewise = function <X, Y>(...intervals: readonly Mapping<X, Y>[]): Piecewise<X, Y> {\n    const piecewise = function (x: X): Y {\n      const interval = piecewise.interval(x);\n      return interval(x);\n    } as Piecewise<X, Y>;\n    Object.setPrototypeOf(piecewise, Piecewise.prototype);\n    const n = intervals.length;\n    if (n === 0) {\n      throw new Error(\"no piecewise intervals\");\n    }\n    let interval = intervals[0]!;\n    let domain = interval.domain;\n    let range = interval.range;\n    for (let i = 1; i < n; i += 1) {\n      interval = intervals[i]!;\n      domain = domain.union(interval.domain);\n      range = range.union(interval.range);\n    }\n    (piecewise as Mutable<typeof piecewise>).intervals = intervals;\n    (piecewise as Mutable<typeof piecewise>).domain = domain;\n    (piecewise as Mutable<typeof piecewise>).range = range;\n    return piecewise;\n  } as {\n    /** @internal */\n    <X, Y>(...intervals: readonly Mapping<X, Y>[]): Piecewise<X, Y>;\n\n    /** @internal */\n    prototype: Piecewise<any, any>;\n  };\n\n  Piecewise.prototype = Object.create(_super.prototype);\n  Piecewise.prototype.constructor = Piecewise;\n\n  Piecewise.prototype.interval = function <X, Y>(this: Piecewise<X, Y>, x: X): Mapping<X, Y> {\n    const intervals = this.intervals;\n    let lo = 0;\n    let hi = intervals.length - 1;\n    let interval: Mapping<X, Y> | undefined;\n    while (lo <= hi) {\n      const mid = (lo + hi) >>> 1;\n      interval = intervals[mid]!;\n      const domain = interval.domain;\n      const u = domain(x);\n      if (u < 0) {\n        hi = mid - 1;\n      } else if (u >= 1) {\n        lo = mid + 1;\n      } else {\n        break;\n      }\n    }\n    return interval!;\n  };\n\n  Piecewise.prototype.canEqual = function <X, Y>(this: Piecewise<X, Y>, that: unknown): boolean {\n    return that instanceof Piecewise;\n  };\n\n  Piecewise.prototype.equals = function <X, Y>(this: Piecewise<X, Y>, that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Piecewise) {\n      return that.canEqual(this)\n          && this.domain.equals(that.domain)\n          && this.range.equals(that.range);\n    }\n    return false;\n  };\n\n  Piecewise.prototype.toString = function <X, Y>(this: Piecewise<X, Y>): string {\n    let s = \"Piecewise(\";\n    const intervals = this.intervals;\n    for (let i = 0; i < intervals.length; i += 1) {\n      const interval = intervals[i]!;\n      if (i !== 0) {\n        s += \", \";\n      }\n      s += interval.toString();\n    }\n    s += \")\";\n    return s;\n  };\n\n  return Piecewise;\n})(Mapping);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"./types\";\nimport {Lazy} from \"./Lazy\";\nimport {Values} from \"./Values\";\nimport {Mapping} from \"./Mapping\";\nimport {Range} from \"./\"; // forward import\nimport {LinearDomain} from \"./\"; // forward import\nimport type {LinearRange} from \"./LinearRange\";\n\n/** @public */\nexport type DomainLike<X> = Domain<X> | readonly [X, X];\n\n/** @public */\nexport interface Domain<X> extends Mapping<X, number> {\n  readonly 0: X;\n\n  readonly 1: X;\n\n  /** @override */\n  readonly domain: this;\n\n  /** @override */\n  readonly range: LinearRange;\n\n  contains(x: X): boolean;\n\n  union(that: Domain<X>): Domain<X>;\n\n  /** @override */\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  equivalentTo(that: unknown, epsilon?: number): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const Domain = (function (_super: typeof Mapping) {\n  const Domain = function <X>(x0: X, x1: X): Domain<X> {\n    const domain = function (x: X): number {\n      return Values.equal(x, domain[1]) ? 1 : 0;\n    } as Domain<X>;\n    Object.setPrototypeOf(domain, Domain.prototype);\n    (domain as Mutable<typeof domain>)[0] = x0;\n    (domain as Mutable<typeof domain>)[1] = x1;\n    return domain;\n  } as {\n    <X>(x0: X, x1: X): Domain<X>;\n\n    /** @internal */\n    prototype: Domain<any>;\n\n    unit(): LinearDomain;\n  };\n\n  Domain.prototype = Object.create(_super.prototype);\n  Domain.prototype.constructor = Domain;\n\n  Object.defineProperty(Domain.prototype, \"domain\", {\n    get<X>(this: Domain<X>): Domain<X> {\n      return this;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Object.defineProperty(Domain.prototype, \"range\", {\n    get<X>(this: Domain<X>): LinearRange {\n      return Range.unit();\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Domain.prototype.contains = function <X>(this: Domain<X>, x: X): boolean {\n    return Values.compare(this[0], x) <= 0 && Values.compare(x, this[1]) <= 0;\n  };\n\n  Domain.prototype.union = function <X>(this: Domain<X>, that: Domain<X>): Domain<X> {\n    const x00 = this[0];\n    const x01 = this[1];\n    const x10 = that[0];\n    const x11 = that[1];\n    const x0 = Values.compare(x00, x10) <= 0 ? x00 : x10;\n    const x1 = Values.compare(x01, x11) >= 0 ? x01 : x11;\n    return Domain(x0, x1);\n  };\n\n  Domain.prototype.canEqual = function <X>(this: Domain<X>, that: unknown): boolean {\n    return that instanceof Domain;\n  };\n\n  Domain.prototype.equals = function <X>(this: Domain<X>, that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Domain) {\n      return that.canEqual(this)\n          && Values.equal(this[0], that[0])\n          && Values.equal(this[1], that[1]);\n    }\n    return false;\n  };\n\n  Domain.prototype.equivalentTo = function <X>(this: Domain<X>, that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Domain) {\n      return Values.equivalent(this[0], that[0], epsilon)\n          && Values.equivalent(this[1], that[1], epsilon);\n    }\n    return false;\n  };\n\n  Domain.prototype.toString = function <X>(this: Domain<X>): string {\n    return \"Domain(\" + this[0] + \", \" + this[1] + \")\";\n  };\n\n  Domain.unit = Lazy(function (): LinearDomain {\n    return LinearDomain(0, 1);\n  });\n\n  return Domain;\n})(Mapping);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"./types\";\nimport {Lazy} from \"./Lazy\";\nimport {Values} from \"./Values\";\nimport {Mapping} from \"./Mapping\";\nimport {Domain} from \"./Domain\";\nimport type {LinearDomain} from \"./LinearDomain\";\nimport {LinearRange} from \"./\"; // forward import\n\n/** @public */\nexport type RangeLike<Y> = Range<Y> | readonly [Y, Y];\n\n/** @public */\nexport interface Range<Y> extends Mapping<number, Y> {\n  readonly 0: Y;\n\n  readonly 1: Y;\n\n  /** @override */\n  readonly domain: LinearDomain;\n\n  /** @override */\n  readonly range: this;\n\n  union(that: Range<Y>): Range<Y>;\n\n  /** @override */\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  equivalentTo(that: unknown, epsilon?: number): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const Range = (function (_super: typeof Mapping) {\n  const Range = function <Y>(y0: Y, y1: Y): Range<Y> {\n    const range = function (u: number): Y {\n      return u < 1 ? range[0] : range[1];\n    } as Range<Y>;\n    Object.setPrototypeOf(range, Range.prototype);\n    (range as Mutable<typeof range>)[0] = y0;\n    (range as Mutable<typeof range>)[1] = y1;\n    return range;\n  } as {\n    <Y>(y0: Y, y1: Y): Range<Y>;\n\n    /** @internal */\n    prototype: Range<any>;\n\n    unit(): LinearRange;\n  };\n\n  Range.prototype = Object.create(_super.prototype);\n  Range.prototype.constructor = Range;\n\n  Object.defineProperty(Range.prototype, \"domain\", {\n    get<Y>(this: Range<Y>): LinearDomain {\n      return Domain.unit();\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Object.defineProperty(Range.prototype, \"range\", {\n    get<Y>(this: Range<Y>): Range<Y> {\n      return this;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Range.prototype.union = function <Y>(this: Range<Y>, that: Range<Y>): Range<Y> {\n    const y00 = this[0];\n    const y01 = this[1];\n    const y10 = that[0];\n    const y11 = that[1];\n    const y0Order = Values.compare(y00, y01);\n    const y1Order = Values.compare(y10, y11);\n    let y0: Y;\n    let y1: Y;\n    if (y0Order <= 0 && y1Order <= 0) {\n      y0 = Values.compare(y00, y10) <= 0 ? y00 : y10;\n      y1 = Values.compare(y01, y11) >= 0 ? y01 : y11;\n    } else if (y0Order >= 0 && y1Order >= 0) {\n      y0 = Values.compare(y00, y10) >= 0 ? y00 : y10;\n      y1 = Values.compare(y01, y11) <= 0 ? y01 : y11;\n    } else if (y0Order <= 0 && y1Order >= 0) {\n      y0 = Values.compare(y00, y11) <= 0 ? y00 : y11;\n      y1 = Values.compare(y01, y10) >= 0 ? y01 : y10;\n    } else { // y0Order >= 0 && y1Order <= 0\n      y0 = Values.compare(y01, y10) <= 0 ? y01 : y10;\n      y1 = Values.compare(y00, y11) >= 0 ? y00 : y11;\n    }\n    return Range(y0, y1);\n  };\n\n  Range.prototype.canEqual = function <Y>(this: Domain<Y>, that: unknown): boolean {\n    return that instanceof Range;\n  };\n\n  Range.prototype.equals = function <Y>(this: Domain<Y>, that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Range) {\n      return that.canEqual(this)\n          && Values.equal(this[0], that[0])\n          && Values.equal(this[1], that[1]);\n    }\n    return false;\n  };\n\n  Range.prototype.equivalentTo = function <Y>(this: Domain<Y>, that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Range) {\n      return Values.equivalent(this[0], that[0], epsilon)\n          && Values.equivalent(this[1], that[1], epsilon);\n    }\n    return false;\n  };\n\n  Range.prototype.toString = function <Y>(this: Domain<Y>): string {\n    return \"Range(\" + this[0] + \", \" + this[1] + \")\";\n  };\n\n  Range.unit = Lazy(function (): LinearRange {\n    return LinearRange(0, 1);\n  });\n\n  return Range;\n})(Mapping);\n\n/** @public */\nexport interface Constant<Y> extends Range<Y> {\n  readonly value: Y;\n\n  /** @override */\n  readonly 0: Y;\n\n  /** @override */\n  readonly 1: Y;\n\n  /** @override */\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const Constant = (function (_super: typeof Range) {\n  const Constant = function <Y>(value: Y): Constant<Y> {\n    const range = function (u: number): Y {\n      return range.value;\n    } as Constant<Y>;\n    Object.setPrototypeOf(range, Constant.prototype);\n    (range as Mutable<typeof range>).value = value;\n    return range;\n  } as {\n    <Y>(value: Y): Constant<Y>;\n\n    /** @internal */\n    prototype: Constant<any>;\n  };\n\n  Constant.prototype = Object.create(_super.prototype);\n  Constant.prototype.constructor = Constant;\n\n  Object.defineProperty(Constant.prototype, 0, {\n    get<Y>(this: Constant<Y>): Y {\n      return this.value;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Object.defineProperty(Constant.prototype, 1, {\n    get<Y>(this: Constant<Y>): Y {\n      return this.value;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Constant.prototype.canEqual = function (that: unknown): boolean {\n    return that instanceof Constant;\n  };\n\n  Constant.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Constant) {\n      return that.canEqual(this) && Values.equal(this.value, that.value);\n    }\n    return false;\n  };\n\n  Constant.prototype.toString = function (): string {\n    return \"Constant(\" + this.value + \")\";\n  };\n\n  return Constant;\n})(Range);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Interpolator} from \"./Interpolator\";\n\n/**\n * Type that can be [[Interpolator interpolated]] to values of type `T`.\n * @public\n */\nexport interface Interpolate<T = unknown> {\n  /**\n   * Returns an [[Interpolator]] function that blends between `this` value and\n   * `that` value, if possible; otherwise returns `null` if `this` is unable to\n   * construct an interpolator to `that`.\n   */\n  interpolateTo(that: unknown): Interpolator<T> | null;\n}\n\n/** @public */\nexport const Interpolate = (function () {\n  const Interpolate = function (x: unknown, y: unknown): Interpolator | null {\n    if (Interpolate[Symbol.hasInstance](x)) {\n      return x.interpolateTo(y);\n    }\n    return null;\n  } as {\n    /**\n     * Returns `x.interpolateTo(y)`, if `x` conforms to the\n     * [[Interpolate]] interface; otherwise returns `null`.\n     */\n    <T>(x: Interpolate<T> | null | undefined, y: unknown): Interpolator<T> | null;\n    (x: unknown, y: unknown): Interpolator | null;\n\n    /**\n     * Returns `true` if `instance` appears to conform to the [[Interpolate]] interface.\n     */\n    [Symbol.hasInstance](instance: unknown): instance is Interpolate;\n  };\n\n  Object.defineProperty(Interpolate, Symbol.hasInstance, {\n    value: function (instance: unknown): instance is Interpolate {\n      if (instance === null || (typeof instance !== \"object\" && typeof instance !== \"function\")) {\n        return false;\n      }\n      return typeof (instance as Interpolate).interpolateTo === \"function\";\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  return Interpolate;\n})();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"./types\";\nimport {Values} from \"./Values\";\nimport {Range} from \"./Range\";\nimport {Interpolate} from \"./Interpolate\";\n\n/** @public */\nexport interface Interpolator<Y = unknown> extends Range<Y>, Interpolate<Interpolator<Y>> {\n  /** @override */\n  readonly 0: Y;\n\n  /** @override */\n  readonly 1: Y;\n\n  /** @override */\n  union(that: Range<Y>): Interpolator<Y>;\n\n  map<Y2>(transform: (y: Y) => Y2): Interpolator<Y2>;\n\n  interpolateTo(that: Interpolator<Y>): Interpolator<Interpolator<Y>>;\n  interpolateTo(that: unknown): Interpolator<Interpolator<Y>> | null;\n\n  /** @override */\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const Interpolator = (function (_super: typeof Range) {\n  const Interpolator = function (y0: unknown, y1: unknown): Interpolator {\n    let interpolator: Interpolator | null;\n    if (y0 === y1) {\n      interpolator = IdentityInterpolator(y0);\n    } else if (typeof y0 === \"number\" && typeof y1 === \"number\") {\n      interpolator = NumberInterpolator(y0, y1);\n    } else if (Array.isArray(y0) && Array.isArray(y1)) {\n      interpolator = ArrayInterpolator(y0, y1);\n    } else {\n      interpolator = Interpolate(y0, y1);\n      if (interpolator === null) {\n        interpolator = StepInterpolator(y0, y1);\n      }\n    }\n    return interpolator;\n  } as {\n    <Y>(y0: Y, y1: Y): Interpolator<Y>;\n    (y0: unknown, y1: unknown): Interpolator;\n\n    /** @internal */\n    prototype: Interpolator<any>;\n  };\n\n  Interpolator.prototype = Object.create(_super.prototype);\n  Interpolator.prototype.constructor = Interpolator;\n\n  Interpolator.prototype.union = function <Y>(this: Interpolator<Y>, that: Range<Y>): Interpolator<Y> {\n    const y00 = this[0];\n    const y01 = this[1];\n    const y10 = that[0];\n    const y11 = that[1];\n    const y0Order = Values.compare(y00, y01);\n    const y1Order = Values.compare(y10, y11);\n    let y0: Y;\n    let y1: Y;\n    if (y0Order <= 0 && y1Order <= 0) {\n      y0 = Values.compare(y00, y10) <= 0 ? y00 : y10;\n      y1 = Values.compare(y01, y11) >= 0 ? y01 : y11;\n    } else if (y0Order >= 0 && y1Order >= 0) {\n      y0 = Values.compare(y00, y10) >= 0 ? y00 : y10;\n      y1 = Values.compare(y01, y11) <= 0 ? y01 : y11;\n    } else if (y0Order <= 0 && y1Order >= 0) {\n      y0 = Values.compare(y00, y11) <= 0 ? y00 : y11;\n      y1 = Values.compare(y01, y10) >= 0 ? y01 : y10;\n    } else { // y0Order >= 0 && y1Order <= 0\n      y0 = Values.compare(y01, y10) <= 0 ? y01 : y10;\n      y1 = Values.compare(y00, y11) >= 0 ? y00 : y11;\n    }\n    return Interpolator(y0, y1);\n  };\n\n  Interpolator.prototype.map = function <Y, Y2>(this: Interpolator<Y>, transform: (y: Y) => Y2): Interpolator<Y2> {\n    return InterpolatorMap(this, transform);\n  };\n\n  Interpolator.prototype.interpolateTo = function <Y>(this: Interpolator<Y>, that: unknown): Interpolator<Interpolator<Y>> | null {\n    if (that instanceof Interpolator) {\n      return InterpolatorInterpolator(this, that);\n    }\n    return null;\n  } as typeof Interpolator.prototype.interpolateTo;\n\n  Interpolator.prototype.canEqual = function <Y>(this: Interpolator<Y>, that: unknown): boolean {\n    return that instanceof this.constructor;\n  };\n\n  Interpolator.prototype.equals = function <Y>(this: Interpolator<Y>, that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Interpolator) {\n      return that.canEqual(this)\n          && Values.equal(this[0], that[0])\n          && Values.equal(this[1], that[1]);\n    }\n    return false;\n  };\n\n  Interpolator.prototype.toString = function <Y>(this: Interpolator<Y>): string {\n    return \"Interpolator(\" + this[0] + \", \" + this[1] + \")\";\n  };\n\n  return Interpolator;\n})(Range);\n\n/** @internal */\nexport interface InterpolatorMap<Y, Y2> extends Interpolator<Y2> {\n  /** @internal */\n  readonly interpolator: Interpolator<Y>;\n\n  /** @internal */\n  readonly transform: (y: Y) => Y2;\n\n  /** @override */\n  readonly 0: Y2;\n\n  /** @override */\n  readonly 1: Y2;\n\n  /** @override */\n  equals(that: unknown): boolean;\n}\n\n/** @internal */\nexport const InterpolatorMap = (function (_super: typeof Interpolator) {\n  const InterpolatorMap = function <Y, Y2>(interpolator: Interpolator<Y>, transform: (y: Y) => Y2): InterpolatorMap<Y, Y2> {\n    const map = function (u: number): Y2 {\n      return map.transform(map.interpolator(u));\n    } as InterpolatorMap<Y, Y2>;\n    Object.setPrototypeOf(map, InterpolatorMap.prototype);\n    (map as Mutable<typeof map>).interpolator = interpolator;\n    (map as Mutable<typeof map>).transform = transform;\n    return map;\n  } as {\n    <Y, Y2>(interpolator: Interpolator<Y>, transform: (y: Y) => Y2): InterpolatorMap<Y, Y2>;\n\n    /** @internal */\n    prototype: InterpolatorMap<any, any>;\n  };\n\n  InterpolatorMap.prototype = Object.create(_super.prototype);\n  InterpolatorMap.prototype.constructor = InterpolatorMap;\n\n  Object.defineProperty(InterpolatorMap.prototype, 0, {\n    get<Y, Y2>(this: InterpolatorMap<Y, Y2>): Y2 {\n      return this.transform(this.interpolator[0]);\n    },\n    configurable: true,\n  });\n\n  Object.defineProperty(InterpolatorMap.prototype, 1, {\n    get<Y, Y2>(this: InterpolatorMap<Y, Y2>): Y2 {\n      return this.transform(this.interpolator[1]);\n    },\n    configurable: true,\n  });\n\n  InterpolatorMap.prototype.equals = function <Y, Y2>(this: InterpolatorMap<Y, Y2>, that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof InterpolatorMap) {\n      return this.interpolator.equals(that.interpolator)\n          && this.transform === that.transform;\n    }\n    return false;\n  };\n\n  return InterpolatorMap;\n})(Interpolator);\n\n/** @internal */\nexport interface IdentityInterpolator<Y> extends Interpolator<Y> {\n  /** @internal */\n  readonly value: Y;\n\n  /** @override */\n  readonly 0: Y;\n\n  /** @override */\n  readonly 1: Y;\n\n  /** @override */\n  equals(that: unknown): boolean;\n}\n\n/** @internal */\nexport const IdentityInterpolator = (function (_super: typeof Interpolator) {\n  const IdentityInterpolator = function <Y>(value: Y): IdentityInterpolator<Y> {\n    const interpolator = function (u: number): Y {\n      return interpolator.value;\n    } as IdentityInterpolator<Y>;\n    Object.setPrototypeOf(interpolator, IdentityInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>).value = value;\n    return interpolator;\n  } as {\n    <Y>(value: Y): IdentityInterpolator<Y>;\n\n    /** @internal */\n    prototype: IdentityInterpolator<any>;\n  };\n\n  IdentityInterpolator.prototype = Object.create(_super.prototype);\n  IdentityInterpolator.prototype.constructor = IdentityInterpolator;\n\n  Object.defineProperty(IdentityInterpolator.prototype, 0, {\n    get<Y>(this: IdentityInterpolator<Y>): Y {\n      return this.value;\n    },\n    configurable: true,\n  });\n\n  Object.defineProperty(IdentityInterpolator.prototype, 1, {\n    get<Y>(this: IdentityInterpolator<Y>): Y {\n      return this.value;\n    },\n    configurable: true,\n  });\n\n  IdentityInterpolator.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof IdentityInterpolator) {\n      return this.value === that.value;\n    }\n    return false;\n  };\n\n  return IdentityInterpolator;\n})(Interpolator);\n\n/** @internal */\nexport interface StepInterpolator<Y> extends Interpolator<Y> {\n  /** @internal */\n  readonly phase: number;\n\n  /** @override */\n  equals(that: unknown): boolean;\n}\n\n/** @internal */\nexport const StepInterpolator = (function (_super: typeof Interpolator) {\n  const StepInterpolator = function <Y>(y0: Y, y1: Y, phase?: number): StepInterpolator<Y> {\n    const interpolator = function (u: number): Y {\n      return u < interpolator.phase ? interpolator[0] : interpolator[1];\n    } as StepInterpolator<Y>;\n    Object.setPrototypeOf(interpolator, StepInterpolator.prototype);\n    if (phase === void 0) {\n      phase = 1;\n    }\n    (interpolator as Mutable<typeof interpolator>).phase = phase;\n    (interpolator as Mutable<typeof interpolator>)[0] = y0;\n    (interpolator as Mutable<typeof interpolator>)[1] = y1;\n    return interpolator;\n  } as {\n    <Y>(y0: Y, y1: Y, phase?: number): StepInterpolator<Y>;\n\n    /** @internal */\n    prototype: StepInterpolator<any>;\n  };\n\n  StepInterpolator.prototype = Object.create(_super.prototype);\n  StepInterpolator.prototype.constructor = StepInterpolator;\n\n  StepInterpolator.prototype.equals = function <Y>(this: StepInterpolator<Y>, that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof StepInterpolator) {\n      return that.canEqual(this)\n          && this.phase === that.phase\n          && Values.equal(this[0], that[0])\n          && Values.equal(this[1], that[1]);\n    }\n    return false;\n  };\n\n  return StepInterpolator;\n})(Interpolator);\n\n/** @internal */\nexport const NumberInterpolator = (function (_super: typeof Interpolator) {\n  const NumberInterpolator = function (y0: number, y1: number): Interpolator<number> {\n    const interpolator = function (u: number): number {\n      const y0 = interpolator[0];\n      const y1 = interpolator[1];\n      return y0 + u * (y1 - y0);\n    } as Interpolator<number>;\n    Object.setPrototypeOf(interpolator, NumberInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = y0;\n    (interpolator as Mutable<typeof interpolator>)[1] = y1;\n    return interpolator;\n  } as {\n    (y0: number, y1: number): Interpolator<number>;\n\n    /** @internal */\n    prototype: Interpolator<number>;\n  };\n\n  NumberInterpolator.prototype = Object.create(_super.prototype);\n  NumberInterpolator.prototype.constructor = NumberInterpolator;\n\n  return NumberInterpolator;\n})(Interpolator);\n\n/** @internal */\nexport interface ArrayInterpolator<Y> extends Interpolator<readonly Y[]> {\n  /** @internal */\n  readonly interpolators: readonly Interpolator<Y>[];\n\n  /** @override */\n  readonly 0: readonly Y[];\n\n  /** @override */\n  readonly 1: readonly Y[];\n\n  /** @override */\n  equals(that: unknown): boolean;\n}\n\n/** @internal */\nexport const ArrayInterpolator = (function (_super: typeof Interpolator) {\n  const ArrayInterpolator = function <Y>(y0: readonly Y[], y1: readonly Y[]): ArrayInterpolator<Y> {\n    const interpolator = function (u: number): readonly Y[] {\n      const interpolators = interpolator.interpolators;\n      const interpolatorCount = interpolators.length;\n      const array = new Array<Y>(interpolatorCount);\n      for (let i = 0; i < interpolatorCount; i += 1) {\n        array[i] = interpolators[i]!(u);\n      }\n      return array;\n    } as ArrayInterpolator<Y>;\n    Object.setPrototypeOf(interpolator, ArrayInterpolator.prototype);\n    const interpolatorCount = Math.min(y0.length, y1.length);\n    const interpolators = new Array<Interpolator<Y>>(interpolatorCount);\n    for (let i = 0; i < interpolatorCount; i += 1) {\n      interpolators[i] = Interpolator(y0[i]!, y1[i]!);\n    }\n    (interpolator as Mutable<typeof interpolator>).interpolators = interpolators;\n    return interpolator;\n  } as {\n    <Y>(y0: readonly Y[], y1: readonly Y[]): ArrayInterpolator<Y>;\n\n    /** @internal */\n    prototype: ArrayInterpolator<any>;\n  };\n\n  ArrayInterpolator.prototype = Object.create(_super.prototype);\n  ArrayInterpolator.prototype.constructor = ArrayInterpolator;\n\n  Object.defineProperty(ArrayInterpolator.prototype, 0, {\n    get<Y>(this: ArrayInterpolator<Y>): readonly Y[] {\n      const interpolators = this.interpolators;\n      const interpolatorCount = interpolators.length;\n      const array = new Array<Y>(interpolatorCount);\n      for (let i = 0; i < interpolatorCount; i += 1) {\n        array[i] = interpolators[i]![0];\n      }\n      return array;\n    },\n    configurable: true,\n  });\n\n  Object.defineProperty(ArrayInterpolator.prototype, 1, {\n    get<Y>(this: ArrayInterpolator<Y>): readonly Y[] {\n      const interpolators = this.interpolators;\n      const interpolatorCount = interpolators.length;\n      const array = new Array<Y>(interpolatorCount);\n      for (let i = 0; i < interpolatorCount; i += 1) {\n        array[i] = interpolators[i]![1];\n      }\n      return array;\n    },\n    configurable: true,\n  });\n\n  ArrayInterpolator.prototype.equals = function <Y>(this: ArrayInterpolator<Y>, that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof ArrayInterpolator) {\n      const n = this.interpolators.length;\n      if (n !== that.interpolators.length) {\n        return false;\n      }\n      for (let i = 0; i < n; i += 1) {\n        if (!this.interpolators[i]!.equals(that.interpolators[i]!)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  };\n\n  return ArrayInterpolator;\n})(Interpolator);\n\n/** @internal */\nexport const InterpolatorInterpolator = (function (_super: typeof Interpolator) {\n  const InterpolatorInterpolator = function <Y>(y0: Interpolator<Y>, y1: Interpolator<Y>): Interpolator<Interpolator<Y>> {\n    const interpolator = function (u: number): Interpolator<Y> {\n      if (u === 0) {\n        return interpolator[0];\n      } else if (u === 1) {\n        return interpolator[1];\n      }\n      return Interpolator(interpolator[0](u), interpolator[1](u));\n    } as Interpolator<Interpolator<Y>>;\n    Object.setPrototypeOf(interpolator, InterpolatorInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = y0;\n    (interpolator as Mutable<typeof interpolator>)[1] = y1;\n    return interpolator;\n  } as {\n    <Y>(y0: Interpolator<Y>, y1: Interpolator<Y>): Interpolator<Interpolator<Y>>;\n\n    /** @internal */\n    prototype: Interpolator<any>;\n  };\n\n  InterpolatorInterpolator.prototype = Object.create(_super.prototype);\n  InterpolatorInterpolator.prototype.constructor = InterpolatorInterpolator;\n\n  return InterpolatorInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"./types\";\nimport type {Mutable} from \"./types\";\nimport {Values} from \"./Values\";\nimport {Domain} from \"./Domain\";\nimport {Interpolator} from \"./Interpolator\";\nimport type {EasingLike} from \"./Easing\";\nimport type {EasingType} from \"./Easing\";\nimport {Easing} from \"./\"; // forward import\nimport {Tweening} from \"./\"; // forward import\n\n/** @public */\nexport type TimingLike = Timing | TimingInit;\n\n/** @public */\nexport interface TimingInit {\n  /** @internal */\n  readonly typeid?: \"TimingInit\";\n  easing?: EasingLike;\n  t0?: number;\n  t1?: number;\n  dt?: number;\n}\n\n/** @public */\nexport interface Timing extends Domain<number> {\n  /** @internal */\n  readonly typeid?: \"Timing\";\n\n  likeType?(like: TimingInit | EasingType): void;\n\n  /** @override */\n  readonly 0: number;\n\n  /** @override */\n  readonly 1: number;\n\n  readonly duration: number;\n\n  readonly easing: Easing;\n\n  /** @override */\n  contains(t: number): boolean;\n\n  withDomain(t0: number, t1: number): Timing;\n\n  withDuration(dt: number): Timing;\n\n  overRange<Y>(range: Interpolator<Y>): Tweening<Y>;\n  overRange<Y>(y0: Y, y1: Y): Tweening<Y>;\n\n  /** @override */\n  union(that: Domain<number>): Timing;\n\n  /** @override */\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  equivalentTo(that: unknown, epsilon?: number): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const Timing = (function (_super: typeof Domain) {\n  const Timing = function (easing: Easing, t0: number, t1: number): Timing {\n    const timing = function (t: number): number {\n      const t0 = timing[0];\n      const t1 = timing[1];\n      return timing.easing(Math.min(Math.max(0, (t - t0) / (t1 - t0)), 1));\n    } as Timing;\n    Object.setPrototypeOf(timing, Timing.prototype);\n    (timing as Mutable<typeof timing>).easing = easing;\n    (timing as Mutable<typeof timing>)[0] = t0;\n    (timing as Mutable<typeof timing>)[1] = t1;\n    return timing;\n  } as {\n    (easing: Easing, t0: number, t1: number): Timing;\n\n    /** @internal */\n    prototype: Timing;\n\n    fromLike<T extends TimingLike | boolean | null | undefined>(value: T): Timing | (T extends true ? true : never) | (T extends false ? false : never) | Uninitable<T>;\n\n    fromInit(init: TimingInit): Timing;\n  };\n\n  Timing.prototype = Object.create(_super.prototype);\n  Timing.prototype.constructor = Timing;\n\n  Object.defineProperty(Timing.prototype, \"duration\", {\n    get(this: Timing): number {\n      return this[1] - this[0];\n    },\n    configurable: true,\n  });\n\n  Timing.prototype.contains = function (t: number): boolean {\n    return this[0] <= t && t <= this[1];\n  };\n\n  Timing.prototype.withDomain = function (t0: number, t1: number): Timing {\n    return Timing(this.easing, t0, t1);\n  };\n\n  Timing.prototype.withDuration = function (dt: number): Timing {\n    const t0 = this[0];\n    return Timing(this.easing, t0, t0 + dt);\n  };\n\n  Timing.prototype.overRange = function <Y>(this: Timing, y0: Interpolator<Y> | Y, y1: Y): Tweening<Y> {\n    let range: Interpolator<Y>;\n    if (arguments.length === 1) {\n      range = y0 as Interpolator<Y>;\n    } else {\n      range = Interpolator(y0 as Y, y1);\n    }\n    return Tweening(this, range);\n  } as typeof Timing.prototype.overRange;\n\n  Timing.prototype.union = function (that: Domain<number>): Timing {\n    return Timing(this.easing, Math.min(this[0], that[0]), Math.max(this[1], that[1]));\n  };\n\n  Timing.prototype.canEqual = function (that: unknown): boolean {\n    return that instanceof Timing;\n  };\n\n  Timing.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Timing) {\n      return that.canEqual(this)\n          && this.easing.equals(that.easing)\n          && Values.equal(this[0], that[0])\n          && Values.equal(this[1], that[1]);\n    }\n    return false;\n  };\n\n  Timing.prototype.equivalentTo = function (that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Timing) {\n      return this.easing.equivalentTo(that.easing, epsilon)\n          && Values.equivalent(this[0], that[0], epsilon)\n          && Values.equivalent(this[1], that[1], epsilon);\n    }\n    return false;\n  };\n\n  Timing.prototype.toString = function (): string {\n    return \"Timing(\" + this.easing + \", \" + this[0] + \", \" + this[1] + \")\";\n  };\n\n  Timing.fromLike = function <T extends TimingLike | boolean | null | undefined>(value: T): Timing | (T extends true ? true : never) | (T extends false ? false : never) | Uninitable<T> {\n    if (value === void 0 || value === null || typeof value === \"boolean\" || value instanceof Timing) {\n      return value as Timing | (T extends true ? true : never) | (T extends false ? false : never) | Uninitable<T>;\n    } else if (typeof value === \"object\") {\n      return this.fromInit(value);\n    }\n    throw new TypeError(\"\" + value);\n  };\n\n  Timing.fromInit = function (init: TimingInit): Timing {\n    let easing = init.easing;\n    if (easing === void 0) {\n      easing = Easing.linear;\n    } else if (typeof easing === \"string\") {\n      easing = Easing(easing);\n    }\n    let t0 = init.t0;\n    if (t0 === void 0) {\n      t0 = 0;\n    }\n    let t1 = init.t1;\n    if (t1 === void 0) {\n      const dt = init.dt;\n      if (dt !== void 0) {\n        t1 = t0 + dt;\n      } else {\n        t1 = t0;\n      }\n    }\n    return Timing(easing, t0, t1);\n  };\n\n  return Timing;\n})(Domain);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"./types\";\nimport type {Mutable} from \"./types\";\nimport {Timing} from \"./Timing\";\n\n/** @public */\nexport type EasingLike = Easing | EasingType;\n\n/** @public */\nexport type EasingType = \"linear\" | \"quad-in\" | \"quad-out\" | \"quad-in-out\"\n                       | \"cubic-in\" | \"cubic-out\" | \"cubic-in-out\"\n                       | \"quart-in\" | \"quart-out\" | \"quart-in-out\"\n                       | \"expo-in\" | \"expo-out\" | \"expo-in-out\"\n                       | \"circ-in\" | \"circ-out\" | \"circ-in-out\"\n                       | \"back-in\" | \"back-out\" | \"back-in-out\"\n                       | \"elastic-in\" | \"elastic-out\" | \"elastic-in-out\"\n                       | \"bounce-in\" | \"bounce-out\" | \"bounce-in-out\";\n\n/** @public */\nexport interface Easing extends Timing {\n  /** @override */\n  likeType?(like: EasingType): void;\n\n  readonly type: string;\n\n  /** @override */\n  readonly 0: 0;\n\n  /** @override */\n  readonly 1: 1;\n\n  /** @override */\n  readonly easing: this;\n\n  /** @override */\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  equivalentTo(that: unknown, epsilon?: number): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const Easing = (function (_super: typeof Timing) {\n  const Easing = function (type: string): Easing {\n    switch (type) {\n      case \"linear\": return Easing.linear;\n      case \"quad-in\": return Easing.quadIn;\n      case \"quad-out\": return Easing.quadOut;\n      case \"quad-in-out\": return Easing.quadInOut;\n      case \"cubic-in\": return Easing.cubicIn;\n      case \"cubic-out\": return Easing.cubicOut;\n      case \"cubic-in-out\": return Easing.cubicInOut;\n      case \"quart-in\": return Easing.quartIn;\n      case \"quart-out\": return Easing.quartOut;\n      case \"quart-in-out\": return Easing.quartInOut;\n      case \"expo-in\": return Easing.expoIn;\n      case \"expo-out\": return Easing.expoOut;\n      case \"expo-in-out\": return Easing.expoInOut;\n      case \"circ-in\": return Easing.circIn;\n      case \"circ-out\": return Easing.circOut;\n      case \"circ-in-out\": return Easing.circInOut;\n      case \"back-in\": return Easing.backIn;\n      case \"back-out\": return Easing.backOut;\n      case \"back-in-out\": return Easing.backInOut;\n      case \"elastic-in\": return Easing.elasticIn;\n      case \"elastic-out\": return Easing.elasticOut;\n      case \"elastic-in-out\": return Easing.elasticInOut;\n      case \"bounce-in\": return Easing.bounceIn;\n      case \"bounce-out\": return Easing.bounceOut;\n      case \"bounce-in-out\": return Easing.bounceInOut;\n      default: throw new Error(\"unknown easing function: \" + type);\n    }\n  } as {\n    (type: string): Easing;\n\n    /** @internal */\n    prototype: Easing;\n\n    readonly linear: Easing;\n    readonly quadIn: Easing;\n    readonly quadOut: Easing;\n    readonly quadInOut: Easing;\n    readonly cubicIn: Easing;\n    readonly cubicOut: Easing;\n    readonly cubicInOut: Easing;\n    readonly quartIn: Easing;\n    readonly quartOut: Easing;\n    readonly quartInOut: Easing;\n    readonly expoIn: Easing;\n    readonly expoOut: Easing;\n    readonly expoInOut: Easing;\n    readonly circIn: Easing;\n    readonly circOut: Easing;\n    readonly circInOut: Easing;\n    readonly backIn: Easing;\n    readonly backOut: Easing;\n    readonly backInOut: Easing;\n    readonly elasticIn: Easing;\n    readonly elasticOut: Easing;\n    readonly elasticInOut: Easing;\n    readonly bounceIn: Easing;\n    readonly bounceOut: Easing;\n    readonly bounceInOut: Easing;\n\n    fromLike<T extends EasingLike | null | undefined>(value: T): Easing | Uninitable<T>;\n  };\n\n  Easing.prototype = Object.create(_super.prototype);\n  Easing.prototype.constructor = Easing;\n\n  Object.defineProperty(Easing.prototype, 0, {\n    value: 0,\n  });\n\n  Object.defineProperty(Easing.prototype, 1, {\n    value: 1,\n  });\n\n  Object.defineProperty(Easing.prototype, \"easing\", {\n    get(this: Easing): Easing {\n      return this;\n    },\n  });\n\n  Easing.prototype.canEqual = function (that: unknown): boolean {\n    return that instanceof Easing;\n  };\n\n  Easing.prototype.equals = function (that: unknown): boolean {\n    return this === that;\n  };\n\n  Easing.prototype.equivalentTo = function (that: unknown, epsilon?: number): boolean {\n    return this === that;\n  };\n\n  Easing.prototype.toString = function (): string {\n    return \"Easing(\\\"\" + this.type + \"\\\")\";\n  };\n\n  Easing.fromLike = function <T extends EasingLike | null | undefined>(value: T): Easing | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof Easing) {\n      return value as Easing | Uninitable<T>;\n    } else if (typeof value === \"string\") {\n      return Easing(value);\n    }\n    throw new TypeError(\"\" + value);\n  };\n\n  (Easing as Mutable<typeof Easing>).linear = function (u: number): number {\n    return u;\n  } as Easing;\n  Object.setPrototypeOf(Easing.linear, Easing.prototype);\n  (Easing.linear as Mutable<Easing>).type = \"linear\";\n\n  (Easing as Mutable<typeof Easing>).quadIn = function (u: number): number {\n    return u * u;\n  } as Easing;\n  Object.setPrototypeOf(Easing.quadIn, Easing.prototype);\n  (Easing.quadIn as Mutable<Easing>).type = \"quad-in\";\n\n  (Easing as Mutable<typeof Easing>).quadOut = function (u: number): number {\n    return u * (2 - u);\n  } as Easing;\n  Object.setPrototypeOf(Easing.quadOut, Easing.prototype);\n  (Easing.quadOut as Mutable<Easing>).type = \"quad-out\";\n\n  (Easing as Mutable<typeof Easing>).quadInOut = function (u: number): number {\n    u *= 2;\n    if (u <= 1) {\n      u = u * u;\n    } else {\n      u -= 1;\n      u = u * (2 - u);\n      u += 1;\n    }\n    u /= 2;\n    return u;\n  } as Easing;\n  Object.setPrototypeOf(Easing.quadInOut, Easing.prototype);\n  (Easing.quadInOut as Mutable<Easing>).type = \"quad-in-out\";\n\n  (Easing as Mutable<typeof Easing>).cubicIn = function (u: number): number {\n    return u * u * u;\n  } as Easing;\n  Object.setPrototypeOf(Easing.cubicIn, Easing.prototype);\n  (Easing.cubicIn as Mutable<Easing>).type = \"cubic-in\";\n\n  (Easing as Mutable<typeof Easing>).cubicOut = function (u: number): number {\n    u -= 1;\n    u = u * u * u;\n    u += 1;\n    return u;\n  } as Easing;\n  Object.setPrototypeOf(Easing.cubicOut, Easing.prototype);\n  (Easing.cubicOut as Mutable<Easing>).type = \"cubic-out\";\n\n  (Easing as Mutable<typeof Easing>).cubicInOut = function (u: number): number {\n    u *= 2;\n    if (u <= 1) {\n      u = u * u * u;\n    } else {\n      u -= 2;\n      u = u * u * u;\n      u += 2;\n    }\n    u /= 2;\n    return u;\n  } as Easing;\n  Object.setPrototypeOf(Easing.cubicInOut, Easing.prototype);\n  (Easing.cubicInOut as Mutable<Easing>).type = \"cubic-in-out\";\n\n  (Easing as Mutable<typeof Easing>).quartIn = function (u: number): number {\n    return u * u * u * u;\n  } as Easing;\n  Object.setPrototypeOf(Easing.quartIn, Easing.prototype);\n  (Easing.quartIn as Mutable<Easing>).type = \"quart-in\";\n\n  (Easing as Mutable<typeof Easing>).quartOut = function (u: number): number {\n    u -= 1;\n    return 1 - u * u * u * u;\n  } as Easing;\n  Object.setPrototypeOf(Easing.quartOut, Easing.prototype);\n  (Easing.quartOut as Mutable<Easing>).type = \"quart-out\";\n\n  (Easing as Mutable<typeof Easing>).quartInOut = function (u: number): number {\n    const v = u - 1;\n    return u < 0.5 ? 8 * u * u * u * u : 1 - 8 * v * v * v * v;\n  } as Easing;\n  Object.setPrototypeOf(Easing.quartInOut, Easing.prototype);\n  (Easing.quartInOut as Mutable<Easing>).type = \"quart-in-out\";\n\n  (Easing as Mutable<typeof Easing>).expoIn = function (u: number): number {\n    if (u === 0) {\n      return 0;\n    }\n    return Math.pow(2, 10 * (u - 1));\n  } as Easing;\n  Object.setPrototypeOf(Easing.expoIn, Easing.prototype);\n  (Easing.expoIn as Mutable<Easing>).type = \"expo-in\";\n\n  (Easing as Mutable<typeof Easing>).expoOut = function (u: number): number {\n    if (u === 1) {\n      return 1;\n    }\n    return (-Math.pow(2, -10 * u) + 1);\n  } as Easing;\n  Object.setPrototypeOf(Easing.expoOut, Easing.prototype);\n  (Easing.expoOut as Mutable<Easing>).type = \"expo-out\";\n\n  (Easing as Mutable<typeof Easing>).expoInOut = function (u: number): number {\n    if (u === 1 || u === 0) {\n      return u;\n    }\n    u *= 2;\n    if (u < 1) {\n      return 0.5 * Math.pow(2, 10 * (u - 1));\n    }\n    return 0.5 * (-Math.pow(2, -10 * (u - 1)) + 2);\n  } as Easing;\n  Object.setPrototypeOf(Easing.expoInOut, Easing.prototype);\n  (Easing.expoInOut as Mutable<Easing>).type = \"expo-in-out\";\n\n  (Easing as Mutable<typeof Easing>).circIn = function (u: number): number {\n    return -1 * (Math.sqrt(1 - (u / 1) * u) - 1);\n  } as Easing;\n  Object.setPrototypeOf(Easing.circIn, Easing.prototype);\n  (Easing.circIn as Mutable<Easing>).type = \"circ-in\";\n\n  (Easing as Mutable<typeof Easing>).circOut = function (u: number): number {\n    u -= 1;\n    return Math.sqrt(1 - u * u);\n  } as Easing;\n  Object.setPrototypeOf(Easing.circOut, Easing.prototype);\n  (Easing.circOut as Mutable<Easing>).type = \"circ-out\";\n\n  (Easing as Mutable<typeof Easing>).circInOut = function (u: number): number {\n    u *= 2;\n    if (u < 1) {\n      return -0.5 * (Math.sqrt(1 - u * u) - 1);\n    }\n    const st = u - 2;\n    return 0.5 * (Math.sqrt(1 - st * st) + 1);\n  } as Easing;\n  Object.setPrototypeOf(Easing.circInOut, Easing.prototype);\n  (Easing.circInOut as Mutable<Easing>).type = \"circ-in-out\";\n\n  (Easing as Mutable<typeof Easing>).backIn = function (u: number): number {\n    const m = 1.70158; // m - Magnitude\n    return u * u * ((m + 1) * u - m);\n  } as Easing;\n  Object.setPrototypeOf(Easing.backIn, Easing.prototype);\n  (Easing.backIn as Mutable<Easing>).type = \"back-in\";\n\n  (Easing as Mutable<typeof Easing>).backOut = function (u: number): number {\n    const m = 1.70158;\n    const st = (u / 1) - 1;\n    return (st * st * ((m + 1) * m + m)) + 1;\n  } as Easing;\n  Object.setPrototypeOf(Easing.backOut, Easing.prototype);\n  (Easing.backOut as Mutable<Easing>).type = \"back-out\";\n\n  (Easing as Mutable<typeof Easing>).backInOut = function (u: number): number {\n    const m = 1.70158;\n    const s = m * 1.525;\n    if ((u *= 2) < 1) {\n      return 0.5 * u * u * (((s + 1) * u) - s);\n    }\n    const st = u - 2;\n    return 0.5 * (st * st * ((s + 1) * st + s) + 2);\n  } as Easing;\n  Object.setPrototypeOf(Easing.backInOut, Easing.prototype);\n  (Easing.backInOut as Mutable<Easing>).type = \"back-in-out\";\n\n  (Easing as Mutable<typeof Easing>).elasticIn = function (u: number): number {\n    if (u === 0 || u === 1) {\n      return u;\n    }\n    const m = 0.7;\n    const st = (u / 1) - 1;\n    const s = (1 - m) / 2 * Math.PI * Math.asin(1);\n    return -(Math.pow(2, 10 * st) * Math.sin((st - s) * 2 * Math.PI / (1 - m)));\n  } as Easing;\n  Object.setPrototypeOf(Easing.elasticIn, Easing.prototype);\n  (Easing.elasticIn as Mutable<Easing>).type = \"elastic-in\";\n\n  (Easing as Mutable<typeof Easing>).elasticOut = function (u: number): number {\n    if (u === 0 || u === 1) {\n      return u;\n    }\n    const m = 0.7;\n    const s = (1 -  m) / (2 * Math.PI) * Math.asin(1);\n    u *= 2;\n    return (Math.pow(2, -10 * u) * Math.sin((u - s) * 2 * Math.PI / (1 - m))) + 1;\n  } as Easing;\n  Object.setPrototypeOf(Easing.elasticOut, Easing.prototype);\n  (Easing.elasticOut as Mutable<Easing>).type = \"elastic-out\";\n\n  (Easing as Mutable<typeof Easing>).elasticInOut = function (u: number): number {\n    if (u === 0 || u === 1) {\n      return u;\n    }\n    const m = 0.65;\n    const s = (1 - m) / (2 * Math.PI) * Math.asin(1);\n    const st = u * 2;\n    const st1 = st - 1;\n    if(st < 1) {\n      return -0.5 * (Math.pow(2, 10 * st1) * Math.sin((st1 - s) * 2 * Math.PI / (1 - m)));\n    }\n    return (Math.pow(2, -10 * st1) * Math.sin((st1 - s) * 2 * Math.PI / (1 - m)) * 0.5) + 1;\n  } as Easing;\n  Object.setPrototypeOf(Easing.elasticInOut, Easing.prototype);\n  (Easing.elasticInOut as Mutable<Easing>).type = \"elastic-in-out\";\n\n  (Easing as Mutable<typeof Easing>).bounceIn = function (u: number): number {\n    const p = 7.5625;\n    if ((u = 1 - u) < 1 / 2.75) {\n      return 1 - (p * u * u);\n    } else if (u < 2 / 2.75) {\n      return 1 - (p * (u -= 1.5 / 2.75) * u + 0.75);\n    } else if (u < 2.5 / 2.75) {\n      return 1 - (p * (u -= 2.25 / 2.75) * u + 0.9375);\n    }\n    return 1 - (p * (u -= 2.625 / 2.75) * u + 0.984375);\n  } as Easing;\n  Object.setPrototypeOf(Easing.bounceIn, Easing.prototype);\n  (Easing.bounceIn as Mutable<Easing>).type = \"bounce-in\";\n\n  (Easing as Mutable<typeof Easing>).bounceOut = function (u: number): number {\n    const p = 7.5625;\n    if (u < 1 / 2.75) {\n      return p * u * u;\n    } else if (u < 2 / 2.75) {\n      return p * (u -= 1.5 / 2.75) * u + 0.75;\n    } else if (u < 2.5 / 2.75) {\n      return p * (u -= 2.25 / 2.75) * u + 0.9375;\n    }\n    return p * (u -= 2.625 / 2.75) * u + 0.984375;\n  } as Easing;\n  Object.setPrototypeOf(Easing.bounceOut, Easing.prototype);\n  (Easing.bounceOut as Mutable<Easing>).type = \"bounce-out\";\n\n  (Easing as Mutable<typeof Easing>).bounceInOut = function (u: number): number {\n    const invert = u < 0.5;\n    u = invert ? 1 - (u * 2) : (u * 2) - 1;\n    const p = 7.5625;\n    if (u < 1 / 2.75) {\n      u = p * u * u;\n    } else if (u < 2 / 2.75) {\n      u = p * (u -= 1.5 / 2.75) * u + 0.75;\n    } else if (u < 2.5 / 2.75) {\n      u = p * (u -= 2.25 / 2.75) * u + 0.9375;\n    } else {\n      u = p * (u -= 2.625 / 2.75) * u + 0.984375;\n    }\n    return invert ? (1 - u) * 0.5 : u * 0.5 + 0.5;\n  } as Easing;\n  Object.setPrototypeOf(Easing.bounceInOut, Easing.prototype);\n  (Easing.bounceInOut as Mutable<Easing>).type = \"bounce-in-out\";\n\n  return Easing;\n})(Timing);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"./types\";\nimport {Mapping} from \"./Mapping\";\nimport type {Interpolator} from \"./Interpolator\";\nimport type {Timing} from \"./Timing\";\n\n/** @public */\nexport interface Tweening<Y> extends Mapping<number, Y> {\n  /** @override */\n  readonly domain: Timing;\n\n  /** @override */\n  readonly range: Interpolator<Y>;\n\n  withDomain(t0: number, t1: number): Tweening<Y>;\n\n  /** @override */\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const Tweening = (function (_super: typeof Mapping) {\n  const Tweening = function <Y>(domain: Timing, range: Interpolator<Y>): Tweening<Y> {\n    const tweening = function (u: number): Y {\n      return tweening.range(tweening.domain(u));\n    } as Tweening<Y>;\n    Object.setPrototypeOf(tweening, Tweening.prototype);\n    (tweening as Mutable<typeof tweening>).domain = domain;\n    (tweening as Mutable<typeof tweening>).range = range;\n    return tweening;\n  } as {\n    <Y>(domain: Timing, range: Interpolator<Y>): Tweening<Y>\n\n    /** @internal */\n    prototype: Tweening<any>;\n  };\n\n  Tweening.prototype = Object.create(_super.prototype);\n  Tweening.prototype.constructor = Tweening;\n\n  Tweening.prototype.withDomain = function <Y>(this: Tweening<Y>, t0: number, t1: number): Tweening<Y> {\n    return this.domain.withDomain(t0, t1).overRange(this.range);\n  };\n\n  Tweening.prototype.canEqual = function <Y>(this: Tweening<Y>, that: unknown): boolean {\n    return that instanceof Tweening;\n  };\n\n  Tweening.prototype.equals = function <Y>(this: Tweening<Y>, that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Tweening) {\n      return this.domain.equals(that.domain) && this.range.equals(that.range);\n    }\n    return false;\n  };\n\n  Tweening.prototype.toString = function <Y>(this: Tweening<Y>): string {\n    return \"Tweening(\" + this.domain + \", \" + this.range + \")\";\n  };\n\n  return Tweening;\n})(Mapping);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Mapping} from \"./Mapping\";\nimport type {Domain} from \"./Domain\";\nimport type {Range} from \"./Range\";\n\n/** @public */\nexport interface Scale<X, Y> extends Mapping<X, Y> {\n  readonly inverse: Mapping<Y, X>;\n\n  withDomain(domain: Domain<X>): Scale<X, Y>;\n  withDomain(x0: X, x1: X): Scale<X, Y>;\n\n  overRange(range: Range<Y>): Scale<X, Y>;\n  overRange(y0: Y, y1: Y): Scale<X, Y>;\n\n  /** @override */\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const Scale = (function (_super: typeof Mapping) {\n  const Scale = function (): never {\n    throw new Error();\n  } as {\n    /** @internal */\n    (): never;\n\n    /** @internal */\n    prototype: Scale<any, any>;\n  };\n\n  Scale.prototype = Object.create(_super.prototype);\n  Scale.prototype.constructor = Scale;\n\n  Scale.prototype.canEqual = function (that: unknown): boolean {\n    return that instanceof Scale;\n  };\n\n  Scale.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Scale) {\n      return this.domain.equals(that.domain) && this.range.equals(that.range);\n    }\n    return false;\n  };\n\n  Scale.prototype.toString = function (): string {\n    return \"Scale(\" + this.domain + \", \" + this.range + \")\";\n  };\n\n  return Scale;\n})(Mapping);\n\n/** @public */\nexport interface ContinuousScale<X, Y> extends Scale<X, Y> {\n  /** @override */\n  readonly inverse: Mapping<Y, X>;\n\n  /** @override */\n  withDomain(domain: Domain<X>): ContinuousScale<X, Y>;\n  withDomain(x0: X, x1: X): ContinuousScale<X, Y>;\n\n  /** @override */\n  overRange(range: Range<Y>): ContinuousScale<X, Y>;\n  overRange(y0: Y, y1: Y): ContinuousScale<X, Y>;\n\n  clampDomain(xMin: X | undefined, xMax: X | undefined,\n              zMin: number | undefined, zMax: number | undefined,\n              epsilon?: number): ContinuousScale<X, Y>;\n\n  solveDomain(x1: X, y1: Y, x2?: X, y2?: Y,\n              reflect?: boolean, epsilon?: number): ContinuousScale<X, Y>;\n\n  /** @override */\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const ContinuousScale = (function (_super: typeof Scale) {\n  const ContinuousScale = function (): never {\n    throw new Error();\n  } as {\n    /** @internal */\n    (): never;\n\n    /** @internal */\n    prototype: ContinuousScale<any, any>;\n  };\n\n  ContinuousScale.prototype = Object.create(_super.prototype);\n  ContinuousScale.prototype.constructor = ContinuousScale;\n\n  ContinuousScale.prototype.canEqual = function (that: unknown): boolean {\n    return that instanceof ContinuousScale;\n  };\n\n  ContinuousScale.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof ContinuousScale) {\n      return this.domain.equals(that.domain) && this.range.equals(that.range);\n    }\n    return false;\n  };\n\n  ContinuousScale.prototype.toString = function (): string {\n    return \"ContinuousScale(\" + this.domain + \", \" + this.range + \")\";\n  };\n\n  return ContinuousScale;\n})(Scale);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"./types\";\nimport {Domain} from \"./Domain\";\nimport type {Interpolate} from \"./Interpolate\";\nimport {Interpolator} from \"./Interpolator\";\nimport {LinearRange} from \"./\"; // forward import\n\n/** @public */\nexport interface LinearDomain extends Domain<number>, Interpolate<LinearDomain> {\n  /** @override */\n  readonly 0: number;\n\n  /** @override */\n  readonly 1: number;\n\n  readonly inverse: LinearRange;\n\n  /** @override */\n  contains(x: number): boolean;\n\n  /** @override */\n  union(that: Domain<number>): LinearDomain;\n\n  /** @override */\n  interpolateTo(that: LinearDomain): Interpolator<LinearDomain>;\n  interpolateTo(that: unknown): Interpolator<LinearDomain> | null;\n\n  /** @override */\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const LinearDomain = (function (_super: typeof Domain) {\n  const LinearDomain = function (x0: number, x1: number): LinearDomain {\n    const domain = function (x: number): number {\n      const x0 = domain[0];\n      const x1 = domain[1];\n      const dx = x1 - x0;\n      return dx !== 0 ? (x - x0) / dx : 0;\n    } as LinearDomain;\n    Object.setPrototypeOf(domain, LinearDomain.prototype);\n    (domain as Mutable<typeof domain>)[0] = x0;\n    (domain as Mutable<typeof domain>)[1] = x1;\n    return domain;\n  } as {\n    (x0: number, x1: number): LinearDomain;\n\n    /** @internal */\n    prototype: LinearDomain;\n  };\n\n  LinearDomain.prototype = Object.create(_super.prototype);\n  LinearDomain.prototype.constructor = LinearDomain;\n\n  Object.defineProperty(LinearDomain.prototype, \"inverse\", {\n    get(this: LinearDomain): LinearRange {\n      return LinearRange(this[0], this[1]);\n    },\n    configurable: true,\n  });\n\n  LinearDomain.prototype.contains = function (x: number): boolean {\n    return this[0] <= x && x <= this[1];\n  };\n\n  LinearDomain.prototype.union = function (that: Domain<number>): LinearDomain {\n    return LinearDomain(Math.min(this[0], that[0]), Math.max(this[1], that[1]));\n  };\n\n  LinearDomain.prototype.interpolateTo = function (this: LinearDomain, that: unknown): Interpolator<LinearDomain> | null {\n    if (that instanceof LinearDomain) {\n      return LinearDomainInterpolator(this, that);\n    }\n    return null;\n  } as typeof LinearDomain.prototype.interpolateTo;\n\n  LinearDomain.prototype.canEqual = function (that: unknown): boolean {\n    return that instanceof LinearDomain;\n  };\n\n  LinearDomain.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof LinearDomain) {\n      return that.canEqual(this) && this[0] === that[0] && this[1] === that[1];\n    }\n    return false;\n  };\n\n  LinearDomain.prototype.toString = function (): string {\n    return \"LinearDomain(\" + this[0] + \", \" + this[1] + \")\";\n  };\n\n  return LinearDomain;\n})(Domain);\n\n/** @internal */\nexport const LinearDomainInterpolator = (function (_super: typeof Interpolator) {\n  const LinearDomainInterpolator = function (x0: LinearDomain, x1: LinearDomain): Interpolator<LinearDomain> {\n    const interpolator = function (u: number): LinearDomain {\n      const x0 = interpolator[0];\n      const x00 = x0[0];\n      const x01 = x0[1];\n      const x1 = interpolator[1];\n      const x10 = x1[0];\n      const x11 = x1[1];\n      return LinearDomain(x00 + u * (x10 - x00), x01 + u * (x11 - x01));\n    } as Interpolator<LinearDomain>;\n    Object.setPrototypeOf(interpolator, LinearDomainInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = x0;\n    (interpolator as Mutable<typeof interpolator>)[1] = x1;\n    return interpolator;\n  } as {\n    (x0: LinearDomain, x1: LinearDomain): Interpolator<LinearDomain>;\n\n    /** @internal */\n    prototype: Interpolator<LinearDomain>;\n  };\n\n  LinearDomainInterpolator.prototype = Object.create(_super.prototype);\n  LinearDomainInterpolator.prototype.constructor = LinearDomainInterpolator;\n\n  return LinearDomainInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"./types\";\nimport {Range} from \"./Range\";\nimport type {Interpolate} from \"./Interpolate\";\nimport {Interpolator} from \"./Interpolator\";\nimport {LinearDomain} from \"./LinearDomain\";\n\n/** @public */\nexport interface LinearRange extends Range<number>, Interpolate<LinearRange> {\n  /** @override */\n  readonly 0: number;\n\n  /** @override */\n  readonly 1: number;\n\n  readonly inverse: LinearDomain;\n\n  /** @override */\n  union(that: Range<number>): LinearRange;\n\n  /** @override */\n  interpolateTo(that: LinearRange): Interpolator<LinearRange>;\n  interpolateTo(that: unknown): Interpolator<LinearRange> | null;\n\n  /** @override */\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const LinearRange = (function (_super: typeof Range) {\n  const LinearRange = function (y0: number, y1: number): LinearRange {\n    const range = function (u: number): number {\n      const y0 = range[0];\n      const y1 = range[1];\n      return y0 + u * (y1 - y0);\n    } as LinearRange;\n    Object.setPrototypeOf(range, LinearRange.prototype);\n    (range as Mutable<typeof range>)[0] = y0;\n    (range as Mutable<typeof range>)[1] = y1;\n    return range;\n  } as {\n    (y0: number, y1: number): LinearRange;\n\n    /** @internal */\n    prototype: LinearRange;\n  };\n\n  LinearRange.prototype = Object.create(_super.prototype);\n  LinearRange.prototype.constructor = LinearRange;\n\n  Object.defineProperty(LinearRange.prototype, \"inverse\", {\n    get(this: LinearRange): LinearDomain {\n      return LinearDomain(this[0], this[1]);\n    },\n    configurable: true,\n  });\n\n  LinearRange.prototype.union = function (that: Range<number>): LinearRange {\n    const y00 = this[0];\n    const y01 = this[1];\n    const y10 = that[0];\n    const y11 = that[1];\n    let y0: number;\n    let y1: number;\n    if (y00 <= y01 && y10 <= y11) {\n      y0 = Math.min(y00, y10);\n      y1 = Math.max(y01, y11);\n    } else if (y00 >= y01 && y10 >= y11) {\n      y0 = Math.max(y00, y10);\n      y1 = Math.min(y01, y11);\n    } else if (y00 <= y01 && y10 >= y11) {\n      y0 = Math.min(y00, y11);\n      y1 = Math.max(y01, y10);\n    } else { // y00 >= y01 && y10 <= y11\n      y0 = Math.min(y01, y10);\n      y1 = Math.max(y00, y11);\n    }\n    return LinearRange(y0, y1);\n  };\n\n  LinearRange.prototype.interpolateTo = function (this: LinearRange, that: unknown): Interpolator<LinearRange> | null {\n    if (that instanceof LinearRange) {\n      return LinearRangeInterpolator(this, that);\n    }\n    return null;\n  } as typeof LinearRange.prototype.interpolateTo;\n\n  LinearRange.prototype.canEqual = function (that: unknown): boolean {\n    return that instanceof LinearRange;\n  };\n\n  LinearRange.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof LinearRange) {\n      return that.canEqual(this) && this[0] === that[0] && this[1] === that[1];\n    }\n    return false;\n  };\n\n  LinearRange.prototype.toString = function (): string {\n    return \"LinearRange(\" + this[0] + \", \" + this[1] + \")\";\n  };\n\n  return LinearRange;\n})(Range);\n\n/** @internal */\nexport const LinearRangeInterpolator = (function (_super: typeof Interpolator) {\n  const LinearRangeInterpolator = function (y0: LinearRange, y1: LinearRange): Interpolator<LinearRange> {\n    const interpolator = function (u: number): LinearRange {\n      const y0 = interpolator[0];\n      const y00 = y0[0];\n      const y01 = y0[1];\n      const y1 = interpolator[1];\n      const y10 = y1[0];\n      const y11 = y1[1];\n      return LinearRange(y00 + u * (y10 - y00), y01 + u * (y11 - y01));\n    } as Interpolator<LinearRange>;\n    Object.setPrototypeOf(interpolator, LinearRangeInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = y0;\n    (interpolator as Mutable<typeof interpolator>)[1] = y1;\n    return interpolator;\n  } as {\n    (y0: LinearRange, y1: LinearRange): Interpolator<LinearRange>;\n\n    /** @internal */\n    prototype: Interpolator<LinearRange>;\n  };\n\n  LinearRangeInterpolator.prototype = Object.create(_super.prototype);\n  LinearRangeInterpolator.prototype.constructor = LinearRangeInterpolator;\n\n  return LinearRangeInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"./types\";\nimport {Equivalent} from \"./Equivalent\";\nimport type {Interpolate} from \"./Interpolate\";\nimport {Interpolator} from \"./Interpolator\";\nimport {ContinuousScale} from \"./Scale\";\nimport {LinearDomain} from \"./LinearDomain\";\nimport {LinearRange} from \"./LinearRange\";\n\n/** @public */\nexport interface LinearScale extends ContinuousScale<number, number>, Interpolate<LinearScale> {\n  /** @override */\n  readonly domain: LinearDomain;\n\n  /** @override */\n  readonly range: LinearRange;\n\n  /** @override */\n  readonly inverse: LinearScale;\n\n  /** @override */\n  withDomain(domain: LinearDomain): LinearScale;\n  withDomain(x0: number, x1: number): LinearScale;\n\n  /** @override */\n  overRange(range: LinearRange): LinearScale;\n  overRange(y0: number, y1: number): LinearScale;\n\n  /** @override */\n  clampDomain(xMin: number | undefined, xMax: number | undefined,\n              zMin: number | undefined, zMax: number | undefined,\n              epsilon?: number): LinearScale;\n\n  /** @override */\n  solveDomain(x1: number, y1: number, x2?: number, y2?: number,\n              reflect?: boolean, epsilon?: number): LinearScale;\n\n  /** @override */\n  interpolateTo(that: LinearScale): Interpolator<LinearScale>;\n  interpolateTo(that: unknown): Interpolator<LinearScale> | null;\n\n  /** @override */\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const LinearScale = (function (_super: typeof ContinuousScale) {\n  const LinearScale = function (domain: LinearDomain, range: LinearRange): LinearScale {\n    const scale = function (x: number): number {\n      return scale.range(scale.domain(x));\n    } as LinearScale;\n    Object.setPrototypeOf(scale, LinearScale.prototype);\n    (scale as Mutable<typeof scale>).domain = domain;\n    (scale as Mutable<typeof scale>).range = range;\n    return scale;\n  } as {\n    (domain: LinearDomain, range: LinearRange): LinearScale;\n\n    /** @internal */\n    prototype: LinearScale;\n  };\n\n  LinearScale.prototype = Object.create(_super.prototype);\n  LinearScale.prototype.constructor = LinearScale;\n\n  Object.defineProperty(LinearScale.prototype, \"inverse\", {\n    get(this: LinearScale): LinearScale {\n      return LinearScale(this.range.inverse, this.domain.inverse);\n    },\n    configurable: true,\n  });\n\n  LinearScale.prototype.withDomain = function (x0: LinearDomain | number, x1?: number): LinearScale {\n    let domain: LinearDomain;\n    if (arguments.length === 1) {\n      domain = x0 as LinearDomain;\n    } else {\n      domain = LinearDomain(x0 as number, x1!);\n    }\n    return LinearScale(domain, this.range);\n  };\n\n  LinearScale.prototype.overRange = function (y0: LinearRange | number, y1?: number): LinearScale {\n    let range: LinearRange;\n    if (arguments.length === 1) {\n      range = y0 as LinearRange;\n    } else {\n      range = LinearRange(y0 as number, y1!);\n    }\n    return LinearScale(this.domain, range);\n  };\n\n  LinearScale.prototype.clampDomain = function (xMin: number | undefined, xMax: number | undefined,\n                                                zMin: number | undefined, zMax: number | undefined,\n                                                epsilon?: number): LinearScale {\n    if (epsilon === void 0) {\n      epsilon = Equivalent.Epsilon;\n    }\n    let x0 = this.domain[0];\n    let x1 = this.domain[1];\n    if (xMin !== void 0 && xMax !== void 0 && Math.abs(x1 - x0) > xMax - xMin) {\n      if (x0 < x1) {\n        x0 = xMin;\n        x1 = xMax;\n      } else {\n        x1 = xMin;\n        x0 = xMax;\n      }\n    } else {\n      if (xMin !== void 0) {\n        if (x0 < x1 && x0 < xMin) {\n          x1 += xMin - x0;\n          x0 = xMin;\n        } else if (x1 < x0 && x1 < xMin) {\n          x0 += xMin - x1;\n          x1 = xMin;\n        }\n      }\n      if (xMax !== void 0) {\n        if (x0 < x1 && x1 > xMax) {\n          x0 -= x1 - xMax;\n          x1 = xMax;\n        } else if (x1 < x0 && x0 > xMax) {\n          x1 -= x0 - xMax;\n          x0 = xMax;\n        }\n      }\n    }\n\n    const y0 = this(x0);\n    const y1 = this(x1);\n    const dy = y0 < y1 ? y1 - y0 : y0 - y1;\n    const z = Math.abs(dy / (x1 - x0));\n    if (zMin !== void 0 && z < 1 / zMin) {\n      const dz = dy * zMin;\n      const xSum = x0 + x1;\n      x0 = (xSum - dz) / 2;\n      x1 = (xSum + dz) / 2;\n    } else if (zMax !== void 0 && z > 1 / zMax) {\n      const dz = dy * zMax;\n      const xSum = x0 + x1;\n      x0 = (xSum - dz) / 2;\n      x1 = (xSum + dz) / 2;\n    }\n\n    if (Math.abs(x0 - this.domain[0]) < epsilon && Math.abs(x1 - this.domain[1]) < epsilon) {\n      return this;\n    }\n    return LinearScale(LinearDomain(x0, x1), this.range);\n  };\n\n  LinearScale.prototype.solveDomain = function (x1: number, y1: number, x2?: number, y2?: number,\n                                                reflect?: boolean, epsilon?: number): LinearScale {\n    if (epsilon === void 0) {\n      epsilon = Equivalent.Epsilon;\n    }\n    const dx = this.domain[1] - this.domain[0];\n    const y0 = this.range[0];\n    const y3 = this.range[1];\n    let m: number;\n    if (x2 === void 0 || y2 === void 0 || Math.abs(x2 - x1) < epsilon || Math.abs(y2 - y1) < epsilon) {\n      m = (y3 - y0) / (dx !== 0 ? dx : epsilon);\n    } else {\n      m = (y2 - y1) / (x2 - x1);\n      if ((reflect === void 0 || !reflect) && (m < 0 !== (y3 - y0) / dx < 0)) {\n        m = -m;\n      }\n    }\n    const b = y1 - m * x1;\n    const x0 = (y0 - b) / m;\n    const x3 = (y3 - b) / m;\n\n    if (Math.abs(x0 - this.domain[0]) < epsilon && Math.abs(x3 - this.domain[1]) < epsilon) {\n      return this;\n    }\n    return LinearScale(LinearDomain(x0, x3), this.range);\n  };\n\n  LinearScale.prototype.interpolateTo = function (this: LinearScale, that: unknown): Interpolator<LinearScale> | null {\n    if (that instanceof LinearScale) {\n      return LinearScaleInterpolator(this, that);\n    }\n    return null;\n  } as typeof LinearScale.prototype.interpolateTo;\n\n  LinearScale.prototype.canEqual = function (that: unknown): boolean {\n    return that instanceof LinearScale;\n  };\n\n  LinearScale.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof LinearScale) {\n      return this.domain.equals(that.domain) && this.range.equals(that.range);\n    }\n    return false;\n  };\n\n  LinearScale.prototype.toString = function (): string {\n    return \"LinearScale(\" + this.domain + \", \" + this.range + \")\";\n  };\n\n  return LinearScale;\n})(ContinuousScale);\n\n/** @internal */\nexport const LinearScaleInterpolator = (function (_super: typeof Interpolator) {\n  const LinearScaleInterpolator = function (s0: LinearScale, s1: LinearScale): Interpolator<LinearScale> {\n    const interpolator = function (u: number): LinearScale {\n      const s0 = interpolator[0];\n      const s1 = interpolator[1];\n      const x0 = s0.domain;\n      const x00 = x0[0];\n      const x01 = x0[1];\n      const x1 = s1.domain;\n      const x10 = x1[0];\n      const x11 = x1[1];\n      const domain = LinearDomain(x00 + u * (x10 - x00), x01 + u * (x11 - x01));\n      const y0 = s0.range;\n      const y00 = y0[0];\n      const y01 = y0[1];\n      const y1 = s1.range;\n      const y10 = y1[0];\n      const y11 = y1[1];\n      const range = LinearRange(y00 + u * (y10 - y00), y01 + u * (y11 - y01));\n      return LinearScale(domain, range);\n    } as Interpolator<LinearScale>;\n    Object.setPrototypeOf(interpolator, LinearScaleInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = s0;\n    (interpolator as Mutable<typeof interpolator>)[1] = s1;\n    return interpolator;\n  } as {\n    (s0: LinearScale, s1: LinearScale): Interpolator<LinearScale>;\n\n    /** @internal */\n    prototype: Interpolator<LinearScale>;\n  };\n\n  LinearScaleInterpolator.prototype = Object.create(_super.prototype);\n  LinearScaleInterpolator.prototype.constructor = LinearScaleInterpolator;\n\n  return LinearScaleInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Values} from \"./Values\";\n\n/**\n * Exception thrown when an [[Assert]] fails.\n * @public\n */\nexport class AssertException extends Error {\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, AssertException.prototype);\n  }\n}\n\n/**\n * Callable [[Assert]] interface.\n *\n * @public\n */\nexport interface AssertFunction extends Assert {\n  /**\n   * Asserts that `condition` is truthy.\n   *\n   * @throws [[AssertException]] with `message` if `condition` is falsy.\n   */\n  (condition: unknown, message?: string): void;\n}\n\n/**\n * Type that implements common assertion functions.\n * @public\n */\nexport interface Assert {\n  /**\n   * Asserts that `condition` is truthy.\n   *\n   * @throws [[AssertException]] with `message` if `condition` is falsy.\n   */\n  ok(condition: unknown, message?: string): void;\n\n  /**\n   * Asserts that `condition` is falsy.\n   *\n   * @throws [[AssertException]] with `message` if `condition` is truthy.\n   */\n  notOk(condition: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` is identical (`===`) to `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` is not identical (`!==`) to `rhs`.\n   */\n  identical(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` is not identical (`!==`) to `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` is identical (`===`) to `rhs`.\n   */\n  notIdentical(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` is less than (`<`) `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` is not less than (`!<`) `rhs`.\n   */\n  lessThan(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` is less than or equal (`<=`) to `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` is not less than or equal (`!<=`) to `rhs`.\n   */\n  lessThanOrEqual(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` is greater than (`>`) `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` is not greater than (`!>`) `rhs`.\n   */\n  greaterThan(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` is greater than or equal (`>=`) to `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` is not greater than or equal (`!>=`) to `rhs`.\n   */\n  greaterThanOrEqual(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` is not less than (`!<`) `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` is less than (`<`) `rhs`.\n   */\n  notLessThan(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` is not less than or equal (`!<=`) to `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` is less than or equal (`<=`) to `rhs`.\n   */\n  notLessThanOrEqual(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` is not greater than (`!>`) `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` is greater than (`>`) `rhs`.\n   */\n  notGreaterThan(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` is not greater than or equal (`!>=`) to `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` is greater than or equal (`>=`) to `rhs`.\n   */\n  notGreaterThanOrEqual(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `object` has the prototype of `constructor` in its prototype chain.\n   *\n   * @throws [[AssertException]] with `message` if `object` does not have the prototype of `constructor` in its prototype chain.\n   */\n  instanceOf(object: unknown, constructor: Function, message?: string): void;\n\n  /**\n   * Asserts that `object` does not have the prototype of `constructor` in its prototype chain.\n   *\n   * @throws [[AssertException]] with `message` if `object` does have the prototype of `constructor` in its prototype chain.\n   */\n  notInstanceOf(object: unknown, constructor: Function, message?: string): void;\n\n  /**\n   * Asserts that `lhs` is [[Values.equal structurally equal]] to `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` is not structurally equal to `rhs`.\n   */\n  equal(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` is not [[Values.equal structurally equal]] to `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` is structurally equal to `rhs`.\n   */\n  notEqual(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` is [[Values.equivalent structurally equivalent]] to `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` is not structurally equivalent to `rhs`.\n   */\n  equivalent(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` is not [[Values.equivalent structurally equivalent]] to `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` is structurally equivalent to `rhs`.\n   */\n  notEquivalent(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` [[Values.compare structurally orders before]] `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` does not structurally order before `rhs`.\n   */\n  compareLessThan(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` does not [[Values.compare structurally order before]] `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` does structurally order before `rhs`.\n   */\n  compareNotLessThan(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` [[Values.compare structurally orders before or the same as]] `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` does not structurally order before or the same as `rhs`.\n   */\n  compareLessThanOrEqual(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` does not [[Values.compare structurally order before or the same as]] `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` does structurally order before or the same as `rhs`.\n   */\n  compareNotLessThanOrEqual(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` [[Values.compare structurally orders the same as]] `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` does not structurally order before or the same as `rhs`.\n   */\n  compareEqual(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` does not [[Values.compare structurally order the same as]] `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` does structurally order before or the same as `rhs`.\n   */\n  compareNotEqual(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` [[Values.compare structurally orders after or the same as]] `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` does not structurally order after or the same as `rhs`.\n   */\n  compareGreaterThanOrEqual(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` does not [[Values.compare structurally order after or the same as]] `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` does structurally order after or the same as `rhs`.\n   */\n  compareNotGreaterThanOrEqual(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` [[Values.compare structurally orders after]] `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` does not structurally order after `rhs`.\n   */\n  compareGreaterThan(lhs: unknown, rhs: unknown, message?: string): void;\n\n  /**\n   * Asserts that `lhs` does not [[Values.compare structurally order after]] `rhs`.\n   *\n   * @throws [[AssertException]] with `message` if `lhs` does structurally order after `rhs`.\n   */\n  compareNotGreaterThan(lhs: unknown, rhs: unknown, message?: string): void;\n}\n\n/** @public */\nexport const Assert = (function () {\n  const Assert = function (condition: unknown, message?: string): void {\n    if (!condition) {\n      throw new AssertException(message);\n    }\n  } as AssertFunction;\n\n  Assert.ok = function (condition: unknown, message?: string): void {\n    if (!condition) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.notOk = function (condition: unknown, message?: string): void {\n    if (condition) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.equal = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (!Values.equal(lhs, rhs)) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.notEqual = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (Values.equal(lhs, rhs)) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.identical = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (lhs !== rhs) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.notIdentical = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (lhs === rhs) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.lessThan = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (!((lhs as any) < (rhs as any))) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.lessThanOrEqual = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (!((lhs as any) <= (rhs as any))) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.greaterThan = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (!((lhs as any) > (rhs as any))) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.greaterThanOrEqual = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (!((lhs as any) >= (rhs as any))) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.notLessThan = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if ((lhs as any) < (rhs as any)) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.notLessThanOrEqual = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if ((lhs as any) <= (rhs as any)) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.notGreaterThan = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if ((lhs as any) > (rhs as any)) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.notGreaterThanOrEqual = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if ((lhs as any) >= (rhs as any)) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.instanceOf = function (object: unknown, constructor: Function, message?: string): void {\n    if (!(object instanceof constructor)) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.notInstanceOf = function (object: unknown, constructor: Function, message?: string): void {\n    if (object instanceof constructor) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.compareLessThan = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (!(Values.compare(lhs, rhs) < 0)) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.compareNotLessThan = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (Values.compare(lhs, rhs) < 0) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.compareLessThanOrEqual = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (!(Values.compare(lhs, rhs) <= 0)) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.compareNotLessThanOrEqual = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (Values.compare(lhs, rhs) <= 0) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.compareEqual = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (!(Values.compare(lhs, rhs) === 0)) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.compareNotEqual = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (Values.compare(lhs, rhs) === 0) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.compareGreaterThanOrEqual = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (!(Values.compare(lhs, rhs) >= 0)) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.compareNotGreaterThanOrEqual = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (Values.compare(lhs, rhs) >= 0) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.compareGreaterThan = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (!(Values.compare(lhs, rhs) > 0)) {\n      throw new AssertException(message);\n    }\n  };\n\n  Assert.compareNotGreaterThan = function (lhs: unknown, rhs: unknown, message?: string): void {\n    if (Values.compare(lhs, rhs) > 0) {\n      throw new AssertException(message);\n    }\n  };\n\n  return Assert;\n})();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"./Murmur3\";\nimport type {HashCode} from \"./HashCode\";\nimport type {Compare} from \"./Compare\";\nimport {Numbers} from \"./Numbers\";\nimport {Strings} from \"./Strings\";\nimport {Constructors} from \"./Constructors\";\n\n/**\n * Level of importance. Used for log levels and diagnostic classifications.\n * @public\n */\nexport class Severity implements HashCode, Compare {\n  /** @internal */\n  constructor(level: number, label: string) {\n    this.level = level;\n    this.label = label;\n  }\n\n  /**\n   * The integer level of importance of this `Severity`, with higher  levels\n   * signifying greater importance. An integer between `0` and `7`, inclusive.\n   * One of `TraceLevel`, `DebugLevel`, `InfoLevel`, `NoteLevel`,\n   * `WarningLevel`, `ErrorLevel`, `AlertLevel`, `FatalLevel`.\n   */\n  readonly level: number;\n\n  /**\n   * A descriptive label for this `Severity`.\n   */\n  readonly label: string;\n\n  /**\n   * Returns `true` if this `Severity` has `TraceLevel` of importance.\n   */\n  isTrace(): boolean {\n    return this.level === Severity.TraceLevel;\n  }\n\n  /**\n   * Returns `true` if this `Severity` has `DebugLevel` of importance.\n   */\n  isDebug(): boolean {\n    return this.level === Severity.DebugLevel;\n  }\n\n  /**\n   * Returns `true` if this `Severity` has `InfoLevel` of importance.\n   */\n  isInfo(): boolean {\n    return this.level === Severity.InfoLevel;\n  }\n\n  /**\n   * Returns `true` if this `Severity` has `NoteLevel` of importance.\n   */\n  isNote(): boolean {\n    return this.level === Severity.NoteLevel;\n  }\n\n  /**\n   * Returns `true` if this `Severity` has `WarningLevel` of importance.\n   */\n  isWarning(): boolean {\n    return this.level === Severity.WarningLevel;\n  }\n\n  /**\n   * Returns `true` if this `Severity` has `ErrorLevel` of importance.\n   */\n  isError(): boolean {\n    return this.level === Severity.ErrorLevel;\n  }\n\n  /**\n   * Returns `true` if this `Severity` has `AlertLevel` of importance.\n   */\n  isAlert(): boolean {\n    return this.level === Severity.AlertLevel;\n  }\n\n  /**\n   * Returns `true` if this `Severity` has `FatalLevel` of importance.\n   */\n  isFatal(): boolean {\n    return this.level === Severity.FatalLevel;\n  }\n\n  compareTo(that: unknown): number {\n    if (this === that) {\n      return 0;\n    } else if (that instanceof Severity) {\n      if (this.level < that.level) {\n        return -1;\n      } else if (this.level > that.level) {\n        return 1;\n      }\n      return this.label.localeCompare(that.label);\n    }\n    return NaN;\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Severity) {\n      return this.level === that.level && this.label === that.label;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(Severity),\n        Numbers.hash(this.level)), Strings.hash(this.label)));\n  }\n\n  toString(): string {\n    return this.label;\n  }\n\n  static readonly TraceLevel: number = 0;\n  static readonly DebugLevel: number = 1;\n  static readonly InfoLevel: number = 2;\n  static readonly NoteLevel: number = 3;\n  static readonly WarningLevel: number = 4;\n  static readonly ErrorLevel: number = 5;\n  static readonly AlertLevel: number = 6;\n  static readonly FatalLevel: number = 7;\n\n  static readonly TraceLabel: string = \"trace\";\n  static readonly DebugLabel: string = \"debug\";\n  static readonly InfoLabel: string = \"info\";\n  static readonly NoteLabel: string = \"note\";\n  static readonly WarningLabel: string = \"warning\";\n  static readonly ErrorLabel: string = \"error\";\n  static readonly AlertLabel: string = \"alert\";\n  static readonly FatalLabel: string = \"fatal\";\n\n  /** @internal */\n  static Trace: Severity | null = null;\n  /** @internal */\n  static Debug: Severity | null = null;\n  /** @internal */\n  static Info: Severity | null = null;\n  /** @internal */\n  static Note: Severity | null = null;\n  /** @internal */\n  static Warning: Severity | null = null;\n  /** @internal */\n  static Error: Severity | null = null;\n  /** @internal */\n  static Alert: Severity | null = null;\n  /** @internal */\n  static Fatal: Severity | null = null;\n\n  /**\n   * Returns a `Severity` with the given importance `level`, and optional\n   * descriptive `label`.\n   *\n   * @throws `Error` if `level` is not a valid level of importance.\n   */\n  static create(level: number, label?: string): Severity {\n    switch (level) {\n      case this.TraceLevel:\n        return this.trace(label);\n      case this.DebugLevel:\n        return this.debug(label);\n      case this.InfoLevel:\n        return this.info(label);\n      case this.NoteLevel:\n        return this.note(label);\n      case this.WarningLevel:\n        return this.warning(label);\n      case this.ErrorLevel:\n        return this.error(label);\n      case this.AlertLevel:\n        return this.alert(label);\n      case this.FatalLevel:\n        return this.fatal(label);\n      default:\n        throw new Error(\"\" + level);\n    }\n  }\n\n  /**\n   * Returns a `Severity` with `TraceLevel` of importance, and an optional\n   * descriptive `label`.\n   */\n  static trace(label?: string): Severity {\n    if (label === void 0 || label === this.TraceLabel) {\n      if (this.Trace === null) {\n        this.Trace = new Severity(this.TraceLevel, this.TraceLabel);\n      }\n      return this.Trace;\n    }\n    return new Severity(this.TraceLevel, label);\n  }\n\n  /**\n   * Returns a `Severity` with `DebugLevel` of importance, and an optional\n   * descriptive `label`.\n   */\n  static debug(label?: string): Severity {\n    if (label === void 0 || label === this.DebugLabel) {\n      if (this.Debug === null) {\n        this.Debug = new Severity(this.DebugLevel, this.DebugLabel);\n      }\n      return this.Debug;\n    }\n    return new Severity(this.DebugLevel, label);\n  }\n\n  /**\n   * Returns a `Severity` with `InfoLevel` of importance, and an optional\n   * descriptive `label`.\n   */\n  static info(label?: string): Severity {\n    if (label === void 0 || label === this.InfoLabel) {\n      if (this.Info === null) {\n        this.Info = new Severity(this.InfoLevel, this.InfoLabel);\n      }\n      return this.Info;\n    }\n    return new Severity(this.InfoLevel, label);\n  }\n\n  /**\n   * Returns a `Severity` with `NoteLevel` of importance, and an optional\n   * descriptive `label`.\n   */\n  static note(label?: string): Severity {\n    if (label === void 0 || label === this.NoteLabel) {\n      if (this.Note === null) {\n        this.Note = new Severity(this.NoteLevel, this.NoteLabel);\n      }\n      return this.Note;\n    }\n    return new Severity(this.NoteLevel, label);\n  }\n\n  /**\n   * Returns a `Severity` with `WarningLevel` of importance, and an optional\n   * descriptive `label`.\n   */\n  static warning(label?: string): Severity {\n    if (label === void 0 || label === this.WarningLabel) {\n      if (this.Warning === null) {\n        this.Warning = new Severity(this.WarningLevel, this.WarningLabel);\n      }\n      return this.Warning;\n    }\n    return new Severity(this.WarningLevel, label);\n  }\n\n  /**\n   * Returns a `Severity` with `ErrorLevel` of importance, and an optional\n   * descriptive `label`.\n   */\n  static error(label?: string): Severity {\n    if (label === void 0 || label === this.ErrorLabel) {\n      if (this.Error === null) {\n        this.Error = new Severity(this.ErrorLevel, this.ErrorLabel);\n      }\n      return this.Error;\n    }\n    return new Severity(this.ErrorLevel, label);\n  }\n\n  /**\n   * Returns a `Severity` with `AlertLevel` of importance, and an optional\n   * descriptive `label`.\n   */\n  static alert(label?: string): Severity {\n    if (label === void 0 || label === this.AlertLabel) {\n      if (this.Alert === null) {\n        this.Alert = new Severity(this.AlertLevel, this.AlertLabel);\n      }\n      return this.Alert;\n    }\n    return new Severity(this.AlertLevel, label);\n  }\n\n  /**\n   * Returns a `Severity` with `FatalLevel` of importance, and an optional\n   * descriptive `label`.\n   */\n  static fatal(label?: string): Severity {\n    if (label === void 0 || label === this.FatalLabel) {\n      if (this.Fatal === null) {\n        this.Fatal = new Severity(this.FatalLevel, this.FatalLabel);\n      }\n      return this.Fatal;\n    }\n    return new Severity(this.FatalLevel, label);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {HashCode} from \"@swim/util\";\nimport type {Mark} from \"./Mark\";\nimport type {Output} from \"../output/Output\";\nimport type {Display} from \"../format/Display\";\nimport type {Debug} from \"../format/Debug\";\n\n/**\n * Description of a source location. Tags are used to annotate input sources,\n * particularly for [[Diagnostic diagnostic]] purposes. A [[Mark]] tag\n * annotates a source position. A [[Span]] tag annotate a source range.\n *\n * @see [[Diagnostic]]\n * @public\n */\nexport abstract class Tag implements HashCode, Display, Debug {\n  /**\n   * The first source position covered by this `Tag`.\n   */\n  abstract readonly start: Mark;\n\n  /**\n   * The last source position covered by this `Tag`.\n   */\n  abstract readonly end: Mark;\n\n  /**\n   * Returns a `Tag` that includes all source locations covered by\n   * both this tag, and `that` tag.\n   */\n  abstract union(that: Tag): Tag;\n\n  /**\n   * Returns the position of this `Tag` relative to the given `mark`.\n   */\n  abstract shift(mark: Mark): Tag;\n\n  abstract display<T>(output: Output<T>): Output<T>;\n\n  abstract debug<T>(output: Output<T>): Output<T>;\n\n  abstract equals(that: unknown): boolean;\n\n  abstract hashCode(): number;\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Strings} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Tag} from \"./Tag\";\nimport {Span} from \"../\"; // forward import\nimport type {Output} from \"../output/Output\";\nimport {Format} from \"../\"; // forward import\n\n/**\n * Description of a source position, identified by byte offset, line, and\n * column number, with an optional note.\n * @public\n */\nexport class Mark extends Tag {\n  /** @internal */\n  constructor(offset: number, line: number, column: number, note: string | undefined) {\n    super();\n    this.offset = offset;\n    this.line = line;\n    this.column = column;\n    this.note = note;\n  }\n\n  /**\n   * The zero-based byte offset of this position.\n   */\n  readonly offset: number;\n\n  /**\n   * The one-based line number of this position.\n   */\n  readonly line: number;\n\n  /**\n   * The one-based column number of this position.\n   */\n  readonly column: number;\n\n  /**\n   * The note attached to the marked position, or `null` if this position has\n   * no attached note.\n   */\n  readonly note: string | undefined;\n\n  withNote(note: string | undefined): Mark {\n    if (this.note !== note) {\n      return Mark.at(this.offset, this.line, this.column, note);\n    } else {\n      return this;\n    }\n  }\n\n  /**\n   * Returns this position, if its byte offset is less than or equal to\n   * `that` position; otherwise returns `that` position.\n   */\n  min(that: Mark): Mark {\n    return this.offset <= that.offset ? this : that;\n  }\n\n  /**\n   * Returns this position, if its byte offset is greater than or equal to\n   * `that` position; otherwise returns `that` position.\n   */\n  max(that: Mark): Mark {\n    return this.offset >= that.offset ? this : that;\n  }\n\n  override get start(): Mark {\n    return this;\n  }\n\n  override get end(): Mark {\n    return this;\n  }\n\n  override union(that: Tag): Tag {\n    if (that instanceof Mark) {\n      if (this.offset === that.offset && this.line === that.line\n          && this.column === that.column) {\n        return this;\n      } else {\n        return Span.from(this, that);\n      }\n    } else if (that instanceof Span) {\n      const start = this.min(that.start);\n      const end = this.max(that.end);\n      if (start === that.start && end === that.end) {\n        return that;\n      } else {\n        return Span.from(start, end);\n      }\n    }\n    throw new Error(that.toString());\n  }\n\n  override shift(mark: Mark): Mark {\n    const offset = this.offset + (this.offset - mark.offset);\n    const line = this.line + (this.line - mark.line);\n    let column = this.column;\n    if (line === 1) {\n      column += (this.column - mark.column);\n    }\n    if (offset === this.offset && line === this.line && column === this.column) {\n      return this;\n    } else {\n      return Mark.at(offset, line, column, this.note);\n    }\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Mark) {\n      return this.offset === that.offset && this.line === that.line\n          && this.column === that.column && this.note === that.note;\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(Constructors.hash(Mark),\n        Numbers.hash(this.offset)), Numbers.hash(this.line)), Numbers.hash(this.column)),\n        Strings.hash(this.note)));\n  }\n\n  override display<T>(output: Output<T>): Output<T> {\n    output = Format.displayNumber(output, this.line);\n    output = output.write(58/*':'*/);\n    output = Format.displayNumber(output, this.column);\n    if (this.note !== void 0) {\n      output = output.write(58/*':'*/).write(32/*' '*/).write(this.note);\n    }\n    return output;\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Mark\").write(\".\").write(\"at\").write(\"(\");\n    output = Format.debugNumber(output, this.offset);\n    output = output.write(\", \");\n    output = Format.debugNumber(output, this.line);\n    output = output.write(\", \");\n    output = Format.debugNumber(output, this.column);\n    if (this.note !== void 0) {\n      output = output.write(\", \");\n      output = Format.debugString(output, this.note);\n    }\n    output = output.write(\")\");\n    return output;\n  }\n\n  override toString(): string {\n    return Format.display(this);\n  }\n\n  /**\n   * Returns a `Mark` at byte offset `0`, line `1`, and column `1`, with no\n   * attached note.\n   */\n  @Lazy\n  static get zero(): Mark {\n    return new Mark(0, 1, 1, void 0);\n  }\n\n  /**\n   * Returns a new `Mark` at the given zero-based byte `offset`, one-based\n   * `line` number, and one-based `column` number, with an optionally attached\n   * `note`.\n   */\n  static at(offset: number, line: number, column: number, note?: string | undefined): Mark {\n    return new Mark(offset, line, column, note);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Tag} from \"./Tag\";\nimport {Mark} from \"./Mark\";\nimport type {Output} from \"../output/Output\";\nimport {Format} from \"../\"; // forward import\n\n/**\n * Description of a source range, identified by a closed interval between start\n * and end [[Mark marks]].\n * @public\n */\nexport class Span extends Tag {\n  /** @internal */\n  constructor(start: Mark, end: Mark) {\n    super();\n    this.start = start;\n    this.end = end;\n  }\n\n  override readonly start: Mark;\n\n  override readonly end: Mark;\n\n  override union(that: Tag): Tag {\n    if (that instanceof Mark) {\n      const start = this.start.min(that);\n      const end = this.end.max(that);\n      if (start === this.start && end === this.end) {\n        return this;\n      } else {\n        return Span.from(start, end);\n      }\n    } else if (that instanceof Span) {\n      const start = this.start.min(that.start);\n      const end = this.end.max(that.end);\n      if (start === this.start && end === this.end) {\n        return this;\n      } else {\n        return Span.from(start, end);\n      }\n    }\n    throw new Error(that.toString());\n  }\n\n  override shift(mark: Mark): Span {\n    const start = this.start.shift(mark);\n    const end = this.end.shift(mark);\n    if (start === this.start && end === this.end) {\n      return this;\n    } else {\n      return Span.from(start, end);\n    }\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Span) {\n      return this.start.equals(that.start) && this.end.equals(that.end);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(Span),\n        this.start.hashCode()), this.end.hashCode()));\n  }\n\n  override display<T>(output: Output<T>): Output<T> {\n    if (this.start.note !== void 0) {\n      output = output.write(this.start.note).write(58/*':'*/).write(32/*' '*/);\n    }\n    output = Format.displayNumber(output, this.start.line);\n    output = output.write(58/*':'*/);\n    output = Format.displayNumber(output, this.start.column);\n    output = output.write(45/*'-'*/);\n    output = Format.displayNumber(output, this.end.line);\n    output = output.write(58/*':'*/);\n    output = Format.displayNumber(output, this.end.column);\n    if (this.end.note !== void 0) {\n      output = output.write(58/*':'*/).write(32/*' '*/).write(this.end.note);\n    }\n    return output;\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Span\").write(\".\").write(\"from\").write(\"(\");\n    output = this.start.debug(output);\n    output = output.write(\", \");\n    output = this.end.debug(output);\n    output = output.write(\")\");\n    return output;\n  }\n\n  override toString(): string {\n    return Format.display(this);\n  }\n\n  /**\n   * Returns a new `Span` representing the closed interval between the given\n   * `start` and `end` marks.\n   */\n  static from(start: Mark, end: Mark): Span {\n    if (start.offset > end.offset) {\n      const tmp = start;\n      start = end;\n      end = tmp;\n    }\n    return new Span(start, end);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"../output/Output\";\n\n/**\n * Stylized text output utility functions.\n * @public\n */\nexport const OutputStyle = (function () {\n  const OutputStyle = {} as {\n    /**\n     * Writes the ASCII reset escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    reset<T>(output: Output<T>): Output<T>\n\n    /**\n     * Writes the ASCII bold (increased intensity) escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    bold<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII faint (decreased intensity) escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    faint<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII black foreground color escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    black<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII red foreground color escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    red<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII green foreground color escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    green<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII yellow foreground color escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    yellow<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII blue foreground color escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    blue<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII magenta foreground color escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    magenta<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII cyan foreground color escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    cyan<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII gray foreground color escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    gray<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII bold black foreground color escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    blackBold<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII bold red foreground color escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    redBold<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII bold green foreground color escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    greenBold<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII bold yellow foreground color escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    yellowBold<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII bold blue foreground color escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    blueBold<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII bold magenta foreground color escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    magentaBold<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII bold cyan foreground color escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    cyanBold<T>(output: Output<T>): Output<T>;\n\n    /**\n     * Writes the ASCII bold gray foreground color escape code to `output`,\n     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    grayBold<T>(output: Output<T>): Output<T>;\n  };\n\n  OutputStyle.reset = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.bold = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.faint = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(50/*'2'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.black = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(59/*';'*/)\n                     .write(51/*'3'*/).write(48/*'0'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.red = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(59/*';'*/)\n                     .write(51/*'3'*/).write(49/*'1'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.green = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(59/*';'*/)\n                     .write(51/*'3'*/).write(50/*'2'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.yellow = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(59/*';'*/)\n                     .write(51/*'3'*/).write(51/*'3'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.blue = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(59/*';'*/)\n                     .write(51/*'3'*/).write(52/*'4'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.magenta = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(59/*';'*/)\n                     .write(51/*'3'*/).write(53/*'5'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.cyan = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(59/*';'*/)\n                     .write(51/*'3'*/).write(54/*'6'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.gray = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(59/*';'*/)\n                     .write(51/*'3'*/).write(55/*'7'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.blackBold = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(59/*';'*/)\n                     .write(51/*'3'*/).write(48/*'0'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.redBold = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(59/*';'*/)\n                     .write(51/*'3'*/).write(49/*'1'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.greenBold = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(59/*';'*/)\n                     .write(51/*'3'*/).write(50/*'2'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.yellowBold = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(59/*';'*/)\n                     .write(51/*'3'*/).write(51/*'3'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.blueBold = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(59/*';'*/)\n                     .write(51/*'3'*/).write(52/*'4'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.magentaBold = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(59/*';'*/)\n                     .write(51/*'3'*/).write(53/*'5'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.cyanBold = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(59/*';'*/)\n                     .write(51/*'3'*/).write(54/*'6'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  OutputStyle.grayBold = function <T>(output: Output<T>): Output<T> {\n    if (output.settings.isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(59/*';'*/)\n                     .write(51/*'3'*/).write(55/*'7'*/).write(109/*'m'*/);\n    }\n    return output;\n  };\n\n  return OutputStyle;\n})();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport {Booleans} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Strings} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"../output/Output\";\nimport type {Debug} from \"../format/Debug\";\nimport {Format} from \"../format/Format\";\n\n/**\n * Either an [[OutputSettings]] instance, or an [[OutputSettingsInit]] object\n * initializer.\n * @public\n */\nexport type OutputSettingsLike = OutputSettings | OutputSettingsInit;\n\n/**\n * [[OutputSettings]] object initializer.\n * @public\n */\nexport interface OutputSettingsInit {\n  lineSeparator?: string;\n  isPretty?: boolean;\n  isStyled?: boolean;\n  precision?: number;\n}\n\n/**\n * [[Output]] production parameters. `OutputSettings` provide contextual\n * configuration parameters to output producers, such as [[Writer Writers]].\n * Uses include enabling pretty printing and styling generated output.\n * Subclasses can provide additional parameters understood by specialized\n * output producers.\n * @public\n */\nexport class OutputSettings implements Debug, HashCode {\n  protected constructor(lineSeparator: string, pretty: boolean,\n                        styled: boolean, precision: number) {\n    Object.defineProperty(this, \"lineSeparator\", {\n      value: lineSeparator,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"pretty\", {\n      value: pretty,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"styled\", {\n      value: styled,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"precision\", {\n      value: precision,\n      enumerable: true,\n    });\n  }\n\n  /**\n   * The Unicode code point sequence used to separate lines of text.\n   * Defaults to the runtime operating system's line separator.\n   */\n  readonly lineSeparator!: string;\n\n  /**\n   * Returns a copy of these settings with the given `lineSeparator`.\n   */\n  withLineSeparator(lineSeparator: string | undefined): string | OutputSettings {\n    return this.copy(lineSeparator, this.pretty, this.styled, this.precision);\n  }\n\n  /** @internal */\n  readonly pretty!: boolean;\n\n  /**\n   * Returns `true` if output producers should pretty print their output,\n   * when possible.\n   */\n  isPretty(): boolean {\n    return this.pretty;\n  }\n\n  /**\n   * Returns a copy of these settings with the given `pretty` flag.\n   */\n  asPretty(pretty: boolean): OutputSettings {\n    return this.copy(this.lineSeparator, pretty, this.styled, this.precision);\n  }\n\n  /** @internal */\n  readonly styled!: boolean;\n\n  /**\n   * Returns `true` if output producers should style their output,\n   * when possible.\n   */\n  isStyled(): boolean {\n    return this.styled;\n  }\n\n  /**\n   * Returns a copy of these settings with the given `styled` flag.\n   */\n  asStyled(styled: boolean): OutputSettings {\n    return this.copy(this.lineSeparator, this.pretty, styled, this.precision);\n  }\n\n  /**\n   * Returns the numeric precision output producers should use\n   * when formatting numbers.\n   */\n  readonly precision!: number;\n\n  /**\n   * Returns a copy of these settings with the given numeric `precision`.\n   */\n  withPrecision(precision: number): OutputSettings {\n    return this.copy(this.lineSeparator, this.pretty, this.styled, precision);\n  }\n\n  protected copy(lineSeparator: string | undefined, pretty: boolean,\n                 styled: boolean, precision: number): OutputSettings {\n    return OutputSettings.create(lineSeparator, pretty, styled, precision);\n  }\n\n  protected canEqual(that: unknown): boolean {\n    return that instanceof OutputSettings;\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof OutputSettings) {\n      return that.canEqual(this) && this.lineSeparator === that.lineSeparator\n          && this.pretty === that.pretty && this.styled === that.styled\n          && this.precision === that.precision;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(\n        Constructors.hash(OutputSettings), Strings.hash(this.lineSeparator)),\n        Booleans.hash(this.pretty)), Booleans.hash(this.styled)),\n        Numbers.hash(this.precision)));\n  }\n\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"OutputSettings\").write(46/*'.'*/);\n    if (!this.pretty && !this.styled) {\n      output = output.write(\"standard\");\n    } else if (this.pretty && !this.styled) {\n      output = output.write(\"pretty\");\n    } else if (!this.pretty && this.styled) {\n      output = output.write(\"styled\");\n    } else {\n      output = output.write(\"prettyStyled\");\n    }\n    output = output.write(40/*'('*/).write(41/*')'*/);\n    if (this.lineSeparator !== Format.lineSeparator) {\n      output = output.write(46/*'.'*/).write(\"lineSeparator\").write(40/*'('*/)\n                     .display(this.lineSeparator).write(41/*')'*/);\n    }\n    if (this.precision !== -1) {\n      output = output.write(46/*'.'*/).write(\"precision\").write(40/*'('*/)\n                     .display(this.precision).write(41/*')'*/);\n    }\n    return output;\n  }\n\n  toString(): string {\n    return Format.debug(this);\n  }\n\n  /**\n   * Returns `OutputSettings` configured with the system line separator,\n   * pretty printing disabled, and styling disabled.\n   */\n  @Lazy\n  static standard(): OutputSettings {\n    return new OutputSettings(Format.lineSeparator, false, false, -1);\n  }\n\n  /**\n   * Returns `OutputSettings` configured with the system line separator,\n   * pretty printing enabled, and styling disabled.\n   */\n  @Lazy\n  static pretty(): OutputSettings {\n    return new OutputSettings(Format.lineSeparator, true, false, -1);\n  }\n\n  /**\n   * Returns `OutputSettings` configured with the system line separator,\n   * pretty printing disabled, and styling enabled.\n   */\n  @Lazy\n  static styled(): OutputSettings {\n    return new OutputSettings(Format.lineSeparator, false, true, -1);\n  }\n\n  /**\n   * Returns `OutputSettings` configured with the system line separator,\n   * pretty printing enabled, and styling enabled.\n   */\n  @Lazy\n  static prettyStyled(): OutputSettings {\n    return new OutputSettings(Format.lineSeparator, true, true, -1);\n  }\n\n  /**\n   * Returns `OutputSettings` configured with the given `lineSeparator`, pretty\n   * printing enabled if `isPretty` is `true`, styling enabled if `isStyled`\n   * is `true`, and with the given numeric `precision`.\n   */\n  static create(lineSeparator?: string, pretty?: boolean,\n                styled?: boolean, precision?: number): OutputSettings {\n    if (typeof lineSeparator !== \"string\") {\n      lineSeparator = Format.lineSeparator;\n    }\n    if (typeof pretty !== \"boolean\") {\n      pretty = false;\n    }\n    if (typeof styled !== \"boolean\") {\n      styled = false;\n    }\n    if (typeof precision !== \"number\") {\n      precision = -1;\n    }\n    if (lineSeparator === Format.lineSeparator && precision === -1) {\n      if (!pretty && !styled) {\n        return OutputSettings.standard();\n      } else if (pretty && !styled) {\n        return OutputSettings.pretty();\n      } else if (!pretty && styled) {\n        return OutputSettings.styled();\n      } else {\n        return OutputSettings.prettyStyled();\n      }\n    }\n    return new OutputSettings(lineSeparator, pretty, styled, precision);\n  }\n\n  /**\n   * Converts a settings `init` object to an instance of `OutputSettings`.\n   */\n  static fromInit(init: OutputSettingsInit): OutputSettings {\n    return OutputSettings.create(init.lineSeparator, init.isPretty,\n                                 init.isStyled, init.precision);\n  }\n\n  /**\n   * Converts a loosely typed settings `value` to an instance of `OutputSettings`.\n   */\n  static fromLike(value: OutputSettingsLike | undefined): OutputSettings {\n    if (value instanceof OutputSettings) {\n      return value;\n    } else if (typeof value === \"object\" && value !== null) {\n      return OutputSettings.fromInit(value);\n    }\n    return OutputSettings.standard();\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Thrown when reading invalid [[Input]].\n * @public\n */\nexport class InputException extends Error {\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, InputException.prototype);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport {Booleans} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"../output/Output\";\nimport type {Debug} from \"../format/Debug\";\nimport {Format} from \"../format/Format\";\n\n/**\n * Either an [[InputSettings]] instance, or an [[InputSettingsInit]] object\n * initializer.\n * @public\n */\nexport type InputSettingsLike = InputSettings | InputSettingsInit;\n\n/**\n * [[InputSettings]] object initializer.\n * @public\n */\nexport interface InputSettingsInit {\n  isStripped?: boolean;\n}\n\n/**\n * [[Input]] consumption parameters. `InputSettings` provide contextual\n * configuration parameters to input consumers, such as [[Parser Parsers]].\n * @public\n */\nexport class InputSettings implements HashCode, Debug {\n  protected constructor(stripped: boolean) {\n    Object.defineProperty(this, \"stripped\", {\n      value: stripped,\n      enumerable: true,\n    });\n  }\n\n  /** @internal */\n  readonly stripped!: boolean;\n\n  /**\n   * Returns `true` if input consumers should not include diagnostic metadata\n   * in generated output.\n   */\n  isStripped(): boolean {\n    return this.stripped;\n  }\n\n  /**\n   * Returns a copy of these settings with the given `stripped` flag.\n   */\n  asStripped(stripped: boolean): InputSettings {\n    return this.copy(stripped);\n  }\n\n  protected copy(stripped: boolean): InputSettings {\n    return InputSettings.create(stripped);\n  }\n\n  protected canEqual(that: unknown): boolean {\n    return that instanceof InputSettings;\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof InputSettings) {\n      return that.canEqual(this) && this.stripped === that.stripped;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(InputSettings),\n        Booleans.hash(this.stripped)));\n  }\n\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"InputSettings\").write(46/*'.'*/);\n    if (!this.stripped) {\n      output = output.write(\"standard\");\n    } else {\n      output = output.write(\"stripped\");\n    }\n    output = output.write(40/*'('*/).write(41/*')'*/);\n    return output;\n  }\n\n  toString(): string {\n    return Format.debug(this);\n  }\n\n  /**\n   * Returns `InputSettings` configured to include diagnostic metadata in\n   * generated output.\n   */\n  @Lazy\n  static standard(): InputSettings {\n    return new InputSettings(false);\n  }\n\n  /**\n   * Returns `InputSettings` configured to omit diagnostic metadata in\n   * generated output.\n   */\n  @Lazy\n  static stripped(): InputSettings {\n    return new InputSettings(true);\n  }\n\n  /**\n   * Returns `InputSettings` configured to not include diagnostic metadata in\n   * generated output, if `isStripped` is `true`.\n   */\n  static create(isStripped?: boolean): InputSettings {\n    if (isStripped) {\n      return InputSettings.stripped();\n    }\n    return InputSettings.standard();\n  }\n\n  /**\n   * Converts the loosely typed `settings` to an instance of `InputSettings`.\n   */\n  static fromLike(settings: InputSettingsLike | undefined): InputSettings {\n    if (settings instanceof InputSettings) {\n      return settings;\n    } else if (typeof settings === \"object\" && settings !== null) {\n       return InputSettings.create(settings.isStripped);\n    } else {\n      return InputSettings.standard();\n    }\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport {Mark} from \"../source/Mark\";\nimport {InputException} from \"./InputException\";\nimport type {InputSettingsLike} from \"./InputSettings\";\nimport {InputSettings} from \"./InputSettings\";\nimport {InputEmpty} from \"../\"; // forward import\nimport {InputDone} from \"../\"; // forward import\nimport {InputError} from \"../\"; // forward import\n\n/**\n * Non-blocking token stream reader, with single token lookahead.\n * `Input` enables incremental, interruptible parsing of network protocols and\n * data formats.\n *\n * ### Input tokens\n * Input tokens are modeled as primitive numbers, commonly representing Unicode\n * code points, or raw octets; each `Input` implementation specifies the\n * semantic type of its tokens. The [[head]]  method peeks at the lookahead\n * token, without consuming it, and the [[step]] method advances the input to\n * the next token.\n *\n * ### Input states\n * An `Input` reader is always in one of three states: _cont_​inue, _empty_, or\n * _done_. The _cont_ state indicates that a lookahead token is immediately\n * available; the _empty_ state indicates that no additional tokens are\n * available at this time, but that the stream may logically resume at some\n * point in the future; and the _done_ state indicates that the stream has\n * terminated. [[isCont]] returns `true` when in the _cont_ state; [[isEmpty]]\n * returns `true` when in the _empty_ state; and [[isDone]] returns `true` when\n * in the _done_ state.\n *\n * ### Non-blocking behavior\n * `Input` readers never block. An `Input` reader that would otherwise block\n * awaiting additional input instead enters the _empty_ state, signaling the\n * input consumer to back off processing the input, but to remain prepared to\n * process additional input in the future. An `Input` reader enters the _done_\n * state when it encounters the final end of its input, signaling the input\n * consumer to stop processing. [[Input.empty]] returns an `Input` reader in\n * the _empty_ state. [[Input.done]] returns an `Input` reader in the _done_\n * state.\n *\n * ### Position tracking\n * The logical position of the lookahead token is made available via the\n * [[mark]] method, with optimized callouts for the byte [[offset]], one-based\n * [[line]] number, and one-based [[column]] in the current line. The [[id]]\n * method returns a diagnostic identifier for the token stream.\n *\n * ### Cloning\n * An `Input` reader may be [[clone cloned]] to provide an indepently mutable\n * position into a shared token stream. Not all `Input` implementations\n * support cloning.\n *\n * @see [[InputSettings]]\n * @see [[Parser]]\n * @public\n */\nexport abstract class Input {\n  /**\n   * Returns `true` when a [[head lookahead]] token is immediately available.\n   * i.e. this `Input` is in the _cont_ state.\n   */\n  abstract isCont(): boolean;\n\n  /**\n   * Returns `true` when no lookahead token is currently available, but\n   * additional input may be available at some point in the future, i.e. this\n   * `Input` is in the _empty_ state.\n   */\n  abstract isEmpty(): boolean;\n\n  /**\n   * Returns `true` when no lookahead token is currently available, and no\n   * additional input will ever become available, i.e. this `Input` is in\n   * the _done_ state.\n   */\n  abstract isDone(): boolean;\n\n  /**\n   * Returns `true` when no lookahead token is currently available due to an\n   * error with the token stream. i.e. this `Input` is in the `error` state.\n   * When `true`, `trap()` will return the input error\n   */\n  abstract isError(): boolean;\n\n  /**\n   * Returns `true` if this is a partial `Input` will that enter the _empty_\n   * state after it consumes the last available input token.\n   */\n  abstract isPart(): boolean;\n\n   /**\n    * Returns a partial `Input` equivalent to this `Input`, if `part` is `true`;\n    * returns a final `Input` equivalent to this `Input` if `part` is `false`.\n    * The caller's reference to this `Input` should be replaced by the returned\n    * `Input`\n    */\n  abstract asPart(part: boolean): Input;\n\n  /**\n   * Returns the current lookahead token, if this `Input` is in the\n   * _cont_ state.\n   *\n   * @throws [[InputException]] if this `Input` is not in the _cont_ state.\n   */\n  abstract head(): number;\n\n  /**\n   * Advances to the next token, if this `Input` is in the _cont_ state.\n   *\n   * @throws `Error` if this `Input` is not in the _cont_ state.\n   */\n  abstract step(): Input;\n\n  /**\n   * Sets the position of this `Input` to the given `mark`. Rewinds to the\n   * start of this `Input`, if `mark` is `undefined`.\n   *\n   * @throws [[InputException]] if this `Input` does not support seeking,\n   *         or is unable to reposition to the `mark`.\n   */\n  abstract seek(mark?: Mark): Input;\n\n  /**\n   * Returns the input error when in the _error_ state\n   *\n   * @throws InputException if the `Input` is not the _error_state\n   */\n  trap(): Error {\n    throw new InputException();\n  }\n\n  /**\n   * An informative identifier for this token stream, or `undefined` if this\n   * stream is unidentified.\n   */\n  abstract readonly id: string | undefined;\n\n  /**\n   * Returns an `Input` equivalent to this `Input`, but logically identified\n   * by the given–possibly `undefined`–`id`. The caller's reference to this\n   * `Input` should be replaced by the returned `Input`.\n   */\n  abstract withId(id: string | undefined): Input;\n\n  /**\n   * The position of the current lookahead token, relative to the start\n   * of the stream.\n   */\n  abstract readonly mark: Mark;\n\n  /**\n   * Returns an `Input` equivalent to this `Input`, but logically positioned\n   * at the given `mark`. The physical position in the input stream is not\n   * modified. The caller's reference to this `Input` should be replaced by\n   * the returned `Input`.\n   */\n  abstract withMark(mark: Mark): Input;\n\n  /**\n   * The byte offset of the current lookahead token, relative to the start\n   * of the stream.\n   */\n  abstract readonly offset: number;\n\n  /**\n   * The one-based line number of the current lookahead token, relative to\n   * the start of the stream.\n   */\n  abstract readonly line: number;\n\n  /**\n   * The one-based column number of the current lookahead token, relative to\n   * the current line in the stream.\n   */\n  abstract readonly column: number;\n\n  /**\n   * The `InputSettings` used to configure the behavior of input consumers\n   * that read from this `Input`.\n   */\n  abstract readonly settings: InputSettings;\n\n  /**\n   * Returns a clone of this `Input` with the given `settings`.\n   *\n   * @throws `Error` if this `Input` reader cannot be cloned.\n   */\n  abstract withSettings(settings: InputSettingsLike): Input;\n\n  /**\n   * Returns an independently positioned view into the token stream,\n   * initialized with identical state to this `Input`.\n   *\n   * @throws `Error` if this `Input` reader cannot be cloned.\n   */\n  abstract clone(): Input;\n\n  /**\n   * Returns an `Input` reader in the _empty_ state.\n   */\n  @Lazy\n  static empty(): Input {\n    return new InputEmpty(void 0, Mark.zero, InputSettings.standard());\n  }\n\n  /**\n   * Returns an `Input` reader in the _done_ state.\n   */\n  @Lazy\n  static done(): Input {\n    return new InputDone(void 0, Mark.zero, InputSettings.standard());\n  }\n\n  /**\n   * Returns an `Input` in the _error_ state that traps the given `error`.\n   */\n  static error(error: Error): Input {\n    return new InputError(error, void 0, Mark.zero, InputSettings.standard());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mark} from \"../source/Mark\";\nimport {InputException} from \"./InputException\";\nimport type {InputSettingsLike} from \"./InputSettings\";\nimport {InputSettings} from \"./InputSettings\";\nimport {Input} from \"./Input\";\n\n/** @internal */\nexport class InputError extends Input {\n  /** @internal */\n  readonly error!: Error;\n\n  constructor(error: Error, id: string | undefined, mark: Mark, settings: InputSettings) {\n    super();\n    Object.defineProperty(this, \"error\", {\n      value: error,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"id\", {\n      value: id,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"mark\", {\n      value: mark,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"settings\", {\n      value: settings,\n      enumerable: true,\n    });\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isEmpty(): boolean {\n    return false;\n  }\n\n  override isDone(): boolean {\n    return false;\n  }\n\n  override isError(): boolean {\n    return true;\n  }\n\n  override isPart(): boolean {\n    return false;\n  }\n\n  override asPart(part: boolean): Input {\n    return this;\n  }\n\n  override head(): number {\n    throw new InputException();\n  }\n\n  override step(): Input {\n    const error = new InputException(\"error step\");\n    return new InputError(error, this.id, this.mark, this.settings);\n  }\n\n  override trap(): Error {\n    return this.error;\n  }\n\n  override seek(mark?: Mark): Input {\n    const error = new InputException(\"error seek\");\n    return new InputError(error, this.id, this.mark, this.settings);\n  }\n\n  override readonly id!: string | undefined;\n\n  override withId(id: string | undefined): Input {\n    return new InputError(this.error, id, this.mark, this.settings);\n  }\n\n  override readonly mark!: Mark;\n\n  override withMark(mark: Mark): Input {\n    return new InputError(this.error, this.id, mark, this.settings);\n  }\n\n  override get offset(): number {\n    return this.mark.offset;\n  }\n\n  override get line(): number {\n    return this.mark.line;\n  }\n\n  override get column(): number {\n    return this.mark.column;\n  }\n\n  override readonly settings!: InputSettings;\n\n  override withSettings(settings: InputSettingsLike): Input {\n    settings = InputSettings.fromLike(settings);\n    return new InputError(this.error, this.id, this.mark, settings);\n  }\n\n  override clone(): Input {\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Strings} from \"@swim/util\";\nimport {Mark} from \"../source/Mark\";\nimport {InputException} from \"../input/InputException\";\nimport type {InputSettingsLike} from \"../input/InputSettings\";\nimport {InputSettings} from \"../input/InputSettings\";\nimport {Input} from \"../input/Input\";\nimport {InputError} from \"../input/InputError\";\n\n/** @internal */\nexport class StringInput extends Input {\n  constructor(string: string, id: string | undefined, offset: number,\n              line: number, column: number, settings: InputSettings,\n              index: number, part: boolean) {\n    super();\n    this.string = string;\n    this.index = index;\n    this.part = part;\n    this.id = id;\n    this.offset = offset;\n    this.line = line;\n    this.column = column;\n    this.settings = settings;\n  }\n\n  /** @internal */\n  readonly string: string;\n\n  /** @internal */\n  readonly index: number;\n\n  /** @internal */\n  readonly part: boolean;\n\n  override isCont(): boolean {\n    return this.index < this.string.length;\n  }\n\n  override isEmpty(): boolean {\n    return this.part && this.index >= this.string.length;\n  }\n\n  override isDone(): boolean {\n    return !this.part && this.index >= this.string.length;\n  }\n\n  override isError(): boolean {\n    return false;\n  }\n\n  override isPart(): boolean {\n    return this.part;\n  }\n\n  override asPart(part: boolean): Input {\n    (this as Mutable<this>).part = part;\n    return this;\n  }\n\n  override head(): number {\n    const string = this.string;\n    const index = this.index;\n    if (index < string.length) {\n      const c = string.codePointAt(index);\n      if (c !== void 0) {\n        return c;\n      } else {\n        return string.charCodeAt(index);\n      }\n    }\n    throw new InputException();\n  }\n\n  override step(): Input {\n    const string = this.string;\n    const index = this.index;\n    if (index < string.length) {\n      const c = string.codePointAt(index);\n      (this as Mutable<this>).index = Strings.offsetByCodePoints(string, index, 1);\n      (this as Mutable<this>).offset += this.index - index;\n      if (c === 10/*'\\n'*/) {\n        (this as Mutable<this>).line += 1;\n        (this as Mutable<this>).column = 1;\n      } else {\n        (this as Mutable<this>).column += 1;\n      }\n      return this;\n    } else {\n      const error = new InputException(\"invalid step\");\n      return new InputError(error, this.id, this.mark, this.settings);\n    }\n  }\n\n  override seek(mark?: Mark): Input {\n    if (mark !== void 0) {\n      const index = this.index + (mark.offset - this.offset);\n      if (0 <= index && index <= this.string.length) {\n        (this as Mutable<this>).index = index;\n        (this as Mutable<this>).offset = mark.offset;\n        (this as Mutable<this>).line = mark.line;\n        (this as Mutable<this>).column = mark.column;\n        return this;\n      } else {\n        const error = new InputException(\"invalid seek to \" + mark);\n        return new InputError(error, this.id, this.mark, this.settings);\n      }\n    } else {\n      (this as Mutable<this>).index = 0;\n      (this as Mutable<this>).offset = 0;\n      (this as Mutable<this>).line = 1;\n      (this as Mutable<this>).column = 1;\n      return this;\n    }\n  }\n\n  readonly id: string | undefined;\n\n  override withId(id: string | undefined): Input {\n    (this as Mutable<this>).id = id;\n    return this;\n  }\n\n  override get mark(): Mark {\n    return Mark.at(this.offset, this.line, this.column);\n  }\n\n  override withMark(mark: Mark): Input {\n    (this as Mutable<this>).offset = mark.offset;\n    (this as Mutable<this>).line = mark.line;\n    (this as Mutable<this>).column = mark.column;\n    return this;\n  }\n\n  override readonly offset: number;\n\n  override readonly line: number;\n\n  override readonly column: number;\n\n  override readonly settings: InputSettings;\n\n  override withSettings(settings: InputSettingsLike): Input {\n    settings = InputSettings.fromLike(settings);\n    (this as Mutable<this>).settings = settings;\n    return this;\n  }\n\n  override clone(): Input {\n    return new StringInput(this.string, this.id, this.offset, this.line,\n                           this.column, this.settings, this.index, this.part);\n  }\n\n  static create(string: string): Input {\n    return new StringInput(string, void 0, 0, 1, 1, InputSettings.standard(), 0, false);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Thrown when writing invalid [[Output]].\n * @public\n */\nexport class OutputException extends Error {\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, OutputException.prototype);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport {OutputException} from \"./OutputException\";\nimport type {OutputSettingsLike} from \"./OutputSettings\";\nimport {OutputSettings} from \"./OutputSettings\";\nimport {OutputFull} from \"../\"; // forward import\nimport {OutputDone} from \"../\"; // forward import\nimport {OutputError} from \"../\"; // forward import\nimport {Format} from \"../\"; // forward import\n\n/**\n * Non-blocking token stream writer. `Output` enables incremental,\n * interruptible writing of network protocols and data formats.\n *\n * ### Output tokens\n * Output tokens are modeled as primitive numbers, commonly representing\n * Unicode code points, or raw octets; each `Output` implementation specifies\n * the semantic type of its tokens.\n *\n * ### Output states\n * An `Output` writer is always in one of three states: _cont_​inue, _full_,\n * or _done_. The _cont_ state indicates that the stream is ready to write a\n * single token; the _full_ state indicates that the stream is unable to write\n * additional tokens at this time, but that the stream may logically resume at\n * some point in the future; and the _done_ state indicates that the stream has\n * terminated, and that [[bind]] will return the output result. [[isCont]]\n * returns `true` when in the _cont_ state; [[isFull]] returns `true` when in\n * the _full_ state; and [[isDone]] returns `true` when in the _done_ state.\n *\n * ### Output results\n * An `Output` writer yields a value of type `T`, obtained via the [[bind]]\n * method, representing some implementation defined result of writing the\n * output. For example, an `Output<string>` implementation may–but is not\n * required to–yield a `string` containing all code points written to the\n * output.\n *\n * ### Non-blocking behavior\n * `Output` writers never block. An `Output` writer that would otherwise block\n * writing additional output instead enters the _full_ state, signaling the\n * output generator to back off producing the output, but to remain prepared to\n * produce additional output in the future. An `Output` writer enters the\n * _done_ state when it encounters the final end of its output, signaling to\n * the output generator to stop producing.\n *\n * ### Output settings\n * An output generator may alter the tokens it produces based on its `Output`\n * writer's [[settings]]. Uses include pretty printing and styling generated\n * output. [[OutputSettings]] subclasses can provide additional parameters\n * understood by specialized output producers.\n *\n * ### Cloning\n * An `Output` writer may be [[clone cloned]] to branch the token stream in an\n * implementation specified manner. Not all `Output` implementations support\n * cloning.\n *\n * @see [[OutputSettings]]\n * @see [[Writer]]\n * @public\n */\nexport abstract class Output<T = unknown> {\n  /**\n   * Returns `true` when the next [[write write(number)]] will succeed.\n   * i.e. this `Output` is in the _cont_ state.\n   */\n  abstract isCont(): boolean;\n\n  /**\n   * Returns `true` when an immediate `write` will fail, but writes may succeed\n   * at some point in the future, i.e. this `Output` is in the _full_ state.\n   */\n  abstract isFull(): boolean;\n\n  /**\n   * Returns `true` when no `write` will ever again succeed.\n   * i.e. this `Output` is in the _done_ state.\n   */\n  abstract isDone(): boolean;\n\n  /**\n   * Returns `true` when an immediate `write` will fail due to an\n   * error with the token stream. i.e. this `Output` is in the `error` state.\n   * When `true`, `trap()` will return the output error.\n   */\n  abstract isError(): boolean;\n\n  /**\n   * Returns `true` if this is a partial `Output` that will enter\n   * the `full` state when it is unable to write additional tokens.\n   */\n  abstract isPart(): boolean;\n\n  /**\n   * Returns a partial `Output` equivalent to this `Output`, if `part` is `true`;\n   * returns a final `Output` equivalent to this `Output` if `part` is `false`.\n   * The caller's reference to this `Output` should be replaced by the returned\n   * `Output`.\n   */\n  abstract asPart(part: boolean): Output<T>;\n\n  /**\n   * Writes a single `token` to the stream, if this `Output` is in the\n   * _cont_ state.\n   *\n   * @returns `this`\n   * @throws [[OutputException]] if this `Output` is not in the _cont_ state.\n   */\n  abstract write(token: number): Output<T>;\n\n  /**\n   * Writes the code points of the given `string`. Assumes this is a Unicode\n   * `Output` writer with sufficient capacity.\n   *\n   * @returns `this`\n   * @throws [[OutputException]] if this `Output` exits the _cont_ state before\n   *         the full `string` has been written.\n   */\n  abstract write(string: string): Output<T>;\n\n  /**\n   * Writes the code points of the given `string`, followed by the code points\n   * of the `settings`' [[OutputSettings.lineSeparator line separator].\n   * Assumes this is a Unicode `Output` writer with sufficient capacity.\n   *\n   * @returns `this`\n   * @throws [[OutputException]] if this `Output` exits the _cont_ state before\n   *         the full `string` and line separator has been written.\n   */\n  writeln(string?: string): Output<T> {\n    if (typeof string === \"string\") {\n      this.write(string);\n    }\n    return this.write(this.settings.lineSeparator);\n  }\n\n  /**\n   * Writes the code points of the human-readable [[Display]] string of the\n   * given `object`. Assumes this is a Unicode `Output` writer with sufficient\n   * capacity.\n   *\n   * @returns the continuation of the `output`.\n   * @throws [[OutputException]] if this `Output` exits the _cont_ state before\n   *         the full display string has been written.\n   */\n  display(object: unknown): Output<T> {\n    return Format.displayAny(this, object);\n  }\n\n  /**\n   * Writes the code points of the developer-readable [[Debug]] string of the\n   * given `object`. Assumes this is a Unicode `Output` writer with sufficient\n   * capacity.\n   *\n   * @returns the continuation of the `output`.\n   * @throws [[OutputException]] if this `Output` exits the _cont_ state before\n   *         the full debug string has been written.\n   */\n  debug(object: unknown): Output<T> {\n    return Format.debugAny(this, object);\n  }\n\n  /**\n   * Writes any internally buffered state to the underlying output stream.\n   */\n  flush(): Output<T> {\n    return this;\n  }\n\n  push(...tokens: number[]): void {\n    const n = tokens.length;\n    for (let i = 0; i < n; i += 1) {\n      this.write(tokens[i]!);\n    }\n  }\n\n  /**\n   * The `OutputSettings` used to configure the behavior of output producers\n   * that write to this `Output`.\n   */\n  abstract readonly settings: OutputSettings;\n\n  /**\n   * Updates the `settings` associated with this `Output`.\n   *\n   * @returns `this`\n   */\n  abstract withSettings(settings: OutputSettingsLike): Output<T>;\n\n  /**\n   * Returns the implementation-defined result of writing the output.\n   */\n  abstract bind(): T;\n\n  /**\n   * Returns the output error. Only guaranteed to return an error when in the\n   * _error_ state.\n   *\n   * @throws OutputException if this `Output` is not in the _error_ state.\n   */\n  trap(): Error {\n    throw new OutputException();\n  }\n\n  /**\n   * Returns an implementation-defined branch of the token stream.\n   *\n   * @throws `Error` if this `Output` writer cannot be cloned.\n   */\n  clone(): Output<T> {\n    throw new Error();\n  }\n\n  /**\n   * Return an `Output` in the _full_ state.\n   */\n  @Lazy\n  static full(): Output<never> {\n    return new OutputFull(OutputSettings.standard());\n  }\n\n  /**\n   * Returns an `Output` in the _done_ state.\n   */\n  @Lazy\n  static done(): Output<never> {\n    return new OutputDone(OutputSettings.standard());\n  }\n\n  /**\n   * Return an `Output` in the _error_ state that traps the given `error`.\n   */\n  static error(error: Error): Output<never> {\n    return new OutputError(error, OutputSettings.standard());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport type {OutputSettingsLike} from \"../output/OutputSettings\";\nimport {OutputSettings} from \"../output/OutputSettings\";\nimport {Output} from \"../output/Output\";\n\n/** @internal */\nexport class StringOutput extends Output<string> {\n  constructor(string: string, settings: OutputSettings) {\n    super();\n    this.string = string;\n    this.settings = settings;\n  }\n\n  /** @internal */\n  readonly string: string;\n\n  override isCont(): boolean {\n    return true;\n  }\n\n  override isFull(): boolean {\n    return false;\n  }\n\n  override isDone(): boolean {\n    return false;\n  }\n\n  override isError(): boolean {\n    return false;\n  }\n\n  override isPart(): boolean {\n    return false;\n  }\n\n  override asPart(part: boolean): Output<string> {\n    return this;\n  }\n\n  override write(token: number | string): Output<string> {\n    if (typeof token === \"number\") {\n      if ((token >= 0x0000 && token <= 0xd7ff)\n          || (token >= 0xe000 && token <= 0xffff)) { // U+0000..U+D7FF | U+E000..U+FFFF\n        token = String.fromCharCode(token);\n      } else if (token >= 0x10000 && token <= 0x10ffff) { // U+10000..U+10FFFF\n        const u = token - 0x10000;\n        token = String.fromCharCode(0xd800 | (u >>> 10), 0xdc00 | (u & 0x3ff));\n      } else { // invalid code point\n        token = \"\\ufffd\";\n      }\n    }\n    (this as Mutable<this>).string += token;\n    return this;\n  }\n\n  override writeln(string?: string): Output<string> {\n    if (string !== void 0) {\n      (this as Mutable<this>).string = this.string.concat(string);\n    }\n    (this as Mutable<this>).string = this.string.concat(this.settings.lineSeparator);\n    return this;\n  }\n\n  override readonly settings: OutputSettings;\n\n  override withSettings(settings: OutputSettingsLike): Output<string> {\n    settings = OutputSettings.fromLike(settings);\n    (this as Mutable<this>).settings = settings;\n    return this;\n  }\n\n  override bind(): string {\n    return this.string;\n  }\n\n  override clone(): Output<string> {\n    return new StringOutput(this.string, this.settings);\n  }\n\n  override toString(): string {\n    return this.string;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Thrown when a [[Writer]] attempts to write invalid syntax.\n * @public\n */\nexport class WriterException extends Error {\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, WriterException.prototype);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport type {Output} from \"../output/Output\";\nimport {WriterException} from \"./WriterException\";\nimport {WriterEnd} from \"../\"; // forward import\nimport {WriterDone} from \"../\"; // forward import\nimport {WriterError} from \"../\"; // forward import\nimport {WriterSequence} from \"../\"; // forward import\n\n/**\n * Continuation of how to write subsequent [[Output]] tokens to a stream.\n * `Writer` enables efficient, interruptible writing of network protocols and\n * data formats, without intermediate buffering.\n *\n * ### Output tokens\n * A `Writer` writes tokens to an `Output` writer. Output tokens are modeled\n * as primitive numbers, commonly representing Unicode code points, or raw\n * octets. Each `Writer` implementation specifies the semantic type of output\n * tokens it produces.\n *\n * ### Writer states\n * A `Writer` is always in one of three states: _cont_​inue, _done_, or _error_.\n * The _cont_ state indicates that [[pull]] is ready to produce `Output`; the\n * _done_ state indicates that writing terminated successfully, and that\n * [[bind]] will return the written result; the _error_ state indicates that\n * writing terminated in failure, and that [[trap]] will return the write error.\n * `Writer` subclasses default to the _cont_ state.\n *\n * ### Feeding input\n * The [[feed]] method returns a `Writer` that represents the continuation\n * of how to write the given input object to subsequent `Output` writers.\n * `feed` can be used to specify an initial object to write, or to change\n * the object to be written.\n *\n * ### Pulling output\n * The [[pull]] method incrementally writes as much `Output` as it can, before\n * returning another `Writer` that represents the continuation of how to write\n * additional `Output`. The `Output` passed to `pull` is only guaranteed to be\n * valid for the duration of the method call; references to the provided\n * `Output` instance must not be stored.\n *\n * ### Writer results\n * A `Writer` produces a written result of type `O`, obtained via the [[bind]]\n * method. `bind` is only guaranteed to return a result when in the _done_\n * state; though `bind` may optionally make available partial results in other\n * states. A failed `Writer` provides a write error via the [[trap]] method.\n * `trap` is only guaranteed to return an error when in the _error_ state.\n *\n * ### Continuations\n * A `Writer` instance represents a continuation of how to write remaining\n * `Output`. Rather than writing a complete output in one go, a `Writer` takes\n * an `Output` chunk and returns another `Writer` instance that knows how to\n * write subsequent `Output` chunks. This enables non-blocking, incremental\n * writing that can be interrupted whenever an `Output` writer runs out of\n * space. A `Writer` terminates by returning a continuation in either the\n * _done_ state, or the _error_ state. [[Writer.done]] returns a `Writer` in\n * the _done_ state. [[Writer.error]] returns a `Writer` in the _error_ state.\n *\n * ### Forking\n * The [[fork]] method passes an out-of-band condition to a `Writer`, yielding\n * a `Writer` continuation whose behavior may be altered by the given condition.\n * For example, a console `Writer` might support a `fork` condition that changes\n * the color and style of printed text. The types of conditions accepted by\n * `fork`, and their intended semantics, are implementation defined.\n *\n * @public\n */\nexport abstract class Writer<I = unknown, O = unknown> {\n  /**\n   * Returns `true` when [[pull]] is able to produce `Output`, i.e. this\n   * `Writer` is in the _cont_ state.\n   */\n  isCont(): boolean {\n    return true;\n  }\n\n  /**\n   * Returns `true` when writing has terminated successfully, and [[bind]] will\n   * return the written result, i.e. this `Writer` is in the _done_ state.\n   */\n  isDone(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns `true` when writing has terminated in failure, and [[trap]] will\n   * return the write error, i.e. this `Writer` is in the _error_ state.\n   */\n  isError(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns a `Writer` that represents the continuation of how to write the\n   * given `input` object.\n   *\n   * @throws `WriterException` if this `Writer` does not know how to write the\n   *         given `input` object.\n   */\n  feed(input: I): Writer<I, O> {\n    throw new WriterException();\n  }\n\n  /**\n   * Incrementally writes as much `output` as possible, and returns another\n   * `Writer` that represents the continuation of how to write additional\n   * `Output`. If `output` enters the _done_ state, `pull` _must_ return a\n   * terminated `Writer`, i.e. a `Writer` in the _done_ state, or in the\n   * _error_ state. The given `output` is only guaranteed to be valid for the\n   * duration of the method call; references to `output` must not be stored.\n   */\n  abstract pull(output: Output): Writer<I, O>;\n\n  /**\n   * Returns a `Writer` continuation whose behavior may be altered by the given\n   * out-of-band `condition`.\n   */\n  fork(condition: unknown): Writer<I, O> {\n    return this;\n  }\n\n  /**\n   * Returns the written result. Only guaranteed to return a result when in\n   * the _done_ state.\n   *\n   * @throws `Error` if this `Writer` is not in the _done_ state.\n   */\n  bind(): O {\n    throw new WriterException();\n  }\n\n  /**\n   * Returns the write error. Only guaranteed to return an error when in the\n   * _error_ state.\n   *\n   * @throws `Error` if this `Writer` is not in the _error_ state.\n   */\n  trap(): Error {\n    throw new WriterException();\n  }\n\n  /**\n   * Casts a done `Writer` to a different input type. A `Writer` in the _done_\n   * state can have any input type.\n   *\n   * @throws `WriterException` if this `Writer` is not in the _done_ state.\n   */\n  asDone<I2>(): Writer<I2, O> {\n    throw new WriterException();\n  }\n\n  /**\n   * Casts an errored `Writer` to different input and output types. A `Writer`\n   * in the _error_ state can have any input type, and any output type.\n   *\n   * @throws `WriterException` if this `Writer` is not in the _error_ state.\n   */\n  asError<I2, O2>(): Writer<I2, O2> {\n    throw new WriterException();\n  }\n\n  /**\n   * Returns a `Writer` that continues writing `that` `Writer`, after it\n   * finishes writing this `Writer`.\n   */\n  andThen<O2>(that: Writer<unknown, O2>): Writer<never, O2> {\n    return new WriterSequence(this, that);\n  }\n\n  /**\n   * Returns a `Writer` in the _done_ state that never binds a value.\n   */\n  @Lazy\n  static end<I>(): Writer<I, never> {\n    return new WriterEnd();\n  }\n\n  /**\n   * Returns a `Writer` in the _done_ state that binds the given written `value`.\n   */\n  static done<I, O>(value: O): Writer<I, O> {\n    return new WriterDone(value);\n  }\n\n  /**\n   * Returns a `Writer` in the _error_ state that traps the given write `error`.\n   */\n  static error<I, O>(error: Error): Writer<I, O> {\n    return new WriterError(error);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Strings} from \"@swim/util\";\nimport type {Output} from \"../output/Output\";\nimport {WriterException} from \"../writer/WriterException\";\nimport {Writer} from \"../writer/Writer\";\n\n/** @internal */\nexport class StringWriter extends Writer<unknown, unknown> {\n  /** @internal */\n  readonly value: unknown;\n  /** @internal */\n  readonly input: string;\n  /** @internal */\n  readonly index: number;\n\n  constructor(value: unknown, input: string, index: number = 0) {\n    super();\n    this.value = value;\n    this.input = input;\n    this.index = index;\n  }\n\n  override feed(input: unknown): Writer<unknown, unknown> {\n    return new StringWriter(input, \"\" + input);\n  }\n\n  override pull(output: Output): Writer<unknown, unknown> {\n    return StringWriter.write(output, this.value, this.input, this.index);\n  }\n\n  static write(output: Output, value: unknown, input: string, index: number = 0): Writer<unknown, unknown> {\n    const length = input.length;\n    while (index < length && output.isCont()) {\n      let c = input.codePointAt(index);\n      if (c === void 0) {\n        c = input.charCodeAt(index);\n      }\n      output = output.write(c);\n      index = Strings.offsetByCodePoints(input, index, 1);\n    }\n    if (index === length) {\n      return Writer.done(value);\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new StringWriter(value, input, index);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Input} from \"../input/Input\";\nimport type {OutputSettingsLike} from \"../output/OutputSettings\";\nimport {OutputSettings} from \"../output/OutputSettings\";\nimport type {Output} from \"../output/Output\";\nimport type {Writer} from \"../writer/Writer\";\nimport {StringInput} from \"./StringInput\";\nimport {StringOutput} from \"./StringOutput\";\nimport {StringWriter} from \"./StringWriter\";\n\n/**\n * Unicode code point [[Input]]/[[Output]]/[[Writer]] factory.\n *\n * The `Unicode.stringInput(...)` function returns an `Input` that reads the\n * Unicode code points of a `string`.\n *\n * The `Unicode.stringOutput(...)` function returns an `Output` that writes\n * Unicode code points to an internal buffer, and [[Output.bind binds]] a\n * `string` containing all written code points.\n * @public\n */\nexport const Unicode = (function () {\n  const Unicode = {} as {\n    stringInput(string: string): Input;\n\n    /**\n     * Returns a new `Output` that appends Unicode code points to the given\n     * `string`, using the given output `settings`. The returned `Output`\n     * accepts an unbounded number of code points, remaining permanently in the\n     * _cont_ state, and [[Output.bind binds]] a `string` containing the given\n     * `string`, and all appended code points.\n     */\n    stringOutput(string?: string, settings?: OutputSettingsLike): Output<string>;\n\n    /**\n     * Returns a new `Output` that buffers Unicode code points, using the given\n     * output `settings`. The returned `Output` accepts an unbounded number of\n     * code points, remaining permanently in the _cont_ state, and [[Output.bind\n     * binds]] a `string` containing all written code points.\n     */\n    stringOutput(settings?: OutputSettingsLike): Output<string>;\n\n    stringWriter<I>(): Writer<I, unknown>;\n\n    stringWriter<I, O>(input: O): Writer<I, O>;\n\n    writeString<I>(output: Output, input: unknown): Writer<I, unknown>;\n\n    /** @internal */\n    isAlpha(c: number): boolean;\n\n    /** @internal */\n    isDigit(c: number): boolean;\n\n    /** @internal */\n    isSpace(c: number): boolean;\n\n    /** @internal */\n    isNewline(c: number): boolean;\n\n    /** @internal */\n    isWhitespace(c: number): boolean;\n  };\n\n  Unicode.stringInput = function (string: string): Input {\n    return StringInput.create(string);\n  };\n\n  Unicode.stringOutput = function (string?: string | OutputSettingsLike, settings?: OutputSettingsLike): Output<string> {\n    if (settings === void 0 && typeof string !== \"string\") {\n      settings = string;\n      string = \"\";\n    } else if (typeof string !== \"string\") {\n      string = \"\";\n    }\n    settings = OutputSettings.fromLike(settings);\n    return new StringOutput(string, settings);\n  };\n\n  Unicode.stringWriter = function <I, O>(input?: O): Writer<I, unknown> {\n    if (input === void 0) {\n      return new StringWriter(void 0, \"\");\n    } else {\n      return new StringWriter(input, \"\" + input);\n    }\n  };\n\n  Unicode.writeString = function <I>(output: Output, input: unknown): Writer<I, unknown> {\n    return StringWriter.write(output, void 0, \"\" + input);\n  };\n\n  Unicode.isAlpha = function (c: number): boolean {\n    return c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/;\n  };\n\n  Unicode.isDigit = function (c: number): boolean {\n    return c >= 48/*'0'*/ && c <= 57/*'9'*/;\n  };\n\n  Unicode.isSpace = function (c: number): boolean {\n    return c === 0x20 || c === 0x9;\n  };\n\n  Unicode.isNewline = function (c: number): boolean {\n    return c === 0xa || c === 0xd;\n  };\n\n  Unicode.isWhitespace = function (c: number): boolean {\n    return Unicode.isSpace(c) || Unicode.isNewline(c);\n  };\n\n  return Unicode;\n})();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport * as OS from \"os\";\nimport type {OutputSettingsLike} from \"../output/OutputSettings\";\nimport type {Output} from \"../output/Output\";\nimport type {Display} from \"./Display\";\nimport type {Debug} from \"./Debug\";\nimport {Unicode} from \"../unicode/Unicode\";\n\n/**\n * utility functions for formatting values.\n * @public\n */\nexport const Format = (function () {\n  const Format = {} as {\n    /**\n     * The operating system specific string used to separate lines of text.\n     */\n    readonly lineSeparator: string;\n\n    /**\n     * Returns the human-readable [[Display]] string for the given `object`,\n     * output using the given `settings`. Delegates to [[Display.display]],\n     * if `object` implements `Display`; otherwise returns the result of\n     * `Object.toString`.\n     */\n    display(object: unknown, settings?: OutputSettingsLike): string;\n\n    /**\n     * Returns the developer-readable [[Debug]] string for the given `object`,\n     * output using the given `settings`. Delegates to [[Debug.debug]], if\n     * `object` implements `Debug`; returns a JavaScript string literal, if\n     * `object` is a `string`, and returns a JavaScript number literal, if\n     * `object` is a `number`; otherwise returns the result of `Object.toString`.\n     */\n    debug(object: unknown, settings?: OutputSettingsLike): string;\n\n    /**\n     * Writes the code points of the human-readable [[Display]] string for the\n     * given `object` to `output`. Assumes `output` is a Unicode `Output` writer\n     * with sufficient capacity. Delegates to [[Display.display]], if `object`\n     * implements `Display`; otherwise writes the result of `Object.toString`.\n     *\n     * @returns the continuation of the `output`.\n     * @throws [[OutputException]] if the `output` exits the _cont_ state before\n     *         the full display string has been written.\n     */\n    displayAny<T>(output: Output<T>, object: unknown): Output<T>;\n\n    /**\n     * Writes the code points of the developer-readable [[Debug]] string for the\n     * given `object` to `output`. Assumes `output` is a Unicode `Output` writer\n     * with sufficient capacity. Delegates to [[Debug.debug]], if `object`\n     * implements `Debug`; writes a JavaScript string literal, if `object` is a\n     * `string`, and writes a JavaScript number literal, if `object` is a\n     * `number`; otherwise writes the result of `Object.toString`.\n     *\n     * @returns the continuation of the `output`.\n     * @throws [[OutputException]] if the `output` exits the _cont_ state before\n     *         the full debug string has been written.\n     */\n    debugAny<T>(output: Output<T>, object: unknown): Output<T>;\n\n    /**\n     * Writes the code points of the numeric string for the given `value`\n     * to `output`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    displayNumber<T>(output: Output<T>, value: number): Output<T>;\n\n    /**\n     * Writes the code points of the JavaScript numeric literal for the given\n     * `value` to `output`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    debugNumber<T>(output: Output<T>, value: number): Output<T>;\n\n    /**\n     * Writes the code points of the JavaScript character literal for the given\n     * `character` to `output`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    debugChar<T>(output: Output<T>, character: number): Output<T>;\n\n    /**\n     * Writes the code points of the JavaScript string literal for the given\n     * `string` to `output`.\n     *\n     * @returns the continuation of the `output`.\n     */\n    debugString<T>(output: Output<T>, string: string): Output<T>;\n\n    /** @internal */\n    encodeHex(x: number): number;\n\n    /**\n     * Returns a string representation of `value` scaled by its SI magnitude,\n     * keeping at most `precision` digits past the decimal place, appended with\n     * the appropriate SI prefix.\n     */\n    prefix(value: number, precision?: number): string;\n\n    decimal(value: number, precision?: number): string;\n\n    /** @internal */\n    trimTrailingZeros(s: string): string;\n\n    /**\n     * Returns a string representation of the duration represented by the given\n     * number of milliseconds.\n     */\n    duration(millis: number, separator?: string): string;\n  };\n\n  Object.defineProperty(Format, \"lineSeparator\", {\n    value: typeof OS !== \"undefined\" && typeof OS.EOL === \"string\" ? OS.EOL : \"\\n\",\n    enumerable: true,\n    configurable: true,\n  });\n\n  Format.display = function (object: unknown, settings?: OutputSettingsLike): string {\n    if (object === void 0) {\n      return \"undefined\";\n    } else if (object === null) {\n      return \"null\";\n    } else if (typeof object === \"number\") {\n      return \"\" + object;\n    } else if (typeof object === \"string\") {\n      return object;\n    } else if (typeof (object as Display).display === \"function\") {\n      let output = Unicode.stringOutput(settings);\n      output = (object as Display).display(output);\n      return output.bind();\n    } else {\n      return \"\" + object;\n    }\n  };\n\n  Format.debug = function (object: unknown, settings?: OutputSettingsLike): string {\n    if (object === void 0) {\n      return \"undefined\";\n    } else if (object === null) {\n      return \"null\";\n    } else if (typeof object === \"number\") {\n      return \"\" + object;\n    } else if (typeof object === \"string\") {\n      let output = Unicode.stringOutput(settings);\n      output = Format.debugString(output, object);\n      return output.bind();\n    } else if (typeof (object as Debug).debug === \"function\") {\n      let output = Unicode.stringOutput(settings);\n      output = (object as Debug).debug(output);\n      return output.bind();\n    } else {\n      return \"\" + object;\n    }\n  };\n\n  Format.displayAny = function <T>(output: Output<T>, object: unknown): Output<T> {\n    if (object === void 0) {\n      output = output.write(\"undefined\");\n    } else if (object === null) {\n      output = output.write(\"null\");\n    } else if (typeof object === \"number\") {\n      output = Format.displayNumber(output, object);\n    } else if (typeof object === \"string\") {\n      output = output.write(object);\n    } else if (typeof (object as Display).display === \"function\") {\n      output = (object as Display).display(output);\n    } else {\n      output = output.write(\"\" + object);\n    }\n    return output;\n  };\n\n  Format.debugAny = function <T>(output: Output<T>, object: unknown): Output<T> {\n    if (object === void 0) {\n      output = output.write(\"undefined\");\n    } else if (object === null) {\n      output = output.write(\"null\");\n    } else if (typeof object === \"number\") {\n      output = Format.debugNumber(output, object);\n    } else if (typeof object === \"string\") {\n      output = Format.debugString(output, object);\n    } else if (typeof (object as Debug).debug === \"function\") {\n      output = (object as Debug).debug(output);\n    } else {\n      output = output.write(\"\" + object);\n    }\n    return output;\n  };\n\n  Format.displayNumber = function <T>(output: Output<T>, value: number): Output<T> {\n    if (isFinite(value) && Math.floor(value) === value && Math.abs(value) < 2147483648) {\n      if (value < 0) {\n        output = output.write(45/*'-'*/);\n      }\n      if (value > -10 && value < 10) {\n        output = output.write(48/*'0'*/ + Math.abs(value));\n      } else {\n        const digits = new Array<number>(19);\n        let x = value;\n        let i = 18;\n        while (x !== 0) {\n          digits[i] = Math.abs((x % 10) | 0);\n          x = (x / 10) | 0;\n          i -= 1;\n        }\n        i += 1;\n        while (i < 19) {\n          output = output.write(48/*'0'*/ + digits[i]!);\n          i += 1;\n        }\n      }\n    } else {\n      output = output.write(Format.decimal(value, output.settings.precision));\n    }\n    return output;\n  };\n\n  Format.debugNumber = function <T>(output: Output<T>, value: number): Output<T> {\n    return Format.displayNumber(output, value);\n  };\n\n  Format.debugChar = function <T>(output: Output<T>, value: number): Output<T> {\n    output = output.write(39/*'\\''*/);\n    switch (value) {\n      case 8/*'\\b'*/: output.write(92/*'\\\\'*/).write(98/*'b'*/); break;\n      case 9/*'\\t'*/: output.write(92/*'\\\\'*/).write(116/*'t'*/); break;\n      case 10/*'\\n'*/: output.write(92/*'\\\\'*/).write(110/*'n'*/); break;\n      case 12/*'\\f'*/: output.write(92/*'\\\\'*/).write(102/*'f'*/); break;\n      case 13/*'\\r'*/: output.write(92/*'\\\\'*/).write(114/*'r'*/); break;\n      case 34/*'\\\"'*/: output.write(92/*'\\\\'*/).write(34/*'\\\"'*/); break;\n      case 39/*'\\\"'*/: output.write(92/*'\\\\'*/).write(39/*'\\''*/); break;\n      case 92/*'\\\\'*/: output.write(92/*'\\\\'*/).write(92/*'\\\\'*/); break;\n      default:\n        if (value >= 0x0000 && value <= 0x001f || value >= 0x007f && value <= 0x009f) {\n          output = output.write(92/*'\\\\'*/).write(117/*'u'*/)\n                         .write(Format.encodeHex(value >>> 12 & 0xf))\n                         .write(Format.encodeHex(value >>>  8 & 0xf))\n                         .write(Format.encodeHex(value >>>  4 & 0xf))\n                         .write(Format.encodeHex(value        & 0xf));\n        } else {\n          output = output.write(value);\n        }\n    }\n    output = output.write(39/*'\\''*/);\n    return output;\n  };\n\n  Format.debugString = function <T>(output: Output<T>, string: string): Output<T> {\n    output = output.write(34/*'\\\"'*/);\n    let input = Unicode.stringInput(string);\n    while (input.isCont()) {\n      const c = input.head();\n      switch (c) {\n        case 8/*'\\b'*/: output.write(92/*'\\\\'*/).write(98/*'b'*/); break;\n        case 9/*'\\t'*/: output.write(92/*'\\\\'*/).write(116/*'t'*/); break;\n        case 10/*'\\n'*/: output.write(92/*'\\\\'*/).write(110/*'n'*/); break;\n        case 12/*'\\f'*/: output.write(92/*'\\\\'*/).write(102/*'f'*/); break;\n        case 13/*'\\r'*/: output.write(92/*'\\\\'*/).write(114/*'r'*/); break;\n        case 34/*'\\\"'*/: output.write(92/*'\\\\'*/).write(34/*'\\\"'*/); break;\n        case 92/*'\\\\'*/: output.write(92/*'\\\\'*/).write(92/*'\\\\'*/); break;\n        default:\n          if (c >= 0x0000 && c <= 0x001f || c >= 0x007f && c <= 0x009f) {\n            output = output.write(92/*'\\\\'*/).write(117/*'u'*/)\n                           .write(Format.encodeHex(c >>> 12 & 0xf))\n                           .write(Format.encodeHex(c >>>  8 & 0xf))\n                           .write(Format.encodeHex(c >>>  4 & 0xf))\n                           .write(Format.encodeHex(c        & 0xf));\n          } else {\n            output = output.write(c);\n          }\n      }\n      input = input.step();\n    }\n    output = output.write(34/*'\\\"'*/);\n    return output;\n  };\n\n  Format.encodeHex = function (x: number): number {\n    if (x < 10) {\n      return 48/*'0'*/ + x;\n    } else {\n      return 65/*'A'*/ + (x - 10);\n    }\n  };\n\n  Format.prefix = (function () {\n    const prefixes: readonly string[] = [\"y\", \"z\", \"a\", \"f\", \"p\", \"n\", String.fromCharCode(0x03BC/*'µ'*/), \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\",\" Z\", \"Y\"];\n    return function (value: number, precision: number = 1): string {\n      if (isFinite(value)) {\n        const exponential = Math.abs(value).toExponential();\n        const exponentIndex = exponential.indexOf(\"e\");\n        const exponent = exponentIndex >= 0 ? +exponential.slice(exponentIndex + 1) : NaN;\n        const power = Math.min(Math.max(-8, Math.floor(exponent / 3)), 8) * 3;\n        const scaled = Math.pow(10, -power) * value;\n        let s = Format.trimTrailingZeros(Math.abs(scaled).toFixed(precision));\n        if (scaled < 0 && +s !== 0) {\n          s = \"-\" + s;\n        }\n        s += prefixes[8 + power / 3];\n        return s;\n      } else {\n        return \"\" + value;\n      }\n    };\n  })();\n\n  Format.decimal = function (value: number, precision: number = -1): string {\n    if (precision >= 0) {\n      let s = Format.trimTrailingZeros(Math.abs(value).toFixed(precision));\n      if (value < 0 && +s !== 0) {\n        s = \"-\" + s;\n      }\n      return s;\n    } else {\n      return \"\" + value;\n    }\n  };\n\n  Format.trimTrailingZeros = function (s: string): string {\n    let i0 = -1;\n    let i1: number | undefined;\n    for (let i = 1; i < s.length; i += 1) {\n      const c = s.charCodeAt(i);\n      if (c === 46/*'.'*/) {\n        i0 = i; // candidate start of trailing zeros\n        i1 = i; // candidate end of trailing zeros\n      } else if (c === 48/*'0'*/) {\n        if (i0 === 0) { // if after decimal\n          i0 = i; // new candidate start of trailing zeros\n        }\n        i1 = i; // new candidate end of trailing zeros\n      } else if (c >= 49/*'1'*/ && c <= 57/*'9'*/) {\n        if (i0 > 0) { // if non-zero digit after decimal\n          i0 = 0; // no candidate start of trailing zeros\n        }\n      } else if (i0 > 0) { // if non-numeric character after decimal\n        break; // accept current range of trailing zeros\n      }\n    }\n    if (i0 > 0) {\n      s = s.slice(0, i0) + s.slice(i1! + 1); // cut out trailing zeros\n    }\n    return s;\n  };\n\n  Format.duration = function (millis: number, separator: string = \" \"): string {\n    if (isFinite(millis)) {\n      const SECOND = 1000;\n      const MINUTE = 60 * SECOND;\n      const HOUR = 60 * MINUTE;\n      const DAY = 24 * HOUR;\n      const WEEK = 7 * DAY;\n      let weeks: number | undefined;\n      if (millis > WEEK) {\n        weeks = Math.floor(millis / WEEK);\n        millis %= WEEK;\n      }\n      let days: number | undefined;\n      if (millis > DAY) {\n        days = Math.floor(millis / DAY);\n        millis %= DAY;\n      }\n      let hours: number | undefined;\n      if (millis > HOUR) {\n        hours = Math.floor(millis / HOUR);\n        millis %= HOUR;\n      }\n      let minutes: number | undefined;\n      if (millis > MINUTE) {\n        minutes = Math.floor(millis / MINUTE);\n        millis %= MINUTE;\n      }\n      let seconds: number | undefined;\n      if (millis > SECOND) {\n        seconds = Math.floor(millis / SECOND);\n        millis %= SECOND;\n      }\n      let s = \"\";\n      if (weeks !== void 0) {\n        s += weeks + \"w\";\n      }\n      if (days !== void 0) {\n        s += (s.length !== 0 ? separator : \"\") + days + \"d\";\n      }\n      if (hours !== void 0) {\n        s += (s.length !== 0 ? separator : \"\") + hours + \"h\";\n      }\n      if (minutes !== void 0) {\n        s += (s.length !== 0 ? separator : \"\") + minutes + \"m\";\n      }\n      if (seconds !== void 0 || millis === 0) {\n        s += (s.length !== 0 ? separator : \"\") + (seconds !== void 0 ? seconds : 0) + \"s\";\n      }\n      if (millis !== 0 && s.length === 0) {\n        s += millis + \"ms\";\n      }\n      return s;\n    } else {\n      return \"\" + millis;\n    }\n  };\n\n  return Format;\n})();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Input} from \"../input/Input\";\nimport type {Output} from \"../output/Output\";\nimport type {Parser} from \"../parser/Parser\";\nimport type {Writer} from \"../writer/Writer\";\nimport {Format} from \"../format/Format\";\nimport {Unicode} from \"../unicode/Unicode\";\nimport {Base10NumberParser} from \"../\"; // forward import\nimport {Base10IntegerWriter} from \"../\"; // forward import\n\n/**\n * Base-10 (decimal) encoding [[Parser]]/[[Writer]] factory.\n * @public\n */\nexport const Base10 = (function () {\n  const Base10 = {} as {\n    /**\n     * Returns `true` if the Unicode code point `c` is a valid base-10 digit.\n     */\n    isDigit(c: number): boolean;\n\n    /**\n     * Returns the decimal quantity between `0` (inclusive) and `10` (exclusive)\n     * represented by the base-10 digit `c`.\n     *\n     * @throws `Error` if `c` is not a valid base-10 digit.\n     */\n    decodeDigit(c: number): number;\n\n    /**\n     * Returns the Unicode code point of the base-10 digit that encodes the given\n     * decimal quantity between `0` (inclusive) and `10` (exclusive).\n     */\n    encodeDigit(b: number): number;\n\n    /**\n     * Returns the number of whole decimal digits in the given absolute `value`.\n     */\n    countDigits(value: number): number;\n\n    integerParser(): Parser<number>;\n\n    parseInteger(input: Input): Parser<number>;\n\n    decimalParser(): Parser<number>;\n\n    parseDecimal(input: Input): Parser<number>;\n\n    numberParser(): Parser<number>;\n\n    parseNumber(input: Input): Parser<number>;\n\n    /**\n     * Returns a `Writer` that, when fed an input `number` value, returns a\n     * continuation that writes the base-10 (decimal) encoding of the input value.\n     */\n    integerWriter(): Writer<number, unknown>;\n\n    /**\n     * Returns a `Writer` continuation that writes the base-10 (decimal) encoding\n     * of the `input` value.\n     */\n    integerWriter(input: number): Writer<unknown, number>;\n\n    /**\n     * Writes the base-10 (decimal) encoding of the `input` value to the `output`,\n     * returning a `Writer` continuation that knows how to write any remaining\n     * output that couldn't be immediately generated.\n     */\n    writeInteger(output: Output, input: number): Writer;\n  };\n\n  Base10.isDigit = function (c: number): boolean {\n    return c >= 48/*'0'*/ && c <= 57/*'9'*/;\n  };\n\n  Base10.decodeDigit = function (c: number): number {\n    if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n      return c - 48/*'0'*/;\n    } else {\n      let message = Unicode.stringOutput();\n      message = message.write(\"Invalid base-10 digit: \");\n      message = Format.debugChar(message, c);\n      throw new Error(message.bind());\n    }\n  };\n\n  Base10.encodeDigit = function (b: number): number {\n    if (b >= 0 && b <= 9) {\n      return 48/*'0'*/ + b;\n    } else {\n      throw new Error(\"\" + b);\n    }\n  };\n\n  Base10.countDigits = function (value: number): number {\n    let size = 0;\n    do {\n      size += 1;\n      value = (value / 10) | 0;\n    } while (value !== 0);\n    return size;\n  };\n\n  Base10.integerParser = function (): Parser<number> {\n    return new Base10NumberParser(void 0, void 0, 0);\n  };\n\n  Base10.parseInteger = function (input: Input): Parser<number> {\n    return Base10NumberParser.parse(input, void 0, void 0, 0);\n  };\n\n  Base10.decimalParser = function (): Parser<number> {\n    return new Base10NumberParser(void 0, void 0, 1);\n  };\n\n  Base10.parseDecimal = function (input: Input): Parser<number> {\n    return Base10NumberParser.parse(input, void 0, void 0, 1);\n  };\n\n  Base10.numberParser = function (): Parser<number> {\n    return new Base10NumberParser();\n  };\n\n  Base10.parseNumber = function (input: Input): Parser<number> {\n    return Base10NumberParser.parse(input);\n  };\n\n  Base10.integerWriter = function (input?: number): Writer {\n    if (input === void 0) {\n      return new Base10IntegerWriter(void 0, 0);\n    } else {\n      return new Base10IntegerWriter(void 0, input);\n    }\n  } as typeof Base10.integerWriter;\n\n  Base10.writeInteger = function (output: Output, input: number): Writer {\n    return Base10IntegerWriter.write(output, void 0, input);\n  };\n\n  return Base10;\n})();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Values} from \"@swim/util\";\nimport {Severity} from \"@swim/util\";\nimport type {Tag} from \"./Tag\";\nimport type {Mark} from \"./Mark\";\nimport type {Input} from \"../input/Input\";\nimport type {OutputSettings} from \"../output/OutputSettings\";\nimport type {Output} from \"../output/Output\";\nimport type {Display} from \"../format/Display\";\nimport {OutputStyle} from \"../format/OutputStyle\";\nimport {Format} from \"../format/Format\";\nimport {Unicode} from \"../unicode/Unicode\";\nimport {Base10} from \"../number/Base10\";\n\n/**\n * Informational message attached to an input location.\n * @public\n */\nexport class Diagnostic implements Display {\n  constructor(input: Input, tag: Tag, severity: Severity, message: string | undefined,\n              note: string | undefined, cause: Diagnostic | null) {\n    this.input = input;\n    this.tag = tag;\n    this.severity = severity;\n    this.message = message;\n    this.note = note;\n    this.cause = cause;\n  }\n\n  /** @internal */\n  readonly input: Input;\n\n  /**\n   * The location in the `input` to which this diagnostic is attached.\n   */\n  readonly tag: Tag;\n\n  /**\n   * The level of importance of this diagnostic.\n   */\n  readonly severity: Severity;\n\n  /**\n   * The help message that describes this diagnostic.\n   */\n  readonly message: string | undefined;\n\n  /**\n   * An informative comment on the source context to which this diagnostic is attached.\n   */\n  readonly note: string | undefined;\n\n  /**\n   * The `Diagnostic` cause of this diagnostic, forming a linked chain of\n   * diagnostics, or `null` if this diagnostic has no cause.\n   */\n  readonly cause: Diagnostic | null;\n\n  private lineDigits(): number {\n    let digits = Base10.countDigits(this.tag.end.line);\n    if (this.cause !== null) {\n      digits = Math.max(digits, this.cause.lineDigits());\n    }\n    return digits;\n  }\n\n  display<T>(output: Output<T>): Output<T> {\n    const input = this.input.clone();\n    const start = this.tag.start;\n    const end = this.tag.end;\n    const severity = this.severity;\n    const message = this.message;\n    const note = this.note;\n    const cause = this.cause;\n    const contextLines = 2;\n    const lineDigits = this.lineDigits();\n    output = Diagnostic.display(output, input, start, end, severity, message,\n                                note, cause, contextLines, lineDigits);\n    return output;\n  }\n\n  private static display<T>(output: Output<T>, input: Input, start: Mark, end: Mark,\n                            severity: Severity, message: string | undefined,\n                            note: string | undefined, cause: Diagnostic | null,\n                            contextLines: number, lineDigits: number): Output<T> {\n    do {\n      if (message !== void 0) {\n        output = Diagnostic.displayMessage(output, severity, message);\n        output = output.writeln();\n      }\n      output = Diagnostic.displayAnchor(output, input, start, lineDigits);\n      output = output.writeln();\n      const cont = Diagnostic.displayContext(output, input, start, end, severity,\n                                             note, cause, contextLines, lineDigits);\n      const next = cont[0];\n      output = cont[1];\n      if (next !== null) {\n        output = output.writeln();\n        input = next.input.clone();\n        start = next.tag.start;\n        end = next.tag.end;\n        severity = next.severity;\n        message = next.message;\n        note = next.note;\n        cause = next.cause;\n      } else {\n        break;\n      }\n    } while (true);\n    return output;\n  }\n\n  /** @internal */\n  static displayMessage<T>(output: Output<T>, severity: Severity, message: string | undefined): Output<T> {\n    output = Diagnostic.formatSeverity(output, severity);\n    output = output.write(severity.label);\n    output = OutputStyle.reset(output);\n    output = OutputStyle.bold(output);\n    output = output.write(58/*':'*/);\n    if (message !== void 0) {\n      output = output.write(32/*' '*/).write(message);\n    }\n    output = OutputStyle.reset(output);\n    return output;\n  }\n\n  private static displayAnchor<T>(output: Output<T>, input: Input,\n                                  start: Mark, lineDigits: number): Output<T> {\n    output = Diagnostic.displayLineLeadArrow(output, lineDigits);\n    output = output.write(32/*' '*/);\n    const id = input.id;\n    if (id !== void 0) {\n      output = Format.displayAny(output, id);\n    }\n    output = output.write(58/*':'*/);\n    output = Format.displayNumber(output, start.line);\n    output = output.write(58/*':'*/);\n    output = Format.displayNumber(output, start.column);\n    output = output.writeln();\n\n    output = Diagnostic.displayLineLead(output, lineDigits);\n    return output;\n  }\n\n  private static displayContext<T>(output: Output<T>, input: Input, start: Mark, end: Mark,\n                                   severity: Severity, note: string | undefined,\n                                   cause: Diagnostic | null, contextLines: number,\n                                   lineDigits: number): [Diagnostic | null, Output<T>] {\n    let next = cause;\n    const sameCause = cause !== null && cause.message === void 0 && Values.equal(input.id, cause.input.id);\n    const causeOrder = sameCause ? (start.offset <= cause!.tag.start.offset ? -1 : 1) : 0;\n    if (causeOrder === 1) {\n      const cont = Diagnostic.displayContext(output, cause!.input.clone(), cause!.tag.start,\n                                             cause!.tag.end, cause!.severity, cause!.note,\n                                             cause!.cause, contextLines, lineDigits);\n      next = cont[0];\n      output = cont[1];\n      output = output.writeln();\n      output = Diagnostic.displayLineLeadEllipsis(output, lineDigits);\n      output = output.writeln();\n    }\n    output = Diagnostic.displayLines(output, input, start, end, severity, contextLines, lineDigits);\n    if (note !== void 0) {\n      output = Diagnostic.displayNote(output, note, lineDigits);\n    }\n    if (causeOrder === -1) {\n      output = output.writeln();\n      output = Diagnostic.displayLineLeadEllipsis(output, lineDigits);\n      output = output.writeln();\n      const cont = Diagnostic.displayContext(output, cause!.input.clone(), cause!.tag.start,\n                                             cause!.tag.end, cause!.severity, cause!.note,\n                                             cause!.cause, contextLines, lineDigits);\n      next = cont[0];\n      output = cont[1];\n    }\n    return [next, output];\n  }\n\n  private static displayLines<T>(output: Output<T>, input: Input, start: Mark, end: Mark,\n                                 severity: Severity, contextLines: number,\n                                 lineDigits: number): Output<T> {\n    const startLine = start.line;\n    const endLine = end.line;\n    let line = input.line;\n\n    while (line < startLine) {\n      Diagnostic.consumeLineText(input, line);\n      line += 1;\n    }\n\n    if (endLine - startLine > 2 * contextLines + 2) {\n      while (line <= startLine + contextLines) {\n        output = Diagnostic.displayLine(output, input, start, end, severity, line, lineDigits);\n        line += 1;\n      }\n      output = Diagnostic.displayLineLeadEllipsis(output, lineDigits);\n      output = output.write(32/*' '*/);\n      output = Diagnostic.formatSeverity(output, severity);\n      output = output.write(124/*'|'*/);\n      output = OutputStyle.reset(output);\n      output = output.writeln();\n      while (line < endLine - contextLines) {\n        Diagnostic.consumeLineText(input, line);\n        line += 1;\n      }\n    }\n\n    while (line <= endLine) {\n      output = Diagnostic.displayLine(output, input, start, end, severity, line, lineDigits);\n      line += 1;\n    }\n    return output;\n  }\n\n  private static displayNote<T>(output: Output<T>, note: string | undefined, lineDigits: number): Output<T> {\n    output = output.writeln();\n    output = Diagnostic.displayLineLead(output, lineDigits);\n    output = output.writeln();\n    output = Diagnostic.displayLineComment(output, 'note', note, lineDigits);\n    return output;\n  }\n\n  private static displayLine<T>(output: Output<T>, input: Input, start: Mark, end: Mark,\n                                severity: Severity, line: number, lineDigits: number): Output<T> {\n    if (start.line === line && end.line === line) {\n      output = Diagnostic.displaySingleLine(output, input, start, end, severity, line, lineDigits);\n    } else if (start.line === line) {\n      output = Diagnostic.displayStartLine(output, input, start, severity, line, lineDigits);\n    } else if (end.line === line) {\n      output = Diagnostic.displayEndLine(output, input, end, severity, line, lineDigits);\n    } else {\n      output = Diagnostic.displayMidLine(output, input, severity, line, lineDigits);\n    }\n    return output;\n  }\n\n  private static displaySingleLine<T>(output: Output<T>, input: Input, start: Mark, end: Mark,\n                                      severity: Severity, line: number, lineDigits: number): Output<T> {\n    output = Diagnostic.displayLineLeadNumber(output, line, lineDigits);\n    output = output.write(32/*' '*/);\n    for (let i = 1; i < input.column; i += 1) {\n      output = output.write(32/*' '*/);\n    }\n    output = Diagnostic.displayLineText(output, input, line);\n\n    output = Diagnostic.displayLineLead(output, lineDigits);\n    output = output.write(32/*' '*/);\n    let i = 1;\n    while (i < start.column) {\n      output = output.write(32/*' '*/);\n      i += 1;\n    }\n    output = Diagnostic.formatSeverity(output, severity);\n    while (i <= end.column) {\n      output = output.write(94/*'^'*/);\n      i += 1;\n    }\n    if (end.note !== void 0) {\n      output = output.write(32/*' '*/).write(end.note);\n    }\n    output = OutputStyle.reset(output);\n    return output;\n  }\n\n  private static displayStartLine<T>(output: Output<T>, input: Input, start: Mark,\n                                     severity: Severity, line: number, lineDigits: number): Output<T> {\n    output = Diagnostic.displayLineLeadNumber(output, line, lineDigits);\n    output = output.write(32/*' '*/).write(32/*' '*/).write(32/*' '*/);\n    for (let i = 1; i < input.column; i += 1) {\n      output = output.write(32/*' '*/);\n    }\n    output = Diagnostic.displayLineText(output, input, line);\n\n    output = Diagnostic.displayLineLead(output, lineDigits);\n    output = output.write(32/*' '*/).write(32/*' '*/);\n    output = Diagnostic.formatSeverity(output, severity);\n    output = output.write(95/*'_'*/);\n    let i = 1;\n    while (i < start.column) {\n      output = output.write(95/*'_'*/);\n      i += 1;\n    }\n    output = output.write(94/*'^'*/);\n    if (start.note !== void 0) {\n      output = output.write(32/*' '*/).write(start.note);\n    }\n    output = OutputStyle.reset(output);\n    output = output.writeln();\n    return output;\n  }\n\n  private static displayEndLine<T>(output: Output<T>, input: Input, end: Mark,\n                                   severity: Severity, line: number, lineDigits: number): Output<T> {\n    output = Diagnostic.displayLineLeadNumber(output, line, lineDigits);\n    output = output.write(32/*' '*/);\n    output = Diagnostic.formatSeverity(output, severity);\n    output = output.write(124/*'|'*/);\n    output = OutputStyle.reset(output);\n    output = output.write(32/*' '*/);\n    output = Diagnostic.displayLineText(output, input, line);\n\n    output = Diagnostic.displayLineLead(output, lineDigits);\n    output = output.write(32/*' '*/);\n    output = Diagnostic.formatSeverity(output, severity);\n    output = output.write(124/*'|'*/).write(95/*'_'*/);\n    let i = 1;\n    while (i < end.column) {\n      output = output.write(95/*'_'*/);\n      i += 1;\n    }\n    output = output.write(94/*'^'*/);\n    if (end.note !== void 0) {\n      output = output.write(32/*' '*/).write(end.note);\n    }\n    output = OutputStyle.reset(output);\n    return output;\n  }\n\n  private static displayMidLine<T>(output: Output<T>, input: Input, severity: Severity,\n                                   line: number, lineDigits: number): Output<T> {\n    output = Diagnostic.displayLineLeadNumber(output, line, lineDigits);\n    output = output.write(32/*' '*/);\n    output = Diagnostic.formatSeverity(output, severity);\n    output = output.write(124/*'|'*/);\n    output = OutputStyle.reset(output);\n    output = output.write(32/*' '*/);\n    output = Diagnostic.displayLineText(output, input, line);\n    return output;\n  }\n\n  private static displayLineComment<T>(output: Output<T>, label: string,\n                                       comment: string | undefined, lineDigits: number): Output<T> {\n    output = Diagnostic.displayLineLeadComment(output, lineDigits);\n    output = output.write(32/*' '*/);\n    output = OutputStyle.bold(output);\n    output = output.write(label).write(58/*':'*/);\n    output = OutputStyle.reset(output);\n    if (comment !== void 0) {\n      output = output.write(32/*' '*/).write(comment);\n    }\n    return output;\n  }\n\n  private static displayLineLead<T>(output: Output<T>, lineDigits: number): Output<T> {\n    output = OutputStyle.blueBold(output);\n    const padding = 1 + lineDigits;\n    for (let i = 0; i < padding; i += 1) {\n      output = output.write(32/*' '*/);\n    }\n    output = output.write(124/*'|'*/);\n    output = OutputStyle.reset(output);\n    return output;\n  }\n\n  private static displayLineLeadComment<T>(output: Output<T>, lineDigits: number): Output<T> {\n    output = OutputStyle.blueBold(output);\n    const padding = 1 + lineDigits;\n    for (let i = 0; i < padding; i += 1) {\n      output = output.write(32/*' '*/);\n    }\n    output = output.write(61/*'='*/);\n    output = OutputStyle.reset(output);\n    return output;\n  }\n\n  private static displayLineLeadArrow<T>(output: Output<T>, lineDigits: number): Output<T> {\n    for (let i = 0; i < lineDigits; i += 1) {\n      output = output.write(32/*' '*/);\n    }\n    output = OutputStyle.blueBold(output);\n    output = output.write(45/*'-'*/).write(45/*'-'*/).write(62/*'>'*/);\n    output = OutputStyle.reset(output);\n    return output;\n  }\n\n  private static displayLineLeadEllipsis<T>(output: Output<T>, lineDigits: number): Output<T> {\n    output = OutputStyle.blueBold(output);\n    for (let i = 0; i < lineDigits; i += 1) {\n      output = output.write(46/*'.'*/);\n    }\n    output = OutputStyle.reset(output);\n    output = output.write(32/*' '*/).write(32/*' '*/);\n    return output;\n  }\n\n  private static displayLineLeadNumber<T>(output: Output<T>, line: number, lineDigits: number): Output<T> {\n    const padding = lineDigits - Base10.countDigits(line);\n    for (let i = 0; i < padding; i += 1) {\n      output = output.write(32/*' '*/);\n    }\n    output = OutputStyle.blueBold(output);\n    output = Format.displayNumber(output, line);\n    output = output.write(32/*' '*/).write(124/*'|'*/);\n    output = OutputStyle.reset(output);\n    return output;\n  }\n\n  private static displayLineText<T>(output: Output<T>, input: Input, line: number): Output<T> {\n    while (input.isCont() && input.line === line) {\n      output = output.write(input.head());\n      input = input.step();\n    }\n    if (input.line === line) {\n      output = output.writeln();\n    }\n    return output;\n  }\n\n  private static consumeLineText(input: Input, line: number): void {\n    while (input.isCont() && input.line === line) {\n      input = input.step();\n    }\n  }\n\n  private static formatSeverity<T>(output: Output<T>, severity: Severity): Output<T> {\n    switch (severity.level) {\n      case Severity.FatalLevel:\n      case Severity.AlertLevel:\n      case Severity.ErrorLevel:\n        output = OutputStyle.redBold(output);\n        break;\n      case Severity.WarningLevel:\n        output = OutputStyle.yellowBold(output);\n        break;\n      case Severity.NoteLevel:\n        output = OutputStyle.greenBold(output);\n        break;\n      case Severity.InfoLevel:\n        output = OutputStyle.cyanBold(output);\n        break;\n      case Severity.DebugLevel:\n      case Severity.TraceLevel:\n      default:\n        output = OutputStyle.magentaBold(output);\n    }\n    return output;\n  }\n\n  toString(settings?: OutputSettings): string {\n    return Format.display(this, settings);\n  }\n\n  static create(input: Input, tag: Tag, severity: Severity, cause?: Diagnostic | null): Diagnostic;\n  static create(input: Input, tag: Tag, severity: Severity, message: string | undefined,\n                cause?: Diagnostic | null): Diagnostic;\n  static create(input: Input, tag: Tag, severity: Severity, message: string | undefined,\n                note: string | undefined, cause?: Diagnostic | null): Diagnostic;\n  static create(input: Input, tag: Tag, severity: Severity, message?: Diagnostic | null | string | undefined,\n                note?: Diagnostic | null | string | undefined, cause?: Diagnostic | null): Diagnostic {\n    if (arguments.length === 3) { // (input, tag, severity)\n      cause = null;\n      note = void 0;\n      message = void 0;\n    } else if (arguments.length === 4) {\n      if (message === null || message instanceof Diagnostic) { // (input, tag, severity, cause)\n        cause = message;\n        message = void 0;\n      } else { // (input, tag, severity, message)\n        cause = null;\n      }\n    } else if (arguments.length === 5) {\n      if (note === null || note instanceof Diagnostic) { // (input, tag, severity, message, cause)\n        cause = note;\n        note = void 0;\n      } else { // (input, tag, severity, message, note)\n        cause = null;\n      }\n    } else { // (input, tag, severity, message, note, cause)\n      if (cause === void 0) {\n        cause = null;\n      }\n    }\n    return new Diagnostic(input.clone(), tag, severity, message as string | undefined, note as string | undefined, cause);\n  }\n\n  static message(message: string, input: Input, cause?: Diagnostic | null): Diagnostic;\n  static message(message: string, input: Input, note: string, cause?: Diagnostic | null): Diagnostic;\n  static message(message: string, input: Input, severity: Severity, cause?: Diagnostic | null): Diagnostic;\n  static message(message: string, input: Input, severity?: Severity, note?: string, cause?: Diagnostic | null): Diagnostic;\n  static message(message: string, input: Input, severity?: Diagnostic | null | Severity | string | undefined,\n                 note?: Diagnostic | null | string | undefined, cause?: Diagnostic | null): Diagnostic {\n    if (arguments.length === 2) { // (message, input)\n      cause = null;\n      note = void 0;\n      severity = Severity.error();\n    } else if (arguments.length === 3) {\n      if (severity === null || severity instanceof Diagnostic) { // (message, input, cause)\n        cause = severity;\n        severity = Severity.error();\n      } else if (typeof severity === \"string\") { // (message, input, note)\n        cause = null;\n        note = severity;\n        severity = Severity.error();\n      } else { // (message, input, severity)\n        cause = null;\n      }\n    } else if (arguments.length === 4) {\n      if (typeof severity === \"string\") { // (message, input, note, cause)\n        cause = note as Diagnostic | null;\n        note = severity;\n        severity = Severity.error();\n      } else if (note === null || note instanceof Diagnostic) { // (message, input, severity, cause)\n        cause = note;\n        note = void 0;\n      } else { // (message, input, severity, note)\n        cause = null;\n      }\n    } else { // (message, input, severity, note, cause)\n      if (cause === void 0) {\n        cause = null;\n      }\n    }\n\n    const mark = input.mark;\n    const source = input.clone();\n    source.seek();\n    return new Diagnostic(source, mark, severity as Severity, message, note as string | undefined, cause);\n  }\n\n  static unexpected(input: Input, cause?: Diagnostic | null): Diagnostic;\n  static unexpected(input: Input, note: string, cause?: Diagnostic | null): Diagnostic;\n  static unexpected(input: Input, severity: Severity, cause?: Diagnostic | null): Diagnostic;\n  static unexpected(input: Input, severity?: Severity, note?: string, cause?: Diagnostic | null): Diagnostic;\n  static unexpected(input: Input, severity?: Diagnostic | null | Severity | string | undefined,\n                    note?: Diagnostic | null | string | undefined, cause?: Diagnostic | null): Diagnostic {\n    if (arguments.length === 1) { // (input)\n      cause = null;\n      severity = Severity.error();\n    } else if (arguments.length === 2) {\n      if (severity === null || severity instanceof Diagnostic) { // (input, cause)\n        cause = severity;\n        severity = Severity.error();\n      } else if (typeof severity === \"string\") { // (input, note)\n        cause = null;\n        note = severity;\n        severity = Severity.error();\n      } else { // (input, severity)\n        cause = null;\n      }\n    } else if (arguments.length === 3) {\n      if (typeof severity === \"string\") { // (input, note, cause)\n        cause = note as Diagnostic | null;\n        note = severity;\n        severity = Severity.error();\n      } else if (note === null || note instanceof Diagnostic) { // (input, severity, cause)\n        cause = note;\n        note = void 0;\n      } else { // (input, severity, note)\n        cause = null;\n      }\n    } else { // (input, severity, note, cause)\n      if (cause === void 0) {\n        cause = null;\n      }\n    }\n\n    let message;\n    if (input.isCont()) {\n      let output = Unicode.stringOutput().write(\"unexpected\").write(32/*' '*/);\n      output = Format.debugChar(output, input.head());\n      message = output.bind();\n    } else {\n      message = \"unexpected end of input\";\n    }\n    const mark = input.mark;\n    const source = input.clone();\n    source.seek();\n    return new Diagnostic(source, mark, severity as Severity, message, note as string | undefined, cause);\n  }\n\n  static expected(expected: string | number, input: Input, cause?: Diagnostic | null): Diagnostic;\n  static expected(expected: string | number, input: Input, note: string, cause?: Diagnostic | null): Diagnostic;\n  static expected(expected: string | number, input: Input, severity: Severity, cause?: Diagnostic | null): Diagnostic;\n  static expected(expected: string | number, input: Input, severity?: Severity, note?: string, cause?: Diagnostic | null): Diagnostic;\n  static expected(expected: string | number, input: Input, severity?: Diagnostic | null | Severity | string | undefined,\n                  note?: Diagnostic | null | string | undefined, cause?: Diagnostic | null): Diagnostic {\n    if (arguments.length === 2) { // (excpected, input)\n      cause = null;\n      severity = Severity.error();\n    } else if (arguments.length === 3) {\n      if (severity === null || severity instanceof Diagnostic) { // (excpected, input, cause)\n        cause = severity;\n        severity = Severity.error();\n      } else if (typeof severity === \"string\") { // (excpected, input, note)\n        cause = null;\n        note = severity;\n        severity = Severity.error();\n      } else { // (expected, input, severity)\n        cause = null;\n      }\n    } else if (arguments.length === 4) {\n      if (typeof severity === \"string\") { // (excpected, input, note, cause)\n        cause = note as Diagnostic | null;\n        note = severity;\n        severity = Severity.error();\n      } else if (note === null || note instanceof Diagnostic) { // (excpected, input, severity, cause)\n        cause = note;\n        note = void 0;\n      } else { // (excpected, input, severity, note)\n        cause = null;\n      }\n    } else { // (excpected, input, severity, note, cause)\n      if (cause === void 0) {\n        cause = null;\n      }\n    }\n\n    let output = Unicode.stringOutput().write(\"expected\").write(32/*' '*/);\n    if (typeof expected === \"number\") {\n      output = Format.debugChar(output, expected);\n    } else {\n      output = output.write(expected);\n    }\n    output = output.write(44/*','*/).write(32/*' '*/).write(\"but found\").write(32/*' '*/);\n    if (input.isCont()) {\n      output = Format.debugChar(output, input.head());\n    } else {\n      output = output.write(\"end of input\");\n    }\n    const message = output.bind();\n    const mark = input.mark;\n    const source = input.clone();\n    source.seek();\n    return new Diagnostic(source, mark, severity as Severity, message, note as string | undefined, cause);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mark} from \"../source/Mark\";\nimport {InputException} from \"./InputException\";\nimport type {InputSettingsLike} from \"./InputSettings\";\nimport {InputSettings} from \"./InputSettings\";\nimport {Input} from \"./Input\";\nimport {InputDone} from \"../\"; // forward import\nimport {InputError} from \"../\"; // forward import\n\n/** @internal */\nexport class InputEmpty extends Input {\n  constructor(id: string | undefined, mark: Mark, settings: InputSettings) {\n    super();\n    Object.defineProperty(this, \"id\", {\n      value: id,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"mark\", {\n      value: mark,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"settings\", {\n      value: settings,\n      enumerable: true,\n    });\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isEmpty(): boolean {\n    return true;\n  }\n\n  override isDone(): boolean {\n    return false;\n  }\n\n  override isError(): boolean {\n    return false;\n  }\n\n  override isPart(): boolean {\n    return true;\n  }\n\n  override asPart(part: boolean): Input {\n    return part ? this : new InputDone(this.id, this.mark, this.settings);\n  }\n\n  override head(): number {\n    throw new InputException();\n  }\n\n  override step(): Input {\n    const error = new InputException(\"empty step\");\n    return new InputError(error, this.id, this.mark, this.settings);\n  }\n\n  override seek(mark?: Mark): Input {\n    const error = new InputException(\"empty seek\");\n    return new InputError(error, this.id, this.mark, this.settings);\n  }\n\n  override readonly id!: string | undefined;\n\n  override withId(id: string | undefined): Input {\n    return new InputEmpty(id, this.mark, this.settings);\n  }\n\n  override readonly mark!: Mark;\n\n  override withMark(mark: Mark): Input {\n    return new InputEmpty(this.id, mark, this.settings);\n  }\n\n  override get offset(): number {\n    return this.mark.offset;\n  }\n\n  override get line(): number {\n    return this.mark.line;\n  }\n\n  override get column(): number {\n    return this.mark.column;\n  }\n\n  override readonly settings!: InputSettings;\n\n  override withSettings(settings: InputSettingsLike): Input {\n    settings = InputSettings.fromLike(settings);\n    return new InputEmpty(this.id, this.mark, settings);\n  }\n\n  override clone(): Input {\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mark} from \"../source/Mark\";\nimport {InputException} from \"./InputException\";\nimport type {InputSettingsLike} from \"./InputSettings\";\nimport {InputSettings} from \"./InputSettings\";\nimport {Input} from \"./Input\";\nimport {InputEmpty} from \"../\"; // forward import\nimport {InputError} from \"../\"; // forward import\n\n/** @internal */\nexport class InputDone extends Input {\n  constructor(id: string | undefined, mark: Mark, settings: InputSettings) {\n    super();\n    Object.defineProperty(this, \"id\", {\n      value: id,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"mark\", {\n      value: mark,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"settings\", {\n      value: settings,\n      enumerable: true,\n    });\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isEmpty(): boolean {\n    return false;\n  }\n\n  override isDone(): boolean {\n    return true;\n  }\n\n  override isError(): boolean {\n    return false;\n  }\n\n  override isPart(): boolean {\n    return false;\n  }\n\n  override asPart(part: boolean): Input {\n    return part ? new InputEmpty(this.id, this.mark, this.settings) : this;\n  }\n\n  override head(): number {\n    throw new InputException();\n  }\n\n  override step(): Input {\n    const error = new InputException(\"done step\");\n    return new InputError(error, this.id, this.mark, this.settings);\n  }\n\n  override seek(mark?: Mark): Input {\n    const error = new InputException(\"empty seek\");\n    return new InputError(error, this.id, this.mark, this.settings);\n  }\n\n  override readonly id!: string | undefined;\n\n  override withId(id: string | undefined): Input {\n    return new InputDone(id, this.mark, this.settings);\n  }\n\n  override readonly mark!: Mark;\n\n  override withMark(mark: Mark): Input {\n    return new InputDone(this.id, mark, this.settings);\n  }\n\n  override get offset(): number {\n    return this.mark.offset;\n  }\n\n  override get line(): number {\n    return this.mark.line;\n  }\n\n  override get column(): number {\n    return this.mark.column;\n  }\n\n  override readonly settings!: InputSettings;\n\n  override withSettings(settings: InputSettingsLike): Input {\n    settings = InputSettings.fromLike(settings);\n    return new InputDone(this.id, this.mark, settings);\n  }\n\n  override clone(): Input {\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport {Mark} from \"../source/Mark\";\nimport type {InputSettingsLike} from \"./InputSettings\";\nimport {InputSettings} from \"./InputSettings\";\nimport {Input} from \"./Input\";\nimport {InputBufferEmpty} from \"../\"; // forward import\nimport {InputBufferDone} from \"../\"; // forward import\nimport {InputBufferError} from \"../\"; // forward import\n\n/**\n * Non-blocking token stream buffer.\n * @public\n */\nexport abstract class InputBuffer extends Input {\n  abstract override asPart(part: boolean): InputBuffer;\n\n  abstract readonly index: number;\n\n  abstract withIndex(index: number): InputBuffer;\n\n  abstract readonly limit: number;\n\n  abstract withLimit(limit: number): InputBuffer;\n\n  abstract readonly capacity: number;\n\n  abstract readonly remaining: number;\n\n  abstract has(index: number): boolean;\n\n  abstract get(index: number): number;\n\n  abstract set(index: number, token: number): void;\n\n  abstract override step(offset?: number): InputBuffer;\n\n  abstract override seek(mark: Mark): InputBuffer;\n\n  abstract override withId(id: string | undefined): InputBuffer;\n\n  abstract override withMark(mark: Mark): InputBuffer;\n\n  abstract override withSettings(settings: InputSettingsLike): InputBuffer;\n\n  abstract override clone(): InputBuffer;\n\n  /**\n   * Returns an `InputBuffer` in the _empty_ state.\n   */\n  @Lazy\n  static override empty(): InputBuffer {\n    return new InputBufferEmpty(void 0, Mark.zero, InputSettings.standard());\n  }\n\n  /**\n   * Returns an `InputBuffer` in the _done_ state.\n   */\n  @Lazy\n  static override done(): InputBuffer {\n    return new InputBufferDone(void 0, Mark.zero, InputSettings.standard());\n  }\n\n  /**\n   * Returns an `InputBuffer` in the _error_ state that traps the given `error`.\n   */\n  static override error(error: Error): InputBuffer {\n    return new InputBufferError(error, void 0, Mark.zero, InputSettings.standard());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mark} from \"../source/Mark\";\nimport {InputException} from \"./InputException\";\nimport type {InputSettingsLike} from \"./InputSettings\";\nimport {InputSettings} from \"./InputSettings\";\nimport {InputBuffer} from \"./InputBuffer\";\nimport {InputBufferDone} from \"../\"; // forward import\nimport {InputBufferError} from \"../\"; // forward import\n\n/** @internal */\nexport class InputBufferEmpty extends InputBuffer {\n  constructor(id: string | undefined, mark: Mark, settings: InputSettings) {\n    super();\n    Object.defineProperty(this, \"id\", {\n      value: id,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"mark\", {\n      value: mark,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"settings\", {\n      value: settings,\n      enumerable: true,\n    });\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isEmpty(): boolean {\n    return true;\n  }\n\n  override isDone(): boolean {\n    return false;\n  }\n\n  override isError(): boolean {\n    return false;\n  }\n\n  override isPart(): boolean {\n    return true;\n  }\n\n  override asPart(part: boolean): InputBuffer {\n    return part ? this : new InputBufferDone(this.id, this.mark, this.settings);\n  }\n\n  override get index(): number {\n    return 0;\n  }\n\n  override withIndex(index: number): InputBuffer {\n    if (index === 0) {\n      return this;\n    } else {\n      const error = new InputException(\"invalid index\");\n      return new InputBufferError(error, this.id, this.mark, this.settings);\n    }\n  }\n\n  override get limit(): number {\n    return 0;\n  }\n\n  override withLimit(limit: number): InputBuffer {\n    if (limit === 0) {\n      return this;\n    } else {\n      const error = new InputException(\"invalid limit\");\n      return new InputBufferError(error, this.id, this.mark, this.settings);\n    }\n  }\n\n  override get capacity(): number {\n    return 0;\n  }\n\n  override get remaining(): number {\n    return 0;\n  }\n\n  override has(index: number): boolean {\n    return false;\n  }\n\n  override get(index: number): number {\n    throw new InputException();\n  }\n\n  override set(index: number, token: number): void {\n    throw new InputException();\n  }\n\n  override head(): number {\n    throw new InputException();\n  }\n\n  override step(offset?: number): InputBuffer {\n    const error = new InputException(\"empty step\");\n    return new InputBufferError(error, this.id, this.mark, this.settings);\n  }\n\n  override seek(mark: Mark): InputBuffer {\n    const error = new InputException(\"empty seek\");\n    return new InputBufferError(error, this.id, this.mark, this.settings);\n  }\n\n  override readonly id!: string | undefined;\n\n  override withId(id: string | undefined): InputBuffer {\n    return new InputBufferEmpty(id, this.mark, this.settings);\n  }\n\n  override readonly mark!: Mark;\n\n  override withMark(mark: Mark): InputBuffer {\n    return new InputBufferEmpty(this.id, mark, this.settings);\n  }\n\n  override get offset(): number {\n    return this.mark.offset;\n  }\n\n  override get line(): number {\n    return this.mark.line;\n  }\n\n  override get column(): number {\n    return this.mark.column;\n  }\n\n  override readonly settings!: InputSettings;\n\n  override withSettings(settings: InputSettingsLike): InputBuffer {\n    settings = InputSettings.fromLike(settings);\n    return new InputBufferEmpty(this.id, this.mark, settings);\n  }\n\n  override clone(): InputBuffer {\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mark} from \"../source/Mark\";\nimport {InputException} from \"./InputException\";\nimport type {InputSettingsLike} from \"./InputSettings\";\nimport {InputSettings} from \"./InputSettings\";\nimport {InputBuffer} from \"./InputBuffer\";\nimport {InputBufferEmpty} from \"../\"; // forward import\nimport {InputBufferError} from \"../\"; // forward import\n\n/** @internal */\nexport class InputBufferDone extends InputBuffer {\n  constructor(id: string | undefined, mark: Mark, settings: InputSettings) {\n    super();\n    Object.defineProperty(this, \"id\", {\n      value: id,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"mark\", {\n      value: mark,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"settings\", {\n      value: settings,\n      enumerable: true,\n    });\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isEmpty(): boolean {\n    return false;\n  }\n\n  override isDone(): boolean {\n    return true;\n  }\n\n  override isError(): boolean {\n    return false;\n  }\n\n  override isPart(): boolean {\n    return false;\n  }\n\n  override asPart(part: boolean): InputBuffer {\n    return part ? new InputBufferEmpty(this.id, this.mark, this.settings) : this;\n  }\n\n  override get index(): number {\n    return 0;\n  }\n\n  override withIndex(index: number): InputBuffer {\n    if (index === 0) {\n      return this;\n    } else {\n      const error = new InputException(\"invalid index\");\n      return new InputBufferError(error, this.id, this.mark, this.settings);\n    }\n  }\n\n  override get limit(): number {\n    return 0;\n  }\n\n  override withLimit(limit: number): InputBuffer {\n    if (limit === 0) {\n      return this;\n    } else {\n      const error = new InputException(\"invalid limit\");\n      return new InputBufferError(error, this.id, this.mark, this.settings);\n    }\n  }\n\n  override get capacity(): number {\n    return 0;\n  }\n\n  override get remaining(): number {\n    return 0;\n  }\n\n  override has(index: number): boolean {\n    return false;\n  }\n\n  override get(index: number): number {\n    throw new InputException();\n  }\n\n  override set(index: number, token: number): void {\n    throw new InputException();\n  }\n\n  override head(): number {\n    throw new InputException();\n  }\n\n  override step(offset?: number): InputBuffer {\n    const error = new InputException(\"done step\");\n    return new InputBufferError(error, this.id, this.mark, this.settings);\n  }\n\n  override seek(mark: Mark): InputBuffer {\n    const error = new InputException(\"done seek\");\n    return new InputBufferError(error, this.id, this.mark, this.settings);\n  }\n\n  override readonly id!: string | undefined;\n\n  override withId(id: string | undefined): InputBuffer {\n    return new InputBufferDone(id, this.mark, this.settings);\n  }\n\n  override readonly mark!: Mark;\n\n  override withMark(mark: Mark): InputBuffer {\n    return new InputBufferDone(this.id, mark, this.settings);\n  }\n\n  override get offset(): number {\n    return this.mark.offset;\n  }\n\n  override get line(): number {\n    return this.mark.line;\n  }\n\n  override get column(): number {\n    return this.mark.column;\n  }\n\n  override readonly settings!: InputSettings;\n\n  override withSettings(settings: InputSettingsLike): InputBuffer {\n    settings = InputSettings.fromLike(settings);\n    return new InputBufferDone(this.id, this.mark, settings);\n  }\n\n  override clone(): InputBuffer {\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mark} from \"../source/Mark\";\nimport {InputException} from \"./InputException\";\nimport type {InputSettingsLike} from \"./InputSettings\";\nimport {InputSettings} from \"./InputSettings\";\nimport {InputBuffer} from \"./InputBuffer\";\n\n/** @internal */\nexport class InputBufferError extends InputBuffer {\n  /** @internal */\n  readonly error!: Error;\n\n  constructor(error: Error, id: string | undefined, mark: Mark, settings: InputSettings) {\n    super();\n    Object.defineProperty(this, \"error\", {\n      value: error,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"id\", {\n      value: id,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"mark\", {\n      value: mark,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"settings\", {\n      value: settings,\n      enumerable: true,\n    });\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isEmpty(): boolean {\n    return false;\n  }\n\n  override isDone(): boolean {\n    return false;\n  }\n\n  override isError(): boolean {\n    return true;\n  }\n\n  override isPart(): boolean {\n    return false;\n  }\n\n  override asPart(part: boolean): InputBuffer {\n    return this;\n  }\n\n  override get index(): number {\n    return 0;\n  }\n\n  override withIndex(index: number): InputBuffer {\n    if (index === 0) {\n      return this;\n    } else {\n      const error = new InputException(\"invalid index\");\n      return new InputBufferError(error, this.id, this.mark, this.settings);\n    }\n  }\n\n  override get limit(): number {\n    return 0;\n  }\n\n  override withLimit(limit: number): InputBuffer {\n    if (limit === 0) {\n      return this;\n    } else {\n      const error = new InputException(\"invalid limit\");\n      return new InputBufferError(error, this.id, this.mark, this.settings);\n    }\n  }\n\n  override get capacity(): number {\n    return 0;\n  }\n\n  override get remaining(): number {\n    return 0;\n  }\n\n  override has(index: number): boolean {\n    return false;\n  }\n\n  override get(index: number): number {\n    throw new InputException();\n  }\n\n  override set(index: number, token: number): void {\n    throw new InputException();\n  }\n\n  override head(): number {\n    throw new InputException();\n  }\n\n  override step(offset?: number): InputBuffer {\n    const error = new InputException(\"error step\");\n    return new InputBufferError(error, this.id, this.mark, this.settings);\n  }\n\n  override trap(): Error {\n    return this.error;\n  }\n\n  override seek(mark: Mark): InputBuffer {\n    const error = new InputException(\"error seek\");\n    return new InputBufferError(error, this.id, this.mark, this.settings);\n  }\n\n  override readonly id!: string | undefined;\n\n  withId(id: string | undefined): InputBuffer {\n    return new InputBufferError(this.error, id, this.mark, this.settings);\n  }\n\n  override readonly mark!: Mark;\n\n  override withMark(mark: Mark): InputBuffer {\n    return new InputBufferError(this.error, this.id, mark, this.settings);\n  }\n\n  override get offset(): number {\n    return this.mark.offset;\n  }\n\n  override get line(): number {\n    return this.mark.line;\n  }\n\n  override get column(): number {\n    return this.mark.column;\n  }\n\n  override readonly settings!: InputSettings;\n\n  override withSettings(settings: InputSettingsLike): InputBuffer {\n    settings = InputSettings.fromLike(settings);\n    return new InputBufferError(this.error, this.id, this.mark, settings);\n  }\n\n  override clone(): InputBuffer {\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {OutputException} from \"./OutputException\";\nimport type {OutputSettingsLike} from \"./OutputSettings\";\nimport {OutputSettings} from \"./OutputSettings\";\nimport {Output} from \"./Output\";\nimport {OutputDone} from \"../\"; // forward import\nimport {OutputError} from \"../\"; // forward import\n\n/** @internal */\nexport class OutputFull extends Output<never> {\n  constructor(settings: OutputSettings) {\n    super();\n    Object.defineProperty(this, \"settings\", {\n      value: settings,\n      enumerable: true,\n    });\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isFull(): boolean {\n    return true;\n  }\n\n  override isDone(): boolean {\n    return false;\n  }\n\n  override isError(): boolean {\n    return false;\n  }\n\n  override isPart(): boolean {\n    return true;\n  }\n\n  override asPart(part: boolean): Output<never> {\n    return part ? this : new OutputDone(this.settings);\n  }\n\n  override write(token: number): Output<never>;\n  override write(string: string): Output<never>;\n  override write(tokenOrString: number | string): Output<never> {\n    return new OutputError(new OutputException(\"full\"), this.settings);\n  }\n\n  override writeln(string?: string): Output<never> {\n    return new OutputError(new OutputException(\"full\"), this.settings);\n  }\n\n  override bind(): never {\n    throw new OutputException();\n  }\n\n  override readonly settings!: OutputSettings;\n\n  override withSettings(settings: OutputSettingsLike): Output<never> {\n    settings = OutputSettings.fromLike(settings);\n    return new OutputFull(settings);\n  }\n\n  override clone(): Output<never> {\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {OutputException} from \"./OutputException\";\nimport type {OutputSettingsLike} from \"./OutputSettings\";\nimport {OutputSettings} from \"./OutputSettings\";\nimport {Output} from \"./Output\";\nimport {OutputFull} from \"../\"; // forward import\nimport {OutputError} from \"../\"; // forward import\n\n/** @internal */\nexport class OutputDone extends Output<never> {\n  constructor(settings: OutputSettings) {\n    super();\n    Object.defineProperty(this, \"settings\", {\n      value: settings,\n      enumerable: true,\n    });\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isFull(): boolean {\n    return false;\n  }\n\n  override isDone(): boolean {\n    return true;\n  }\n\n  override isError(): boolean {\n    return false;\n  }\n\n  override isPart(): boolean {\n    return false;\n  }\n\n  override asPart(part: boolean): Output<never> {\n    return part ? new OutputFull(this.settings) : this;\n  }\n\n  override write(token: number): Output<never>;\n  override write(string: string): Output<never>;\n  override write(tokenOrString: number | string): Output<never> {\n    return new OutputError(new OutputException(\"done\"), this.settings);\n  }\n\n  override writeln(string?: string): Output<never> {\n    return new OutputError(new OutputException(\"done\"), this.settings);\n  }\n\n  override bind(): never {\n    throw new OutputException();\n  }\n\n  override readonly settings!: OutputSettings;\n\n  override withSettings(settings: OutputSettingsLike): Output<never> {\n    settings = OutputSettings.fromLike(settings);\n    return new OutputDone(settings);\n  }\n\n  override clone(): Output<never> {\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {OutputException} from \"./OutputException\";\nimport type {OutputSettingsLike} from \"./OutputSettings\";\nimport {OutputSettings} from \"./OutputSettings\";\nimport {Output} from \"./Output\";\n\n/** @internal */\nexport class OutputError extends Output<never> {\n  /** @internal */\n  readonly error!: Error;\n\n  constructor(error: Error, settings: OutputSettings) {\n    super();\n    Object.defineProperty(this, \"error\", {\n      value: error,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"settings\", {\n      value: settings,\n      enumerable: true,\n    });\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isFull(): boolean {\n    return false;\n  }\n\n  override isDone(): boolean {\n    return false;\n  }\n\n  override isError(): boolean {\n    return true;\n  }\n\n  override isPart(): boolean {\n    return false;\n  }\n\n  override asPart(part: boolean): Output<never> {\n    return this;\n  }\n\n  override write(token: number): Output<never>;\n  override write(string: string): Output<never>;\n  override write(tokenOrString: number | string): Output<never> {\n    return this;\n  }\n\n  override writeln(string?: string): Output<never> {\n    return this;\n  }\n\n  override bind(): never {\n    throw new OutputException();\n  }\n\n  override trap(): Error {\n    return this.error;\n  }\n\n  override readonly settings!: OutputSettings;\n\n  override withSettings(settings: OutputSettingsLike): Output<never> {\n    settings = OutputSettings.fromLike(settings);\n    return new OutputError(this.error, settings);\n  }\n\n  override clone(): Output<never> {\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport type {OutputSettingsLike} from \"./OutputSettings\";\nimport {OutputSettings} from \"./OutputSettings\";\nimport {Output} from \"./Output\";\nimport {OutputBufferFull} from \"../\"; // forward import\nimport {OutputBufferDone} from \"../\"; // forward import\nimport {OutputBufferError} from \"../\"; // forward import\n\n/**\n * Non-blocking token stream buffer.\n * @public\n */\nexport abstract class OutputBuffer<T = unknown> extends Output<T> {\n  abstract override asPart(part: boolean): OutputBuffer<T>;\n\n  abstract readonly index: number;\n\n  abstract withIndex(index: number): OutputBuffer<T>;\n\n  abstract readonly limit: number;\n\n  abstract withLimit(limit: number): OutputBuffer<T>;\n\n  abstract readonly capacity: number;\n\n  abstract readonly remaining: number;\n\n  abstract has(index: number): boolean;\n\n  abstract get(index: number): number;\n\n  abstract set(index: number, token: number): void;\n\n  abstract override write(token: number): OutputBuffer<T>;\n  abstract override write(string: string): OutputBuffer<T>;\n\n  override writeln(string?: string): OutputBuffer<T> {\n    if (typeof string === \"string\") {\n      this.write(string);\n    }\n    return this.write(this.settings.lineSeparator);\n  }\n\n  abstract step(offset?: number): OutputBuffer<T>;\n\n  override flush(): OutputBuffer<T> {\n    return this;\n  }\n\n  abstract override withSettings(settings: OutputSettingsLike): Output<T>;\n\n  override clone(): OutputBuffer<T> {\n    throw new Error();\n  }\n\n  /**\n   * Returns an `OutputBuffer` in the _full_ state.\n   */\n  @Lazy\n  static override full(): OutputBuffer<never> {\n    return new OutputBufferFull(OutputSettings.standard());\n  }\n\n  /**\n   * Returns an `OutputBuffer` in the _done_ state.\n   */\n  @Lazy\n  static override done(): OutputBuffer<never> {\n    return new OutputBufferDone(OutputSettings.standard());\n  }\n\n  /**\n   * Returns an `OutputBuffer` in the _error_ state that traps the given `error`.\n   */\n  static override error(error: Error): OutputBuffer<never> {\n    return new OutputBufferError(error, OutputSettings.standard());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {OutputException} from \"./OutputException\";\nimport type {OutputSettingsLike} from \"./OutputSettings\";\nimport {OutputSettings} from \"./OutputSettings\";\nimport {OutputBuffer} from \"./OutputBuffer\";\nimport {OutputBufferDone} from \"../\"; // forward import\nimport {OutputBufferError} from \"../\"; // forward import\n\n/** @internal */\nexport class OutputBufferFull extends OutputBuffer<never> {\n  constructor(settings: OutputSettings) {\n    super();\n    Object.defineProperty(this, \"settings\", {\n      value: settings,\n      enumerable: true,\n    });\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isFull(): boolean {\n    return true;\n  }\n\n  override isDone(): boolean {\n    return false;\n  }\n\n  override isError(): boolean {\n    return false;\n  }\n\n  override isPart(): boolean {\n    return true;\n  }\n\n  override asPart(part: boolean): OutputBuffer<never> {\n    return part ? this : new OutputBufferDone(this.settings);\n  }\n\n  override get index(): number {\n    return 0;\n  }\n\n  override withIndex(index: number): OutputBuffer<never> {\n    if (index === 0) {\n      return this;\n    } else {\n      return new OutputBufferError(new OutputException(\"invalid index\"), this.settings);\n    }\n  }\n\n  override get limit(): number {\n    return 0;\n  }\n\n  override withLimit(limit: number): OutputBuffer<never> {\n    if (limit === 0) {\n      return this;\n    } else {\n      return new OutputBufferError(new OutputException(\"invalid limit\"), this.settings);\n    }\n  }\n\n  override get capacity(): number {\n    return 0;\n  }\n\n  override get remaining(): number {\n    return 0;\n  }\n\n  override has(index: number): boolean {\n    return false;\n  }\n\n  override get(index: number): number {\n    throw new OutputException();\n  }\n\n  override set(index: number, token: number): void {\n    throw new OutputException();\n  }\n\n  override write(token: number): OutputBuffer<never>;\n  override write(string: string): OutputBuffer<never>;\n  override write(tokenOrString: number | string): OutputBuffer<never> {\n    return new OutputBufferError(new OutputException(\"full\"), this.settings);\n  }\n\n  override writeln(string?: string): OutputBuffer<never> {\n    return new OutputBufferError(new OutputException(\"full\"), this.settings);\n  }\n\n  override step(offset: number = 1): OutputBuffer<never> {\n    if (offset === 0) {\n      return this;\n    } else {\n      return new OutputBufferError(new OutputException(\"invalid step\"), this.settings);\n    }\n  }\n\n  override bind(): never {\n    throw new OutputException();\n  }\n\n  override readonly settings!: OutputSettings;\n\n  override withSettings(settings: OutputSettingsLike): OutputBuffer<never> {\n    settings = OutputSettings.fromLike(settings);\n    return new OutputBufferFull(settings);\n  }\n\n  override clone(): OutputBuffer<never> {\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {OutputException} from \"./OutputException\";\nimport type {OutputSettingsLike} from \"./OutputSettings\";\nimport {OutputSettings} from \"./OutputSettings\";\nimport {OutputBuffer} from \"./OutputBuffer\";\nimport {OutputBufferFull} from \"../\"; // forward import\nimport {OutputBufferError} from \"../\"; // forward import\n\n/** @internal */\nexport class OutputBufferDone extends OutputBuffer<never> {\n  constructor(settings: OutputSettings) {\n    super();\n    Object.defineProperty(this, \"settings\", {\n      value: settings,\n      enumerable: true,\n    });\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isFull(): boolean {\n    return false;\n  }\n\n  override isDone(): boolean {\n    return true;\n  }\n\n  override isError(): boolean {\n    return false;\n  }\n\n  override isPart(): boolean {\n    return false;\n  }\n\n  override asPart(part: boolean): OutputBuffer<never> {\n    return part ? new OutputBufferFull(this.settings) : this;\n  }\n\n  override get index(): number {\n    return 0;\n  }\n\n  override withIndex(index: number): OutputBuffer<never> {\n    if (index === 0) {\n      return this;\n    } else {\n      return new OutputBufferError(new OutputException(\"invalid index\"), this.settings);\n    }\n  }\n\n  override get limit(): number {\n    return 0;\n  }\n\n  override withLimit(limit: number): OutputBuffer<never> {\n    if (limit === 0) {\n      return this;\n    } else {\n      return new OutputBufferError(new OutputException(\"invalid limit\"), this.settings);\n    }\n  }\n\n  override get capacity(): number {\n    return 0;\n  }\n\n  override get remaining(): number {\n    return 0;\n  }\n\n  override has(index: number): boolean {\n    return false;\n  }\n\n  override get(index: number): number {\n    throw new OutputException();\n  }\n\n  override set(index: number, token: number): void {\n    throw new OutputException();\n  }\n\n  override write(token: number): OutputBuffer<never>;\n  override write(string: string): OutputBuffer<never>;\n  override write(tokenOrString: number | string): OutputBuffer<never> {\n    return new OutputBufferError(new OutputException(\"done\"), this.settings);\n  }\n\n  override writeln(string?: string): OutputBuffer<never> {\n    return new OutputBufferError(new OutputException(\"done\"), this.settings);\n  }\n\n  override step(offset: number = 1): OutputBuffer<never> {\n    if (offset === 0) {\n      return this;\n    } else {\n      return new OutputBufferError(new OutputException(\"invalid step\"), this.settings);\n    }\n  }\n\n  override bind(): never {\n    throw new OutputException();\n  }\n\n  override readonly settings!: OutputSettings;\n\n  override withSettings(settings: OutputSettingsLike): OutputBuffer<never> {\n    settings = OutputSettings.fromLike(settings);\n    return new OutputBufferDone(settings);\n  }\n\n  override clone(): OutputBuffer<never> {\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {OutputException} from \"./OutputException\";\nimport type {OutputSettingsLike} from \"./OutputSettings\";\nimport {OutputSettings} from \"./OutputSettings\";\nimport {OutputBuffer} from \"./OutputBuffer\";\n\n/** @internal */\nexport class OutputBufferError extends OutputBuffer<never> {\n  /** @internal */\n  readonly error!: Error;\n\n  constructor(error: Error, settings: OutputSettings) {\n    super();\n    Object.defineProperty(this, \"error\", {\n      value: error,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"settings\", {\n      value: settings,\n      enumerable: true,\n    });\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isFull(): boolean {\n    return false;\n  }\n\n  override isDone(): boolean {\n    return false;\n  }\n\n  override isError(): boolean {\n    return true;\n  }\n\n  override isPart(): boolean {\n    return false;\n  }\n\n  override asPart(part: boolean): OutputBuffer<never> {\n    return this;\n  }\n\n  override get index(): number {\n    return 0;\n  }\n\n  override withIndex(index: number): OutputBuffer<never> {\n    if (index === 0) {\n      return this;\n    } else {\n      return new OutputBufferError(new OutputException(\"invalid index\"), this.settings);\n    }\n  }\n\n  override get limit(): number {\n    return 0;\n  }\n\n  override withLimit(limit: number): OutputBuffer<never> {\n    if (limit === 0) {\n      return this;\n    } else {\n      return new OutputBufferError(new OutputException(\"invalid limit\"), this.settings);\n    }\n  }\n\n  override get capacity(): number {\n    return 0;\n  }\n\n  override get remaining(): number {\n    return 0;\n  }\n\n  override has(index: number): boolean {\n    return false;\n  }\n\n  override get(index: number): number {\n    throw new OutputException();\n  }\n\n  override set(index: number, token: number): void {\n    throw new OutputException();\n  }\n\n  override write(token: number): OutputBuffer<never>;\n  override write(string: string): OutputBuffer<never>;\n  override write(tokenOrString: number | string): OutputBuffer<never> {\n    return this;\n  }\n\n  override writeln(string?: string): OutputBuffer<never> {\n    return this;\n  }\n\n  override step(offset: number = 1): OutputBuffer<never> {\n    if (offset === 0) {\n      return this;\n    } else {\n      return new OutputBufferError(new OutputException(\"invalid step\"), this.settings);\n    }\n  }\n\n  override bind(): never {\n    throw new OutputException();\n  }\n\n  override trap(): Error {\n    return this.error;\n  }\n\n  override readonly settings!: OutputSettings;\n\n  override withSettings(settings: OutputSettingsLike): OutputBuffer<never> {\n    settings = OutputSettings.fromLike(settings);\n    return new OutputBufferError(this.error, settings);\n  }\n\n  override clone(): OutputBuffer<never> {\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Diagnostic} from \"../source/Diagnostic\";\n\n/**\n * Thrown when a [[Parser]] parses invalid syntax.\n * @public\n */\nexport class ParserException extends Error {\n  constructor(message?: Diagnostic | string) {\n    super(message instanceof Diagnostic ? message.message : message);\n    Object.setPrototypeOf(this, ParserException.prototype);\n    this.diagnostic = message instanceof Diagnostic ? message : null;\n  }\n\n  readonly diagnostic: Diagnostic | null;\n\n  override toString(): string {\n    if (this.diagnostic !== null) {\n      return this.diagnostic.toString();\n    } else {\n      return super.toString();\n    }\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Diagnostic} from \"../source/Diagnostic\";\nimport type {Input} from \"../input/Input\";\nimport {ParserException} from \"./ParserException\";\nimport {ParserDone} from \"../\"; // forward import\nimport {ParserError} from \"../\"; // forward import\n\n/**\n * Continuation of how to parse subsequent [[Input]] tokens from a stream.\n * `Parser` enables efficient, interruptible parsing of network protocols and\n * data formats, without intermediate buffering.\n *\n * ### Input tokens\n * A `Parser` reads tokens from an `Input` reader. Input tokens are modeled as\n * primitive numbers, commonly representing Unicode code points, or raw octets.\n * Each `Parser` implementation specifies the semantic type of input tokens it\n * consumes.\n *\n * ### Parser states\n * A `Parser` is always in one of three states: _cont_​inue, _done_, or _error_.\n * The _cont_ state indicates that [[feed]] is ready to consume `Input`; the\n * _done_ state indicates that parsing terminated successfully, and that\n * [[bind]] will return the parsed result; the _error_ state indicates that\n * parsing terminated in failure, and that [[trap]] will return the parse error.\n * `Parser` subclasses default to the _cont_ state.\n *\n * ### Feeding input\n * The [[feed]] method incrementally parses as much `Input` as it can, before\n * returning another `Parser` that represents the continuation of how to parse\n * additional `Input`. The `Input` passed to `feed` is only guaranteed to be\n * valid for the duration of the method call; references to the provided `Input`\n * instance must not be stored.\n *\n * ### Parser results\n * A `Parser` produces a parsed result of type `O`, obtained via the [[bind]]\n * method. `bind` is only guaranteed to return a result when in the _done_\n * state; though `bind` may optionally make available partial results in other\n * states. A failed `Parser` provides a parse error via the [[trap]] method.\n * `trap` is only guaranteed to return an error when in the _error_ state.\n *\n * ### Continuations\n * A `Parser` instance represents a continuation of how to parse remaining\n * `Input`. Rather than parsing a complete input in one go, a `Parser` takes\n * an `Input` chunk and returns another `Parser` instance that knows how to\n * parse subsequent `Input` chunks. This enables non-blocking, incremental\n * parsing that can be interrupted whenever an `Input` reader runs out of\n * immediately available data. A `Parser` terminates by returning a\n * continuation in either the _done_ state, or the _error_ state.\n * [[Parser.done]] returns a `Parser` in the _done_ state. [[Parser.error]]\n * returns a `Parser` in the _error_ state.\n *\n * ### Iteratees\n * `Parser` is an [Iteratee](https://en.wikipedia.org/wiki/Iteratee). Though\n * unlike strictly functional iteratees, a `Parser` statefully iterates over\n * its `Input`, rather than allocating an object for each incremental input\n * continutaion. This internal mutability minimizes garbage collector memory\n * pressure, without violating the functional Iteratee abstraction, provided\n * that `feed` logically takes exclusive ownership of its `Input` when invoked,\n * and logically returns ownership of the `Input` in a state that's consistent\n * with the returned `Parser` continuation.\n *\n * ### Immutability\n * A `Parser` should be immutable. Specifically, an invocation of `feed`\n * should not alter the behavior of future calls to `feed` on the same `Parser`\n * instance. A `Parser` should only mutate its internal state if it's essential\n * to do so, such as for critical path performance reasons.\n *\n * ### Backtracking\n * `feed` can internally [[Input.clone clone]] its `Input`, if it might need to\n * backtrack. Keep in mind that, because `Input` is only valid for the duration\n * of a call to `feed`, input must be internally buffered if it needs to be\n * preserved between `feed` invocations.\n *\n * ### Forking\n * The [[fork]] method passes an out-of-band condition to a `Parser`, yielding\n * a `Parser` continuation whose behavior may be altered by the given condition.\n * For example, an HTML `Parser` might `fork` an inner text parser to directly\n * parse an embedded micro format out of an HTML element, based on some\n * out-of-band schema information. The types of conditions accepted by `fork`,\n * and their intended semantics, are implementation defined.\n *\n * @public\n */\nexport abstract class Parser<O> {\n  /**\n   * Returns `true` when [[feed]] is able to consume `Input`, i.e. this\n   * `Parser` is in the _cont_ state.\n   */\n  isCont(): boolean {\n    return true;\n  }\n\n  /**\n   * Returns `true` when parsing has terminated successfully, and [[bind]] will\n   * return the parsed result, i.e. this `Parser` is in the _done_ state.\n   */\n  isDone(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns `true` when parsing has terminated in failure, and [[trap]] will\n   * return the parse error, i.e. this `Parser` is in the _error_ state.\n   */\n  isError(): boolean {\n    return false;\n  }\n\n  /**\n   * Incrementally parses as much `input` as possible, and returns another\n   * `Parser` that represents the continuation of how to parse additional\n   * `Input`. If `input` enters the _done_ state, `feed` _must_ return a\n   * terminated `Parser`, i.e. a `Parser` in the _done_ state, or in the\n   * _error_ state. The given `input` is only guaranteed to be valid for the\n   * duration of the method call; references to `input` must not be stored.\n   */\n  abstract feed(input: Input): Parser<O>;\n\n  /**\n   * Returns a `Parser` continuation whose behavior may be altered by the\n   * given out-of-band `condition`.\n   */\n  fork(condition: unknown): Parser<O> {\n    return this;\n  }\n\n  /**\n   * Returns the parsed result. Only guaranteed to return a result when in the\n   * _done_ state.\n   *\n   * @throws `Error` if this `Parser` is not in the _done_ state.\n   */\n  bind(): O {\n    throw new ParserException();\n  }\n\n  /**\n   * Returns the parse error. Only guaranteed to return an error when in the\n   * _error_ state.\n   *\n   * @throws `Error` if this `Parser` is not in the _error_ state.\n   */\n  trap(): Error {\n    throw new ParserException();\n  }\n\n  /**\n   * Casts an errored `Parser` to a different output type. A `Parser` in the\n   * _error_ state can have any output type.\n   *\n   * @throws `ParserException` if this `Parser` is not in the _error_ state.\n   */\n  asError<O2>(): Parser<O2> {\n    throw new ParserException();\n  }\n\n  /**\n   * Returns a `Parser` in the _done_ state that binds the given parsed `value`.\n   */\n  static done<O>(value: O): Parser<O> {\n    return new ParserDone(value);\n  }\n\n  /**\n   * Returns a `Parser` in the _error_ state that `trap`s the given parse `error`.\n   */\n  static error<O>(error: Error | Diagnostic): Parser<O> {\n    if (error instanceof Error) {\n      return new ParserError(error);\n    } else {\n      return new ParserError(new ParserException(error));\n    }\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Input} from \"../input/Input\";\nimport {Parser} from \"./Parser\";\n\n/** @internal */\nexport class ParserDone<O> extends Parser<O> {\n  /** @internal */\n  readonly value!: O;\n\n  constructor(value: O) {\n    super();\n    Object.defineProperty(this, \"value\", {\n      value: value,\n      enumerable: true,\n    });\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isDone(): boolean {\n    return true;\n  }\n\n  override feed(input: Input): Parser<O> {\n    return this;\n  }\n\n  override bind(): O {\n    return this.value;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Input} from \"../input/Input\";\nimport {Parser} from \"./Parser\";\n\n/** @internal */\nexport class ParserError extends Parser<never> {\n  /** @internal */\n  readonly error!: Error;\n\n  constructor(error: Error) {\n    super();\n    Object.defineProperty(this, \"error\", {\n      value: error,\n      enumerable: true,\n    });\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isError(): boolean {\n    return true;\n  }\n\n  override feed(input: Input): Parser<never> {\n    return this;\n  }\n\n  override bind(): never {\n    throw this.error;\n  }\n\n  override trap(): Error {\n    return this.error;\n  }\n\n  override asError<O2>(): Parser<O2> {\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"../output/Output\";\nimport {WriterException} from \"./WriterException\";\nimport {Writer} from \"./Writer\";\n\n/** @internal */\nexport class WriterEnd extends Writer<unknown, never> {\n  constructor() {\n    super();\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isDone(): boolean {\n    return true;\n  }\n\n  override pull(output: Output): Writer<unknown, never> {\n    return this;\n  }\n\n  override bind(): never {\n    throw new WriterException();\n  }\n\n  override asDone<I2>(): Writer<I2, never> {\n    return this;\n  }\n\n  override andThen<O2>(that: Writer<unknown, O2>): Writer<unknown, O2> {\n    return that;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"../output/Output\";\nimport {Writer} from \"./Writer\";\n\n/** @internal */\nexport class WriterDone<O> extends Writer<unknown, O> {\n  /** @internal */\n  readonly value!: O;\n\n  constructor(value: O) {\n    super();\n    Object.defineProperty(this, \"value\", {\n      value: value,\n      enumerable: true,\n    });\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isDone(): boolean {\n    return true;\n  }\n\n  override pull(output: Output): Writer<unknown, O> {\n    return this;\n  }\n\n  override bind(): O {\n    return this.value;\n  }\n\n  override asDone<I2>(): Writer<I2, O> {\n    return this;\n  }\n\n  override andThen<O2>(that: Writer<unknown, O2>): Writer<unknown, O2> {\n    return that;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"../output/Output\";\nimport {Writer} from \"./Writer\";\n\n/** @internal */\nexport class WriterError extends Writer<never, never> {\n  /** @internal */\n  readonly error!: Error;\n\n  constructor(error: Error) {\n    super();\n    Object.defineProperty(this, \"error\", {\n      value: error,\n      enumerable: true,\n    });\n  }\n\n  override isCont(): boolean {\n    return false;\n  }\n\n  override isError(): boolean {\n    return true;\n  }\n\n  override pull(output: Output): Writer<never, never> {\n    return this;\n  }\n\n  override bind(): never {\n    throw this.error;\n  }\n\n  override trap(): Error {\n    return this.error;\n  }\n\n  override asError<I2, O2>(): Writer<I2, O2> {\n    return this;\n  }\n\n  override andThen<O2>(that: Writer<never, O2>): Writer<never, O2> {\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"../output/Output\";\nimport {Writer} from \"./Writer\";\n\n/** @internal */\nexport class WriterSequence<O> extends Writer<never, O> {\n  /** @internal */\n  readonly head: Writer<unknown, unknown>;\n  /** @internal */\n  readonly tail: Writer<unknown, O>;\n\n  constructor(head: Writer<unknown, unknown>, tail: Writer<unknown, O>) {\n    super();\n    this.head = head;\n    this.tail = tail;\n  }\n\n  override pull(output: Output): Writer<never, O> {\n    let head = this.head;\n    if (head.isCont()) {\n      head = head.pull(output);\n    }\n    if (head.isError()) {\n      return head.asError();\n    } else if (head.isDone()) {\n      return this.tail.pull(output);\n    } else {\n      return new WriterSequence(head, this.tail);\n    }\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport type {OutputSettingsLike} from \"../output/OutputSettings\";\nimport {OutputSettings} from \"../output/OutputSettings\";\nimport {Output} from \"../output/Output\";\n\n/** @internal */\nexport abstract class ByteOutput<T> extends Output<T> {\n  constructor(array: Uint8Array | null, size: number, settings: OutputSettings) {\n    super();\n    this.array = array;\n    this.size = size;\n    this.settings = settings;\n  }\n\n  /** @internal */\n  readonly array: Uint8Array | null;\n\n  /** @internal */\n  readonly size: number;\n\n  override isCont(): boolean {\n    return true;\n  }\n\n  override isFull(): boolean {\n    return false;\n  }\n\n  override isDone(): boolean {\n    return false;\n  }\n\n  override isError(): boolean {\n    return false;\n  }\n\n  override isPart(): boolean {\n    return false;\n  }\n\n  override asPart(part: boolean): Output<T> {\n    return this;\n  }\n\n  override write(b: number | string): Output<T> {\n    if (typeof b === \"number\") {\n      const n = this.size;\n      const oldArray = this.array;\n      let newArray;\n      if (oldArray === null || n + 1 > oldArray.length) {\n        newArray = new Uint8Array(ByteOutput.expand(n + 1));\n        if (oldArray !== null) {\n          newArray.set(oldArray, 0);\n        }\n        (this as Mutable<this>).array = newArray;\n      } else {\n        newArray = oldArray;\n      }\n      newArray[n] = b;\n      (this as Mutable<this>).size = n + 1;\n      return this;\n    } else {\n      throw new TypeError(\"\" + b);\n    }\n  }\n\n  override writeln(string?: string): Output<T> {\n    throw new TypeError(\"\" + string);\n  }\n\n  toUint8Array(): Uint8Array {\n    const n = this.size;\n    const oldArray = this.array;\n    if (oldArray !== null && n === oldArray.length) {\n      return oldArray;\n    } else {\n      const newArray = new Uint8Array(n);\n      if (oldArray !== null) {\n        newArray.set(oldArray.slice(0, n), 0);\n      }\n      (this as Mutable<this>).array = newArray;\n      return newArray;\n    }\n  }\n\n  cloneArray(): Uint8Array | null {\n    const oldArray = this.array;\n    if (oldArray !== null) {\n      return oldArray.slice(0, this.size);\n    } else {\n      return null;\n    }\n  }\n\n  override readonly settings: OutputSettings;\n\n  override withSettings(settings: OutputSettingsLike): Output<T> {\n    settings = OutputSettings.fromLike(settings);\n    (this as Mutable<this>).settings = settings;\n    return this;\n  }\n\n  /** @internal */\n  static expand(n: number): number {\n    n = Math.max(32, n) - 1;\n    n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16;\n    return n + 1;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {OutputSettings} from \"../output/OutputSettings\";\nimport type {Output} from \"../output/Output\";\nimport {ByteOutput} from \"./ByteOutput\";\n\n/** @internal */\nexport class ByteOutputUint8Array extends ByteOutput<Uint8Array> {\n  constructor(array: Uint8Array | null, size: number, settings: OutputSettings) {\n    super(array, size, settings);\n  }\n\n  override bind(): Uint8Array {\n    return this.toUint8Array();\n  }\n\n  override clone(): Output<Uint8Array> {\n    return new ByteOutputUint8Array(this.cloneArray(), this.size, this.settings);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {OutputException} from \"../output/OutputException\";\nimport type {OutputSettingsLike} from \"../output/OutputSettings\";\nimport {OutputSettings} from \"../output/OutputSettings\";\nimport {OutputBuffer} from \"../output/OutputBuffer\";\nimport {OutputBufferError} from \"../output/OutputBufferError\";\n\n/** @internal */\nexport class ByteOutputBuffer extends OutputBuffer<Uint8Array> {\n  constructor(array: Uint8Array, index: number, limit: number,\n              part: boolean, settings: OutputSettings) {\n    super();\n    this.array = array;\n    this.index = index;\n    this.limit = limit;\n    this.part = part;\n    this.settings = settings;\n  }\n\n  /** @internal */\n  readonly array: Uint8Array;\n\n  /** @internal */\n  readonly part: boolean;\n\n  override isCont(): boolean {\n    return this.index < this.limit;\n  }\n\n  override isFull(): boolean {\n    return this.part && this.index >= this.limit;\n  }\n\n  override isDone(): boolean {\n    return !this.part && this.index >= this.limit;\n  }\n\n  override isError(): boolean {\n    return false;\n  }\n\n  override isPart(): boolean {\n    return this.part;\n  }\n\n  override asPart(part: boolean): OutputBuffer<Uint8Array> {\n    (this as Mutable<this>).part = part;\n    return this;\n  }\n\n  readonly index: number;\n\n  override withIndex(index: number): OutputBuffer<Uint8Array> {\n    if (0 <= index && index <= this.limit) {\n      (this as Mutable<this>).index = index;\n      return this;\n    } else {\n      return new OutputBufferError(new OutputException(\"invalid index\"), this.settings);\n    }\n  }\n\n  readonly limit: number;\n\n  override withLimit(limit: number): OutputBuffer<Uint8Array> {\n    if (0 <= limit && limit <= this.array.length) {\n      (this as Mutable<this>).limit = limit;\n      return this;\n    } else {\n      return new OutputBufferError(new OutputException(\"invalid limit\"), this.settings);\n    }\n  }\n\n  override get capacity(): number {\n    return this.array.length;\n  }\n\n  override get remaining(): number {\n    return this.limit - this.index;\n  }\n\n  override has(index: number): boolean {\n    return 0 <= index && index < this.limit;\n  }\n\n  override get(index: number): number {\n    if (0 <= index && index < this.limit) {\n      return this.array[index]!;\n    } else {\n      throw new OutputException();\n    }\n  }\n\n  override set(index: number, token: number): void {\n    if (0 <= index && index < this.limit) {\n      this.array[index] = token;\n    } else {\n      throw new OutputException();\n    }\n  }\n\n  override write(token: number | string): OutputBuffer<Uint8Array> {\n    if (typeof token === \"number\") {\n      const index = this.index;\n      if (index < this.limit) {\n        this.array[index] = token;\n        (this as Mutable<this>).index += 1;\n        return this;\n      } else {\n        return new OutputBufferError(new OutputException(\"full\"), this.settings);\n      }\n    } else {\n      return new OutputBufferError(new OutputException(\"binary output\"), this.settings);\n    }\n  }\n\n  override writeln(string?: string): OutputBuffer<Uint8Array> {\n    return new OutputBufferError(new OutputException(\"binary output\"), this.settings);\n  }\n\n  override step(offset: number): OutputBuffer<Uint8Array> {\n    const index = this.index + offset;\n    if (0 <= index && index <= this.limit) {\n      (this as Mutable<this>).index = index;\n      return this;\n    } else {\n      return new OutputBufferError(new OutputException(\"invalid step\"), this.settings);\n    }\n  }\n\n  override bind(): Uint8Array {\n    return new Uint8Array(this.array.buffer, 0, this.index);\n  }\n\n  override readonly settings: OutputSettings;\n\n  override withSettings(settings: OutputSettingsLike): OutputBuffer<Uint8Array> {\n    settings = OutputSettings.fromLike(settings);\n    (this as Mutable<this>).settings = settings;\n    return this;\n  }\n\n  override clone(): OutputBuffer<Uint8Array> {\n    return new ByteOutputBuffer(this.array, this.index, this.limit, this.part, this.settings);\n  }\n\n  static create(array: Uint8Array, offset?: number, length?: number): OutputBuffer<Uint8Array> {\n    if (offset === void 0) {\n      offset = 0;\n    }\n    if (length === void 0) {\n      length = array.length;\n    }\n    return new ByteOutputBuffer(array, offset, offset + length, false, OutputSettings.standard());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {OutputSettingsLike} from \"../output/OutputSettings\";\nimport {OutputSettings} from \"../output/OutputSettings\";\nimport type {Output} from \"../output/Output\";\nimport type {OutputBuffer} from \"../output/OutputBuffer\";\nimport {ByteOutputBuffer} from \"./ByteOutputBuffer\";\nimport {ByteOutputUint8Array} from \"./ByteOutputUint8Array\";\n\n/**\n * Byte [[Input]]/[[Output]] factory.\n *\n * The `Binary.outputBuffer(...)` function returns an `Output` that writes\n * bytes to a growable array, and [[Output.bind binds]] a `Uint8Array`\n * containing all written bytes.\n * @public\n */\nexport const Binary = (function () {\n  const Binary = {} as {\n    /**\n     * Returns a new `Output` that appends bytes to a growable array,\n     * pre-allocated with space for `initialCapacity` bytes, if `initialCapacity`\n     * is defined, using the given `settings`, if `settings` is defined. The\n     * returned `Output` accepts an unbounded number of bytes, remaining\n     * permanently in the _cont_ state, and can [[Output.bind bind]] a\n     * `Uint8Array` with the current output state at any time.\n     */\n    output(initialCapacity?: number, settings?: OutputSettingsLike): Output<Uint8Array>;\n\n    /**\n     * Returns a new `Output` that appends bytes to a growable array, using the\n     * given `settings`. The returned `Output` accepts an unbounded number of\n     * bytes, remaining permanently in the _cont_ state, and can [[Output.bind\n     * bind]] a `Uint8Array` array with the current output state at any time.\n     */\n    output(settings: OutputSettingsLike): Output<Uint8Array>;\n\n    outputBuffer(array: Uint8Array, offset?: number, length?: number): OutputBuffer<Uint8Array>;\n  };\n\n  Binary.output = function (initialCapacity?: number | OutputSettingsLike,\n                            settings?: OutputSettingsLike): Output<Uint8Array> {\n    if (settings === void 0 && typeof initialCapacity !== \"number\") {\n      settings = initialCapacity;\n      initialCapacity = void 0;\n    } else if (typeof initialCapacity !== \"number\") {\n      initialCapacity = void 0;\n    }\n    let array: Uint8Array | null;\n    if (typeof initialCapacity === \"number\") {\n      array = new Uint8Array(initialCapacity);\n    } else {\n      array = null;\n    }\n    settings = OutputSettings.fromLike(settings);\n    return new ByteOutputUint8Array(array, 0, settings);\n  };\n\n  Binary.outputBuffer = function (array: Uint8Array, offset?: number,\n                                  length?: number): OutputBuffer<Uint8Array> {\n    return ByteOutputBuffer.create(array, offset, length);\n  };\n\n  return Binary;\n})();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Output} from \"../output/Output\";\nimport type {Debug} from \"../format/Debug\";\nimport {Format} from \"../format/Format\";\nimport {UtfErrorModeFatal} from \"../\"; // forward import\nimport {UtfErrorModeReplacement} from \"../\"; // forward import\n\n/**\n * Unicode transformation format error handling mode.\n * @public\n */\nexport abstract class UtfErrorMode implements HashCode, Debug {\n  /**\n   * Returns `true` if a Unicode decoding should abort with an error when an\n   * invalid code unit sequence is encountered.\n   */\n  isFatal(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns `true` if a Unicode decoding should substitute invalid code unit\n   * sequences with a replacement character.\n   */\n  isReplacement(): boolean {\n    return false;\n  }\n\n  /**\n   * The Unicode code point of the replacement character used to substitute\n   * for invalid code unit sequences.\n   */\n  abstract readonly replacementChar: number;\n\n  /**\n   * Returns `true` if Unicode decoding should abort with an error when a\n   * `NUL` byte is encountered.\n   */\n  abstract isNonZero(): boolean;\n\n  /**\n   * Returns a `UtfErrorMode` that, if `isNonZero` is `true`, aborts when\n   * Unicode decoding encounters a `NUL` byte.\n   */\n  abstract asNonZero(isNonZero: boolean): UtfErrorMode;\n\n  abstract equals(that: unknown): boolean;\n\n  abstract hashCode(): number;\n\n  abstract debug<T>(output: Output<T>): Output<T>;\n\n  toString(): string {\n    return Format.debug(this);\n  }\n\n  /**\n   * Returns a `UtfErrorMode` that aborts Unicode decoding with an error when\n   * invalid code unit sequences are encountered.\n   */\n  @Lazy\n  static fatal(): UtfErrorMode {\n    return new UtfErrorModeFatal(false);\n  }\n\n  /**\n   * Returns a `UtfErrorMode` that aborts Unicode decoding with an error when\n   * invalid code unit sequences, and `NUL` bytes, are encountered.\n   */\n  @Lazy\n  static fatalNonZero(): UtfErrorMode {\n    return new UtfErrorModeFatal(true);\n  }\n\n  /**\n   * Returns a `UtfErrorMode` that substitutes invalid code unit sequences\n   * with the replacement character (`U+FFFD`).\n   */\n  @Lazy\n  static replacement(): UtfErrorMode {\n    return new UtfErrorModeReplacement(0xfffd, false);\n  }\n\n  /**\n   * Returns a `UtfErrorMode` that substitutes invalid code unit sequences\n   * with the replacement character (`U+FFFD`), and aborts decoding with an\n   * error when `NUL` bytes are encountered.\n   */\n  @Lazy\n  static replacementNonZero(): UtfErrorMode {\n    return new UtfErrorModeReplacement(0xfffd, true);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Booleans} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"../output/Output\";\nimport {UtfErrorMode} from \"./UtfErrorMode\";\n\n/** @internal */\nexport class UtfErrorModeFatal extends UtfErrorMode {\n  constructor(nonZero: boolean) {\n    super();\n    Object.defineProperty(this, \"nonZero\", {\n      value: nonZero,\n      enumerable: true,\n    });\n  }\n\n  override isFatal(): boolean {\n    return true;\n  }\n\n  override get replacementChar(): number {\n    return 0xfffd;\n  }\n\n  /** @internal */\n  readonly nonZero!: boolean;\n\n  override isNonZero(): boolean {\n    return this.nonZero;\n  }\n\n  override asNonZero(nonZero: boolean): UtfErrorMode {\n    if (nonZero) {\n      return UtfErrorMode.fatalNonZero();\n    } else {\n      return UtfErrorMode.fatal();\n    }\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UtfErrorModeFatal) {\n      return this.nonZero === that.nonZero;\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(UtfErrorModeFatal),\n        Booleans.hash(this.nonZero)));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"UtfErrorMode\").write(46/*'.'*/)\n                   .write(this.nonZero ? \"fatalNonZero\" : \"fatal\")\n                   .write(40/*'('*/).write(41/*')'*/);\n    return output;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Booleans} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"../output/Output\";\nimport {UtfErrorMode} from \"./UtfErrorMode\";\n\n/** @internal */\nexport class UtfErrorModeReplacement extends UtfErrorMode {\n  constructor(replacementChar: number, nonZero: boolean) {\n    super();\n    Object.defineProperty(this, \"replacementChar\", {\n      value: replacementChar,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"nonZero\", {\n      value: nonZero,\n      enumerable: true,\n    });\n  }\n\n  override isReplacement(): boolean {\n    return true;\n  }\n\n  override readonly replacementChar!: number;\n\n  /** @internal */\n  readonly nonZero!: boolean;\n\n  override isNonZero(): boolean {\n    return this.nonZero;\n  }\n\n  override asNonZero(nonZero: boolean): UtfErrorMode {\n    if (this.replacementChar === 0xfffd) {\n      if (nonZero) {\n        return UtfErrorMode.replacementNonZero();\n      } else {\n        return UtfErrorMode.replacement();\n      }\n    } else {\n      return new UtfErrorModeReplacement(this.replacementChar, nonZero);\n    }\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UtfErrorModeReplacement) {\n      return this.replacementChar === that.replacementChar\n          && this.nonZero === that.nonZero;\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(UtfErrorModeReplacement),\n        Numbers.hash(this.replacementChar)), Booleans.hash(this.nonZero)));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"UtfErrorMode\").write(46/*'.'*/)\n                   .write(this.nonZero ? \"replacementNonZero\" : \"replacement\")\n                   .write(40/*'('*/).write(41/*')'*/);\n    return output;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport type {Input} from \"../input/Input\";\nimport type {Output} from \"../output/Output\";\nimport type {Parser} from \"../parser/Parser\";\nimport type {Writer} from \"../writer/Writer\";\nimport {Format} from \"../format/Format\";\nimport {Binary} from \"../binary/Binary\";\nimport {Unicode} from \"../unicode/Unicode\";\nimport {Base16Parser} from \"../\"; // forward import\nimport {Base16Writer} from \"../\"; // forward import\nimport {Base16IntegerWriter} from \"../\"; // forward import\n\n/**\n * Base-16 (hexadecimal) encoding [[Parser]]/[[Writer]] factory.\n * @public\n */\nexport class Base16 {\n  constructor(alphabet: string) {\n    Object.defineProperty(this, \"alphabet\", {\n      value: alphabet,\n      enumerable: true,\n    });\n  }\n\n  /**\n   * Returns a 16 character string, where the character at index `i` is the\n   * encoding of the base-16 digit `i`.\n   */\n  readonly alphabet!: string;\n\n  /**\n   * Returns the Unicode code point of the base-16 digit that encodes the given\n   * 4-bit quantity.\n   */\n  encodeDigit(b: number): number {\n    return this.alphabet.charCodeAt(b);\n  }\n\n  /**\n   * Returns a `Writer` that, when fed an input `Uint8Array`, returns a\n   * continuation that writes the base-16 (hexadecimal) encoding of the input\n   * byte array.\n   */\n  uint8ArrayWriter(): Writer<Uint8Array, unknown>;\n  /**\n   * Returns a `Writer` continuation that writes the base-16 (hexadecimal)\n   * encoding of the `input` `Uint8Array`.\n   */\n  uint8ArrayWriter(input: Uint8Array): Writer<unknown, Uint8Array>;\n  uint8ArrayWriter(input?: Uint8Array): Writer<unknown, unknown> {\n    if (input === void 0) {\n      return new Base16Writer(this, void 0, null);\n    } else {\n      return new Base16Writer(this, input, input);\n    }\n  }\n\n  /**\n   * Writes the base-16 (hexadecimal) encoding of the `input` `Uint8Array` to\n   * the `output`, returning a `Writer` continuation that knows how to write any\n   * remaining output that couldn't be immediately generated.\n   */\n  writeUint8Array(output: Output, input: Uint8Array): Writer<unknown, unknown> {\n    return Base16Writer.write(output, this, void 0, input);\n  }\n\n  writeInteger(output: Output, input: number, width: number = 0): Writer<unknown, unknown> {\n    return Base16IntegerWriter.write(output, this, void 0, input, width);\n  }\n\n  writeIntegerLiteral(output: Output, input: number, width: number = 0): Writer<unknown, unknown> {\n    return Base16IntegerWriter.writeLiteral(output, this, void 0, input, width);\n  }\n\n  /**\n   * Returns the `Base16` encoding with lowercase alphanumeric digits.\n   */\n  @Lazy\n  static get lowercase(): Base16 {\n    return new Base16(\"0123456789abcdef\");\n  }\n\n  /**\n   * Returns the `Base16` encoding with uppercase alphanumeric digits.\n   */\n  @Lazy\n  static get uppercase(): Base16 {\n    return new Base16(\"0123456789ABCDEF\");\n  }\n\n  /**\n   * Returns `true` if the Unicode code point `c` is a valid base-16 digit.\n   */\n  static isDigit(c: number): boolean {\n    return c >= 48/*'0'*/ && c <= 57/*'9'*/\n        || c >= 65/*'A'*/ && c <= 70/*'F'*/\n        || c >= 97/*'a'*/ && c <= 102/*'f'*/;\n  }\n\n  /**\n   * Returns the 4-bit quantity represented by the base-16 digit `c`.\n   *\n   * @throws `Error` if `c` is not a valid base-16 digit.\n   */\n  static decodeDigit(c: number): number {\n    if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n      return c - 48/*'0'*/;\n    } else if (c >= 65/*'A'*/ && c <= 70/*'F'*/) {\n      return 10 + (c - 65/*'A'*/);\n    } else if (c >= 97/*'a'*/ && c <= 102/*'f'*/) {\n      return 10 + (c - 97/*'a'*/);\n    } else {\n      let message = Unicode.stringOutput();\n      message = message.write(\"Invalid base-16 digit: \");\n      message = Format.debugChar(message, c);\n      throw new Error(message.bind());\n    }\n  }\n\n  /**\n   * Decodes the base-16 digits `c1` and `c2`, and writes the 8-bit  quantity\n   * they represent to the given `output`.\n   *\n   * @returns the continuation of the `output`.\n   */\n  static writeQuantum<T>(output: Output<T>, c1: number, c2: number): Output<T> {\n    const x = Base16.decodeDigit(c1);\n    const y = Base16.decodeDigit(c2);\n    output = output.write(x << 4 | y);\n    return output;\n  }\n\n  /**\n   * Returns a `Parser` that decodes base-16 (hexadecimal) encoded input, and\n   * writes the decoded bytes to `output`.\n   */\n  static parser<O>(output: Output<O>): Parser<O> {\n    return new Base16Parser<O>(output);\n  }\n\n  /**\n   * Parses the base-16 (hexadecimal) encoded `input`, and writes the decoded\n   * bytes to `output`, returning a `Parser` continuation that knows how to\n   * parse any additional input.\n   */\n  static parse<O>(input: Input, output: Output<O>): Parser<O> {\n    return Base16Parser.parse(input, output);\n  }\n\n  /**\n   * Parses the base-16 (hexadecimal) encoded `input`, and writes the decoded\n   * bytes to a growable array, returning a `Parser` continuation that knows\n   * how to parse any additional input. The returned `Parser` [[Parser.bind\n   * binds]] a `Uint8Array` array containing all parsed base-16 data.\n   */\n  static parseUint8Array(input: Input): Parser<Uint8Array> {\n    return Base16Parser.parse(input, Binary.output());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {OutputException} from \"../output/OutputException\";\nimport type {OutputSettingsLike} from \"../output/OutputSettings\";\nimport type {OutputSettings} from \"../output/OutputSettings\";\nimport {Output} from \"../output/Output\";\nimport {Unicode} from \"./Unicode\";\nimport {UtfErrorMode} from \"./UtfErrorMode\";\nimport {Base16} from \"../number/Base16\";\n\n/** @internal */\nexport class Utf8DecodedOutput<T> extends Output<T> {\n  /** @internal */\n  readonly output: Output<T>;\n  /** @internal */\n  readonly errorMode: UtfErrorMode;\n  /** @internal */\n  c1: number;\n  /** @internal */\n  c2: number;\n  /** @internal */\n  c3: number;\n  /** @internal */\n  have: number;\n\n  constructor(output: Output<T>, errorMode: UtfErrorMode,\n              c1: number, c2: number, c3: number, have: number) {\n    super();\n    this.output = output;\n    this.errorMode = errorMode;\n    this.c1 = c1;\n    this.c2 = c2;\n    this.c3 = c3;\n    this.have = have;\n  }\n\n  override isCont(): boolean {\n    return this.output.isCont();\n  }\n\n  override isFull(): boolean {\n    return this.output.isFull();\n  }\n\n  override isDone(): boolean {\n    return this.output.isDone();\n  }\n\n  override isError(): boolean {\n    return this.output.isError();\n  }\n\n  override isPart(): boolean {\n    return this.output.isPart();\n  }\n\n  override asPart(part: boolean): Output<T> {\n    (this as Mutable<this>).output = this.output.asPart(part);\n    return this;\n  }\n\n  override write(token: number | string): Output<T> {\n    if (typeof token === \"number\") {\n      let c1 = this.c1;\n      let c2 = this.c2;\n      let c3 = this.c3;\n      let c4 = -1;\n      let have = this.have;\n\n      if (token >= 0) {\n        switch (have) {\n          case 0:\n            c1 = token & 0xff;\n            have = 1;\n            break;\n          case 1:\n            c2 = token & 0xff;\n            have = 2;\n            break;\n          case 2:\n            c3 = token & 0xff;\n            have = 3;\n            break;\n          case 3:\n            c4 = token & 0xff;\n            have = 4;\n            break;\n          default:\n            throw new Error(\"unreachable\");\n        }\n      }\n\n      if (c1 === 0 && this.errorMode.isNonZero()) { // invalid NUL byte\n        return Output.error(new OutputException(\"unexpected NUL byte\"));\n      } else if (c1 >= 0 && c1 <= 0x7f) { // U+0000..U+007F\n        (this as Mutable<this>).output = this.output.write(c1);\n        this.have = 0;\n      } else if (c1 >= 0xc2 && c1 <= 0xf4) {\n        if (c1 >= 0xc2 && c1 <= 0xdf && c2 >= 0x80 && c2 <= 0xbf) { // U+0080..U+07FF\n          (this as Mutable<this>).output = this.output.write((c1 & 0x1f) << 6 | c2 & 0x3f);\n          this.c1 = -1;\n          this.have = 0;\n        } else if (c1 === 0xe0 && c2 >= 0xa0 && c2 <= 0xbf // U+0800..U+0FFF\n                || c1 >= 0xe1 && c1 <= 0xec && c2 >= 0x80 && c2 <= 0xbf // U+1000..U+CFFF\n                || c1 === 0xed && c2 >= 0x80 && c2 <= 0x9f // U+D000..U+D7FF\n                || c1 >= 0xee && c1 <= 0xef && c2 >= 0x80 && c2 <= 0xbf) { // U+E000..U+FFFF\n          if (c3 >= 0x80 && c3 <= 0xbf) {\n            (this as Mutable<this>).output = this.output.write((c1 & 0x0f) << 12 | (c2 & 0x3f) << 6 | c3 & 0x3f);\n            this.c1 = -1;\n            this.c2 = -1;\n            this.have = 0;\n          } else if (c3 >= 0) { // invalid c3\n            if (this.errorMode.isFatal()) {\n              return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2, c3)));\n            }\n            (this as Mutable<this>).output = this.output.write(this.errorMode.replacementChar);\n            this.c1 = c3;\n            this.c2 = -1;\n            this.have = 1;\n          } else if (token < 0 || this.output.isDone()) { // incomplete c3\n            return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2)));\n          } else { // awaiting c3\n            this.c2 = c2;\n            this.have = 2;\n          }\n        } else if (c1 === 0xf0 && c2 >= 0x90 && c2 <= 0xbf // U+10000..U+3FFFF\n                || c1 >= 0xf1 && c1 <= 0xf3 && c2 >= 0x80 && c2 <= 0xbf // U+40000..U+FFFFF\n                || c1 === 0xf4 && c2 >= 0x80 && c2 <= 0x8f) { // U+100000..U+10FFFF\n          if (c3 >= 0x80 && c3 <= 0xbf) {\n            if (c4 >= 0x80 && c4 <= 0xbf) {\n              this.have = 4;\n              (this as Mutable<this>).output = this.output.write((c1 & 0x07) << 18 | (c2 & 0x3f) << 12 | (c3 & 0x3f) << 6 | c4 & 0x3f);\n              this.c1 = -1;\n              this.c2 = -1;\n              this.c3 = -1;\n              this.have = 0;\n            } else if (c4 >= 0) { // invalid c4\n              if (this.errorMode.isFatal()) {\n                return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2, c3, c4)));\n              }\n              (this as Mutable<this>).output = this.output.write(this.errorMode.replacementChar);\n              this.c1 = c4;\n              this.c2 = -1;\n              this.c3 = -1;\n              this.have = 1;\n            } else if (token < 0 || this.output.isDone()) { // incomplete c4\n              return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2, c3)));\n            } else { // awaiting c4\n              this.c3 = c3;\n              this.have = 3;\n            }\n          } else if (c3 >= 0) { // invalid c3\n            if (this.errorMode.isFatal()) {\n              return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2, c3)));\n            }\n            (this as Mutable<this>).output = this.output.write(this.errorMode.replacementChar);\n            this.c1 = c3;\n            this.c2 = -1;\n            this.have = 1;\n          } else if (token < 0 || this.output.isDone()) { // incomplete c3\n            return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2)));\n          } else { // awaiting c3\n            this.c2 = c2;\n            this.have = 2;\n          }\n        } else if (c2 >= 0) { // invalid c2\n          if (this.errorMode.isFatal()) {\n            return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2)));\n          }\n          (this as Mutable<this>).output = this.output.write(this.errorMode.replacementChar);\n          this.c1 = c2;\n          this.have = 1;\n        } else if (token < 0 || this.output.isDone()) { // incomplete c2\n          return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1)));\n        } else { // awaiting c2\n          this.c1 = c1;\n          this.have = 1;\n        }\n      } else if (c1 >= 0) { // invalid c1\n        if (this.errorMode.isFatal()) {\n          return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1)));\n        }\n        (this as Mutable<this>).output = this.output.write(this.errorMode.replacementChar);\n        this.have = 0;\n      }\n      if (this.output.isError()) {\n        return this.output;\n      }\n      return this;\n    } else if (typeof token === \"string\") {\n      (this as Mutable<this>).output = this.output.write(token);\n      return this;\n    } else {\n      throw new TypeError(\"\" + token);\n    }\n  }\n\n  private static invalid(c1: number, c2?: number, c3?: number, c4?: number): string {\n    let output = Unicode.stringOutput();\n    output = output.write(\"invalid UTF-8 code unit sequence: \");\n    const base16 = Base16.uppercase;\n    base16.writeIntegerLiteral(output, c1, 2);\n    if (c2 !== void 0) {\n      output = output.write(' ');\n      base16.writeIntegerLiteral(output, c2, 2);\n      if (c3 !== void 0) {\n        output = output.write(' ');\n        base16.writeIntegerLiteral(output, c3, 2);\n        if (c4 !== void 0) {\n          output = output.write(' ');\n          base16.writeIntegerLiteral(output, c4, 2);\n        }\n      }\n    }\n    return output.bind();\n  }\n\n  override get settings(): OutputSettings {\n    return this.output.settings;\n  }\n\n  override withSettings(settings: OutputSettingsLike): Output<T> {\n    (this as Mutable<this>).output = this.output.withSettings(settings);\n    return this;\n  }\n\n  override bind(): T {\n    if (this.have === 0) {\n      return this.output.bind();\n    } else {\n      return this.write(-1).bind();\n    }\n  }\n\n  override trap(): Error {\n    return this.output.trap();\n  }\n\n  override clone(): Output<T> {\n    return new Utf8DecodedOutput(this.output.clone(), this.errorMode,\n                                 this.c1, this.c2, this.c3, this.have);\n  }\n\n  static create<T>(output: Output<T>, errorMode?: UtfErrorMode): Output<T> {\n    if (errorMode === void 0) {\n      errorMode = UtfErrorMode.fatal();\n    }\n    return new Utf8DecodedOutput(output, errorMode, -1, -1, -1, 0);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {OutputException} from \"../output/OutputException\";\nimport type {OutputSettingsLike} from \"../output/OutputSettings\";\nimport type {OutputSettings} from \"../output/OutputSettings\";\nimport {Output} from \"../output/Output\";\nimport {UtfErrorMode} from \"./UtfErrorMode\";\n\n/** @internal */\nexport class Utf8EncodedOutput<T> extends Output<T> {\n  /** @internal */\n  readonly output: Output<T>;\n  /** @internal */\n  readonly errorMode: UtfErrorMode;\n  /** @internal */\n  c2: number;\n  /** @internal */\n  c3: number;\n  /** @internal */\n  c4: number;\n  /** @internal */\n  index: number;\n\n  constructor(output: Output<T>, errorMode: UtfErrorMode, c2: number,\n              c3: number, c4: number, index: number) {\n    super();\n    this.output = output;\n    this.errorMode = errorMode;\n    this.c2 = c2;\n    this.c3 = c3;\n    this.c4 = c4;\n    this.index = index;\n  }\n\n  override isCont(): boolean {\n    return this.output.isCont();\n  }\n\n  override isFull(): boolean {\n    return this.output.isFull();\n  }\n\n  override isDone(): boolean {\n    return this.output.isDone();\n  }\n\n  override isError(): boolean {\n    return false;\n  }\n\n  override isPart(): boolean {\n    return this.output.isPart();\n  }\n\n  override asPart(part: boolean): Output<T> {\n    (this as Mutable<this>).output = this.output.asPart(part);\n    return this;\n  }\n\n  override write(token: number | string): Output<T> {\n    if (typeof token === \"number\") {\n      let c1 = 0;\n      let c2 = this.c2;\n      let c3 = this.c3;\n      let c4 = this.c4;\n      let output = this.output;\n      let index = this.index;\n      while (index < 4) {\n        if (output.isCont()) {\n          switch (index) {\n            case 1: output = output.write(c2); this.c2 = 0; break;\n            case 2: output = output.write(c3); this.c3 = 0; break;\n            case 3: output = output.write(c4); this.c4 = 0; break;\n            default: throw new Error(\"unreachable\");\n          }\n          index += 1;\n        } else {\n          return Output.error(new OutputException(\"unable to flush buffered code units\"));\n        }\n      }\n      if (token >= 0 && token <= 0x7f) { // U+0000..U+007F\n        c4 = token;\n        index = 3;\n      } else if (token >= 0x80 && token <= 0x7ff) { // U+0080..U+07FF\n        c3 = 0xc0 | (token >>> 6);\n        c4 = 0x80 | (token & 0x3f);\n        index = 2;\n      } else if (token >= 0x0800 && token <= 0xffff || // U+0800..U+D7FF\n                 token >= 0xe000 && token <= 0xffff) { // U+E000..U+FFFF\n        c2 = 0xe0 | (token  >>> 12);\n        c3 = 0x80 | ((token >>>  6) & 0x3f);\n        c4 = 0x80 | (token & 0x3f);\n        index = 1;\n      } else if (token >= 0x10000 && token <= 0x10ffff) { // U+10000..U+10FFFF\n        c1 = 0xf0 | (token  >>> 18);\n        c2 = 0x80 | ((token >>> 12) & 0x3f);\n        c3 = 0x80 | ((token >>>  6) & 0x3f);\n        c4 = 0x80 | (token & 0x3f);\n        index = 0;\n      } else { // surrogate or invalid code point\n        if (this.errorMode.isFatal()) {\n          return Output.error(new OutputException(\"invalid code point: \" + token));\n        } else {\n          return this.write(this.errorMode.replacementChar);\n        }\n      }\n      do {\n        switch (index) {\n          case 0: output = output.write(c1); break;\n          case 1: output = output.write(c2); this.c2 = 0; break;\n          case 2: output = output.write(c3); this.c3 = 0; break;\n          case 3: output = output.write(c4); this.c4 = 0; break;\n          default: throw new Error(\"unreachable\");\n        }\n        (this as Mutable<this>).output = output;\n        index += 1;\n      } while (index < 4 && output.isCont());\n      if (index < 4) {\n        if (index < 3) {\n          if (index < 2) {\n            this.c2 = c2;\n          }\n          this.c3 = c3;\n        }\n        this.c4 = c4;\n      }\n      (this as Mutable<this>).output = output;\n      this.index = index;\n      return this;\n    } else if (typeof token === \"string\") {\n      (this as Mutable<this>).output = this.output.write(token);\n      return this;\n    } else {\n      throw new TypeError(\"\" + token);\n    }\n  }\n\n  override flush(): Output<T> {\n    let output = this.output;\n    let index = this.index;\n    while (index < 4) {\n      if (output.isCont()) {\n        switch (index) {\n          case 1: output = output.write(this.c2); this.c2 = 0; break;\n          case 2: output = output.write(this.c3); this.c3 = 0; break;\n          case 3: output = output.write(this.c4); this.c4 = 0; break;\n          default: throw new Error(\"unreachable\");\n        }\n        index += 1;\n      } else {\n        return Output.error(new OutputException(\"unable to flush buffered code units\"));\n      }\n    }\n    (this as Mutable<this>).output = output;\n    this.index = index;\n    return this;\n  }\n\n  override get settings(): OutputSettings {\n    return this.output.settings;\n  }\n\n  override withSettings(settings: OutputSettingsLike): Output<T> {\n    (this as Mutable<this>).output = this.output.withSettings(settings);\n    return this;\n  }\n\n  override bind(): T {\n    return this.output.bind();\n  }\n\n  override clone(): Output<T> {\n    return new Utf8EncodedOutput(this.output.clone(), this.errorMode,\n                                 this.c2, this.c3, this.c4, this.index);\n  }\n\n  static create<T>(output: Output<T>, errorMode?: UtfErrorMode): Output<T> {\n    if (errorMode === void 0) {\n      errorMode = UtfErrorMode.fatal();\n    }\n    return new Utf8EncodedOutput(output, errorMode, 0, 0, 0, 4);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Strings} from \"@swim/util\";\nimport type {Output} from \"../output/Output\";\nimport {Unicode} from \"./Unicode\";\nimport type {UtfErrorMode} from \"./UtfErrorMode\";\nimport {Utf8DecodedOutput} from \"./Utf8DecodedOutput\";\nimport {Utf8EncodedOutput} from \"./Utf8EncodedOutput\";\n\n/**\n * UTF-8 [[Input]]/[[Output]] factory.\n * @public\n */\nexport const Utf8 = (function () {\n  const Utf8 = {} as {\n    /**\n     * Returns the number of bytes in the UTF-8 encoding of the Unicode code\n     * point `c`, handling invalid code unit sequences according to the\n     * `errorMode` policy. Returns the size of the\n     * [[UtfErrorMode.replacementChar]] for surrogates and invalid code points,\n     * if [[UtfErrorMode.isReplacement]] is `true`; otherwise returns `0` for\n     * surrogates and invalid code points. Uses the two byte modified UTF-8\n     * encoding of the NUL character (`U+0000`), if [[UtfErrorMode.isNonZero]]\n     * is `true`.\n     */\n    sizeOf(c: number | undefined, errorMode?: UtfErrorMode): number;\n\n    /**\n     * Returns the number of bytes in the UTF-8 encoding of the Unicode code\n     * point `c`; returns the size of the Unicode replacement character (`U+FFFD`)\n     * for surrogates and invalid code points.\n     */\n    sizeOf(c: number | undefined): number;\n\n    /**\n     * Returns the number of bytes in the UTF-8 encoding the given `string`,\n     * handling invalid code unit sequences according to the `errorMode` policy.\n     */\n    sizeOf(string: string, errorMode?: UtfErrorMode): number;\n\n    /**\n     * Returns the number of bytes in the UTF-8 encoding the given `string`,\n     * assuming the Unicode replacement character (`U+FFFD`) replaces unpaired\n     * surrogates and invalid code points.\n     */\n    sizeOf(string: string): number;\n\n    /**\n     * Returns a new `Output` that accepts UTF-8 code unit sequences, and writes\n     * writes decoded Unicode code points to the composed `output`, handling\n     * invalid code unit sequences according to the `errorMode` policy.\n     */\n    decodedOutput<T>(output: Output<T>, errorMode?: UtfErrorMode): Output<T>;\n\n    /**\n     * Returns a new `Output` that accepts Unicode code points, and writes\n     * encoded UTF-8 code unit sequences to the composed `output`, handling\n     * invalid code unit sequences according to the `errorMode` policy.\n     */\n    encodedOutput<T>(output: Output<T>, errorMode?: UtfErrorMode): Output<T>;\n\n    /**\n     * Returns a new `Output` that accepts UTF-8 code unit sequences, and writes\n     * decoded Unicode code points to a growable `string`, handling invalid code\n     * unit sequences according to the [[UtfErrorMode.fatal]] policy. The\n     * returned `Output` accepts an unbounded number of UTF-8 code units,\n     * remaining permanently in the _cont_ state, and [[Output.bind binds]] a\n     * `string` containing all decoded code points.\n     */\n    decodedString(): Output<string>;\n  };\n\n  Utf8.sizeOf = function (u: string | number | undefined, errorMode?: UtfErrorMode): number {\n    if (typeof u === \"number\" || u === void 0) {\n      if (typeof u === \"number\") {\n        if (u === 0x0000 && errorMode !== void 0 && errorMode.isNonZero()) { // Modified UTF-8\n          return 2; // U+0000 encoded as 0xC0, 0x80\n        } else if (u >= 0x0000 && u <= 0x007F) { // U+0000..U+007F\n          return 1;\n        } else if (u >= 0x0080 && u <= 0x07FF) { // U+0080..U+07FF\n          return 2;\n        } else if (u >= 0x0800 && u <= 0xFFFF || // U+0800..U+D7FF\n                   u >= 0xE000 && u <= 0xFFFF) { // U+E000..U+FFFF\n          return 3;\n        } else if (u >= 0x10000 && u <= 0x10FFFF) { // U+10000..U+10FFFF\n          return 4;\n        }\n      }\n      // surrogate or invalid code point\n      if (errorMode === void 0) {\n        return 3;\n      } else if (errorMode.isReplacement()) {\n        return Utf8.sizeOf(errorMode.replacementChar);\n      } else {\n        return 0;\n      }\n    } else if (typeof u === \"string\") {\n      let size = 0;\n      for (let i = 0; i < u.length; i = Strings.offsetByCodePoints(u, i, 1)) {\n        size += Utf8.sizeOf(u.charCodeAt(i), errorMode);\n      }\n      return size;\n    } else {\n      throw new TypeError(\"\" + u);\n    }\n  };\n\n  Utf8.decodedOutput = function <T>(output: Output<T>, errorMode?: UtfErrorMode): Output<T> {\n    return Utf8DecodedOutput.create(output, errorMode);\n  };\n\n  Utf8.encodedOutput = function <T>(output: Output<T>, errorMode?: UtfErrorMode): Output<T> {\n    return Utf8EncodedOutput.create(output, errorMode);\n  };\n\n  Utf8.decodedString = function (): Output<string> {\n    return Utf8.decodedOutput(Unicode.stringOutput());\n  };\n\n  return Utf8;\n})();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Diagnostic} from \"../source/Diagnostic\";\nimport type {Input} from \"../input/Input\";\nimport type {Output} from \"../output/Output\";\nimport {Parser} from \"../parser/Parser\";\nimport {Unicode} from \"../unicode/Unicode\";\n\n/** @internal */\nexport class Base10NumberParser extends Parser<number> {\n  /** @internal */\n  readonly sign: number;\n  /** @internal */\n  readonly value: number;\n  /** @internal */\n  readonly mode: number;\n  /** @internal */\n  readonly step: number;\n\n  constructor(sign: number = 1, value: number = 0, mode: number = 2, step: number = 1) {\n    super();\n    this.sign = sign;\n    this.value = value;\n    this.mode = mode;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<number> {\n    return Base10NumberParser.parse(input, this.sign, this.value, this.mode, this.step);\n  }\n\n  static parse(input: Input, sign: number = 1, value: number = 0,\n               mode: number = 2, step: number = 1): Parser<number> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 45/*'-'*/) {\n          input = input.step();\n          sign = -1;\n        } else if (c === 43/*'+'*/) {\n          input = input.step();\n          sign = 1;\n        }\n        step = 2;\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"number\", input));\n      }\n    }\n    if (step === 2) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 48/*'0'*/) {\n          input = input.step();\n          step = 4;\n        } else if (c >= 49/*'1'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          value = sign * (c - 48/*'0'*/);\n          step = 3;\n        } else if (mode > 0 && c === 46/*'.'*/) {\n          let output = Unicode.stringOutput();\n          if (sign < 0) {\n            output = output.write(45/*'-'*/);\n          }\n          return Base10DecimalParser.parse(input, output, mode);\n        } else {\n          return Parser.error(Diagnostic.expected(\"number\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"number\", input));\n      }\n    }\n    if (step === 3) {\n      while (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          const newValue = 10 * value + sign * (c - 48/*'0'*/);\n          if (-9007199254740991 <= newValue && newValue <= 9007199254740992) {\n            value = newValue;\n            input = input.step();\n          } else {\n            return Parser.error(Diagnostic.message(\"integer overflow\", input));\n          }\n        } else {\n          break;\n        }\n      }\n      if (input.isCont()) {\n        step = 4;\n      } else if (input.isDone()) {\n        return Parser.done(value);\n      }\n    }\n    if (step === 4) {\n      if (input.isCont()) {\n        c = input.head();\n        if (mode > 0 && c === 46/*'.'*/ || mode > 1 && (c === 69/*'E'*/ || c === 101/*'e'*/)) {\n          let output = Unicode.stringOutput();\n          if (sign < 0 && value === 0) {\n            output = output.write(45/*'-'*/).write(48/*'0'*/);\n          } else {\n            output = output.write(\"\" + value);\n          }\n          return Base10DecimalParser.parse(input, output, mode);\n        } else {\n          return Parser.done(value);\n        }\n      } else if (input.isDone()) {\n        return Parser.done(value);\n      }\n    }\n    return new Base10NumberParser(sign, value, mode, step);\n  }\n}\n\n/** @internal */\nclass Base10DecimalParser extends Parser<number> {\n  /** @internal */\n  readonly output: Output<string>;\n  /** @internal */\n  readonly mode: number;\n  /** @internal */\n  readonly step: number;\n\n  constructor(output: Output<string>, mode: number = 2, step: number = 1) {\n    super();\n    this.output = output;\n    this.mode = mode;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<number> {\n    return Base10DecimalParser.parse(input, this.output, this.mode, this.step);\n  }\n\n  static parse(input: Input, output: Output<string>, mode: number = 2,\n               step: number = 1): Parser<number> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 46/*'.'*/) {\n          input = input.step();\n          output = output.write(c);\n          step = 2;\n        } else if (mode > 1 && (c === 69/*'E'*/ || c === 101/*'e'*/)) {\n          input = input.step();\n          output = output.write(c);\n          step = 5;\n        } else {\n          return Parser.error(Diagnostic.expected(\"decimal or exponent\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"decimal or exponent\", input));\n      }\n    }\n    if (step === 2) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          output = output.write(c);\n          step = 3;\n        } else {\n          return Parser.error(Diagnostic.expected(\"digit\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"digit\", input));\n      }\n    }\n    if (step === 3) {\n      while (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          output = output.write(c);\n        } else {\n          break;\n        }\n      }\n      if (input.isCont()) {\n        if (mode > 1) {\n          step = 4;\n        } else {\n          return Parser.done(+output.bind());\n        }\n      } else if (input.isDone()) {\n        return Parser.done(+output.bind());\n      }\n    }\n    if (step === 4) {\n      c = input.head();\n      if (c === 69/*'E'*/ || c === 101/*'e'*/) {\n        input = input.step();\n        output = output.write(c);\n        step = 5;\n      } else {\n        return Parser.done(+output.bind());\n      }\n    }\n    if (step === 5) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 43/*'+'*/ || c === 45/*'-'*/) {\n          input = input.step();\n          output = output.write(c);\n        }\n        step = 6;\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 6) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          output = output.write(c);\n          step = 7;\n        } else {\n          return Parser.error(Diagnostic.expected(\"digit\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"digit\", input));\n      }\n    }\n    if (step === 7) {\n      while (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          output = output.write(c);\n        } else {\n          break;\n        }\n      }\n      if (!input.isEmpty()) {\n        return Parser.done(+output.bind());\n      }\n    }\n    return new Base10DecimalParser(output, mode, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"../output/Output\";\nimport {WriterException} from \"../writer/WriterException\";\nimport {Writer} from \"../writer/Writer\";\nimport {Base10} from \"./Base10\";\n\n/** @internal */\nexport class Base10IntegerWriter extends Writer {\n  /** @internal */\n  readonly value: unknown;\n  /** @internal */\n  readonly input: number;\n  /** @internal */\n  readonly index: number;\n  /** @internal */\n  readonly step: number;\n\n  constructor(value: unknown, input: number, index: number = 0, step: number = 1) {\n    super();\n    this.value = value;\n    this.input = input;\n    this.index = index;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return Base10IntegerWriter.write(output, this.value, this.input, this.index, this.step);\n  }\n\n  static write(output: Output, value: unknown, input: number, index: number = 0,\n               step: number = 1): Writer {\n    if (step === 0) {\n      return Writer.end();\n    }\n    if (step === 1) {\n      if (input < 0) {\n        if (output.isCont()) {\n          output = output.write(45/*'-'*/);\n          step = 2;\n        }\n      } else {\n        step = 2;\n      }\n    }\n    if (step === 2) {\n      if (input > -10 && input < 10) {\n        if (output.isCont()) {\n          output = output.write(Base10.encodeDigit(Math.abs(input | 0)));\n          return Writer.done(value);\n        }\n      } else {\n        const digits = new Array<number>(19);\n        let x = input;\n        let i = 18;\n        while (x !== 0) {\n          digits[i] = Math.abs((x % 10) | 0);\n          x = (x / 10) | 0;\n          i -= 1;\n        }\n        i += 1 + index;\n        while (i < 19 && output.isCont()) {\n          output = output.write(Base10.encodeDigit(digits[i]!));\n          index += 1;\n          i += 1;\n        }\n        if (i === 19) {\n          return Writer.done(value);\n        }\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new Base10IntegerWriter(value, input, index, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Diagnostic} from \"../source/Diagnostic\";\nimport type {Input} from \"../input/Input\";\nimport type {Output} from \"../output/Output\";\nimport {Parser} from \"../parser/Parser\";\nimport {Base16} from \"./Base16\";\n\n/** @internal */\nexport class Base16Parser<O> extends Parser<O> {\n  /** @internal */\n  readonly output: Output<O>;\n  /** @internal */\n  readonly p: number;\n  /** @internal */\n  readonly step: number;\n\n  constructor(output: Output<O>, p: number = 0, step: number = 1) {\n    super();\n    this.output = output;\n    this.p = p;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<O> {\n    return Base16Parser.parse(input, this.output.clone(), this.p, this.step);\n  }\n\n  static parse<O>(input: Input, output: Output<O>, p: number = 0, step: number = 1): Parser<O> {\n    let c = 0;\n    while (!input.isEmpty()) {\n      if (step === 1) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          p = c;\n          step = 2;\n        } else if (!input.isEmpty()) {\n          return Parser.done(output.bind());\n        }\n      }\n      if (step === 2) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          output = Base16.writeQuantum(output, p, c);\n          p = 0;\n          step = 1;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"base16 digit\", input));\n        }\n      }\n    }\n    return new Base16Parser<O>(output, p, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"../output/Output\";\nimport {WriterException} from \"../writer/WriterException\";\nimport {Writer} from \"../writer/Writer\";\nimport type {Base16} from \"./Base16\";\n\n/** @internal */\nexport class Base16Writer extends Writer {\n  /** @internal */\n  readonly base16: Base16;\n  /** @internal */\n  readonly value: unknown;\n  /** @internal */\n  readonly input: Uint8Array | null;\n  /** @internal */\n  readonly index: number;\n  /** @internal */\n  readonly step: number;\n\n  constructor(base16: Base16, value: unknown, input: Uint8Array | null,\n              index: number = 0, step: number = 1) {\n    super();\n    this.base16 = base16;\n    this.value = value;\n    this.input = input;\n    this.index = index;\n    this.step = step;\n  }\n\n  override feed(value: unknown): Writer {\n    if (value instanceof Uint8Array) {\n      return new Base16Writer(this.base16, void 0, value);\n    } else {\n      throw new TypeError(\"\" + value);\n    }\n  }\n\n  override pull(output: Output): Writer {\n    if (this.input === null) {\n      throw new WriterException();\n    }\n    return Base16Writer.write(output, this.base16, this.value, this.input,\n                              this.index, this.step);\n  }\n\n  static write(output: Output, base16: Base16, value: unknown, input: Uint8Array,\n               index: number = 0, step: number = 1): Writer {\n    while (index < input.length) {\n      const x = input[index]!;\n      if (step === 1 && output.isCont()) {\n        output = output.write(base16.encodeDigit(x >>> 4));\n        step = 2;\n      }\n      if (step === 2 && output.isCont()) {\n        output = output.write(base16.encodeDigit(x & 0x0f));\n        index += 1;\n        step = 1;\n      }\n    }\n    if (index === input.length) {\n      return Writer.done(value);\n    } else if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new Base16Writer(base16, value, input, index, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"../output/Output\";\nimport {WriterException} from \"../writer/WriterException\";\nimport {Writer} from \"../writer/Writer\";\nimport type {Base16} from \"./Base16\";\n\n/** @internal */\nexport class Base16IntegerWriter extends Writer {\n  /** @internal */\n  readonly base16: Base16;\n  /** @internal */\n  readonly value: unknown;\n  /** @internal */\n  readonly input: number;\n  /** @internal */\n  readonly width: number;\n  /** @internal */\n  readonly index: number;\n  /** @internal */\n  readonly step: number;\n\n  constructor(base16: Base16, value: unknown, input: number,\n              width: number, index: number = 0, step: number = 3) {\n    super();\n    this.base16 = base16;\n    this.value = value;\n    this.input = input;\n    this.width = width;\n    this.index = index;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return Base16IntegerWriter.write(output, this.base16, this.value, this.input,\n                                     this.width, this.index, this.step);\n  }\n\n  static write(output: Output, base16: Base16, value: unknown, input: number,\n               width: number, index: number = 0, step: number = 3): Writer {\n    if (step <= 0) {\n      return Writer.end();\n    }\n    if (step === 1 && output.isCont()) {\n      output = output.write(48/*'0'*/);\n      step = 2;\n    }\n    if (step === 2 && output.isCont()) {\n      output = output.write(120/*'x'*/);\n      step = 3;\n    }\n    if (step === 3) {\n      if (input >= 0 && input < 16 && width <= 1) {\n        if (output.isCont()) {\n          output = output.write(base16.encodeDigit(input));\n          return Writer.done(value);\n        }\n      } else {\n        let i = 15;\n        const digits = new Array<number>(16);\n        let x = input;\n        while (x !== 0 || i >= 16 - width) {\n          digits[i] = x & 0xf;\n          x >>>= 4;\n          i -= 1;\n        }\n        i += 1 + index;\n        while (i < 16 && output.isCont()) {\n          output = output.write(base16.encodeDigit(digits[i]!));\n          index += 1;\n          i += 1;\n        }\n        if (i === 16) {\n          return Writer.done(value);\n        }\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new Base16IntegerWriter(base16, value, input, width, index, step);\n  }\n\n  static writeLiteral(output: Output, base16: Base16, value: unknown,\n                      input: number, width: number): Writer {\n    return Base16IntegerWriter.write(output, base16, value, input, width, 0, 1);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport type {Input} from \"../input/Input\";\nimport {Output} from \"../output/Output\";\nimport type {Parser} from \"../parser/Parser\";\nimport type {Writer} from \"../writer/Writer\";\nimport {Format} from \"../format/Format\";\nimport {Binary} from \"../binary/Binary\";\nimport {Unicode} from \"../unicode/Unicode\";\nimport {Base64Parser} from \"../\"; // forward import\nimport {Base64Writer} from \"../\"; // forward import\n\n/**\n * Base-64 (7-bit ASCII) encoding [[Parser]]/[[Writer]] factory.\n * @public\n */\nexport abstract class Base64 {\n  /**\n   * The 64 character string, where the character at index `i` is the encoding\n   * of the base-64 digit `i`.\n   */\n  abstract readonly alphabet: string;\n\n  /**\n   * Returns `true` if this base-64 encoding requires padding.\n   */\n  abstract isPadded(): boolean;\n\n  /**\n   * Returns this `Base64` encoding with required padding, if `padded` is `true`.\n   */\n  abstract asPadded(padded: boolean): Base64;\n\n  /**\n   * Returns `true` if the Unicode code point `c` is a valid base-64 digit.\n   */\n  abstract isDigit(c: number): boolean;\n\n  /**\n   * Returns the 7-bit quantity represented by the base-64 digit `c`.\n   *\n   * @throws `Error` if `c` is not a valid base-64 digit.\n   */\n  decodeDigit(c: number): number {\n    if (c >= 65/*'A'*/ && c <= 90/*'Z'*/) {\n      return c - 65/*'A'*/;\n    } else if (c >= 97/*'a'*/ && c <= 122/*'z'*/) {\n      return c + (26 - 97/*'a'*/);\n    } else if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n      return c + (52 - 48/*'0'*/);\n    } else if (c === 43/*'+'*/ || c === 45/*'-'*/) {\n      return 62;\n    } else if (c === 47/*'/'*/ || c === 95/*'_'*/) {\n      return 63;\n    } else {\n      let message = Unicode.stringOutput();\n      message = message.write(\"Invalid base-64 digit: \");\n      message = Format.debugChar(message, c);\n      throw new Error(message.bind());\n    }\n  }\n\n  /**\n   * Returns the Unicode code point of the base-64 digit that encodes the given\n   * 7-bit quantity.\n   */\n  encodeDigit(b: number): number {\n    return this.alphabet.charCodeAt(b);\n  }\n\n  /**\n   * Decodes the base-64 digits `c1`, `c2`, `c3`, and `c4`, and writes the 8 to\n   * 24 bit quantity they represent to the given `output`.\n   *\n   * @returns the continuation of the `output`.\n   */\n  writeQuantum<T>(output: Output<T>, c1: number, c2: number, c3: number, c4: number): Output<T> {\n    const x = this.decodeDigit(c1);\n    const y = this.decodeDigit(c2);\n    if (c3 !== 61/*'='*/) {\n      const z = this.decodeDigit(c3);\n      if (c4 !== 61/*'='*/) {\n        const w = this.decodeDigit(c4);\n        output = output.write((x << 2) | (y >>> 4));\n        output = output.write((y << 4) | (z >>> 2));\n        output = output.write((z << 6) | w);\n      } else {\n        output = output.write((x << 2) | (y >>> 4));\n        output = output.write((y << 4) | (z >>> 2));\n      }\n    } else {\n      if (c4 !== 61/*'='*/) {\n        return Output.error(new Error(\"Improperly padded base-64\"));\n      }\n      output = output.write((x << 2) | (y >>> 4));\n    }\n    return output;\n  }\n\n  /**\n   * Returns a `Parser` that decodes base-64 (7-bit ASCII) encoded input, and\n   * writes the decoded bytes to `output`.\n   */\n  parser<O>(output: Output<O>): Parser<O> {\n    return new Base64Parser<O>(this, output);\n  }\n\n  /**\n   * Parses the base-64 (7-bit ASCII) encoded `input`, and writes the decoded\n   * bytes to `output`, returning a `Parser` continuation that knows how to\n   * parse any additional input.\n   */\n  parse<O>(input: Input, output: Output<O>): Parser<O> {\n    return Base64Parser.parse(input, this, output);\n  }\n\n  /**\n   * Parses the base-64 (7-bit ASCII) encoded `input`, and writes the decoded\n   * bytes to a growable array, returning a `Parser` continuation that knows\n   * how to parse any additional input. The returned `Parser` [[Parser.bind\n   * binds]] a `Uint8Array` array containing all parsed base-64 data.\n   */\n  parseUint8Array(input: Input): Parser<Uint8Array> {\n    return Base64Parser.parse(input, this, Binary.output());\n  }\n\n  /**\n   * Returns a `Writer` that, when fed an input `Uint8Array`, returns a\n   * continuation that writes the base-64 (7-bit ASCII) encoding of the input\n   * `Uint8Array`.\n   */\n  uint8ArrayWriter(): Writer<Uint8Array, unknown>;\n  /**\n   * Returns a `Writer` continuation that writes the base-64 (7-bit ASCII)\n   * encoding of the `input` byte array.\n   */\n  uint8ArrayWriter(input: Uint8Array): Writer<unknown, Uint8Array>;\n  uint8ArrayWriter(input?: Uint8Array): Writer {\n    if (input === void 0) {\n      return new Base64Writer(this, void 0, null);\n    } else {\n      return new Base64Writer(this, input, input);\n    }\n  }\n\n  /**\n   * Writes the base-64 (7-bit ASCII) encoding of the `input` `Uint8Array` to\n   * the `output`, returning a `Writer` continuation that knows how to write\n   * any remaining output that couldn't be immediately generated.\n   */\n  writeUint8Array(output: Output, input: Uint8Array): Writer {\n    return Base64Writer.write(output, this, void 0, input);\n  }\n\n  /** @internal */\n  @Lazy\n  static get standardPadded(): Base64 {\n    return new Base64Standard(true);\n  }\n\n  /** @internal */\n  @Lazy\n  static get standardUnpadded(): Base64 {\n    return new Base64Standard(false);\n  }\n\n  /**\n   * Returns the `Base64` encoding with the standard alphabet, and required\n   * padding, if `isPadding` is `true`.\n   */\n  static standard(padded: boolean = true): Base64 {\n    if (padded) {\n      return Base64.standardPadded;\n    } else {\n      return Base64.standardUnpadded;\n    }\n  }\n\n  /** @internal */\n  @Lazy\n  static get urlPadded(): Base64 {\n    return new Base64Url(true);\n  }\n\n  /** @internal */\n  @Lazy\n  static get urlUnpadded(): Base64 {\n    return new Base64Url(false);\n  }\n\n  /**\n   * Returns the `Base64` encoding with the url and filename safe alphabet,\n   * and required padding, if `padded` is `true`.\n   */\n  static url(padded: boolean = true): Base64 {\n    if (padded) {\n      return Base64.urlPadded;\n    } else {\n      return Base64.urlUnpadded;\n    }\n  }\n}\n\n/** @internal */\nclass Base64Standard extends Base64 {\n  constructor(padded: boolean) {\n    super();\n    Object.defineProperty(this, \"padded\", {\n      value: padded,\n      enumerable: true,\n    });\n  }\n\n  get alphabet(): string {\n    return \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  }\n\n  /** @internal */\n  readonly padded!: boolean;\n\n  isPadded(): boolean {\n    return this.padded;\n  }\n\n  asPadded(padded: boolean): Base64 {\n    if (padded === this.padded) {\n      return this;\n    } else {\n      return Base64.standard(padded);\n    }\n  }\n\n  isDigit(c: number): boolean {\n    return c >= 48/*'0'*/ && c <= 57/*'9'*/\n        || c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/\n        || c === 43/*'+'*/ || c === 47/*'/'*/;\n  }\n}\n\n/** @internal */\nclass Base64Url extends Base64 {\n  constructor(padded: boolean) {\n    super();\n    Object.defineProperty(this, \"padded\", {\n      value: padded,\n      enumerable: true,\n    });\n  }\n\n  get alphabet(): string {\n    return \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n  }\n\n  /** @internal */\n  readonly padded!: boolean;\n\n  isPadded(): boolean {\n    return this.padded;\n  }\n\n  asPadded(padded: boolean): Base64 {\n    if (padded === this.padded) {\n      return this;\n    } else {\n      return Base64.url(padded);\n    }\n  }\n\n  isDigit(c: number): boolean {\n    return c >= 48/*'0'*/ && c <= 57/*'9'*/\n        || c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/\n        || c === 45/*'-'*/ || c === 95/*'_'*/;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Diagnostic} from \"../source/Diagnostic\";\nimport type {Input} from \"../input/Input\";\nimport type {Output} from \"../output/Output\";\nimport {Parser} from \"../parser/Parser\";\nimport type {Base64} from \"./Base64\";\n\n/** @internal */\nexport class Base64Parser<O> extends Parser<O> {\n  /** @internal */\n  readonly base64: Base64;\n  /** @internal */\n  readonly output: Output<O>;\n  /** @internal */\n  readonly p: number;\n  /** @internal */\n  readonly q: number;\n  /** @internal */\n  readonly r: number;\n  /** @internal */\n  readonly step: number;\n\n  constructor(base64: Base64, output: Output<O>, p: number = 0, q: number = 0,\n              r: number = 0, step: number = 1) {\n    super();\n    this.base64 = base64;\n    this.output = output;\n    this.p = p;\n    this.q = q;\n    this.r = r;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<O> {\n    return Base64Parser.parse(input, this.base64, this.output.clone(),\n                              this.p, this.q, this.r, this.step);\n  }\n\n  static parse<O>(input: Input, base64: Base64, output: Output<O>, p: number = 0,\n                  q: number = 0, r: number = 0, step: number = 1): Parser<O> {\n    let c = 0;\n    while (!input.isEmpty()) {\n      if (step === 1) {\n        if (input.isCont() && (c = input.head(), base64.isDigit(c))) {\n          input = input.step();\n          p = c;\n          step = 2;\n        } else if (!input.isEmpty()) {\n          return Parser.done(output.bind());\n        }\n      }\n      if (step === 2) {\n        if (input.isCont() && (c = input.head(), base64.isDigit(c))) {\n          input = input.step();\n          q = c;\n          step = 3;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"base64 digit\", input));\n        }\n      }\n      if (step === 3) {\n        if (input.isCont() && (c = input.head(), base64.isDigit(c) || c === 61/*'='*/)) {\n          input = input.step();\n          r = c;\n          if (c !== 61/*'='*/) {\n            step = 4;\n          } else {\n            step = 5;\n          }\n        } else if (!input.isEmpty()) {\n          if (!base64.isPadded()) {\n            output = base64.writeQuantum(output, p, q, 61/*'='*/, 61/*'='*/);\n            return Parser.done(output.bind());\n          } else {\n            return Parser.error(Diagnostic.unexpected(input));\n          }\n        }\n      }\n      if (step === 4) {\n        if (input.isCont() && (c = input.head(), base64.isDigit(c) || c === 61/*'='*/)) {\n          input = input.step();\n          output = base64.writeQuantum(output, p, q, r, c);\n          r = 0;\n          q = 0;\n          p = 0;\n          if (c !== 61/*'='*/) {\n            step = 1;\n          } else {\n            return Parser.done(output.bind());\n          }\n        } else if (!input.isEmpty()) {\n          if (!base64.isPadded()) {\n            output = base64.writeQuantum(output, p, q, r, 61/*'='*/);\n            return Parser.done(output.bind());\n          } else {\n            return Parser.error(Diagnostic.unexpected(input));\n          }\n        }\n      } else if (step === 5) {\n        if (input.isCont() && (c = input.head(), c === 61/*'='*/)) {\n          input = input.step();\n          output = base64.writeQuantum(output, p, q, r, c);\n          r = 0;\n          q = 0;\n          p = 0;\n          return Parser.done(output.bind());\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(61/*'='*/, input));\n        }\n      }\n    }\n    return new Base64Parser<O>(base64, output, p, q, r, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"../output/Output\";\nimport {WriterException} from \"../writer/WriterException\";\nimport {Writer} from \"../writer/Writer\";\nimport type {Base64} from \"./Base64\";\n\n/** @internal */\nexport class Base64Writer extends Writer {\n  /** @internal */\n  readonly base64: Base64;\n  /** @internal */\n  readonly value: unknown;\n  /** @internal */\n  readonly input: Uint8Array | null;\n  /** @internal */\n  readonly index: number;\n  /** @internal */\n  readonly step: number;\n\n  constructor(base64: Base64, value: unknown, input: Uint8Array | null,\n              index: number = 0, step: number = 1) {\n    super();\n    this.base64 = base64;\n    this.value = value;\n    this.input = input;\n    this.index = index;\n    this.step = step;\n  }\n\n  override feed(value: unknown): Writer {\n    if (value instanceof Uint8Array) {\n      return new Base64Writer(this.base64, null, value);\n    } else {\n      throw new TypeError(\"\" + value);\n    }\n  }\n\n  override pull(output: Output): Writer {\n    if (this.input === null) {\n      throw new WriterException();\n    }\n    return Base64Writer.write(output, this.base64, this.value, this.input,\n                              this.index, this.step);\n  }\n\n  static write(output: Output, base64: Base64, value: unknown, input: Uint8Array,\n               index: number = 0, step: number = 1): Writer {\n    while (index + 2 < input.length && output.isCont()) {\n      const x = input[index]!;\n      const y = input[index + 1]!;\n      const z = input[index + 2]!;\n      if (step === 1 && output.isCont()) {\n        output = output.write(base64.encodeDigit(x >>> 2));\n        step = 2;\n      }\n      if (step === 2 && output.isCont()) {\n        output = output.write(base64.encodeDigit(((x << 4) | (y >>> 4)) & 0x3f));\n        step = 3;\n      }\n      if (step === 3 && output.isCont()) {\n        output = output.write(base64.encodeDigit(((y << 2) | (z >>> 6)) & 0x3f));\n        step = 4;\n      }\n      if (step === 4 && output.isCont()) {\n        output = output.write(base64.encodeDigit(z & 0x3f));\n        index += 3;\n        step = 1;\n      }\n    }\n    if (index + 1 < input.length && output.isCont()) {\n      const x = input[index]!;\n      const y = input[index + 1]!;\n      if (step === 1 && output.isCont()) {\n        output = output.write(base64.encodeDigit(x >>> 2));\n        step = 2;\n      }\n      if (step === 2 && output.isCont()) {\n        output = output.write(base64.encodeDigit(((x << 4) | (y >>> 4)) & 0x3f));\n        step = 3;\n      }\n      if (step === 3 && output.isCont()) {\n        output = output.write(base64.encodeDigit((y << 2) & 0x3f));\n        step = 4;\n      }\n      if (step === 4) {\n        if (!base64.isPadded()) {\n          index += 2;\n        } else if (output.isCont()) {\n          output = output.write(61/*'='*/);\n          index += 2;\n        }\n      }\n    } else if (index < input.length && output.isCont()) {\n      const x = input[index]!;\n      if (step === 1 && output.isCont()) {\n        output = output.write(base64.encodeDigit(x >>> 2));\n        step = 2;\n      }\n      if (step === 2 && output.isCont()) {\n        output = output.write(base64.encodeDigit((x << 4) & 0x3f));\n        step = 3;\n      }\n      if (step === 3) {\n        if (!base64.isPadded()) {\n          index += 1;\n        } else if (output.isCont()) {\n          output = output.write(61/*'='*/);\n          step = 4;\n        }\n      }\n      if (step === 4 && output.isCont()) {\n        output = output.write(61/*'='*/);\n        index += 1;\n      }\n    }\n    if (index === input.length) {\n      return Writer.done(value);\n    } else if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new Base64Writer(base64, value, input, index, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/** @public */\nexport type Affinity = 0 | 1 | 2 | 3 | 4;\n\n/** @public */\nexport const Affinity: {\n  readonly Transient: 0;\n  readonly Inherited: 1;\n  readonly Intrinsic: 2;\n  readonly Extrinsic: 3;\n\n  readonly Reflexive: 4;\n\n  /** @internal */\n  readonly Shift: number;\n  /** @internal */\n  readonly Mask: number;\n} = Object.freeze({\n  Transient: 0,\n  Inherited: 1,\n  Intrinsic: 2,\n  Extrinsic: 3,\n\n  Reflexive: 4,\n\n  Shift: 2,\n  Mask: (1 << 2) - 1,\n});\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Proto} from \"@swim/util\";\nimport type {Timing} from \"@swim/util\";\nimport type {FastenerClass} from \"./Fastener\";\nimport type {Fastener} from \"./Fastener\";\n\n// Polyfill Symbol.metadata\nif (Symbol.metadata === void 0) {\n  (Symbol as any).metadata = Symbol(\"Symbol.metadata\");\n}\n\n/** @public */\nexport interface FastenerContext {\n  getFastener?<F extends Fastener<any, any, any>>(fastenerName: PropertyKey, fastenerType?: Proto<F>, contextType?: Proto<any> | null): F | null;\n\n  getParentFastener?<F extends Fastener<any, any, any>>(fastenerName: PropertyKey, fastenerType?: Proto<F>, contextType?: Proto<any> | null): F | null;\n\n  attachFastener?(fastener: Fastener<any, any, any>): void;\n\n  decohereFastener?(fastener: Fastener<any, any, any>): void;\n\n  requireUpdate?(updateFlags: number): void;\n\n  getTransition?(fastener: Fastener<any, any, any>): Timing | null;\n}\n\n/** @public */\nexport const FastenerContext: {\n  /** @internal */\n  readonly metaclass: unique symbol;\n\n  getMetaclass<R>(context: R): FastenerContextMetaclass<R> | null;\n} = {\n  metaclass: Symbol(\"FastenerContext.metaclass\") as any,\n\n  getMetaclass<R>(context: R): FastenerContextMetaclass<R> | null {\n    const constructor = (context as object).constructor;\n    if (constructor === void 0) {\n      return null;\n    }\n    const metadata = constructor[Symbol.metadata];\n    if (metadata === void 0 || metadata === null) {\n      return null;\n    }\n    const contextMetaclass = metadata[FastenerContext.metaclass];\n    if (contextMetaclass === void 0) {\n      return null;\n    }\n    return contextMetaclass as FastenerContextMetaclass<R>;\n  },\n};\n\n/** @public */\nexport class FastenerContextMetaclass<R> {\n  constructor() {\n    this.classMap = {};\n    this.slotMap = {};\n    this.slots = [];\n  }\n\n  /** @internal */\n  readonly classMap: {[fastenerName: PropertyKey]: FastenerClass<any> | undefined};\n\n  /** @internal */\n  readonly slotMap: {[fastenerName: PropertyKey]: keyof R | undefined};\n\n  /** @internal */\n  readonly slots: (keyof R)[];\n\n  getFastenerClass<K extends keyof R>(fastenerName: K): R[K] extends Fastener<any, any, any> ? FastenerClass<R[K]> | null : null {\n    const fastenerClass = this.classMap[fastenerName];\n    return (fastenerClass !== void 0 ? fastenerClass : null) as R[K] extends Fastener<any, any, any> ? FastenerClass<R[K]> | null : null;\n  }\n\n  getFastenerSlot(fastenerName: PropertyKey): keyof R | undefined {\n    return this.slotMap[fastenerName];\n  }\n\n  tryFastener<K extends keyof R, F extends R[K]>(owner: R, fastenerName: K): (F extends Fastener<any, any, any> ? F | null : never) | null {\n    const fastenerSlot = this.slotMap[fastenerName];\n    const fastener = fastenerSlot !== void 0 ? owner[fastenerSlot] : void 0;\n    return (fastener !== void 0 ? fastener : null) as (F extends Fastener<any, any, any> ? F | null : never) | null;\n  }\n\n  static get<R>(metadata: Record<PropertyKey, unknown> & object /*DecoratorMetadataObject*/): FastenerContextMetaclass<R> | null {\n    if (Object.hasOwnProperty.call(metadata, FastenerContext.metaclass)) {\n      return metadata[FastenerContext.metaclass] as FastenerContextMetaclass<R>;\n    }\n    return null;\n  }\n\n  static getOrCreate<R>(metadata: Record<PropertyKey, unknown> & object /*DecoratorMetadataObject*/): FastenerContextMetaclass<R> {\n    if (Object.hasOwnProperty.call(metadata, FastenerContext.metaclass)) {\n      return metadata[FastenerContext.metaclass] as FastenerContextMetaclass<R>;\n    }\n\n    const superMetaclass = metadata[FastenerContext.metaclass] as FastenerContextMetaclass<R> | undefined;\n    const contextMetaclass = new FastenerContextMetaclass<R>();\n    metadata[FastenerContext.metaclass] = contextMetaclass;\n\n    if (superMetaclass !== void 0) {\n      for (const fastenerName in superMetaclass.classMap) {\n        contextMetaclass.classMap[fastenerName] = superMetaclass.classMap[fastenerName];\n      }\n      for (const fastenerName in superMetaclass.slotMap) {\n        contextMetaclass.slotMap[fastenerName] = superMetaclass.slotMap[fastenerName];\n      }\n      contextMetaclass.slots.push(...superMetaclass.slots);\n    }\n\n    return contextMetaclass;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {__esDecorate} from \"tslib\";\nimport {__runInitializers} from \"tslib\";\nimport type {Mutable} from \"@swim/util\";\nimport type {Proto} from \"@swim/util\";\nimport {Identifiers} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport type {Timing} from \"@swim/util\";\nimport {Affinity} from \"./Affinity\";\nimport {FastenerContext} from \"./FastenerContext\";\nimport {FastenerContextMetaclass} from \"./FastenerContext\";\n\n/** @public */\nexport type FastenerFlags = number;\n\n/** @public */\nexport interface FastenerDescriptor<R> {\n  name?: PropertyKey;\n  extends?: Proto<Fastener<any, any, any>> | boolean | null;\n  affinity?: Affinity;\n  inherits?: PropertyKey | boolean;\n}\n\n/** @public */\nexport interface FastenerDecorator<F extends Fastener<any, any, any>> {\n  <T>(target: any, context: ClassFieldDecoratorContext<T, F>): (this: T, value?: F) => F;\n  <T>(target: (this: T) => F, context: ClassGetterDecoratorContext<T, F>): (this: T) => F;\n}\n\n/** @public */\nexport type FastenerTemplate<F extends Fastener<any, any, any>> =\n  F extends {readonly descriptorType?: Proto<infer D>}\n          ? ThisType<F> & D & Partial<Omit<F, keyof D>> & (F extends Fastener<infer R, any, any> ? {readonly inletKeys?: readonly (keyof R)[]} : {})\n          : never;\n\n/** @public */\nexport type FastenerClassTemplate<C extends FastenerClass<any>> =\n  ThisType<C> & Partial<C>;\n\n/** @public */\nexport interface FastenerClass<F extends Fastener<any, any, any> = Fastener<any, any, any>> {\n  /** @internal */\n  prototype: F;\n\n  <F2 extends F>(template: FastenerTemplate<F2>): FastenerDecorator<F2>;\n\n  create(owner: F extends Fastener<infer R, any, any> ? R : never): F;\n\n  /** @protected */\n  construct(fastener: F | null, owner: F extends Fastener<infer R, any, any> ? R : never): F;\n\n  /** @internal */\n  declare<F2 extends F, C extends FastenerClass<any> = FastenerClass<F2>>(className: PropertyKey): C;\n\n  /** @internal */\n  implement<F2 extends F, C extends FastenerClass<any> = FastenerClass<F2>>(fastenerClass: C, template: FastenerTemplate<F2>, classTemplate?: FastenerClassTemplate<C>): void;\n\n  specialize(template: F extends {readonly descriptorType?: Proto<infer D>} ? D : never): FastenerClass<F>;\n\n  refine(fastenerClass: FastenerClass<Fastener<any, any, any>>): void;\n\n  extend<F2 extends F, C extends FastenerClass<any> = FastenerClass<F2>>(className: PropertyKey, template: FastenerTemplate<F2>, classTemplate?: FastenerClassTemplate<C>): C;\n\n  define<F2 extends F>(className: PropertyKey, template: FastenerTemplate<F2>, extendsClass?: FastenerClass<F>): FastenerClass<F2>;\n\n  /**\n   * Dummy getter function that always throws an exception. Used as a stand-in\n   * for decorated fastener getters, whose implementation is injected by the\n   * decorator.\n   */\n  getter<F2 extends F>(): F2;\n\n  /** @internal */\n  decorate<F2 extends F>(baseClass: FastenerClass<any>, template: FastenerTemplate<F2>, target: undefined, context: ClassFieldDecoratorContext<F2 extends Fastener<infer R, any, any> ? R : never, F2>): (this: F2 extends Fastener<infer R, any, any> ? R : never, value?: F2) => F2;\n  /** @internal */\n  decorate<F2 extends F>(baseClass: FastenerClass<any>, template: FastenerTemplate<F2>, target: (this: F2 extends Fastener<infer R, any, any> ? R : never) => F2, context: ClassGetterDecoratorContext<F2 extends Fastener<infer R, any, any> ? R : never, F2>): (this: F2 extends Fastener<infer R, any, any> ? R : never) => F2;\n\n  /** @internal */\n  decorateField<F2 extends F>(baseClass: FastenerClass<any>, template: FastenerTemplate<F2>, target: undefined, context: ClassFieldDecoratorContext<F2 extends Fastener<infer R, any, any> ? R : never, F2>): (this: F2 extends Fastener<infer R, any, any> ? R : never, value?: F2) => F2;\n\n  /** @internal */\n  decorateGetter<F2 extends F>(baseClass: FastenerClass<any>, template: FastenerTemplate<F2>, target: (this: F2 extends Fastener<infer R, any, any> ? R : never) => F2, context: ClassGetterDecoratorContext<F2 extends Fastener<infer R, any, any> ? R : never, F2>): (this: F2 extends Fastener<infer R, any, any> ? R : never) => F2;\n\n  /** @internal */\n  initDecorators(): void;\n\n  /** @internal */\n  defineField<F2 extends F, K extends keyof F2>(name: K, decorators: F2[K] extends Fastener<any, any, any> ? FastenerDecorator<F2[K]>[] : never): void;\n\n  /** @internal */\n  defineGetter<F2 extends F, K extends keyof F2>(name: K, decorators: F2[K] extends Fastener<any, any, any> ? FastenerDecorator<F2[K]>[] : never): void;\n\n  /** @internal */\n  initFasteners(fastener: F): void;\n\n  /** @internal */\n  readonly fieldInitializers?: {[name: PropertyKey]: Function[]};\n  /** @internal */\n  readonly instanceInitializers?: Function[];\n\n  /** @internal */\n  readonly MountedFlag: FastenerFlags;\n  /** @internal */\n  readonly InheritsFlag: FastenerFlags;\n  /** @internal */\n  readonly DerivedFlag: FastenerFlags;\n  /** @internal */\n  readonly DecoherentFlag: FastenerFlags;\n\n  /** @internal */\n  readonly FlagShift: number;\n  /** @internal */\n  readonly FlagMask: FastenerFlags;\n}\n\n/** @public */\nexport interface Fastener<R = any, O = any, I extends any[] = [O]> extends FastenerContext {\n  get descriptorType(): Proto<FastenerDescriptor<R>>;\n\n  get fastenerType(): Proto<Fastener<any, any, any>>;\n\n  readonly owner: R;\n\n  readonly name: PropertyKey;\n\n  get binds(): boolean;\n\n  /** @protected */\n  init(): void;\n\n  /** @internal */\n  get flagsInit(): FastenerFlags;\n\n  /** @internal */\n  readonly flags: FastenerFlags;\n\n  /** @internal */\n  setFlags(flags: FastenerFlags): void;\n\n  readonly coherentTime: number;\n\n  /** @protected */\n  setCoherentTime(coherentTime: number): void;\n\n  readonly version: number;\n\n  /** @protected */\n  incrementVersion(): void;\n\n  get parentType(): Proto<any> | null | undefined;\n\n  get parent(): Fastener<any, any, any> | null;\n\n  readonly inletVersion: readonly number[] | number;\n\n  readonly inlet: readonly Fastener<any, any, any>[] | Fastener<any, any, any> | null;\n\n  /** @internal */\n  inheritInlet(): void;\n\n  bindInlet<K extends keyof I, IK extends I[K]>(inlet: Fastener<any, IK, any>, key: IK): void;\n  bindInlet<I0 extends I[0]>(inlet: Fastener<any, I0, any>): void;\n\n  /** @protected */\n  willBindInlet(inlet: Fastener<any, any, any>): void;\n\n  /** @protected */\n  onBindInlet(inlet: Fastener<any, any, any>): void;\n\n  /** @protected */\n  didBindInlet(inlet: Fastener<any, any, any>): void;\n\n  /** @internal */\n  uninheritInlet(): void;\n\n  unbindInlet(inlet?: Fastener<any, any, any>): void;\n\n  /** @protected */\n  willUnbindInlet(inlet: Fastener<any, any, any>): void;\n\n  /** @protected */\n  onUnbindInlet(inlet: Fastener<any, any, any>): void;\n\n  /** @protected */\n  didUnbindInlet(inlet: Fastener<any, any, any>): void;\n\n  /** @internal */\n  attachOutlet(outlet: Fastener<any, any, any>): void;\n\n  /** @internal */\n  detachOutlet(outlet: Fastener<any, any, any>): void;\n\n  get inheritName(): PropertyKey | undefined;\n\n  get inherits(): boolean;\n\n  setInherits(inherits: PropertyKey | boolean): void;\n\n  /** @protected */\n  willSetInherits(inherits: boolean, inheritName: PropertyKey | undefined): void;\n\n  /** @protected */\n  onSetInherits(inherits: boolean, inheritName: PropertyKey | undefined): void;\n\n  /** @protected */\n  didSetInherits(inherits: boolean, inheritName: PropertyKey | undefined): void;\n\n  get derived(): boolean;\n\n  /** @internal */\n  setDerived(derived: boolean): void;\n\n  get affinity(): Affinity;\n\n  hasAffinity(affinity: Affinity): boolean;\n\n  /** @internal */\n  initAffinity(affinity: Affinity): void;\n\n  /** @internal */\n  minAffinity(affinity: Affinity): boolean;\n\n  setAffinity(affinity: Affinity): void;\n\n  /** @protected */\n  willSetAffinity(newAffinity: Affinity, oldAffinity: Affinity): void;\n\n  /** @protected */\n  onSetAffinity(newAffinity: Affinity, oldAffinity: Affinity): void;\n\n  /** @protected */\n  didSetAffinity(newAffinity: Affinity, oldAffinity: Affinity): void;\n\n  get(): O;\n\n  get coherent(): boolean;\n\n  /** @protected */\n  setCoherent(coherent: boolean): void;\n\n  decohere(inlet?: Fastener<any, any, any>): void;\n\n  requireRecohere(): void;\n\n  recohere(t: number): void;\n\n  /** @protected */\n  get inletKeys(): readonly PropertyKey[] | undefined;\n\n  resolveInlets(): readonly Fastener<any, any, any>[] | null;\n\n  /** @protected */\n  attachInlets(): void;\n\n  /** @protected */\n  detachInlets(): void;\n\n  /** @override */\n  getFastener<F extends Fastener>(fastenerName: PropertyKey, fastenerType?: Proto<F>, contextType?: Proto<any> | null): F | null;\n\n  /** @override */\n  getParentFastener<F extends Fastener>(fastenerName: string, fastenerType?: Proto<F>, contextType?: Proto<any>): F | null;\n\n  /** @override */\n  attachFastener(fastener: Fastener<any, any, any>): void;\n\n  /** @override */\n  decohereFastener(fastener: Fastener<any, any, any>): void;\n\n  /** @override */\n  requireUpdate(updateFlags: number): void;\n\n  /** @override */\n  getTransition?(fastener: Fastener<any, any, any>): Timing | null;\n\n  /** @internal @protected */\n  mountFasteners(): void;\n\n  /** @internal @protected */\n  unmountFasteners(): void;\n\n  get mounted(): boolean;\n\n  /** @internal */\n  mount(): void;\n\n  /** @protected */\n  willMount(): void;\n\n  /** @protected */\n  onMount(): void;\n\n  /** @protected */\n  didMount(): void;\n\n  /** @internal */\n  unmount(): void;\n\n  /** @protected */\n  willUnmount(): void;\n\n  /** @protected */\n  onUnmount(): void;\n\n  /** @protected */\n  didUnmount(): void;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const Fastener = (<R, O, I extends any[], F extends Fastener<any, any, any>>() => (function (template: FastenerTemplate<Fastener<R, O, I>>, classTemplate: FastenerClassTemplate<FastenerClass<F>>): FastenerClass<F> {\n  const Fastener = function (template: FastenerTemplate<F>): FastenerDecorator<F> {\n    return Fastener.decorate.bind(Fastener, Fastener, template) as unknown as FastenerDecorator<F>;\n  } as FastenerClass<F>;\n  Object.setPrototypeOf(template, Object.prototype);\n  Fastener.prototype = template as F;\n  Fastener.prototype.constructor = Fastener;\n  Object.setPrototypeOf(classTemplate, Fastener.prototype);\n  Object.setPrototypeOf(Fastener, classTemplate);\n  return Fastener;\n})({\n  get fastenerType(): Proto<Fastener<any, any, any>> {\n    return Fastener;\n  },\n\n  get name(): string {\n    return \"Fastener\";\n  },\n\n  init(): void {\n    // hook\n  },\n\n  binds: false,\n\n  flagsInit: 0,\n\n  setFlags(flags: FastenerFlags): void {\n    (this as Mutable<typeof this>).flags = flags;\n  },\n\n  incrementVersion(): void {\n    (this as Mutable<typeof this>).version += 1;\n  },\n\n  setCoherentTime(coherentTime: number): void {\n    (this as Mutable<typeof this>).coherentTime = coherentTime;\n  },\n\n  get parentType(): Proto<any> | null | undefined {\n    return void 0;\n  },\n\n  get parent(): Fastener<any, any, any> | null {\n    const inheritName = this.inheritName;\n    if (inheritName === void 0 || !Objects.hasAllKeys<FastenerContext>(this.owner, \"getParentFastener\")) {\n      return null;\n    }\n    return this.owner.getParentFastener!(inheritName, this.fastenerType, this.parentType);\n  },\n\n  inheritInlet(): void {\n    let inlet: Fastener | null;\n    if ((this.flags & Fastener.InheritsFlag) === 0 || (inlet = this.parent) === null) {\n      return;\n    }\n    this.willBindInlet(inlet);\n    inlet.attachOutlet(this);\n    (this as Mutable<typeof this>).inletVersion = -1;\n    (this as Mutable<typeof this>).inlet = inlet;\n    this.onBindInlet(inlet);\n    this.didBindInlet(inlet);\n  },\n\n  bindInlet<K extends keyof I, IK extends I[K]>(inlet: Fastener<any, IK, any>, key?: IK): void {\n    this.setInherits(false);\n    this.willBindInlet(inlet);\n    inlet.attachOutlet(this);\n    (this as Mutable<typeof this>).inletVersion = -1;\n    (this as Mutable<typeof this>).inlet = inlet;\n    this.onBindInlet(inlet);\n    this.didBindInlet(inlet);\n  },\n\n  willBindInlet(inlet: Fastener<any, any, any>): void {\n    // hook\n  },\n\n  onBindInlet(inlet: Fastener<any, any, any>): void {\n    this.recohere(performance.now());\n  },\n\n  didBindInlet(inlet: Fastener<any, any, any>): void {\n    // hook\n  },\n\n  uninheritInlet(): void {\n    if ((this.flags & Fastener.InheritsFlag) === 0) {\n      return;\n    }\n    const inlet = this.inlet;\n    if (!(inlet instanceof Fastener)) {\n      return;\n    }\n    this.willUnbindInlet(inlet);\n    inlet.detachOutlet(this);\n    (this as Mutable<typeof this>).inletVersion = -1;\n    (this as Mutable<typeof this>).inlet = null;\n    this.onUnbindInlet(inlet);\n    this.didUnbindInlet(inlet);\n  },\n\n  unbindInlet(inlet?: Fastener<any, any, any>): void {\n    if (inlet === void 0 && this.inlet instanceof Fastener) {\n      inlet = this.inlet;\n    }\n    if (inlet instanceof Fastener && inlet === this.inlet) {\n      this.willUnbindInlet(inlet);\n      inlet.detachOutlet(this);\n      (this as Mutable<typeof this>).inletVersion = -1;\n      (this as Mutable<typeof this>).inlet = null;\n      this.onUnbindInlet(inlet);\n      this.didUnbindInlet(inlet);\n    } else if (inlet === void 0) {\n      (this as Mutable<typeof this>).inletVersion = -1;\n      (this as Mutable<typeof this>).inlet = null;\n    }\n  },\n\n  willUnbindInlet(inlet: Fastener<any, any, any>): void {\n    // hook\n  },\n\n  onUnbindInlet(inlet: Fastener<any, any, any>): void {\n    this.setDerived(false);\n  },\n\n  didUnbindInlet(inlet: Fastener<any, any, any>): void {\n    // hook\n  },\n\n  attachOutlet(outlet: Fastener<any, any, any>): void {\n    // hook\n  },\n\n  detachOutlet(outlet: Fastener<any, any, any>): void {\n    // hook\n  },\n\n  get inheritName(): PropertyKey | undefined {\n    return (this.flags & Fastener.InheritsFlag) !== 0 ? this.name : void 0;\n  },\n\n  get inherits(): boolean {\n    return (this.flags & Fastener.InheritsFlag) !== 0;\n  },\n\n  setInherits(inherits: PropertyKey | boolean): void {\n    let inheritName: PropertyKey | undefined;\n    if (typeof inherits === \"string\" || typeof inherits === \"number\" || typeof inherits === \"symbol\") {\n      if (inherits !== this.name) {\n        inheritName = inherits;\n      }\n      inherits = true;\n    }\n    if (inherits && ((this.flags & Fastener.InheritsFlag) === 0 || (inheritName !== void 0 && inheritName !== this.name))) {\n      this.unbindInlet();\n      this.willSetInherits(true, inheritName);\n      if (inheritName !== void 0) {\n        Object.defineProperty(this, \"name\", {\n          value: inheritName,\n          enumerable: true,\n          configurable: true,\n        });\n      }\n      this.setFlags(this.flags | Fastener.InheritsFlag);\n      this.onSetInherits(true, inheritName);\n      this.didSetInherits(true, inheritName);\n      this.inheritInlet();\n    } else if (!inherits && (this.flags & Fastener.InheritsFlag) !== 0) {\n      this.unbindInlet();\n      this.willSetInherits(false, inheritName);\n      this.setFlags(this.flags & ~Fastener.InheritsFlag);\n      this.onSetInherits(false, inheritName);\n      this.didSetInherits(false, inheritName);\n    }\n  },\n\n  willSetInherits(inherits: boolean, inheritName: PropertyKey | undefined): void {\n    // hook\n  },\n\n  onSetInherits(inherits: boolean, inheritName: PropertyKey | undefined): void {\n    // hook\n  },\n\n  didSetInherits(inherits: boolean, inheritName: PropertyKey | undefined): void {\n    // hook\n  },\n\n  get derived(): boolean {\n    return (this.flags & Fastener.DerivedFlag) !== 0;\n  },\n\n  setDerived(derived: boolean): void {\n    if (derived) {\n      this.setFlags(this.flags | Fastener.DerivedFlag);\n    } else {\n      this.setFlags(this.flags & ~Fastener.DerivedFlag);\n    }\n  },\n\n  get affinity(): Affinity {\n    return (this.flags & Affinity.Mask) as Affinity;\n  },\n\n  hasAffinity(affinity: Affinity): boolean {\n    return affinity >= (this.flags & Affinity.Mask);\n  },\n\n  initAffinity(affinity: Affinity): void {\n    (this as Mutable<typeof this>).flags = this.flags & ~Affinity.Mask | affinity & Affinity.Mask;\n  },\n\n  minAffinity(newAffinity: Affinity): boolean {\n    const oldAffinity = (this.flags & Affinity.Mask) as Affinity;\n    if (newAffinity === Affinity.Reflexive) {\n      newAffinity = oldAffinity;\n    } else if ((newAffinity & ~Affinity.Mask) !== 0) {\n      throw new Error(\"invalid affinity: \" + newAffinity);\n    }\n    if (newAffinity > oldAffinity) {\n      this.willSetAffinity(newAffinity, oldAffinity);\n      this.setFlags(this.flags & ~Affinity.Mask | newAffinity);\n      this.onSetAffinity(newAffinity, oldAffinity);\n      this.didSetAffinity(newAffinity, oldAffinity);\n    }\n    return newAffinity >= oldAffinity;\n  },\n\n  setAffinity(newAffinity: Affinity): void {\n    if ((newAffinity & ~Affinity.Mask) !== 0) {\n      throw new Error(\"invalid affinity: \" + newAffinity);\n    }\n    const oldAffinity = (this.flags & Affinity.Mask) as Affinity;\n    if (newAffinity === oldAffinity) {\n      return;\n    }\n    this.willSetAffinity(newAffinity, oldAffinity);\n    this.setFlags(this.flags & ~Affinity.Mask | newAffinity);\n    this.onSetAffinity(newAffinity, oldAffinity);\n    this.didSetAffinity(newAffinity, oldAffinity);\n  },\n\n  willSetAffinity(newAffinity: Affinity, oldAffinity: Affinity): void {\n    // hook\n  },\n\n  onSetAffinity(newAffinity: Affinity, oldAffinity: Affinity): void {\n    if (newAffinity > oldAffinity && (this.flags & Fastener.DerivedFlag) !== 0) {\n      const inlet = this.inlet;\n      if (inlet instanceof Fastener && Math.min(inlet.flags & Affinity.Mask, Affinity.Intrinsic) < newAffinity) {\n        this.setDerived(false);\n      }\n    } else if (newAffinity < oldAffinity && (this.flags & Fastener.InheritsFlag) !== 0) {\n      const inlet = this.inlet;\n      if (inlet instanceof Fastener && Math.min(inlet.flags & Affinity.Mask, Affinity.Intrinsic) >= newAffinity) {\n        this.decohere(inlet);\n      }\n    }\n  },\n\n  didSetAffinity(newAffinity: Affinity, oldAffinity: Affinity): void {\n    // hook\n  },\n\n  get(): O {\n    return void 0 as O;\n  },\n\n  get coherent(): boolean {\n    return (this.flags & Fastener.DecoherentFlag) === 0;\n  },\n\n  setCoherent(coherent: boolean): void {\n    if (coherent) {\n      this.setFlags(this.flags & ~Fastener.DecoherentFlag);\n    } else {\n      this.setFlags(this.flags | Fastener.DecoherentFlag);\n    }\n  },\n\n  decohere(inlet?: Fastener<any, any, any>): void {\n    if (inlet === void 0 || inlet !== this.inlet || (this.flags & Fastener.DerivedFlag) !== 0) {\n      if ((this.flags & Fastener.DecoherentFlag) === 0) {\n        this.requireRecohere();\n      }\n    } else {\n      this.recohere(performance.now());\n    }\n  },\n\n  requireRecohere(): void {\n    this.setCoherent(false);\n    if (Objects.hasAllKeys<FastenerContext>(this.owner, \"decohereFastener\")) {\n      this.owner.decohereFastener!(this);\n    }\n  },\n\n  recohere(t: number): void {\n    this.setCoherentTime(t);\n    const inlet = this.inlet;\n    if (inlet instanceof Fastener) {\n      this.setDerived((this.flags & Affinity.Mask) <= Math.min(inlet.flags & Affinity.Mask, Affinity.Intrinsic));\n    } else if (Array.isArray(inlet)) {\n      this.setDerived(true);\n    } else {\n      this.setDerived(false);\n    }\n    this.setCoherent(true);\n  },\n\n  inletKeys: void 0,\n\n  resolveInlets(): readonly Fastener<any, any, any>[] | null {\n    const inletKeys = this.inletKeys;\n    if (inletKeys === void 0 || !Objects.hasAllKeys<FastenerContext>(this.owner, \"getFastener\")) {\n      return null;\n    }\n    const inlets = new Array<Fastener<any, any, any>>(inletKeys.length);\n    for (let i = 0; i < inletKeys.length; i += 1) {\n      const inletKey = inletKeys[i]!;\n      const inlet = this.owner.getFastener!(inletKey);\n      if (inlet === null) {\n        return null;\n      }\n      inlets[i] = inlet;\n    }\n    return inlets;\n  },\n\n  attachInlets(): void {\n    const inlets = this.resolveInlets();\n    if (inlets !== null) {\n      this.setInherits(false);\n      this.setFlags(this.flags | Fastener.DerivedFlag);\n      const inletVersions = new Array<number>(inlets.length);\n      for (let i = 0; i < inlets.length; i += 1) {\n        inletVersions[i] = -1;\n      }\n      (this as Mutable<typeof this>).inletVersion = inletVersions;\n      (this as Mutable<typeof this>).inlet = inlets;\n      for (let i = 0; i < inlets.length; i += 1) {\n        inlets[i]!.attachOutlet(this);\n      }\n    } else {\n      this.inheritInlet();\n    }\n  },\n\n  detachInlets(): void {\n    const inlet = this.inlet;\n    if (Array.isArray(inlet)) {\n      for (let i = 0; i < inlet.length; i += 1) {\n        (inlet[i] as Fastener).detachOutlet(this);\n      }\n      (this as Mutable<typeof this>).inletVersion = -1;\n      (this as Mutable<typeof this>).inlet = null;\n      this.setFlags(this.flags & ~Fastener.DerivedFlag);\n    } else {\n      this.uninheritInlet();\n    }\n  },\n\n  getFastener<F extends Fastener>(fastenerName: PropertyKey, fastenerType?: Proto<F>, contextType?: Proto<any> | null): F | null {\n    if (contextType !== void 0 && contextType !== null && !(this instanceof contextType)) {\n      return null;\n    }\n    const fastener = (this as any)[fastenerName] as F | null | undefined;\n    if (fastener === void 0 || (fastenerType !== void 0 && fastenerType !== null && !(fastener instanceof fastenerType))) {\n      return null;\n    }\n    return fastener;\n  },\n\n  getParentFastener<F extends Fastener>(fastenerName: string, fastenerType?: Proto<F>, contextType?: Proto<any>): F | null {\n    return null;\n  },\n\n  attachFastener(fastener: Fastener): void {\n    if (this.mounted) {\n      fastener.mount();\n    }\n  },\n\n  decohereFastener(fastener: Fastener<any, any, any>): void {\n    if (Objects.hasAllKeys<FastenerContext>(this.owner, \"decohereFastener\")) {\n      this.owner.decohereFastener!(fastener);\n    }\n  },\n\n  requireUpdate(updateFlags: number): void {\n    if (Objects.hasAllKeys<FastenerContext>(this.owner, \"requireUpdate\")) {\n      this.owner.requireUpdate!(updateFlags);\n    }\n  },\n\n  getTransition(fastener: Fastener<any, any, any>): Timing | null {\n    if (Objects.hasAllKeys<FastenerContext>(this.owner, \"getTransition\")) {\n      return this.owner.getTransition!(fastener);\n    }\n    return null;\n  },\n\n  mountFasteners(): void {\n    const metaclass = FastenerContext.getMetaclass(this);\n    if (metaclass === null) {\n      return;\n    }\n    const fastenerSlots = metaclass.slots;\n    for (let i = 0; i < fastenerSlots.length; i += 1) {\n      const fastener = this[fastenerSlots[i]!];\n      if (fastener instanceof Fastener) {\n        fastener.mount();\n      }\n    }\n  },\n\n  unmountFasteners(): void {\n    const metaclass = FastenerContext.getMetaclass(this);\n    if (metaclass === null) {\n      return;\n    }\n    const fastenerSlots = metaclass.slots;\n    for (let i = 0; i < fastenerSlots.length; i += 1) {\n      const fastener = this[fastenerSlots[i]!];\n      if (fastener instanceof Fastener) {\n        fastener.unmount();\n      }\n    }\n  },\n\n  get mounted(): boolean {\n    return (this.flags & Fastener.MountedFlag) !== 0;\n  },\n\n  mount(): void {\n    if ((this.flags & Fastener.MountedFlag) !== 0) {\n      return;\n    }\n    this.willMount();\n    this.setFlags(this.flags | Fastener.MountedFlag);\n    this.onMount();\n    this.didMount();\n  },\n\n  willMount(): void {\n    // hook\n  },\n\n  onMount(): void {\n    this.attachInlets();\n  },\n\n  didMount(): void {\n    this.mountFasteners();\n  },\n\n  unmount(): void {\n    if ((this.flags & Fastener.MountedFlag) === 0) {\n      return;\n    }\n    this.willUnmount();\n    this.setFlags(this.flags & ~Fastener.MountedFlag);\n    this.onUnmount();\n    this.didUnmount();\n  },\n\n  willUnmount(): void {\n    this.unmountFasteners();\n  },\n\n  onUnmount(): void {\n    this.detachInlets();\n  },\n\n  didUnmount(): void {\n    // hook\n  },\n\n  toString(): string {\n    return this.name.toString();\n  },\n},\n{\n  create(owner: F extends Fastener<infer R, any, any> ? R : never): F {\n    const fastener = this.construct(null, owner);\n    fastener.init();\n    return fastener;\n  },\n\n  construct(fastener: F | null, owner: F extends Fastener<infer R, any, any> ? R : never): F {\n    if (fastener === null) {\n      fastener = Object.create(this.prototype) as F;\n    }\n    (fastener as Mutable<typeof fastener>).owner = owner;\n    (fastener as Mutable<typeof fastener>).flags = fastener.flagsInit;\n    (fastener as Mutable<typeof fastener>).coherentTime = 0;\n    (fastener as Mutable<typeof fastener>).version = 0;\n    (fastener as Mutable<typeof fastener>).inletVersion = -1;\n    (fastener as Mutable<typeof fastener>).inlet = null;\n    return fastener;\n  },\n\n  declare<F2 extends F, C extends FastenerClass<any>>(className: PropertyKey): C {\n    if (typeof className === \"string\" && Identifiers.isValid(className) && className !== \"Fastener\" && className !== \"template\") {\n      return new Function(\"Fastener\",\n        \"return function \" + className + \"(template) { return Fastener.decorate.bind(Fastener, \" + className + \", template); }\"\n      )(Fastener) as C;\n    }\n\n    const fastenerClass = function <F extends Fastener<any, any, any>>(template: FastenerTemplate<F>): FastenerDecorator<F> {\n      return Fastener.decorate.bind(Fastener, Fastener, template) as unknown as FastenerDecorator<F>;\n    } as C;\n    Object.defineProperty(fastenerClass, \"name\", {\n      value: className,\n      enumerable: true,\n      configurable: true,\n    });\n    return fastenerClass;\n  },\n\n  implement<F2 extends F, C extends FastenerClass<any>>(fastenerClass: C, template: FastenerTemplate<F2>, classTemplate?: FastenerClassTemplate<C>): void {\n    Object.defineProperty(template, \"name\", {\n      value: fastenerClass.name,\n      enumerable: true,\n      configurable: true,\n    });\n    if (\"extends\" in template) {\n      delete template.extends;\n    }\n\n    // Directly insert the template object into the prototype chain\n    // to ensure that super works correctly.\n    Object.setPrototypeOf(template, this.prototype);\n    fastenerClass.prototype = template as unknown as F2;\n    fastenerClass.prototype.constructor = fastenerClass;\n    if (classTemplate !== void 0) {\n      Object.setPrototypeOf(fastenerClass, classTemplate);\n      Object.setPrototypeOf(classTemplate, this);\n    } else {\n      Object.setPrototypeOf(fastenerClass, this);\n    }\n  },\n\n  specialize(template: F extends {readonly descriptorType?: Proto<infer D>} ? D : never): FastenerClass<F> {\n    let baseClass = template.extends as FastenerClass<F> | null | undefined;\n    if (baseClass === void 0 || baseClass === null) {\n      baseClass = this;\n    }\n    return baseClass;\n  },\n\n  refine(fastenerClass: FastenerClass<Fastener<any, any, any>>): void {\n    const fastenerPrototype = fastenerClass.prototype;\n\n    let flagsInit = fastenerPrototype.flagsInit;\n    if (Object.prototype.hasOwnProperty.call(fastenerPrototype, \"affinity\")) {\n      flagsInit = flagsInit & ~Affinity.Mask | fastenerPrototype.affinity & Affinity.Mask;\n      delete (fastenerPrototype as FastenerDescriptor<any>).affinity;\n    }\n    if (Object.prototype.hasOwnProperty.call(fastenerPrototype, \"inherits\")) {\n      let inherits = fastenerPrototype.inherits as PropertyKey | boolean;\n      if (typeof inherits === \"string\" || typeof inherits === \"number\" || typeof inherits === \"symbol\") {\n        Object.defineProperty(fastenerPrototype, \"name\", {\n          value: inherits,\n          enumerable: true,\n          configurable: true,\n        });\n        inherits = true;\n      }\n      if (inherits) {\n        flagsInit |= Fastener.InheritsFlag;\n      } else {\n        flagsInit &= ~Fastener.InheritsFlag;\n      }\n      delete (fastenerPrototype as FastenerDescriptor<any>).inherits;\n    }\n    Object.defineProperty(fastenerPrototype, \"flagsInit\", {\n      value: flagsInit,\n      enumerable: true,\n      configurable: true,\n    });\n  },\n\n  extend<F2 extends F, C extends FastenerClass<any>>(className: PropertyKey, template: FastenerTemplate<F2>, classTemplate?: FastenerClassTemplate<C>): any {\n    if (template.name !== void 0) {\n      className = template.name;\n    }\n    const fastenerClass = this.declare<F2, C>(className);\n    this.implement(fastenerClass, template, classTemplate);\n    this.refine(fastenerClass);\n    return fastenerClass;\n  },\n\n  define<F2 extends F>(className: PropertyKey, template: FastenerTemplate<F2>, extendsClass?: FastenerClass<F>): FastenerClass<F2> {\n    if (typeof template.extends === \"boolean\") {\n      if (template.extends === true) {\n        Object.defineProperty(template, \"extends\", {\n          value: extendsClass,\n          enumerable: true,\n          configurable: true,\n        });\n      } else if (template.extends === false) {\n        Object.defineProperty(template, \"extends\", {\n          value: null,\n          enumerable: true,\n          configurable: true,\n        });\n      }\n    }\n    const baseClass = this.specialize(template);\n    return baseClass.extend(className, template);\n  },\n\n  getter<F2 extends F>(): F2 {\n    throw new Error(\"missing decorator\");\n  },\n\n  decorate<F2 extends F>(baseClass: FastenerClass<any>, template: FastenerTemplate<F2>, target: ((this: F2 extends Fastener<infer R, any, any> ? R : never) => F2) | undefined, context: ClassFieldDecoratorContext<F2 extends Fastener<infer R, any, any> ? R : never, F2> | ClassGetterDecoratorContext<F2 extends Fastener<infer R, any, any> ? R : never, F2>): (this: F2 extends Fastener<infer R, any, any> ? R : never, value?: F2) => F2 {\n    if (context.kind === \"field\") {\n      return Fastener.decorateField(baseClass, template, target as undefined, context);\n    } else if (context.kind === \"getter\") {\n      return Fastener.decorateGetter(baseClass, template, target!, context);\n    }\n    throw new Error(\"unsupported \" + (context as ClassMemberDecoratorContext).kind + \" decorator\");\n  },\n\n  decorateField<F2 extends F>(baseClass: FastenerClass<any>, template: FastenerTemplate<F2>, target: undefined, context: ClassFieldDecoratorContext<F2 extends Fastener<infer R, any, any> ? R : never, F2>): (this: F2 extends Fastener<infer R, any, any> ? R : never, value?: F2) => F2 {\n    const metaclass = FastenerContextMetaclass.getOrCreate<any>(context.metadata);\n\n    const fastenerName = context.name;\n    const fastenerSlot = fastenerName;\n\n    const fastenerSuperclass = metaclass.classMap[fastenerName];\n    const fastenerClass = baseClass.define(fastenerName, template, fastenerSuperclass);\n\n    metaclass.classMap[fastenerName] = fastenerClass;\n    metaclass.slotMap[fastenerName] = fastenerSlot;\n    if (fastenerSuperclass === void 0) {\n      metaclass.slots.push(fastenerSlot);\n    }\n\n    return function (this: F2 extends Fastener<infer R, any, any> ? R : never, value?: F2): F2 {\n      return fastenerClass.create(this);\n    };\n  },\n\n  decorateGetter<F2 extends F>(baseClass: FastenerClass<any>, template: FastenerTemplate<F2>, target: F2 extends Fastener<infer R, any, any> ? (this: R) => F2 : never, context: ClassGetterDecoratorContext<F2 extends Fastener<infer R, any, any> ? R : never, F2>): (this: F2 extends Fastener<infer R, any, any> ? R : never) => F2 {\n    const metaclass = FastenerContextMetaclass.getOrCreate<any>(context.metadata);\n\n    const fastenerName = context.name;\n    const fastenerSlot = metaclass.slotMap[fastenerName] !== void 0\n                       ? metaclass.slotMap[fastenerName]!\n                       : Symbol(fastenerName.toString());\n\n    const fastenerSuperclass = metaclass.classMap[fastenerName];\n    const fastenerClass = baseClass.define(fastenerName, template, fastenerSuperclass);\n\n    metaclass.classMap[fastenerName] = fastenerClass;\n    metaclass.slotMap[fastenerName] = fastenerSlot;\n    if (fastenerSuperclass === void 0) {\n      metaclass.slots.push(fastenerSlot);\n    }\n\n    context.addInitializer(function (this: F2 extends Fastener<infer R, any, any> ? R : never): void {\n      this[fastenerSlot] = void 0;\n    });\n    return function (this: F2 extends Fastener<infer R, any, any> ? R : never): F2 {\n      let fastener = this[fastenerSlot] as F2 | undefined;\n      if (fastener === void 0) {\n        fastener = fastenerClass.create(this);\n        this[fastenerSlot] = fastener;\n        if ((this as FastenerContext).attachFastener !== void 0) {\n          (this as FastenerContext).attachFastener!(fastener);\n        }\n      }\n      return fastener;\n    };\n  },\n\n  initDecorators(): void {\n    // Ensure each fastener class has its own metadata and decorator initializer fields.\n    if (!Object.hasOwnProperty.call(this, Symbol.metadata)) {\n      const superMetadata: Record<PropertyKey, unknown> & object /*DecoratorMetadataObject*/ | undefined = Object.getPrototypeOf(this)[Symbol.metadata];\n      Object.defineProperty(this, Symbol.metadata, {\n        value: Object.create(superMetadata !== void 0 ? superMetadata : null),\n        writable: true,\n        enumerable: true,\n        configurable: true,\n      });\n    }\n    if (!Object.hasOwnProperty.call(this, \"fieldInitializers\")) {\n      Object.defineProperty(this, \"fieldInitializers\", {\n        value: {},\n        enumerable: true,\n        configurable: true,\n      });\n    }\n    if (!Object.hasOwnProperty.call(this, \"instanceInitializers\")) {\n      Object.defineProperty(this, \"instanceInitializers\", {\n        value: [],\n        enumerable: true,\n        configurable: true,\n      });\n    }\n  },\n\n  defineField<F2 extends F, K extends keyof F2>(name: K, decorators: F2[K] extends Fastener<any, any, any> ? FastenerDecorator<F2[K]>[] : never): void {\n    this.initDecorators();\n    __esDecorate(null, null, decorators as Function[], {\n      kind: \"field\",\n      name,\n      static: false,\n      private: false,\n      access: {\n        has(obj: F2): boolean {\n          return name in obj;\n        },\n        get(obj: F2): F2[K] {\n          return obj[name];\n        },\n        set(obj: F2, value: F2[K]): void {\n          obj[name] = value;\n        },\n      },\n      metadata: this[Symbol.metadata],\n    }, this.fieldInitializers![name] = [], this.instanceInitializers!);\n  },\n\n  defineGetter<F2 extends F, K extends keyof F2>(name: K, decorators: F2[K] extends Fastener<any, any, any> ? FastenerDecorator<F2[K]>[] : never): void {\n    this.initDecorators();\n    Object.defineProperty(this.prototype, name, {\n      get: Fastener.getter,\n      enumerable: true,\n      configurable: true,\n    });\n    __esDecorate(this, null, decorators as Function[], {\n      kind: \"getter\",\n      name,\n      static: false,\n      private: false,\n      access: {\n        has(obj: F2): boolean {\n          return name in obj;\n        },\n        get(obj: F2): F2[K] {\n          return obj[name];\n        },\n        set(obj: F2, value: F2[K]): void {\n          obj[name] = value;\n        },\n      },\n      metadata: this[Symbol.metadata],\n    }, null, this.instanceInitializers!);\n  },\n\n  initFasteners(fastener: F): void {\n    if (!Object.hasOwnProperty.call(this, \"fieldInitializers\")\n        || !Object.hasOwnProperty.call(this, \"instanceInitializers\")) {\n      return;\n    }\n    __runInitializers(fastener, this.instanceInitializers!);\n    for (const key in this.fieldInitializers!) {\n      (fastener as any)[key] = __runInitializers(fastener, this.fieldInitializers[key]!, void 0);\n    }\n  },\n\n  MountedFlag: 1 << (Affinity.Shift + 0),\n  InheritsFlag: 1 << (Affinity.Shift + 1),\n  DerivedFlag: 1 << (Affinity.Shift + 2),\n  DecoherentFlag: 1 << (Affinity.Shift + 3),\n\n  FlagShift: Affinity.Shift + 4,\n  FlagMask: (1 << (Affinity.Shift + 4)) - 1,\n}))();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport type {Proto} from \"@swim/util\";\nimport {Equals} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport type {LikeType} from \"@swim/util\";\nimport {FromLike} from \"@swim/util\";\nimport type {Timing} from \"@swim/util\";\nimport {Affinity} from \"./Affinity\";\nimport {FastenerContext} from \"./FastenerContext\";\nimport type {FastenerDescriptor} from \"./Fastener\";\nimport type {FastenerClass} from \"./Fastener\";\nimport {Fastener} from \"./Fastener\";\n\n/** @public */\nexport interface PropertyDescriptor<R, T> extends FastenerDescriptor<R> {\n  extends?: Proto<Property<any, any, any>> | boolean | null;\n  valueType?: unknown;\n  value?: T | LikeType<T>;\n  updateFlags?: number;\n}\n\n/** @public */\nexport interface PropertyClass<P extends Property<any, any, any> = Property<any, any, any>> extends FastenerClass<P> {\n  tryValue<R, K extends keyof R, F extends R[K] = R[K]>(owner: R, fastenerName: K): F extends {readonly value: infer T} ? T : undefined;\n\n  tryValueOr<R, K extends keyof R, E, F extends R[K] = R[K]>(owner: R, fastenerName: K, elseValue: E): F extends {readonly value: infer T} ? NonNullable<T> | E : E;\n}\n\n/** @public */\nexport interface Property<R = any, T = any, I extends any[] = [T]> extends Fastener<R, T, I> {\n  /** @override */\n  get descriptorType(): Proto<PropertyDescriptor<R, T>>;\n\n  /** @override */\n  get fastenerType(): Proto<Property<any, any, any>>;\n\n  /** @override */\n  get parent(): Property<any, I[0], any> | null;\n\n  get inletValue(): I[0] | undefined;\n\n  getInletValue(): NonNullable<I[0]>;\n\n  getInletValueOr<E>(elseValue: E): NonNullable<I[0]> | E;\n\n  /** @internal */\n  readonly outlets: ReadonlySet<Fastener<any, any, any>> | null;\n\n  /** @internal @override */\n  attachOutlet(outlet: Fastener<any, any, any>): void;\n\n  /** @internal @override */\n  detachOutlet(outlet: Fastener<any, any, any>): void;\n\n  /** @internal @protected */\n  decohereOutlets(): void;\n\n  getOutletValue(outlet: Fastener<any, any, any>): T;\n\n  get(): T;\n\n  set(newValue: T | LikeType<T> | Fastener<any, I[0], any>): R;\n\n  setIntrinsic(newValue: T | LikeType<T> | Fastener<any, I[0], any>): R;\n\n  get valueType(): unknown | undefined;\n\n  initValue(): T;\n\n  readonly value: T;\n\n  getValue(): NonNullable<T>;\n\n  getValueOr<E>(elseValue: E): NonNullable<T> | E;\n\n  transformValue(value: T): T;\n\n  setValue(newValue: T | LikeType<T>, affinity?: Affinity): void;\n\n  /** @protected */\n  willSetValue(newValue: T, oldValue: T): void;\n\n  /** @protected */\n  onSetValue(newValue: T, oldValue: T): void;\n\n  /** @protected */\n  didSetValue(newValue: T, oldValue: T): void;\n\n  get transition(): Timing | boolean | null;\n\n  get updateFlags(): number | undefined;\n\n  deriveValue(...inletValues: I): T;\n\n  /** @override */\n  recohere(t: number): void;\n\n  definedValue(value: T): boolean;\n\n  equalValues(newValue: T, oldValue: T | undefined): boolean;\n\n  fromLike(value: T | LikeType<T>): T;\n}\n\n/** @public */\nexport const Property = (<R, T, I extends any[], P extends Property<any, any, any>>() => Fastener.extend<Property<R, T, I>, PropertyClass<P>>(\"Property\", {\n  get fastenerType(): Proto<Property<any, any, any>> {\n    return Property;\n  },\n\n  get inletValue(): I[0] | undefined {\n    const inlet = this.inlet;\n    return inlet instanceof Property ? inlet.getOutletValue(this) : void 0;\n  },\n\n  getInletValue(): NonNullable<I[0]> {\n    const inletValue = this.inletValue;\n    if (inletValue === void 0 || inletValue === null) {\n      let message = inletValue + \" \";\n      const name = this.name.toString();\n      if (name.length !== 0) {\n        message += name + \" \";\n      }\n      message += \"inlet value\";\n      throw new TypeError(message);\n    }\n    return inletValue;\n  },\n\n  getInletValueOr<E>(elseValue: E): NonNullable<I[0]> | E {\n    const inletValue: I[0] | E | undefined = this.inletValue;\n    if (inletValue === void 0 || inletValue === null) {\n      return elseValue;\n    }\n    return inletValue;\n  },\n\n  attachOutlet(outlet: Property<any, any, any>): void {\n    let outlets = this.outlets as Set<Property<any, any, any>> | null;\n    if (outlets === null) {\n      outlets = new Set<Property<any, any, any>>();\n      (this as Mutable<typeof this>).outlets = outlets;\n    }\n    outlets.add(outlet);\n  },\n\n  detachOutlet(outlet: Property<any, any, any>): void {\n    const outlets = this.outlets as Set<Property<any, any, any>> | null;\n    if (outlets !== null) {\n      outlets.delete(outlet);\n    }\n  },\n\n  decohereOutlets(): void {\n    const outlets = this.outlets;\n    if (outlets !== null) {\n      for (const outlet of outlets) {\n        outlet.decohere(this);\n      }\n    }\n  },\n\n  getOutletValue(outlet: Property<any, any, any>): T {\n    return this.value;\n  },\n\n  get(): T {\n    return this.value;\n  },\n\n  set(newValue: T | LikeType<T> | Fastener<any, I[0], any>): R {\n    if (newValue instanceof Fastener) {\n      this.bindInlet(newValue);\n    } else {\n      this.setValue(newValue, Affinity.Extrinsic);\n    }\n    return this.owner;\n  },\n\n  setIntrinsic(newValue: T | LikeType<T> | Fastener<any, I[0], any>): R {\n    if (newValue instanceof Fastener) {\n      this.bindInlet(newValue);\n    } else {\n      this.setValue(newValue, Affinity.Intrinsic);\n    }\n    return this.owner;\n  },\n\n  valueType: void 0,\n\n  initValue(): T {\n    return (Object.getPrototypeOf(this) as Property<any, T, any>).value;\n  },\n\n  getValue(): NonNullable<T> {\n    const value = this.value;\n    if (value === void 0 || value === null) {\n      let message = value + \" \";\n      const name = this.name.toString();\n      if (name.length !== 0) {\n        message += name + \" \";\n      }\n      message += \"value\";\n      throw new TypeError(message);\n    }\n    return value;\n  },\n\n  getValueOr<E>(elseValue: E): NonNullable<T> | E {\n    const value: T | E = this.value;\n    if (value === void 0 || value === null) {\n      return elseValue;\n    }\n    return value;\n  },\n\n  transformValue(value: T): T {\n    return value;\n  },\n\n  setValue(newValue: T | LikeType<T>, affinity?: Affinity): void {\n    if (affinity === void 0) {\n      affinity = Affinity.Extrinsic;\n    }\n    if (!this.minAffinity(affinity)) {\n      return;\n    }\n    newValue = this.fromLike(newValue);\n    newValue = this.transformValue(newValue);\n    const oldValue = this.value;\n    if (this.equalValues(newValue, oldValue)) {\n      this.setCoherent(true);\n      return;\n    }\n    this.willSetValue(newValue, oldValue);\n    this.incrementVersion();\n    (this as Mutable<typeof this>).value = newValue;\n    this.onSetValue(newValue, oldValue);\n    this.didSetValue(newValue, oldValue);\n    this.setCoherent(true);\n    this.decohereOutlets();\n  },\n\n  willSetValue(newValue: T, oldValue: T): void {\n    // hook\n  },\n\n  onSetValue(newValue: T, oldValue: T): void {\n    const updateFlags = this.updateFlags;\n    if (updateFlags !== void 0 && Objects.hasAllKeys<FastenerContext>(this.owner, \"requireUpdate\")) {\n      this.owner.requireUpdate!(updateFlags);\n    }\n  },\n\n  didSetValue(newValue: T, oldValue: T): void {\n    // hook\n  },\n\n  get transition(): Timing | boolean | null {\n    if (this.derived && this.inlet instanceof Property) {\n      return this.inlet.transition;\n    }\n    return null;\n  },\n\n  updateFlags: void 0,\n\n  deriveValue(...inletValues: any[]): T {\n    return inletValues[0] as T;\n  },\n\n  recohere(t: number): void {\n    this.setCoherentTime(t);\n    const inlet = this.inlet;\n    if (inlet instanceof Property) {\n      this.setDerived((this.flags & Affinity.Mask) <= Math.min(inlet.flags & Affinity.Mask, Affinity.Intrinsic));\n      if ((this.flags & Fastener.DerivedFlag) !== 0) {\n        (this as Mutable<typeof this>).inletVersion = inlet.version;\n        const derivedValue = (this as unknown as Property<R, T, [unknown]>).deriveValue(inlet.getOutletValue(this));\n        this.setValue(derivedValue, Affinity.Reflexive);\n      } else {\n        this.setCoherent(true);\n      }\n    } else if (Array.isArray(inlet)) {\n      this.setDerived(true);\n      const inletVersions = this.inletVersion as number[];\n      const inletValues = new Array<unknown>(inlet.length);\n      for (let i = 0; i < inlet.length; i += 1) {\n        if (inlet[i] instanceof Property) {\n          inletVersions[i] = (inlet[i] as Property).version;\n          inletValues[i] = (inlet[i] as Property).getOutletValue(this);\n        } else {\n          this.setDerived(false);\n          this.setCoherent(true);\n          return;\n        }\n      }\n      const derivedValue = this.deriveValue(...(inletValues as I));\n      this.setValue(derivedValue, Affinity.Reflexive);\n    } else {\n      this.setDerived(false);\n      this.setCoherent(true);\n    }\n  },\n\n  definedValue(value: T): boolean {\n    return value !== void 0 && value !== null;\n  },\n\n  equalValues(newValue: T, oldValue: T | undefined): boolean {\n    return Equals(newValue, oldValue);\n  },\n\n  fromLike(value: T | LikeType<T>): T {\n    return FromLike(this.valueType, value);\n  },\n},\n{\n  tryValue<R, K extends keyof R, F extends R[K]>(owner: R, fastenerName: K): F extends {readonly value: infer T} ? T : undefined {\n    const metaclass = FastenerContext.getMetaclass(owner);\n    if (metaclass === null) {\n      return void 0 as any;\n    }\n    const property = metaclass.tryFastener(owner, fastenerName);\n    if (!(property instanceof Property)) {\n      const propertyClass = metaclass.getFastenerClass(fastenerName) as PropertyClass | null;\n      if (propertyClass === null) {\n        return void 0 as any;\n      }\n      return propertyClass.prototype.value;\n    }\n    return property.value;\n  },\n\n  tryValueOr<R, K extends keyof R, E, F extends R[K] = R[K]>(owner: R, fastenerName: K, elseValue: E): F extends {readonly value: infer T} ? NonNullable<T> | E : E {\n    let value: (F extends {readonly value: infer T} ? T : undefined) | E = this.tryValue(owner, fastenerName);\n    if (value === void 0 || value === null) {\n      value = elseValue;\n    }\n    return value as F extends {readonly value: infer T} ? NonNullable<T> | E : E;\n  },\n\n  construct(property: P | null, owner: P extends Fastener<infer R, any, any> ? R : never): P {\n    property = super.construct(property, owner) as P;\n    (property as Mutable<typeof property>).outlets = null;\n    (property as Mutable<typeof property>).value = property.initValue();\n    return property;\n  },\n\n  refine(propertyClass: FastenerClass<Property<any, any, any>>): void {\n    super.refine(propertyClass);\n    const propertyPrototype = propertyClass.prototype;\n\n    const valueDescriptor = Object.getOwnPropertyDescriptor(propertyPrototype, \"value\");\n    if (valueDescriptor !== void 0 && \"value\" in valueDescriptor) {\n      valueDescriptor.value = propertyPrototype.fromLike(valueDescriptor.value);\n      Object.defineProperty(propertyPrototype, \"value\", valueDescriptor);\n    }\n  },\n}))();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport type {Proto} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport type {LikeType} from \"@swim/util\";\nimport type {TimingLike} from \"@swim/util\";\nimport {Timing} from \"@swim/util\";\nimport {Easing} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport {Affinity} from \"./Affinity\";\nimport type {FastenerContext} from \"./FastenerContext\";\nimport type {FastenerFlags} from \"./Fastener\";\nimport type {FastenerClass} from \"./Fastener\";\nimport {Fastener} from \"./Fastener\";\nimport type {PropertyDescriptor} from \"./Property\";\nimport type {PropertyClass} from \"./Property\";\nimport {Property} from \"./Property\";\n\n/** @public */\nexport interface AnimatorDescriptor<R, T> extends PropertyDescriptor<R, T> {\n  extends?: Proto<Animator<any, any, any>> | boolean | null;\n  transition?: TimingLike | boolean | null;\n}\n\n/** @public */\nexport interface AnimatorClass<A extends Animator<any, any, any> = Animator<any, any, any>> extends PropertyClass<A> {\n  /** @internal */\n  readonly TweeningFlag: FastenerFlags;\n  /** @internal */\n  readonly DivergedFlag: FastenerFlags;\n  /** @internal */\n  readonly InterruptFlag: FastenerFlags;\n\n  /** @internal @override */\n  readonly FlagShift: number;\n  /** @internal @override */\n  readonly FlagMask: FastenerFlags;\n}\n\n/** @public */\nexport interface Animator<R = any, T = any, I extends any[] = [T]> extends Property<R, T, I> {\n  /** @override */\n  get descriptorType(): Proto<AnimatorDescriptor<R, T>>;\n\n  get inletState(): I[0] | undefined;\n\n  getInletState(): NonNullable<I[0]>;\n\n  getInletStateOr<E>(elseState: E): NonNullable<I[0]> | E;\n\n  getOutletState(outlet: Fastener<any, any, any>): T;\n\n  /** @override */\n  set(newValue: T | LikeType<T> | Fastener<any, I[0], any>, timing?: TimingLike | boolean | null): R;\n\n  /** @override */\n  setIntrinsic(newValue: T | LikeType<T> | Fastener<any, I[0], any>, timing?: TimingLike | boolean | null): R;\n\n  /** @override */\n  setValue(newValue: T | LikeType<T>, affinity?: Affinity): void;\n\n  readonly state: T;\n\n  getState(): NonNullable<T>;\n\n  getStateOr<E>(elseState: E): NonNullable<T> | E;\n\n  transformState(state: T): T;\n\n  setState(newState: T | LikeType<T>, timingOrAffinity: Affinity | TimingLike | boolean | null | undefined): void;\n  setState(newState: T | LikeType<T>, timing?: TimingLike | boolean | null, affinity?: Affinity): void;\n\n  /** @protected */\n  willSetState(newState: T, oldState: T): void;\n\n  /** @protected */\n  onSetState(newState: T, oldState: T): void;\n\n  /** @protected */\n  didSetState(newState: T, oldState: T): void;\n\n  readonly timing: Timing | null;\n\n  readonly interpolator: Interpolator<T> | null;\n\n  setInterpolatedValue(newValue: T, newState?: T): void;\n\n  /** @override */\n  decohere(inlet?: Fastener<any, any, any>): void;\n\n  /** @override */\n  recohere(t: number): void;\n\n  /** @internal @protected */\n  tween(t: number): void;\n\n  /** @internal @protected */\n  tweenInherited(t: number): void;\n\n  /**\n   * Returns `true` if this animator is actively transitioning to a new `state`.\n   */\n  get tweening(): boolean;\n\n  /** @internal */\n  startTweening(): void;\n\n  /** @protected */\n  willStartTweening(): void;\n\n  /** @protected */\n  onStartTweening(): void;\n\n  /** @protected */\n  didStartTweening(): void;\n\n  /** @internal */\n  stopTweening(): void;\n\n  /** @protected */\n  willStopTweening(): void;\n\n  /** @protected */\n  onStopTweening(): void;\n\n  /** @protected */\n  didStopTweening(): void;\n\n  /** @protected */\n  willTransition(oldValue: T): void;\n\n  /** @protected */\n  didTransition(newValue: T): void;\n\n  /** @protected */\n  didInterrupt(value: T): void;\n}\n\n/** @public */\nexport const Animator = (<R, T, I extends any[], A extends Animator<any, any, any>>() => Property.extend<Animator<R, T, I>, AnimatorClass<A>>(\"Animator\", {\n  get inletState(): I[0] | undefined {\n    const inlet = this.inlet;\n    return inlet instanceof Animator ? inlet.getOutletState(this) : void 0;\n  },\n\n  getInletState(): NonNullable<I[0]> {\n    const inletState = this.inletState;\n    if (inletState === void 0 || inletState === null) {\n      let message = inletState + \" \";\n      const name = this.name.toString();\n      if (name.length !== 0) {\n        message += name + \" \";\n      }\n      message += \"inlet state\";\n      throw new TypeError(message);\n    }\n    return inletState;\n  },\n\n  getInletStateOr<E>(elseState: E): NonNullable<I[0]> | E {\n    const inletState: I[0] | E | undefined = this.inletState;\n    if (inletState === void 0 || inletState === null) {\n      return elseState;\n    }\n    return inletState;\n  },\n\n  getOutletState(outlet: Fastener<any, any, any>): T {\n    return this.state;\n  },\n\n  set(newValue: T | LikeType<T> | Fastener<any, I[0], any>, timing?: TimingLike | boolean | null): R {\n    if (newValue instanceof Fastener) {\n      this.bindInlet(newValue);\n    } else {\n      this.setState(newValue, timing, Affinity.Extrinsic);\n    }\n    return this.owner;\n  },\n\n  setIntrinsic(newValue: T | LikeType<T> | Fastener<any, I[0], any>, timing?: TimingLike | boolean | null): R {\n    if (newValue instanceof Fastener) {\n      this.bindInlet(newValue);\n    } else {\n      this.setState(newValue, timing, Affinity.Intrinsic);\n    }\n    return this.owner;\n  },\n\n  setValue(newValue: T | LikeType<T>, affinity?: Affinity): void {\n    if (affinity === void 0) {\n      affinity = Affinity.Extrinsic;\n    }\n    if (!this.minAffinity(affinity)) {\n      return;\n    }\n    newValue = this.fromLike(newValue);\n    newValue = this.transformValue(newValue);\n    const oldValue = this.value;\n    if (this.equalValues(newValue, oldValue)) {\n      return;\n    }\n    this.willSetValue(newValue, oldValue);\n    this.incrementVersion();\n    (this as Mutable<typeof this>).value = newValue;\n    this.onSetValue(newValue, oldValue);\n    this.didSetValue(newValue, oldValue);\n    this.decohereOutlets();\n  },\n\n  getState(): NonNullable<T> {\n    const state = this.state;\n    if (state === void 0 || state === null) {\n      let message = state + \" \";\n      const name = this.name.toString();\n      if (name.length !== 0) {\n        message += name + \" \";\n      }\n      message += \"state\";\n      throw new TypeError(message);\n    }\n    return state;\n  },\n\n  getStateOr<E>(elseState: E): NonNullable<T> | E {\n    const state: T | E = this.state;\n    if (state === void 0 || state === null) {\n      return elseState;\n    }\n    return state;\n  },\n\n  transformState(state: T): T {\n    return state;\n  },\n\n  setState(newState: T | LikeType<T>, timing?: Affinity | TimingLike | boolean | null, affinity?: Affinity): void {\n    if (typeof timing === \"number\") {\n      affinity = timing;\n      timing = void 0;\n    }\n    if (affinity === void 0) {\n      affinity = Affinity.Extrinsic;\n    }\n    if (!this.minAffinity(affinity)) {\n      return;\n    }\n\n    newState = this.fromLike(newState);\n    newState = this.transformState(newState);\n    const oldState = this.state;\n    if (timing === void 0 && this.equalValues(newState, oldState)) {\n      return;\n    }\n\n    if (timing === void 0) {\n      timing = this.transition;\n    } else {\n      timing = Timing.fromLike(timing);\n    }\n    if (timing === true) {\n      if (Objects.hasAllKeys<FastenerContext>(this.owner, \"getTransition\")) {\n        timing = this.owner.getTransition!(this);\n      } else {\n        timing = this.timing;\n      }\n    } else if (timing === false) {\n      timing = null;\n    }\n\n    const tweened = timing !== null && this.definedValue(oldState);\n\n    this.willSetState(newState, oldState);\n\n    (this as Mutable<typeof this>).state = newState;\n\n    if (tweened) {\n      (this as Mutable<typeof this>).timing = timing;\n      (this as Mutable<typeof this>).interpolator = Interpolator(this.value, newState);\n      if ((this.flags & Animator.TweeningFlag) !== 0) {\n        this.setFlags(this.flags | (Animator.DivergedFlag | Animator.InterruptFlag));\n      } else {\n        this.setFlags(this.flags | Animator.DivergedFlag);\n      }\n    } else {\n      (this as Mutable<typeof this>).timing = null;\n      (this as Mutable<typeof this>).interpolator = null;\n    }\n\n    this.onSetState(newState, oldState);\n\n    if (!tweened) {\n      this.setValue(newState, Affinity.Reflexive);\n    }\n\n    this.didSetState(newState, oldState);\n\n    if (tweened) {\n      this.startTweening();\n    } else if ((this.flags & Animator.TweeningFlag) !== 0) {\n      this.didInterrupt(this.value);\n      this.stopTweening();\n    }\n  },\n\n  willSetState(newState: T, oldState: T): void {\n    // hook\n  },\n\n  onSetState(newState: T, oldState: T): void {\n    // hook\n  },\n\n  didSetState(newState: T, oldState: T): void {\n    // hook\n  },\n\n  setInterpolatedValue(this: Animator<unknown, T>, newValue: T, newState?: T): void {\n    const oldState = arguments.length > 1 ? this.state : void 0;\n    const stateChanged = arguments.length > 1 && !this.equalValues(newState!, oldState);\n    if (stateChanged) {\n      this.willSetState(newState!, oldState!);\n      (this as Mutable<typeof this>).state = newState!;\n      (this as Mutable<typeof this>).timing = null;\n      (this as Mutable<typeof this>).interpolator = null;\n      this.onSetState(newState!, oldState!);\n    }\n\n    this.setValue(newValue, Affinity.Reflexive);\n\n    if (stateChanged) {\n      this.didSetState(newState!, oldState!);\n      if ((this.flags & Animator.TweeningFlag) !== 0) {\n        this.didInterrupt(this.value);\n        this.stopTweening();\n      }\n    }\n  },\n\n  decohere(inlet?: Fastener<any, any, any>): void {\n    if (inlet === void 0 || inlet !== this.inlet || (this.flags & Fastener.DerivedFlag) !== 0) {\n      if (inlet instanceof Animator && (inlet.flags & Animator.TweeningFlag) !== 0) {\n        this.startTweening();\n      }\n      if ((this.flags & Fastener.DecoherentFlag) === 0) {\n        this.requireRecohere();\n      }\n    } else {\n      this.recohere(performance.now());\n    }\n  },\n\n  recohere(t: number): void {\n    this.setCoherentTime(t);\n    const inlet = this.inlet;\n    if (inlet instanceof Animator) {\n      this.setDerived((this.flags & Affinity.Mask) <= Math.min(inlet.flags & Affinity.Mask, Affinity.Intrinsic));\n      if ((this.flags & Fastener.DerivedFlag) !== 0) {\n        this.tweenInherited(t);\n      } else if ((this.flags & Animator.TweeningFlag) !== 0) {\n        this.tween(t);\n      } else {\n        this.setCoherent(true);\n      }\n    } else if (inlet instanceof Property) {\n      this.setDerived((this.flags & Affinity.Mask) <= Math.min(inlet.flags & Affinity.Mask, Affinity.Intrinsic));\n      if ((this.flags & Fastener.DerivedFlag) !== 0 && this.inletVersion !== inlet.version) {\n        (this as Mutable<typeof this>).inletVersion = inlet.version;\n        const derivedValue = (this as unknown as Property<R, T, [unknown]>).deriveValue(inlet.getOutletValue(this));\n        this.setState(derivedValue, Affinity.Reflexive);\n        if ((this.flags & Animator.TweeningFlag) !== 0) {\n          this.tween(t);\n        } else {\n          this.setCoherent(true);\n        }\n      } else if ((this.flags & Animator.TweeningFlag) !== 0) {\n        this.tween(t);\n      } else {\n        this.setCoherent(true);\n      }\n    } else if (Array.isArray(inlet)) {\n      this.setDerived(true);\n      const inletVersions = this.inletVersion as number[];\n      const inletValues = new Array<unknown>(inlet.length);\n      for (let i = 0; i < inlet.length; i += 1) {\n        if (inlet[i] instanceof Property) {\n          inletVersions[i] = (inlet[i] as Property).version;\n          inletValues[i] = (inlet[i] as Property).getOutletValue(this);\n        } else {\n          this.setDerived(false);\n          this.setCoherent(true);\n          return;\n        }\n      }\n      const derivedValue = this.deriveValue(...(inletValues as I));\n      this.setState(derivedValue, Affinity.Reflexive);\n      if ((this.flags & Animator.TweeningFlag) !== 0) {\n        this.tween(t);\n      } else {\n        this.setCoherent(true);\n      }\n    } else {\n      this.setDerived(false);\n      if ((this.flags & Animator.TweeningFlag) !== 0) {\n        this.tween(t);\n      } else {\n        this.setCoherent(true);\n      }\n    }\n  },\n\n  tween(t: number): void {\n    const oldValue = this.value;\n\n    let timing = this.timing;\n    if (timing === null) {\n      timing = Easing.linear.withDomain(t, t);\n      (this as Mutable<typeof this>).timing = timing;\n    }\n\n    let interpolator = this.interpolator;\n    if (interpolator === null) {\n      interpolator = Interpolator(oldValue, this.state);\n      (this as Mutable<typeof this>).interpolator = interpolator;\n    }\n\n    if ((this.flags & Animator.InterruptFlag) !== 0) {\n      this.setFlags(this.flags & ~Animator.InterruptFlag);\n      this.didInterrupt(oldValue);\n    }\n\n    if ((this.flags & Animator.DivergedFlag) !== 0) {\n      this.setFlags(this.flags & ~Animator.DivergedFlag);\n      if (!this.equalValues(this.state, oldValue)) {\n        timing = timing.withDomain(t, t + timing.duration);\n      } else {\n        timing = timing.withDomain(t - timing.duration, t);\n      }\n      (this as Mutable<typeof this>).timing = timing;\n      this.willTransition(oldValue);\n    }\n\n    const u = timing(t);\n    const newValue = interpolator(u);\n    this.setValue(newValue, Affinity.Reflexive);\n\n    if (u < 1) {\n      this.requireRecohere();\n    } else if ((this.flags & Animator.TweeningFlag) !== 0) {\n      this.stopTweening();\n      (this as Mutable<typeof this>).interpolator = null;\n      this.didTransition(this.value);\n    } else {\n      this.setCoherent(true);\n    }\n  },\n\n  tweenInherited(t: number): void {\n    const inlet = this.inlet;\n    if (!(inlet instanceof Animator)) {\n      this.stopTweening();\n      return;\n    }\n    (this as Mutable<typeof this>).inletVersion = inlet.version;\n    const newValue = (this as unknown as Animator<R, T, [unknown]>).deriveValue(inlet.getOutletValue(this));\n    const newState = (this as unknown as Animator<R, T, [unknown]>).deriveValue(inlet.getOutletState(this));\n    const oldState = this.state;\n    const stateChanged = !this.equalValues(newState, oldState);\n    if (stateChanged) {\n      this.willSetState(newState, oldState);\n      (this as Mutable<typeof this>).state = newState!;\n      (this as Mutable<typeof this>).timing = null;\n      (this as Mutable<typeof this>).interpolator = null;\n      this.onSetState(newState, oldState);\n    }\n\n    this.setValue(newValue, Affinity.Reflexive);\n\n    if (stateChanged) {\n      this.didSetState(newState, oldState!);\n      if ((this.flags & Animator.TweeningFlag) !== 0) {\n        this.didInterrupt(this.value);\n      }\n      this.willTransition(this.value);\n    }\n\n    if ((inlet.flags & Animator.TweeningFlag) !== 0) {\n      this.requireRecohere();\n    } else if ((this.flags & Animator.TweeningFlag) !== 0) {\n      this.stopTweening();\n      this.didTransition(this.value);\n    } else {\n      this.setCoherent(true);\n    }\n  },\n\n  get tweening(): boolean {\n    return (this.flags & Animator.TweeningFlag) !== 0;\n  },\n\n  startTweening(): void {\n    if ((this.flags & Animator.TweeningFlag) !== 0) {\n      return;\n    }\n    this.willStartTweening();\n    this.setFlags(this.flags | Animator.TweeningFlag);\n    this.onStartTweening();\n    this.didStartTweening();\n  },\n\n  willStartTweening(): void {\n    // hook\n  },\n\n  onStartTweening(): void {\n    this.decohere();\n    this.decohereOutlets();\n  },\n\n  didStartTweening(): void {\n    // hook\n  },\n\n  stopTweening(): void {\n    if ((this.flags & Animator.TweeningFlag) === 0) {\n      return;\n    }\n    this.willStopTweening();\n    this.setFlags(this.flags & ~Animator.TweeningFlag);\n    this.onStopTweening();\n    this.didStopTweening();\n  },\n\n  willStopTweening(): void {\n    // hook\n  },\n\n  onStopTweening(): void {\n    this.setCoherent(true);\n  },\n\n  didStopTweening(): void {\n    // hook\n  },\n\n  willTransition(oldValue: T): void {\n    // hook\n  },\n\n  didTransition(newValue: T): void {\n    // hook\n  },\n\n  didInterrupt(value: T): void {\n    // hook\n  },\n},\n{\n  construct(animator: A | null, owner: A extends Fastener<infer R, any, any> ? R : never): A {\n    animator = super.construct(animator, owner) as A;\n    (animator as Mutable<typeof animator>).state = animator.value;\n    (animator as Mutable<typeof animator>).timing = null;\n    (animator as Mutable<typeof animator>).interpolator = null;\n    return animator;\n  },\n\n  refine(animatorClass: FastenerClass<Animator<any, any, any>>): void {\n    super.refine(animatorClass);\n    const animatorPrototype = animatorClass.prototype;\n\n    const transitionDescriptor = Object.getOwnPropertyDescriptor(animatorPrototype, \"transition\");\n    if (transitionDescriptor !== void 0 && \"value\" in transitionDescriptor) {\n      transitionDescriptor.value = Timing.fromLike(transitionDescriptor.value);\n      Object.defineProperty(animatorPrototype, \"transition\", transitionDescriptor);\n    }\n  },\n\n  TweeningFlag: 1 << (Property.FlagShift + 0),\n  DivergedFlag: 1 << (Property.FlagShift + 1),\n  InterruptFlag: 1 << (Property.FlagShift + 2),\n\n  FlagShift: Property.FlagShift + 3,\n  FlagMask: (1 << (Property.FlagShift + 3)) - 1,\n}))();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport type {Proto} from \"@swim/util\";\nimport type {FastenerDescriptor} from \"./Fastener\";\nimport type {FastenerClass} from \"./Fastener\";\nimport {Fastener} from \"./Fastener\";\n\n/** @public */\nexport interface TimerDescriptor<R> extends FastenerDescriptor<R> {\n  extends?: Proto<Timer<any>> | boolean | null;\n}\n\n/** @public */\nexport interface TimerClass<F extends Timer<any> = Timer<any>> extends FastenerClass<F> {\n}\n\n/** @public */\nexport interface Timer<R = any> extends Fastener<R> {\n  (): void;\n\n  /** @override */\n  get descriptorType(): Proto<TimerDescriptor<R>>;\n\n  /** @override */\n  get fastenerType(): Proto<Timer<any>>;\n\n  /** @protected */\n  fire(): void;\n\n  initDelay(): number;\n\n  readonly delay: number;\n\n  setDelay(delay: number): void;\n\n  readonly deadline: number | undefined;\n\n  get elapsed(): number | undefined;\n\n  get remaining(): number | undefined;\n\n  get scheduled(): boolean;\n\n  schedule(delay?: number): void;\n\n  throttle(delay?: number): void;\n\n  debounce(delay?: number): void;\n\n  /** @protected */\n  willSchedule(delay: number): void;\n\n  /** @protected */\n  onSchedule(delay: number): void;\n\n  /** @protected */\n  didSchedule(delay: number): void;\n\n  cancel(): void;\n\n  /** @protected */\n  willCancel(): void;\n\n  /** @protected */\n  onCancel(): void;\n\n  /** @protected */\n  didCancel(): void;\n\n  /** @internal @protected */\n  expire(): void;\n\n  /** @protected */\n  willExpire(): void;\n\n  /** @protected */\n  onExpire(): void;\n\n  /** @protected */\n  didExpire(): void;\n\n  /** @internal */\n  readonly timeout: unknown | undefined;\n\n  /** @protected */\n  setTimeout(callback: () => void, delay: number): unknown;\n\n  /** @protected */\n  clearTimeout(timeoutId: unknown): void;\n\n  /** @override @protected */\n  onUnmount(): void;\n}\n\n/** @public */\nexport const Timer = (<R, F extends Timer<any>>() => Fastener.extend<Timer<R>, TimerClass<F>>(\"Timer\", {\n  get fastenerType(): Proto<Timer<any>> {\n    return Timer;\n  },\n\n  fire(): void {\n    // hook\n  },\n\n  delay: 0,\n\n  initDelay(): number {\n    const delay = (Object.getPrototypeOf(this) as Timer<any>).delay;\n    return Math.max(0, delay);\n  },\n\n  setDelay(delay: number): void {\n    (this as Mutable<typeof this>).delay = Math.max(0, delay);\n  },\n\n  get elapsed(): number | undefined {\n    const deadline = this.deadline;\n    if (deadline === void 0) {\n      return void 0;\n    }\n    return Math.max(0, performance.now() - (deadline - this.delay));\n  },\n\n  get remaining(): number | undefined {\n    const deadline = this.deadline;\n    if (deadline === void 0) {\n      return void 0;\n    }\n    return Math.max(0, deadline - performance.now());\n  },\n\n  get scheduled(): boolean {\n    return this.timeout !== void 0;\n  },\n\n  schedule(delay?: number): void {\n    if (this.timeout !== void 0) {\n      throw new Error(\"timer already scheduled; call throttle or debounce to reschedule\");\n    } else if (delay === void 0) {\n      delay = this.delay;\n    } else {\n      this.setDelay(delay);\n    }\n    this.willSchedule(delay);\n    (this as Mutable<typeof this>).deadline = performance.now() + delay;\n    (this as Mutable<typeof this>).timeout = this.setTimeout(this, delay);\n    this.onSchedule(delay);\n    this.didSchedule(delay);\n  },\n\n  throttle(delay?: number): void {\n    if (this.timeout !== void 0) {\n      return;\n    } else if (delay === void 0) {\n      delay = this.delay;\n    } else {\n      this.setDelay(delay);\n    }\n    this.willSchedule(delay);\n    (this as Mutable<typeof this>).deadline = performance.now() + delay;\n    (this as Mutable<typeof this>).timeout = this.setTimeout(this, delay);\n    this.onSchedule(delay);\n    this.didSchedule(delay);\n  },\n\n  debounce(delay?: number): void {\n    const timeout = this.timeout;\n    if (timeout !== void 0) {\n      this.willCancel();\n      (this as Mutable<typeof this>).timeout = void 0;\n      (this as Mutable<typeof this>).deadline = void 0;\n      this.clearTimeout(timeout);\n      this.onCancel();\n      this.didCancel();\n    }\n    if (delay === void 0) {\n      delay = this.delay;\n    } else {\n      this.setDelay(delay);\n    }\n    this.willSchedule(delay);\n    (this as Mutable<typeof this>).deadline = performance.now() + delay;\n    (this as Mutable<typeof this>).timeout = this.setTimeout(this, delay);\n    this.onSchedule(delay);\n    this.didSchedule(delay);\n  },\n\n  willSchedule(delay: number): void {\n    // hook\n  },\n\n  onSchedule(delay: number): void {\n    // hook\n  },\n\n  didSchedule(delay: number): void {\n    // hook\n  },\n\n  cancel(): void {\n    const timeout = this.timeout;\n    if (timeout === void 0) {\n      return;\n    }\n    this.willCancel();\n    (this as Mutable<typeof this>).timeout = void 0;\n    (this as Mutable<typeof this>).deadline = void 0;\n    this.clearTimeout(timeout);\n    this.onCancel();\n    this.didCancel();\n  },\n\n  willCancel(): void {\n    // hook\n  },\n\n  onCancel(): void {\n    // hook\n  },\n\n  didCancel(): void {\n    // hook\n  },\n\n  expire(): void {\n    (this as Mutable<typeof this>).timeout = void 0;\n    (this as Mutable<typeof this>).deadline = void 0;\n    this.willExpire();\n    this.fire();\n    this.onExpire();\n    this.didExpire();\n  },\n\n  willExpire(): void {\n    // hook\n  },\n\n  onExpire(): void {\n    // hook\n  },\n\n  didExpire(): void {\n    // hook\n  },\n\n  setTimeout(callback: () => void, delay: number): unknown {\n    return setTimeout(callback, delay);\n  },\n\n  clearTimeout(timeout: unknown): void {\n    clearTimeout(timeout as any);\n  },\n\n  onUnmount(): void {\n    super.onUnmount();\n    this.cancel();\n  },\n},\n{\n  construct(fastener: F | null, owner: F extends Fastener<infer R, any, any> ? R : never): F {\n    if (fastener === null) {\n      fastener = function (): void {\n        fastener!.expire();\n      } as F;\n      Object.defineProperty(fastener, \"name\", {\n        value: this.prototype.name,\n        enumerable: true,\n        configurable: true,\n      });\n      Object.setPrototypeOf(fastener, this.prototype);\n    }\n    fastener = super.construct(fastener, owner) as F;\n    (fastener as Mutable<typeof fastener>).delay = fastener.initDelay();\n    (fastener as Mutable<typeof fastener>).deadline = 0;\n    (fastener as Mutable<typeof fastener>).timeout = void 0;\n    return fastener;\n  },\n}))();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport type {Proto} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport type {FastenerFlags} from \"./Fastener\";\nimport type {FastenerDescriptor} from \"./Fastener\";\nimport type {FastenerClass} from \"./Fastener\";\nimport {Fastener} from \"./Fastener\";\nimport type {Component} from \"./Component\";\n\n/** @public */\nexport interface EventHandlerDescriptor<R, T> extends FastenerDescriptor<R> {\n  extends?: Proto<EventHandler<any, any>> | boolean | null;\n  enabled?: boolean;\n}\n\n/** @public */\nexport interface EventHandlerClass<F extends EventHandler<any, any> = EventHandler<any, any>> extends FastenerClass<F> {\n  /** @internal */\n  readonly EnabledFlag: FastenerFlags;\n\n  /** @internal @override */\n  readonly FlagShift: number;\n  /** @internal @override */\n  readonly FlagMask: FastenerFlags;\n}\n\n/** @public */\nexport interface EventHandler<R = any, T = EventTarget> extends Fastener<R>, EventListener {\n  /** @override */\n  (event: Event): void;\n\n  /** @override */\n  get descriptorType(): Proto<EventHandlerDescriptor<R, T>>;\n\n  /** @override */\n  get fastenerType(): Proto<EventHandler<any, any>>;\n\n  get bindsOwner(): boolean;\n\n  initEventType(): string | readonly string[] | undefined;\n\n  readonly eventType: string | readonly string[] | undefined;\n\n  initTarget(): T | null;\n\n  readonly target: T | null;\n\n  getTarget(): T;\n\n  setTarget(target: T | null): T | null;\n\n  /** @protected */\n  willAttachTarget(target: T): void;\n\n  /** @protected */\n  onAttachTarget(target: T): void;\n\n  /** @protected */\n  didAttachTarget(target: T): void;\n\n  /** @protected */\n  willDetachTarget(target: T): void;\n\n  /** @protected */\n  onDetachTarget(target: T): void;\n\n  /** @protected */\n  didDetachTarget(target: T): void;\n\n  get options(): AddEventListenerOptions | undefined;\n\n  /** @protected */\n  attachEvents(target: T): void;\n\n  /** @protected */\n  attachEvent(target: T, eventType: string): void;\n\n  /** @protected */\n  detachEvents(target: T): void;\n\n  /** @protected */\n  detachEvent(target: T, eventType: string): void;\n\n  /** @protected */\n  handle(event: Event): void;\n\n  get enabled(): boolean;\n\n  set enabled(enabled: boolean);\n\n  /** @protected */\n  willEnable(): void;\n\n  /** @protected */\n  onEnable(): void;\n\n  /** @protected */\n  didEnable(): void;\n\n  /** @protected */\n  willDisable(): void;\n\n  /** @protected */\n  onDisable(): void;\n\n  /** @protected */\n  didDisable(): void;\n\n  /** @internal */\n  bindComponent(component: Component<any>, target?: Component<any> | null): void;\n\n  /** @internal */\n  unbindComponent(component: Component<any>): void;\n\n  detectComponent(component: Component<any>): T | null;\n\n  /** @protected @override */\n  onMount(): void;\n\n  /** @protected @override */\n  onUnmount(): void;\n}\n\n/** @public */\nexport const EventHandler = (<R, T, F extends EventHandler<any, any>>() => Fastener.extend<EventHandler<R, T>, EventHandlerClass<F>>(\"EventHandler\", {\n  get fastenerType(): Proto<EventHandler<any, any>> {\n    return EventHandler;\n  },\n\n  bindsOwner: false,\n\n  eventType: void 0,\n\n  initEventType(): string | readonly string[] | undefined {\n    return (Object.getPrototypeOf(this) as EventHandler<R, T>).eventType;\n  },\n\n  target: null,\n\n  initTarget(): T | null {\n    let target = (Object.getPrototypeOf(this) as EventHandler<R, T>).target;\n    if (target === null && this.bindsOwner === true) {\n      target = this.owner as unknown as T;\n    }\n    return target;\n  },\n\n  getTarget(): T {\n    const target = this.target;\n    if (target === null) {\n      let message = target + \" \";\n      const name = this.name.toString();\n      if (name.length !== 0) {\n        message += name + \" \";\n      }\n      message += \"event target\";\n      throw new TypeError(message);\n    }\n    return target;\n  },\n\n  setTarget(newTarget: T | null): T | null {\n    const oldTarget = this.target;\n    if (oldTarget === newTarget) {\n      return oldTarget;\n    } else if (oldTarget !== null) {\n      (this as Mutable<typeof this>).target = null;\n      this.willDetachTarget(oldTarget);\n      this.onDetachTarget(oldTarget);\n      this.didDetachTarget(oldTarget);\n    }\n    if (newTarget !== null) {\n      (this as Mutable<typeof this>).target = newTarget;\n      this.willAttachTarget(newTarget);\n      this.onAttachTarget(newTarget);\n      this.didAttachTarget(newTarget);\n    }\n    return oldTarget;\n  },\n\n  willAttachTarget(target: T): void {\n    // hook\n  },\n\n  onAttachTarget(target: T): void {\n    if ((this.flags & (Fastener.MountedFlag | EventHandler.EnabledFlag)) === (Fastener.MountedFlag | EventHandler.EnabledFlag)) {\n      this.attachEvents(target);\n    }\n  },\n\n  didAttachTarget(target: T): void {\n    // hook\n  },\n\n  willDetachTarget(target: T): void {\n    // hook\n  },\n\n  onDetachTarget(target: T): void {\n    if ((this.flags & (Fastener.MountedFlag | EventHandler.EnabledFlag)) === (Fastener.MountedFlag | EventHandler.EnabledFlag)) {\n      this.detachEvents(target);\n    }\n  },\n\n  didDetachTarget(target: T): void {\n    // hook\n  },\n\n  options: void 0,\n\n  attachEvents(target: T): void {\n    const eventType = this.eventType;\n    if (typeof eventType === \"string\") {\n      this.attachEvent(target, eventType);\n    } else if (eventType !== void 0) {\n      for (let i = 0; i < eventType.length; i += 1) {\n        this.attachEvent(target, eventType[i]!);\n      }\n    }\n  },\n\n  attachEvent(target: T, eventType: string): void {\n    if (Objects.hasAllKeys<EventTarget>(target, \"addEventListener\", \"removeEventListener\")) {\n      target.addEventListener(eventType, this, this.options);\n    }\n  },\n\n  detachEvents(target: T): void {\n    const eventType = this.eventType;\n    if (typeof eventType === \"string\") {\n      this.detachEvent(target, eventType);\n    } else if (eventType !== void 0) {\n      for (let i = 0; i < eventType.length; i += 1) {\n        this.detachEvent(target, eventType[i]!);\n      }\n    }\n  },\n\n  detachEvent(target: T, eventType: string): void {\n    if (Objects.hasAllKeys<EventTarget>(target, \"addEventListener\", \"removeEventListener\")) {\n      target.removeEventListener(eventType, this, this.options);\n    }\n  },\n\n  handle(event: Event): void {\n    // hook\n  },\n\n  flagsInit: 1 << (Fastener.FlagShift + 0), // EnabledFlag\n\n  get enabled(): boolean {\n    return (this.flags & EventHandler.EnabledFlag) !== 0;\n  },\n\n  set enabled(enabled: boolean) {\n    if (enabled && ((this.flags & EventHandler.EnabledFlag) === 0)) {\n      this.willEnable();\n      this.setFlags(this.flags | EventHandler.EnabledFlag);\n      this.onEnable();\n      this.didEnable();\n    } else if (!enabled && ((this.flags & EventHandler.EnabledFlag) !== 0)) {\n      this.willDisable();\n      this.setFlags(this.flags & ~EventHandler.EnabledFlag);\n      this.onDisable();\n      this.didDisable();\n    }\n  },\n\n  willEnable(): void {\n    // hook\n  },\n\n  onEnable(): void {\n    const target = this.target;\n    if (target !== null && (this.flags & Fastener.MountedFlag) !== 0) {\n      this.attachEvents(target);\n    }\n  },\n\n  didEnable(): void {\n    // hook\n  },\n\n  willDisable(): void {\n    // hook\n  },\n\n  onDisable(): void {\n    const target = this.target;\n    if (target !== null && (this.flags & Fastener.MountedFlag) !== 0) {\n      this.detachEvents(target);\n    }\n  },\n\n  didDisable(): void {\n    // hook\n  },\n\n  bindComponent(component: Component<any>): void {\n    if (!this.binds || this.target !== null) {\n      return;\n    }\n    const target = this.detectComponent(component);\n    if (target !== null) {\n      this.setTarget(target);\n    }\n  },\n\n  unbindComponent(component: Component<any>): void {\n    if (!this.binds) {\n      return;\n    }\n    const target = this.detectComponent(component);\n    if (target !== null && target === this.target) {\n      this.setTarget(null);\n    }\n  },\n\n  detectComponent(component: Component<any>): T | null {\n    return null;\n  },\n\n  onMount(): void {\n    super.onMount();\n    const target = this.target;\n    if (target !== null && (this.flags & EventHandler.EnabledFlag) !== 0) {\n      this.attachEvents(target);\n    }\n  },\n\n  onUnmount(): void {\n    super.onUnmount();\n    const target = this.target;\n    if (target !== null && (this.flags & EventHandler.EnabledFlag) !== 0) {\n      this.detachEvents(target);\n    }\n  },\n},\n{\n  construct(fastener: F | null, owner: F extends Fastener<infer R, any, any> ? R : never): F {\n    if (fastener === null) {\n      fastener = function (event: Event): void {\n        fastener!.handle(event);\n      } as F;\n      Object.defineProperty(fastener, \"name\", {\n        value: this.prototype.name,\n        enumerable: true,\n        configurable: true,\n      });\n      Object.setPrototypeOf(fastener, this.prototype);\n    }\n    fastener = super.construct(fastener, owner) as F;\n    (fastener as Mutable<typeof fastener>).eventType = fastener.initEventType();\n    (fastener as Mutable<typeof fastener>).target = fastener.initTarget();\n    return fastener;\n  },\n\n  refine(fastenerClass: FastenerClass<EventHandler<any, any>>): void {\n    super.refine(fastenerClass);\n    const fastenerPrototype = fastenerClass.prototype;\n\n    let flagsInit = fastenerPrototype.flagsInit;\n    if (Object.prototype.hasOwnProperty.call(fastenerPrototype, \"enabled\")) {\n      if (fastenerPrototype.enabled) {\n        flagsInit |= EventHandler.EnabledFlag;\n      } else {\n        flagsInit &= ~EventHandler.EnabledFlag;\n      }\n      delete (fastenerPrototype as EventHandlerDescriptor<any, any>).enabled;\n    }\n    Object.defineProperty(fastenerPrototype, \"flagsInit\", {\n      value: flagsInit,\n      enumerable: true,\n      configurable: true,\n    });\n\n    const targetDescriptor = Object.getOwnPropertyDescriptor(fastenerPrototype, \"target\");\n    if (targetDescriptor !== void 0 && \"value\" in targetDescriptor) {\n      if (targetDescriptor.value === void 0) {\n        targetDescriptor.value = null;\n      }\n      Object.defineProperty(fastenerPrototype, \"target\", targetDescriptor);\n    }\n  },\n\n  EnabledFlag: 1 << (Fastener.FlagShift + 0),\n\n  FlagShift: Fastener.FlagShift + 1,\n  FlagMask: (1 << (Fastener.FlagShift + 1)) - 1,\n}))();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport type {Proto} from \"@swim/util\";\nimport type {Fastener} from \"./Fastener\";\nimport type {EventHandlerDescriptor} from \"./EventHandler\";\nimport type {EventHandlerClass} from \"./EventHandler\";\nimport {EventHandler} from \"./EventHandler\";\n\n/** @public */\nexport interface EventTimerDescriptor<R, T> extends EventHandlerDescriptor<R, T> {\n  extends?: Proto<EventTimer<any, any>> | boolean | null;\n}\n\n/** @public */\nexport interface EventTimerClass<F extends EventTimer<any, any> = EventTimer<any, any>> extends EventHandlerClass<F> {\n}\n\n/** @public */\nexport interface EventTimer<R = any, T = EventTarget> extends EventHandler<R, T> {\n  /** @override */\n  (event: Event): void;\n  (): void;\n\n  /** @override */\n  get descriptorType(): Proto<EventTimerDescriptor<R, T>>;\n\n  /** @protected */\n  readonly event: Event | null;\n\n  /** @protected */\n  defer(event: Event): void;\n\n  initDelay(): number;\n\n  readonly delay: number;\n\n  setDelay(delay: number): void;\n\n  readonly deadline: number | undefined;\n\n  get elapsed(): number | undefined;\n\n  get remaining(): number | undefined;\n\n  get scheduled(): boolean;\n\n  schedule(event: Event | null, delay?: number): void;\n\n  throttle(event: Event | null, delay?: number): void;\n\n  debounce(event: Event | null, delay?: number): void;\n\n  /** @protected */\n  willSchedule(event: Event | null, delay: number): void;\n\n  /** @protected */\n  onSchedule(event: Event | null, delay: number): void;\n\n  /** @protected */\n  didSchedule(event: Event | null, delay: number): void;\n\n  cancel(): void;\n\n  /** @protected */\n  willCancel(event: Event | null): void;\n\n  /** @protected */\n  onCancel(event: Event | null): void;\n\n  /** @protected */\n  didCancel(event: Event | null): void;\n\n  /** @internal @protected */\n  expire(): void;\n\n  /** @protected */\n  willExpire(event: Event | null): void;\n\n  /** @protected */\n  onExpire(event: Event | null): void;\n\n  /** @protected */\n  didExpire(event: Event | null): void;\n\n  /** @internal */\n  readonly timeout: unknown | undefined;\n\n  /** @protected */\n  setTimeout(callback: () => void, delay: number): unknown;\n\n  /** @protected */\n  clearTimeout(timeoutId: unknown): void;\n\n  /** @override @protected */\n  onUnmount(): void;\n}\n\n/** @public */\nexport const EventTimer = (<R, T, F extends EventTimer<any, any>>() => EventHandler.extend<EventTimer<R, T>, EventTimerClass<F>>(\"EventTimer\", {\n  defer(event: Event): void {\n    this.throttle(event);\n  },\n\n  delay: 0,\n\n  initDelay(): number {\n    const delay = (Object.getPrototypeOf(this) as EventTimer<any, any>).delay;\n    return Math.max(0, delay);\n  },\n\n  setDelay(delay: number): void {\n    (this as Mutable<typeof this>).delay = Math.max(0, delay);\n  },\n\n  get elapsed(): number | undefined {\n    const deadline = this.deadline;\n    if (deadline === void 0) {\n      return void 0;\n    }\n    return Math.max(0, performance.now() - (deadline - this.delay));\n  },\n\n  get remaining(): number | undefined {\n    const deadline = this.deadline;\n    if (deadline === void 0) {\n      return void 0;\n    }\n    return Math.max(0, deadline - performance.now());\n  },\n\n  get scheduled(): boolean {\n    return this.timeout !== void 0;\n  },\n\n  schedule(event: Event | null, delay?: number): void {\n    if (this.timeout !== void 0) {\n      throw new Error(\"timer already scheduled; call throttle or debounce to reschedule\");\n    } else if (delay === void 0) {\n      delay = this.delay;\n    } else {\n      this.setDelay(delay);\n    }\n    this.willSchedule(event, delay);\n    (this as Mutable<typeof this>).event = event;\n    (this as Mutable<typeof this>).deadline = performance.now() + delay;\n    (this as Mutable<typeof this>).timeout = this.setTimeout(this, delay);\n    this.onSchedule(event, delay);\n    this.didSchedule(event, delay);\n  },\n\n  throttle(event: Event | null, delay?: number): void {\n    if (this.timeout !== void 0) {\n      return;\n    } else if (delay === void 0) {\n      delay = this.delay;\n    } else {\n      this.setDelay(delay);\n    }\n    this.willSchedule(event, delay);\n    (this as Mutable<typeof this>).event = event;\n    (this as Mutable<typeof this>).deadline = performance.now() + delay;\n    (this as Mutable<typeof this>).timeout = this.setTimeout(this, delay);\n    this.onSchedule(event, delay);\n    this.didSchedule(event, delay);\n  },\n\n  debounce(event: Event | null, delay?: number): void {\n    const timeout = this.timeout;\n    if (timeout !== void 0) {\n      const event = this.event;\n      this.willCancel(event);\n      (this as Mutable<typeof this>).event = null;\n      (this as Mutable<typeof this>).timeout = void 0;\n      (this as Mutable<typeof this>).deadline = void 0;\n      this.clearTimeout(timeout);\n      this.onCancel(event);\n      this.didCancel(event);\n    }\n    if (delay === void 0) {\n      delay = this.delay;\n    } else {\n      this.setDelay(delay);\n    }\n    this.willSchedule(event, delay);\n    (this as Mutable<typeof this>).event = event;\n    (this as Mutable<typeof this>).deadline = performance.now() + delay;\n    (this as Mutable<typeof this>).timeout = this.setTimeout(this, delay);\n    this.onSchedule(event, delay);\n    this.didSchedule(event, delay);\n  },\n\n  willSchedule(event: Event | null, delay: number): void {\n    // hook\n  },\n\n  onSchedule(event: Event | null, delay: number): void {\n    // hook\n  },\n\n  didSchedule(event: Event | null, delay: number): void {\n    // hook\n  },\n\n  cancel(): void {\n    const timeout = this.timeout;\n    if (timeout === void 0) {\n      return;\n    }\n    const event = this.event;\n    this.willCancel(event);\n    (this as Mutable<typeof this>).event = null;\n    (this as Mutable<typeof this>).timeout = void 0;\n    (this as Mutable<typeof this>).deadline = void 0;\n    this.clearTimeout(timeout);\n    this.onCancel(event);\n    this.didCancel(event);\n  },\n\n  willCancel(event: Event | null): void {\n    // hook\n  },\n\n  onCancel(event: Event | null): void {\n    // hook\n  },\n\n  didCancel(event: Event | null): void {\n    // hook\n  },\n\n  expire(): void {\n    const event = this.event;\n    (this as Mutable<typeof this>).event = null;\n    (this as Mutable<typeof this>).timeout = void 0;\n    (this as Mutable<typeof this>).deadline = void 0;\n    this.willExpire(event);\n    if (event !== null) {\n      this.handle(event);\n    }\n    this.onExpire(event);\n    this.didExpire(event);\n  },\n\n  willExpire(event: Event | null): void {\n    // hook\n  },\n\n  onExpire(event: Event | null): void {\n    // hook\n  },\n\n  didExpire(event: Event | null): void {\n    // hook\n  },\n\n  setTimeout(callback: () => void, delay: number): unknown {\n    return setTimeout(callback, delay);\n  },\n\n  clearTimeout(timeout: unknown): void {\n    clearTimeout(timeout as any);\n  },\n\n  onUnmount(): void {\n    super.onUnmount();\n    this.cancel();\n  },\n},\n{\n  construct(fastener: F | null, owner: F extends Fastener<infer R, any, any> ? R : never): F {\n    if (fastener === null) {\n      fastener = function (event?: Event): void {\n        if (event !== void 0) { // event callback\n          fastener!.defer(event);\n        } else { // timer callback\n          fastener!.expire();\n        }\n      } as F;\n      Object.defineProperty(fastener, \"name\", {\n        value: this.prototype.name,\n        enumerable: true,\n        configurable: true,\n      });\n      Object.setPrototypeOf(fastener, this.prototype);\n    }\n    fastener = super.construct(fastener, owner) as F;\n    (fastener as Mutable<typeof fastener>).event = null;\n    (fastener as Mutable<typeof fastener>).delay = fastener.initDelay();\n    (fastener as Mutable<typeof fastener>).deadline = 0;\n    (fastener as Mutable<typeof fastener>).timeout = void 0;\n    return fastener;\n  },\n}))();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport type {Proto} from \"@swim/util\";\nimport type {Observes} from \"@swim/util\";\nimport {Affinity} from \"./Affinity\";\nimport {FastenerContext} from \"./FastenerContext\";\nimport type {FastenerFlags} from \"./Fastener\";\nimport type {FastenerDescriptor} from \"./Fastener\";\nimport type {FastenerClass} from \"./Fastener\";\nimport {Fastener} from \"./Fastener\";\nimport type {ServiceFactory} from \"./Service\";\nimport {Service} from \"./\"; // forward import\n\n/** @public */\nexport interface ProviderDescriptor<R, S extends Service> extends FastenerDescriptor<R> {\n  extends?: Proto<Provider<any, any>> | boolean | null;\n  serviceKey?: string | boolean;\n}\n\n/** @public */\nexport interface ProviderClass<P extends Provider<any, any> = Provider<any, any>> extends FastenerClass<P> {\n  tryService<R, K extends keyof R, F extends R[K] = R[K]>(owner: R, fastenerName: K): (F extends {readonly service: infer S | null} ? S | null : never) | null;\n\n  /** @internal */\n  readonly ManagedFlag: FastenerFlags;\n\n  /** @internal @override */\n  readonly FlagShift: number;\n  /** @internal @override */\n  readonly FlagMask: FastenerFlags;\n}\n\n/** @public */\nexport interface Provider<R = any, S extends Service = any> extends Fastener<R> {\n  /** @override */\n  get descriptorType(): Proto<ProviderDescriptor<R, S>>;\n\n  /** @override */\n  get fastenerType(): Proto<Provider<any, any>>;\n\n  get serviceType(): ServiceFactory<S> | null;\n\n  get observes(): boolean;\n\n  get creates(): boolean;\n\n  /** @protected @override */\n  onBindInlet(inlet: Fastener<any, any, any>): void;\n\n  /** @protected @override */\n  onUnbindInlet(inlet: Fastener<any, any, any>): void;\n\n  /** @override */\n  get parent(): Provider<any, S> | null;\n\n  get inletService(): S | null;\n\n  getInletService(): S;\n\n  get serviceKey(): string | undefined;\n\n  readonly service: S | null;\n\n  getService(): NonNullable<S>;\n\n  setService(service: S | null, target?: Service | null, key?: string): S | null;\n\n  /** @protected */\n  initService(service: S): void;\n\n  /** @protected */\n  willAttachService(service: S, target: Service | null): void;\n\n  /** @protected */\n  onAttachService(service: S, target: Service | null): void;\n\n  /** @protected */\n  didAttachService(service: S, target: Service | null): void;\n\n  /** @protected */\n  deinitService(service: S): void;\n\n  /** @protected */\n  willDetachService(service: S): void;\n\n  /** @protected */\n  onDetachService(service: S): void;\n\n  /** @protected */\n  didDetachService(service: S): void;\n\n  /** @protected */\n  get parentService(): Service | null;\n\n  /** @protected */\n  insertChild(parent: Service, child: S, target: Service | null, key: string | undefined): void;\n\n  createService(): S;\n\n  /** @protected */\n  mountService(service: S, target: Service | null, key: string | undefined): void;\n\n  /** @protected */\n  unmountService(service: S): void;\n\n  /** @protected */\n  mountRootService(service: S): void;\n\n  /** @protected */\n  unmountRootService(service: S): void;\n\n  /** @protected @override */\n  onMount(): void;\n\n  /** @protected @override */\n  onUnmount(): void;\n}\n\n/** @public */\nexport const Provider = (<R, S extends Service, P extends Provider<any, any>>() => Fastener.extend<Provider<R, S>, ProviderClass<P>>(\"Provider\", {\n  get fastenerType(): Proto<Provider<any, any>> {\n    return Provider;\n  },\n\n  serviceType: null,\n\n  observes: false,\n\n  creates: true,\n\n  inherits: true,\n\n  affinity: Affinity.Inherited,\n\n  onBindInlet(inlet: Fastener<any, any, any>): void {\n    if ((this.flags & Fastener.InheritsFlag) !== 0 && (this.flags & Affinity.Mask) === Affinity.Inherited) {\n      this.initAffinity(Affinity.Transient);\n    }\n    if (inlet instanceof Provider) {\n      this.setDerived(true);\n      this.setService(inlet.service);\n    }\n  },\n\n  onUnbindInlet(inlet: Fastener<any, any, any>): void {\n    super.onUnbindInlet(inlet);\n    if ((this.flags & Fastener.InheritsFlag) !== 0 && (this.flags & Affinity.Mask) === Affinity.Transient) {\n      this.initAffinity(Affinity.Inherited);\n    }\n  },\n\n  get inletService(): S | null {\n    const inlet = this.inlet;\n    return inlet instanceof Provider ? inlet.service : null;\n  },\n\n  getInletService(): S {\n    const inletService = this.inletService;\n    if (inletService === void 0 || inletService === null) {\n      let message = inletService + \" \";\n      const name = this.name.toString();\n      if (name.length !== 0) {\n        message += name + \" \";\n      }\n      message += \"inlet service\";\n      throw new TypeError(message);\n    }\n    return inletService;\n  },\n\n  serviceKey: void 0,\n\n  getService(): NonNullable<S> {\n    const service = this.service;\n    if (service === void 0 || service === null) {\n      let message = service + \" \";\n      const name = this.name.toString();\n      if (name.length !== 0) {\n        message += name + \" \";\n      }\n      message += \"service\";\n      throw new TypeError(message);\n    }\n    return service;\n  },\n\n  setService(newService: S | null, target?: Service | null, key?: string): S | null {\n    const oldService = this.service;\n    if (oldService === newService) {\n      this.setCoherent(true);\n      return oldService;\n    }\n    if (target === void 0) {\n      target = null;\n    }\n    if (oldService !== null) {\n      (this as Mutable<typeof this>).service = null;\n      this.willDetachService(oldService);\n      if ((this.flags & Fastener.MountedFlag) !== 0) {\n        this.unmountService(oldService);\n      }\n      this.onDetachService(oldService);\n      this.deinitService(oldService);\n      this.didDetachService(oldService);\n    }\n    if (newService !== null) {\n      (this as Mutable<typeof this>).service = newService;\n      this.willAttachService(newService, target);\n      if ((this.flags & Fastener.MountedFlag) !== 0) {\n        this.mountService(newService, target, key);\n      }\n      this.onAttachService(newService, target);\n      this.initService(newService);\n      this.didAttachService(newService, target);\n    }\n    this.setCoherent(true);\n    return oldService;\n  },\n\n  initService(service: S): void {\n    // hook\n  },\n\n  willAttachService(service: S, target: Service | null): void {\n    // hook\n  },\n\n  onAttachService(service: S, target: Service | null): void {\n    if (this.observes && (this.flags & Fastener.MountedFlag) !== 0) {\n      service.observe(this as Observes<S>);\n    }\n  },\n\n  didAttachService(service: S, target: Service | null): void {\n    // hook\n  },\n\n  deinitService(service: S): void {\n    // hook\n  },\n\n  willDetachService(service: S): void {\n    // hook\n  },\n\n  onDetachService(service: S): void {\n    if (this.observes && (this.flags & Fastener.MountedFlag) !== 0) {\n      service.unobserve(this as Observes<S>);\n    }\n  },\n\n  didDetachService(service: S): void {\n    // hook\n  },\n\n  get parentService(): S | null {\n    const parentProvider = this.parent;\n    return parentProvider !== null ? parentProvider.service : null;\n  },\n\n  insertChild(parent: Service, child: S, target: Service | null, key: string | undefined): void {\n    parent.insertChild(child, target, key);\n  },\n\n  createService(): S {\n    let service: S | undefined;\n    const serviceType = this.serviceType;\n    if (serviceType !== null) {\n      service = serviceType.global();\n    }\n    if (service === void 0 || service === null) {\n      let message = \"unable to create \";\n      const name = this.name.toString();\n      if (name.length !== 0) {\n        message += name + \" \";\n      }\n      message += \"service\";\n      throw new Error(message);\n    }\n    return service;\n  },\n\n  mountService(service: S, target: Service | null, key: string | undefined): void {\n    if (service.parent === null && !service.mounted) {\n      let parent = this.parentService;\n      if (parent === null) {\n        parent = Service.global();\n        target = null;\n        key = void 0;\n      } else if (key === void 0) {\n        key = this.serviceKey;\n      }\n      this.insertChild(parent, service, target, key);\n      this.setFlags(this.flags | Provider.ManagedFlag);\n    }\n    if (!this.derived) {\n      this.mountRootService(service);\n    }\n  },\n\n  unmountService(service: S): void {\n    if (!this.derived) {\n      this.unmountRootService(service);\n    }\n    if ((this.flags & Provider.ManagedFlag) !== 0) {\n      this.setFlags(this.flags & ~Provider.ManagedFlag);\n      service.remove();\n    }\n  },\n\n  mountRootService(service: S): void {\n    // hook\n  },\n\n  unmountRootService(service: S): void {\n    // hook\n  },\n\n  onMount(): void {\n    super.onMount();\n    let service = this.service;\n    if (service !== null) {\n      this.mountService(service, null, void 0);\n      if (this.observes) {\n        service.observe(this as Observes<S>);\n      }\n    } else if (this.creates) {\n      service = this.createService();\n      this.setService(service);\n    }\n  },\n\n  onUnmount(): void {\n    const service = this.service;\n    if (service !== null) {\n      if (this.observes) {\n        service.unobserve(this as Observes<S>);\n      }\n      this.unmountService(service);\n    }\n    super.onUnmount();\n  },\n},\n{\n  tryService<R, K extends keyof R, F extends R[K]>(owner: R, fastenerName: K): (F extends {readonly service: infer S | null} ? S | null : never) | null {\n    const metaclass = FastenerContext.getMetaclass(owner);\n    const provider = metaclass !== null ? metaclass.tryFastener(owner, fastenerName) : null;\n    return provider instanceof Provider ? provider.service : null;\n  },\n\n  create(owner: P extends Fastener<infer R, any, any> ? R : never): P {\n    const provider = super.create(owner) as P;\n    if (provider.service === null && provider.creates) {\n      const service = provider.createService();\n      provider.setService(service);\n    }\n    return provider;\n  },\n\n  construct(provider: P | null, owner: P extends Fastener<infer R, any, any> ? R : never): P {\n    provider = super.construct(provider, owner) as P;\n    (provider as Mutable<typeof provider>).service = null;\n    return provider;\n  },\n\n  refine(providerClass: FastenerClass<Provider<any, any>>): void {\n    super.refine(providerClass);\n    const providerPrototype = providerClass.prototype;\n\n    const serviceKeyDescriptor = Object.getOwnPropertyDescriptor(providerPrototype, \"serviceKey\");\n    if (serviceKeyDescriptor !== void 0 && \"value\" in serviceKeyDescriptor) {\n      if (serviceKeyDescriptor.value === true) {\n        serviceKeyDescriptor.value = providerClass.name;\n        Object.defineProperty(providerPrototype, \"serviceKey\", serviceKeyDescriptor);\n      } else if (serviceKeyDescriptor.value === false) {\n        serviceKeyDescriptor.value = void 0;\n        Object.defineProperty(providerPrototype, \"serviceKey\", serviceKeyDescriptor);\n      }\n    }\n  },\n\n  ManagedFlag: 1 << (Fastener.FlagShift + 0),\n\n  FlagShift: Fastener.FlagShift + 1,\n  FlagMask: (1 << (Fastener.FlagShift + 1)) - 1,\n}))();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {__esDecorate} from \"tslib\";\nimport {__runInitializers} from \"tslib\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport type {Class} from \"@swim/util\";\nimport type {Instance} from \"@swim/util\";\nimport type {Proto} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Comparator} from \"@swim/util\";\nimport type {LikeType} from \"@swim/util\";\nimport type {FromLike} from \"@swim/util\";\nimport type {Dictionary} from \"@swim/util\";\nimport type {MutableDictionary} from \"@swim/util\";\nimport type {TimingLike} from \"@swim/util\";\nimport {Creatable} from \"@swim/util\";\nimport type {Observes} from \"@swim/util\";\nimport type {Observable} from \"@swim/util\";\nimport type {ObserverMethods} from \"@swim/util\";\nimport type {ObserverParameters} from \"@swim/util\";\nimport type {Observer} from \"@swim/util\";\nimport {FastenerContext} from \"./FastenerContext\";\nimport type {FastenerDecorator} from \"./Fastener\";\nimport {Fastener} from \"./Fastener\";\nimport {Animator} from \"./Animator\";\nimport {EventHandler} from \"./EventHandler\";\nimport {ComponentRelation} from \"./\"; // forward import\n\n/** @public */\nexport type ComponentFlags = number;\n\n/** @public */\nexport interface ComponentFactory<C extends Component<any> = Component> extends Creatable<C>, FromLike<C> {\n}\n\n/** @public */\nexport interface ComponentClass<C extends Component<any> = Component> extends Function, ComponentFactory<C> {\n  readonly prototype: C;\n}\n\n/** @public */\nexport interface ComponentConstructor<C extends Component<any> = Component> extends ComponentClass<C> {\n  new(): C;\n}\n\n/** @public */\nexport interface ComponentObserver<C extends Component<any> = Component> extends Observer<C> {\n}\n\n/** @public */\nexport class Component<C extends Component<C> = Component<any>> implements HashCode, FastenerContext, Observable {\n  constructor() {\n    this.uid = (this.constructor as typeof Component).uid();\n    this.key = void 0;\n    this.flags = 0;\n    this.parent = null;\n    this.nextSibling = null;\n    this.previousSibling = null;\n    this.firstChild = null;\n    this.lastChild = null;\n    this.childMap = null;\n    this.coherentTime = 0;\n    this.decoherent = null;\n    this.recohering = null;\n    this.observers = null;\n  }\n\n  likeType?(like: {create?(): C}): void;\n\n  /** @override */\n  declare readonly observerType?: Class<ComponentObserver>;\n\n  get componentType(): Class<Component> {\n    return Component;\n  }\n\n  /** @internal */\n  readonly uid: string;\n\n  readonly key: string | undefined;\n\n  /** @internal */\n  setKey(key: string | undefined): void {\n    (this as Mutable<this>).key = key;\n  }\n\n  /** @internal */\n  readonly flags: ComponentFlags;\n\n  /** @internal */\n  setFlags(flags: ComponentFlags): void {\n    (this as Mutable<this>).flags = flags;\n  }\n\n  readonly parent: C | null;\n\n  /** @internal */\n  attachParent(parent: C, nextSibling: C | null): void;\n  attachParent(this: C, parent: C, nextSibling: C | null): void {\n    // assert(this.parent === null);\n    this.willAttachParent(parent);\n    (this as Mutable<typeof this>).parent = parent;\n    let previousSibling: C | null;\n    if (nextSibling !== null) {\n      previousSibling = nextSibling.previousSibling;\n      this.setNextSibling(nextSibling);\n      nextSibling.setPreviousSibling(this);\n    } else {\n      previousSibling = parent.lastChild;\n      parent.setLastChild(this);\n    }\n    if (previousSibling !== null) {\n      previousSibling.setNextSibling(this);\n      this.setPreviousSibling(previousSibling);\n    } else {\n      parent.setFirstChild(this);\n    }\n    if (parent.mounted) {\n      this.cascadeMount();\n    }\n    this.onAttachParent(parent);\n    this.didAttachParent(parent);\n  }\n\n  protected willAttachParent(parent: C): void {\n    // hook\n  }\n\n  protected onAttachParent(parent: C): void {\n    // hook\n  }\n\n  protected didAttachParent(parent: C): void {\n    // hook\n  }\n\n  /** @internal */\n  detachParent(parent: C): void {\n    // assert(this.parent === parent);\n    this.willDetachParent(parent);\n    if (this.mounted) {\n      this.cascadeUnmount();\n    }\n    this.onDetachParent(parent);\n    const nextSibling = this.nextSibling;\n    const previousSibling = this.previousSibling;\n    if (nextSibling !== null) {\n      this.setNextSibling(null);\n      nextSibling.setPreviousSibling(previousSibling);\n    } else {\n      parent.setLastChild(previousSibling);\n    }\n    if (previousSibling !== null) {\n      previousSibling.setNextSibling(nextSibling);\n      this.setPreviousSibling(null);\n    } else {\n      parent.setFirstChild(nextSibling);\n    }\n    (this as Mutable<this>).parent = null;\n    this.didDetachParent(parent);\n  }\n\n  protected willDetachParent(parent: C): void {\n    // hook\n  }\n\n  protected onDetachParent(parent: C): void {\n    // hook\n  }\n\n  protected didDetachParent(parent: C): void {\n    // hook\n  }\n\n  /** @internal */\n  reattachParent(newNextSibling: C | null): void;\n  reattachParent(this: C, newNextSibling: C | null): void {\n    const parent = this.parent!;\n    // assert(parent !== null);\n\n    this.willDetachParent(parent);\n    this.onDetachParent(parent);\n    const oldNextSibling = this.nextSibling;\n    const oldPreviousSibling = this.previousSibling;\n    if (oldNextSibling !== null) {\n      this.setNextSibling(null);\n      oldNextSibling.setPreviousSibling(oldPreviousSibling);\n    } else {\n      parent.setLastChild(oldPreviousSibling);\n    }\n    if (oldPreviousSibling !== null) {\n      oldPreviousSibling.setNextSibling(oldNextSibling);\n      this.setPreviousSibling(null);\n    } else {\n      parent.setFirstChild(oldNextSibling);\n    }\n    this.didDetachParent(parent);\n\n    this.willAttachParent(parent);\n    let newPreviousSibling: C | null;\n    if (newNextSibling !== null) {\n      newPreviousSibling = newNextSibling.previousSibling;\n      this.setNextSibling(newNextSibling);\n      newNextSibling.setPreviousSibling(this);\n    } else {\n      newPreviousSibling = parent.lastChild;\n      parent.setLastChild(this);\n    }\n    if (newPreviousSibling !== null) {\n      newPreviousSibling.setNextSibling(this);\n      this.setPreviousSibling(newPreviousSibling);\n    } else {\n      parent.setFirstChild(this);\n    }\n    this.onAttachParent(parent);\n    this.didAttachParent(parent);\n  }\n\n  readonly nextSibling: C | null;\n\n  getNextSibling<F extends Class<C>>(siblingType: F): InstanceType<F> | null;\n  getNextSibling(siblingType: Class<C>): C | null;\n  getNextSibling(siblingType: Class<C>): C | null {\n    let nextSibling = this.nextSibling;\n    do {\n      if (nextSibling === null) {\n        return null;\n      } else if (nextSibling instanceof siblingType) {\n        return nextSibling;\n      }\n      nextSibling = nextSibling.nextSibling;\n    } while (true);\n  }\n\n  /** @internal */\n  setNextSibling(nextSibling: C | null): void {\n    (this as Mutable<this>).nextSibling = nextSibling;\n  }\n\n  readonly previousSibling: C | null;\n\n  getPreviousSibling<F extends Class<C>>(siblingType: F): InstanceType<F> | null;\n  getPreviousSibling(siblingType: Class<C>): C | null;\n  getPreviousSibling(siblingType: Class<C>): C | null {\n    let previousSibling = this.previousSibling;\n    do {\n      if (previousSibling === null) {\n        return null;\n      } else if (previousSibling instanceof siblingType) {\n        return previousSibling;\n      }\n      previousSibling = previousSibling.previousSibling;\n    } while (true);\n  }\n\n  /** @internal */\n  setPreviousSibling(previousSibling: C | null): void {\n    (this as Mutable<this>).previousSibling = previousSibling;\n  }\n\n  readonly firstChild: C | null;\n\n  getFirstChild<F extends Class<C>>(childType: F): InstanceType<F> | null;\n  getFirstChild(childType: Class<C>): C | null;\n  getFirstChild(childType: Class<C>): C | null {\n    let child = this.firstChild;\n    do {\n      if (child === null) {\n        return null;\n      } else if (child instanceof childType) {\n        return child;\n      }\n      child = child.nextSibling;\n    } while (true);\n  }\n\n  /** @internal */\n  setFirstChild(firstChild: C | null): void {\n    (this as Mutable<this>).firstChild = firstChild;\n  }\n\n  readonly lastChild: C | null;\n\n  getLastChild<F extends Class<C>>(childType: F): InstanceType<F> | null;\n  getLastChild(childType: Class<C>): C | null;\n  getLastChild(childType: Class<C>): C | null {\n    let child = this.lastChild;\n    do {\n      if (child === null) {\n        return null;\n      } else if (child instanceof childType) {\n        return child;\n      }\n      child = child.previousSibling;\n    } while (true);\n  }\n\n  /** @internal */\n  setLastChild(lastChild: C | null): void {\n    (this as Mutable<this>).lastChild = lastChild;\n  }\n\n  forEachChild<T>(callback: (child: C) => T | void): T | undefined;\n  forEachChild<T, S>(callback: (this: S, child: C) => T | void, thisArg: S): T | undefined;\n  forEachChild<T, S>(this: C, callback: (this: S | undefined, child: C) => T | void, thisArg?: S): T | undefined {\n    let result: T | undefined;\n    let child = this.firstChild;\n    while (child !== null) {\n      const next = child.nextSibling;\n      const result = callback.call(thisArg, child);\n      if (result !== void 0) {\n        break;\n      }\n      child = next !== null && next.parent === this ? next : null;\n    }\n    return result;\n  }\n\n  /** @internal */\n  readonly childMap: Dictionary<C> | null;\n\n  /** @internal */\n  protected insertChildMap(child: C): void {\n    const key = child.key;\n    if (key === void 0) {\n      return;\n    }\n    let childMap = this.childMap as MutableDictionary<C>;\n    if (childMap === null) {\n      childMap = {};\n      (this as Mutable<this>).childMap = childMap;\n    }\n    childMap[key] = child;\n  }\n\n  /** @internal */\n  protected removeChildMap(child: C): void {\n    const key = child.key;\n    if (key === void 0) {\n      return;\n    }\n    const childMap = this.childMap as MutableDictionary<C>;\n    if (childMap !== null) {\n      delete childMap[key];\n    }\n  }\n\n  getChild<F extends Class<C>>(key: string, childType: F): InstanceType<F> | null;\n  getChild(key: string, childType?: Class<C>): C | null;\n  getChild(key: string, childType?: Class<C>): C | null {\n    const childMap = this.childMap;\n    if (childMap === null) {\n      return null;\n    }\n    const child = childMap[key];\n    if (child === void 0 || (childType !== void 0 && !(child instanceof childType))) {\n      return null;\n    }\n    return child;\n  }\n\n  setChild<F extends Class<Instance<F, C>> & Creatable<Instance<F, C>>>(key: string, newChildFactory: F): C | null;\n  setChild(key: string, newChild: C | LikeType<C> | null): C | null;\n  setChild(this: C, key: string, newChild: C | LikeType<C> | null): C | null {\n    if (newChild !== null) {\n      newChild = (this.componentType as unknown as FromLike<C>).fromLike(newChild);\n    }\n\n    const oldChild = this.getChild(key);\n    let target: C | null;\n\n    if (oldChild !== null && newChild !== null && oldChild !== newChild) { // replace\n      newChild.remove();\n      target = oldChild.nextSibling;\n\n      if ((oldChild.flags & Component.RemovingFlag) === 0) {\n        oldChild.setFlags(oldChild.flags | Component.RemovingFlag);\n        this.willRemoveChild(oldChild);\n        oldChild.detachParent(this);\n        this.removeChildMap(oldChild);\n        this.onRemoveChild(oldChild);\n        this.didRemoveChild(oldChild);\n        oldChild.setKey(void 0);\n        oldChild.setFlags(oldChild.flags & ~Component.RemovingFlag);\n      }\n\n      newChild.setFlags(newChild.flags | Component.InsertingFlag);\n      newChild.setKey(oldChild.key);\n      this.willInsertChild(newChild, target);\n      this.insertChildMap(newChild);\n      newChild.attachParent(this, target);\n      this.onInsertChild(newChild, target);\n      this.didInsertChild(newChild, target);\n      newChild.cascadeInsert();\n      newChild.setFlags(newChild.flags & ~Component.InsertingFlag);\n    } else if (newChild !== oldChild || newChild !== null && newChild.key !== key) {\n      if (oldChild !== null) { // remove\n        target = oldChild.nextSibling;\n        if ((oldChild.flags & Component.RemovingFlag) === 0) {\n          oldChild.setFlags(oldChild.flags | Component.RemovingFlag);\n          this.willRemoveChild(oldChild);\n          oldChild.detachParent(this);\n          this.removeChildMap(oldChild);\n          this.onRemoveChild(oldChild);\n          this.didRemoveChild(oldChild);\n          oldChild.setKey(void 0);\n          oldChild.setFlags(oldChild.flags & ~Component.RemovingFlag);\n        }\n      } else {\n        target = null;\n      }\n\n      if (newChild !== null) { // insert\n        newChild.remove();\n\n        newChild.setFlags(newChild.flags | Component.InsertingFlag);\n        newChild.setKey(key);\n        this.willInsertChild(newChild, target);\n        this.insertChildMap(newChild);\n        newChild.attachParent(this, target);\n        this.onInsertChild(newChild, target);\n        this.didInsertChild(newChild, target);\n        newChild.cascadeInsert();\n        newChild.setFlags(newChild.flags & ~Component.InsertingFlag);\n      }\n    }\n\n    return oldChild;\n  }\n\n  appendChild<F extends Class<Instance<F, C>> & Creatable<Instance<F, C>>>(childFactory: F, key?: string): InstanceType<F>;\n  appendChild<Child extends C>(child: Child | LikeType<Child>, key?: string): Child;\n  appendChild(child: C | LikeType<C>, key?: string): C;\n  appendChild(this: C, child: C | LikeType<C>, key?: string): C {\n    child = (this.componentType as unknown as FromLike<C>).fromLike(child);\n\n    child.remove();\n    if (key !== void 0) {\n      this.removeChild(key);\n    }\n\n    child.setFlags(child.flags | Component.InsertingFlag);\n    child.setKey(key);\n    this.willInsertChild(child, null);\n    this.insertChildMap(child);\n    child.attachParent(this, null);\n    this.onInsertChild(child, null);\n    this.didInsertChild(child, null);\n    child.cascadeInsert();\n    child.setFlags(child.flags & ~Component.InsertingFlag);\n\n    return child;\n  }\n\n  prependChild<F extends Class<Instance<F, C>> & Creatable<Instance<F, C>>>(childFactory: F, key?: string): InstanceType<F>;\n  prependChild<Child extends C>(child: Child | LikeType<Child>, key?: string): Child;\n  prependChild(child: C | LikeType<C>, key?: string): C;\n  prependChild(this: C, child: C | LikeType<C>, key?: string): C {\n    child = (this.componentType as unknown as FromLike<C>).fromLike(child);\n\n    child.remove();\n    if (key !== void 0) {\n      this.removeChild(key);\n    }\n    const target = this.firstChild;\n\n    child.setFlags(child.flags | Component.InsertingFlag);\n    child.setKey(key);\n    this.willInsertChild(child, target);\n    this.insertChildMap(child);\n    child.attachParent(this, target);\n    this.onInsertChild(child, target);\n    this.didInsertChild(child, target);\n    child.cascadeInsert();\n    child.setFlags(child.flags & ~Component.InsertingFlag);\n\n    return child;\n  }\n\n  insertChild<F extends Class<Instance<F, C>> & Creatable<Instance<F, C>>>(childFactory: F, target: C | null, key?: string): InstanceType<F>;\n  insertChild<Child extends C>(child: Child | LikeType<Child>, target: C | null, key?: string): Child;\n  insertChild(child: C | LikeType<C>, target: C | null, key?: string): C;\n  insertChild(this: C, child: C | LikeType<C>, target: C | null, key?: string): C {\n    child = (this.componentType as unknown as FromLike<C>).fromLike(child);\n\n    if (target !== null && target.parent !== this) {\n      target = null;\n    }\n\n    child.remove();\n    if (key !== void 0) {\n      this.removeChild(key);\n    }\n\n    child.setFlags(child.flags | Component.InsertingFlag);\n    child.setKey(key);\n    this.willInsertChild(child, target);\n    this.insertChildMap(child);\n    child.attachParent(this, target);\n    this.onInsertChild(child, target);\n    this.didInsertChild(child, target);\n    child.cascadeInsert();\n    child.setFlags(child.flags & ~Component.InsertingFlag);\n\n    return child;\n  }\n\n  replaceChild<F extends Class<Instance<F, C>> & Creatable<Instance<F, C>>>(newChildFactory: F, oldChild: C): C;\n  replaceChild<Child extends C>(newChild: C | LikeType<C>, oldChild: Child): Child;\n  replaceChild(newChild: C | LikeType<C>, oldChild: C): C;\n  replaceChild(this: C, newChild: C | LikeType<C>, oldChild: C): C {\n    if (oldChild.parent !== this) {\n      throw new Error(\"replacement target is not a child\");\n    }\n\n    newChild = (this.componentType as unknown as FromLike<C>).fromLike(newChild);\n\n    if (newChild === oldChild) {\n      return oldChild;\n    }\n\n    newChild.remove();\n    const target = oldChild.nextSibling;\n\n    if ((oldChild.flags & Component.RemovingFlag) === 0) {\n      oldChild.setFlags(oldChild.flags | Component.RemovingFlag);\n      this.willRemoveChild(oldChild);\n      oldChild.detachParent(this);\n      this.removeChildMap(oldChild);\n      this.onRemoveChild(oldChild);\n      this.didRemoveChild(oldChild);\n      oldChild.setKey(void 0);\n      oldChild.setFlags(oldChild.flags & ~Component.RemovingFlag);\n    }\n\n    newChild.setFlags(newChild.flags | Component.InsertingFlag);\n    newChild.setKey(oldChild.key);\n    this.willInsertChild(newChild, target);\n    this.insertChildMap(newChild);\n    newChild.attachParent(this, target);\n    this.onInsertChild(newChild, target);\n    this.didInsertChild(newChild, target);\n    newChild.cascadeInsert();\n    newChild.setFlags(newChild.flags & ~Component.InsertingFlag);\n\n    return oldChild;\n  }\n\n  get insertChildFlags(): ComponentFlags {\n    return (this.constructor as typeof Component).InsertChildFlags;\n  }\n\n  get inserting(): boolean {\n    return (this.flags & Component.InsertingFlag) !== 0;\n  }\n\n  protected willInsertChild(child: C, target: C | null): void {\n    // hook\n  }\n\n  protected onInsertChild(child: C, target: C | null): void {\n    this.requireUpdate(this.insertChildFlags);\n    this.bindChildFasteners(child, target);\n  }\n\n  protected didInsertChild(child: C, target: C | null): void {\n    // hook\n  }\n\n  /** @internal */\n  cascadeInsert(): void {\n    // hook\n  }\n\n  removeChild<Child extends C>(child: Child): Child;\n  removeChild(child: C): C;\n  removeChild(key: string | C): C | null;\n  removeChild(this: C, key: string | C): C | null {\n    let child: C | null;\n    if (typeof key === \"string\") {\n      child = this.getChild(key);\n      if (child === null) {\n        return null;\n      }\n    } else {\n      child = key;\n      if (child.parent !== this) {\n        throw new Error(\"not a child\");\n      }\n    }\n\n    if ((child.flags & Component.RemovingFlag) === 0) {\n      child.setFlags(child.flags | Component.RemovingFlag);\n      this.willRemoveChild(child);\n      child.detachParent(this);\n      this.removeChildMap(child);\n      this.onRemoveChild(child);\n      this.didRemoveChild(child);\n      child.setKey(void 0);\n      child.setFlags(child.flags & ~Component.RemovingFlag);\n    }\n\n    return child;\n  }\n\n  get removeChildFlags(): ComponentFlags {\n    return (this.constructor as typeof Component).RemoveChildFlags;\n  }\n\n  get removing(): boolean {\n    return (this.flags & Component.RemovingFlag) !== 0;\n  }\n\n  protected willRemoveChild(child: C): void {\n    // hook\n  }\n\n  protected onRemoveChild(child: C): void {\n    this.requireUpdate(this.removeChildFlags);\n    this.unbindChildFasteners(child);\n  }\n\n  protected didRemoveChild(child: C): void {\n    // hook\n  }\n\n  removeChildren(): void\n  removeChildren(this: C): void {\n    let child: C | null;\n    while (child = this.lastChild, child !== null) {\n      if ((child.flags & Component.RemovingFlag) !== 0) {\n        throw new Error(\"inconsistent removeChildren\");\n      }\n      this.willRemoveChild(child);\n      child.detachParent(this);\n      this.removeChildMap(child);\n      this.onRemoveChild(child);\n      this.didRemoveChild(child);\n      child.setKey(void 0);\n      child.setFlags(child.flags & ~Component.RemovingFlag);\n    }\n  }\n\n  remove(): void;\n  remove(this: C): void {\n    const parent = this.parent;\n    if (parent !== null) {\n      parent.removeChild(this);\n    } else if (this.mounted) {\n      this.unmount();\n    }\n  }\n\n  get reinsertChildFlags(): ComponentFlags {\n    return (this.constructor as typeof Component).ReinsertChildFlags;\n  }\n\n  reinsertChild(child: C, target: C | null): void;\n  reinsertChild(this: C, child: C, target: C | null): void {\n    if (child.parent !== this) {\n      throw new Error(\"not a child\");\n    } else if (target !== null && target.parent !== this) {\n      throw new Error(\"reinsert target is not a child\");\n    } else if (child.nextSibling === target) {\n      return;\n    }\n\n    this.willReinsertChild(child, target);\n    child.reattachParent(target);\n    this.onReinsertChild(child, target);\n    this.didReinsertChild(child, target);\n  }\n\n  protected willReinsertChild(child: C, target: C | null): void {\n    // hook\n  }\n\n  protected onReinsertChild(child: C, target: C | null): void {\n    this.requireUpdate(this.reinsertChildFlags);\n  }\n\n  protected didReinsertChild(child: C, target: C | null): void {\n    // hook\n  }\n\n  sortChildren(comparator: Comparator<C>): void {\n    let child = this.firstChild;\n    if (child === null) {\n      return;\n    }\n\n    const children: C[] = [];\n    do {\n      children.push(child);\n      child = child.nextSibling;\n    } while (child !== null);\n    children.sort(comparator);\n\n    child = children[0]!;\n    this.setFirstChild(child);\n    child.setPreviousSibling(null);\n    for (let i = 1; i < children.length; i += 1) {\n      const next = children[i]!;\n      child.setNextSibling(next);\n      next.setPreviousSibling(child);\n      child = next;\n    }\n    child.setNextSibling(null);\n    this.setLastChild(child);\n  }\n\n  getTargetChild(child: C, comparator: Comparator<C>): C | null {\n    let target = this.lastChild;\n    while (target !== null) {\n      if (target !== child && comparator(child, target) >= 0) {\n        target = target.nextSibling;\n        if (target === child) {\n          target = target.nextSibling;\n        }\n        return target;\n      }\n      target = target.previousSibling;\n    }\n    target = this.firstChild;\n    if (target === child) {\n      target = target.nextSibling;\n    }\n    return target;\n  }\n\n  getAncestor<F extends Class<C>>(ancestorType: F): InstanceType<F> | null;\n  getAncestor(ancestorType: Class<C>): C | null;\n  getAncestor(ancestorType: Class<C>): C | null {\n    let ancestor = this.parent;\n    while (ancestor !== null) {\n      if (ancestor instanceof ancestorType) {\n        return ancestor;\n      }\n      ancestor = ancestor.parent;\n    }\n    return null;\n  }\n\n  getRoot<F extends Class<C>>(rootType: F): InstanceType<F> | null;\n  getRoot(rootType: Class<C>): C | null;\n  getRoot(rootType: Class<C>): C | null {\n    let base: C | null = null;\n    let ancestor = this.parent;\n    while (ancestor !== null) {\n      if (ancestor instanceof rootType) {\n        base = ancestor;\n      }\n      ancestor = ancestor.parent;\n    }\n    return base;\n  }\n\n  isAncestorOf(descendant: C | null): boolean;\n  isAncestorOf(this: C, descendant: C | null): boolean {\n    while (descendant !== null) {\n      if (descendant === this) {\n        return true;\n      }\n      descendant = descendant.parent;\n    }\n    return false;\n  }\n\n  commonAncestor(relative: C | null): C | null;\n  commonAncestor(this: C, relative: C | null): C | null {\n    while (relative !== null) {\n      if (relative.isAncestorOf(this)) {\n        return relative;\n      }\n      relative = relative.parent;\n    }\n    return null;\n  }\n\n  get mounted(): boolean {\n    return (this.flags & Component.MountedFlag) !== 0;\n  }\n\n  get mountFlags(): ComponentFlags {\n    return (this.constructor as typeof Component).MountFlags;\n  }\n\n  mount(): void {\n    if (this.mounted || this.parent !== null) {\n      return;\n    }\n    this.setFlags(this.flags | Component.InsertingFlag);\n    this.cascadeMount();\n    this.cascadeInsert();\n    this.setFlags(this.flags & ~Component.InsertingFlag);\n  }\n\n  /** @internal */\n  cascadeMount(): void {\n    if ((this.flags & Component.MountedFlag) !== 0) {\n      throw new Error(\"already mounted\");\n    }\n    this.willMount();\n    this.setFlags(this.flags | Component.MountedFlag);\n    this.onMount();\n    this.mountChildren();\n    this.didMount();\n  }\n\n  protected willMount(): void {\n    // hook\n  }\n\n  protected onMount(): void {\n    // hook\n  }\n\n  protected didMount(): void {\n    this.requireUpdate(this.mountFlags);\n    this.mountFasteners();\n  }\n\n  /** @internal */\n  protected mountChildren(): void;\n  protected mountChildren(this: C): void {\n    let child = this.firstChild;\n    while (child !== null) {\n      const next = child.nextSibling;\n      child.cascadeMount();\n      if (next !== null && next.parent !== this) {\n        throw new Error(\"inconsistent mount\");\n      }\n      child = next;\n    }\n  }\n\n  unmount(): void {\n    if (!this.mounted || this.parent !== null) {\n      return;\n    }\n    this.cascadeUnmount();\n  }\n\n  /** @internal */\n  cascadeUnmount(): void {\n    if ((this.flags & Component.MountedFlag) === 0) {\n      throw new Error(\"already unmounted\");\n    }\n    this.willUnmount();\n    this.setFlags(this.flags & ~Component.MountedFlag);\n    this.unmountChildren();\n    this.onUnmount();\n    this.didUnmount();\n  }\n\n  protected willUnmount(): void {\n    this.unmountFasteners();\n  }\n\n  protected onUnmount(): void {\n    // hook\n  }\n\n  protected didUnmount(): void {\n    // hook\n  }\n\n  /** @internal */\n  protected unmountChildren(): void;\n  protected unmountChildren(this: C): void {\n    let child = this.lastChild;\n    while (child !== null) {\n      const prev = child.previousSibling;\n      child.cascadeUnmount();\n      if (prev !== null && prev.parent !== this) {\n        throw new Error(\"inconsistent unmount\");\n      }\n      child = prev;\n    }\n  }\n\n  requireUpdate(updateFlags: ComponentFlags, immediate?: boolean): void {\n    // hook\n  }\n\n  tryFastener<K extends keyof this, F extends this[K] = this[K]>(fastenerName: K): (F extends Fastener<any, any, any> ? F | null : never) | null {\n    const metaclass = FastenerContext.getMetaclass(this);\n    return metaclass !== null ? metaclass.tryFastener(this, fastenerName) : null;\n  }\n\n  getFastener<F extends Fastener<any, any, any>>(fastenerName: PropertyKey, fastenerType?: Proto<F>, contextType?: Proto<any> | null): F | null {\n    if (contextType !== void 0 && contextType !== null && !(this instanceof contextType)) {\n      return null;\n    }\n    const fastener = (this as any)[fastenerName] as F | null | undefined;\n    if (fastener === void 0 || (fastenerType !== void 0 && fastenerType !== null && !(fastener instanceof fastenerType))) {\n      return null;\n    }\n    return fastener;\n  }\n\n  /** @override */\n  getParentFastener<F extends Fastener<any, any, any>>(fastenerName: PropertyKey, fastenerType?: Proto<F>, contextType?: Proto<any> | null): F | null {\n    let parent = this.parent;\n    while (parent !== null) {\n      const fastener = parent.getFastener(fastenerName, fastenerType, contextType);\n      if (fastener !== null) {\n        return fastener;\n      }\n      parent = parent.parent;\n    }\n    return null;\n  }\n\n  /** @override */\n  attachFastener(fastener: Fastener<any, any, any>): void {\n    if (this.mounted) {\n      fastener.mount();\n    }\n    this.bindFastener(fastener);\n  }\n\n  /** @internal */\n  protected mountFasteners(): void {\n    const metaclass = FastenerContext.getMetaclass(this);\n    if (metaclass === null) {\n      return;\n    }\n    const fastenerSlots = metaclass.slots;\n    for (let i = 0; i < fastenerSlots.length; i += 1) {\n      const fastener = this[fastenerSlots[i]!];\n      if (fastener instanceof Fastener) {\n        fastener.mount();\n      }\n    }\n  }\n\n  /** @internal */\n  protected unmountFasteners(): void {\n    const metaclass = FastenerContext.getMetaclass(this);\n    if (metaclass === null) {\n      return;\n    }\n    const fastenerSlots = metaclass.slots;\n    for (let i = 0; i < fastenerSlots.length; i += 1) {\n      const fastener = this[fastenerSlots[i]!];\n      if (fastener instanceof Fastener) {\n        fastener.unmount();\n      }\n    }\n  }\n\n  protected bindFastener(fastener: Fastener<any, any, any>): void;\n  protected bindFastener(this: C, fastener: Fastener<any, any, any>): void {\n    if (!fastener.binds) {\n      return;\n    }\n    let child = this.firstChild;\n    while (child !== null) {\n      const next = child.nextSibling;\n      this.bindChildFastener(fastener, child, next);\n      child = next !== null && next.parent === this ? next : null;\n    }\n  }\n\n  /** @internal */\n  protected bindChildFasteners(child: C, target: C | null): void {\n    const metaclass = FastenerContext.getMetaclass(this);\n    if (metaclass === null) {\n      return;\n    }\n    const fastenerSlots = metaclass.slots;\n    for (let i = 0; i < fastenerSlots.length; i += 1) {\n      const fastener = this[fastenerSlots[i]!];\n      if (fastener instanceof Fastener) {\n        this.bindChildFastener(fastener, child, target);\n      }\n    }\n  }\n\n  /** @internal */\n  protected bindChildFastener(fastener: Fastener<any, any, any>, child: C, target: C | null): void {\n    if (fastener instanceof ComponentRelation || fastener instanceof EventHandler) {\n      fastener.bindComponent(child, target);\n    }\n  }\n\n  /** @internal */\n  protected unbindChildFasteners(child: C): void {\n    const metaclass = FastenerContext.getMetaclass(this);\n    if (metaclass === null) {\n      return;\n    }\n    const fastenerSlots = metaclass.slots;\n    for (let i = 0; i < fastenerSlots.length; i += 1) {\n      const fastener = this[fastenerSlots[i]!];\n      if (fastener instanceof Fastener) {\n        this.unbindChildFastener(fastener, child);\n      }\n    }\n  }\n\n  /** @internal */\n  protected unbindChildFastener(fastener: Fastener<any, any, any>, child: C): void {\n    if (fastener instanceof ComponentRelation || fastener instanceof EventHandler) {\n      fastener.unbindComponent(child);\n    }\n  }\n\n  set<S>(this: S, properties: {[K in keyof S as S[K] extends {set(value: any): any} ? K : never]?: S[K] extends {set(value: infer T): any} ? T : never}, timing?: TimingLike | boolean | null): this;\n  set(properties: {[K in keyof this as this[K] extends {set(value: any): any} ? K : never]?: this[K] extends {set(value: infer T): any} ? T : never}, timing?: TimingLike | boolean | null): this {\n    for (const key in properties) {\n      const value = properties[key];\n      const property = (this as any)[key] as {set?(value: any): any} | undefined;\n      if (property === void 0 || property === null) {\n        throw new Error(\"unknown property \" + key);\n      } else if (property.set === void 0) {\n        throw new Error(\"unsettable property \" + key);\n      } else if (property instanceof Animator) {\n        property.set(value, timing);\n      } else {\n        property.set(value);\n      }\n    }\n    return this;\n  }\n\n  setIntrinsic<S>(this: S, properties: {[K in keyof S as S[K] extends {setIntrinsic(value: any): any} ? K : never]?: S[K] extends {setIntrinsic(value: infer T): any} ? T : never}, timing?: TimingLike | boolean | null): this;\n  setIntrinsic(properties: {[K in keyof this as this[K] extends {setIntrinsic(value: any): any} ? K : never]?: this[K] extends {setIntrinsic(value: infer T): any} ? T : never}, timing?: TimingLike | boolean | null): this {\n    for (const key in properties) {\n      const value = properties[key];\n      const property = (this as any)[key] as {setIntrinsic?(value: any): any} | undefined;\n      if (property === void 0 || property === null) {\n        throw new Error(\"unknown property \" + key);\n      } else if (property.setIntrinsic === void 0) {\n        throw new Error(\"unsettable property \" + key);\n      } else if (property instanceof Animator) {\n        property.setIntrinsic(value, timing);\n      } else {\n        property.setIntrinsic(value);\n      }\n    }\n    return this;\n  }\n\n  /** @internal */\n  readonly coherentTime: number;\n\n  /** @internal */\n  readonly decoherent: readonly Fastener<any, any, any>[] | null;\n\n  /** @internal */\n  readonly recohering: readonly Fastener<any, any, any>[] | null;\n\n  /** @override */\n  decohereFastener(fastener: Fastener<any, any, any>): void {\n    const recohering = this.recohering as Fastener<any, any, any>[] | null;\n    if (recohering !== null && fastener.coherentTime !== this.coherentTime) {\n      recohering.push(fastener);\n      return;\n    }\n    this.enqueueFastener(fastener);\n  }\n\n  protected enqueueFastener(fastener: Fastener<any, any, any>): void {\n    let decoherent = this.decoherent as Fastener<any, any, any>[] | null;\n    if (decoherent === null) {\n      decoherent = [];\n      (this as Mutable<this>).decoherent = decoherent;\n    }\n    decoherent.push(fastener);\n  }\n\n  recohereFasteners(t?: number): void {\n    const decoherent = this.decoherent;\n    if (decoherent === null || decoherent.length === 0) {\n      return;\n    } else if (t === void 0) {\n      t = performance.now();\n    }\n    (this as Mutable<this>).coherentTime = t;\n    (this as Mutable<this>).decoherent = null;\n    (this as Mutable<this>).recohering = decoherent;\n    try {\n      for (let i = 0; i < decoherent.length; i += 1) {\n        const fastener = decoherent[i]!;\n        fastener.recohere(t);\n      }\n    } finally {\n      (this as Mutable<this>).recohering = null;\n    }\n  }\n\n  /** @internal */\n  readonly observers: ReadonlySet<Observes<this>> | null;\n\n  /** @override */\n  observe(observer: Observes<this>): void {\n    let observers = this.observers as Set<Observes<this>> | null;\n    if (observers === null) {\n      observers = new Set<Observes<this>>();\n      (this as Mutable<this>).observers = observers;\n    } else if (observers.has(observer)) {\n      return;\n    }\n    this.willObserve(observer);\n    observers.add(observer);\n    this.onObserve(observer);\n    this.didObserve(observer);\n  }\n\n  protected willObserve(observer: Observes<this>): void {\n    // hook\n  }\n\n  protected onObserve(observer: Observes<this>): void {\n    // hook\n  }\n\n  protected didObserve(observer: Observes<this>): void {\n    // hook\n  }\n\n  /** @override */\n  unobserve(observer: Observes<this>): void {\n    const observers = this.observers as Set<Observes<this>> | null;\n    if (observers === null || !observers.has(observer)) {\n      return;\n    }\n    this.willUnobserve(observer);\n    observers.delete(observer);\n    this.onUnobserve(observer);\n    this.didUnobserve(observer);\n  }\n\n  protected willUnobserve(observer: Observes<this>): void {\n    // hook\n  }\n\n  protected onUnobserve(observer: Observes<this>): void {\n    // hook\n  }\n\n  protected didUnobserve(observer: Observes<this>): void {\n    // hook\n  }\n\n  callObservers<O, K extends keyof ObserverMethods<O>>(this: {readonly observerType?: Class<O>}, key: K, ...args: ObserverParameters<O, K>): void {\n    const observers = (this as Component).observers as ReadonlySet<ObserverMethods<O>> | null;\n    if (observers === null) {\n      return;\n    }\n    for (const observer of observers) {\n      const method = observer[key];\n      if (typeof method === \"function\") {\n        method.call(observer, ...args);\n      }\n    }\n  }\n\n  /** @override */\n  equals(that: unknown): boolean {\n    return this === that;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Murmur3.mash(Murmur3.mixString(0, this.uid));\n  }\n\n  static create<S extends new () => InstanceType<S>>(this: S): InstanceType<S> {\n    return new this();\n  }\n\n  static fromLike<S extends Class<Instance<S, Component>>>(this: S, value: InstanceType<S> | LikeType<InstanceType<S>>): InstanceType<S> {\n    if (value === void 0 || value === null) {\n      return value as InstanceType<S>;\n    } else if (value instanceof Component) {\n      if (!(value instanceof this)) {\n        throw new TypeError(value + \" not an instance of \" + this);\n      }\n      return value;\n    } else if (Creatable[Symbol.hasInstance](value)) {\n      return (value as Creatable<InstanceType<S>>).create();\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  /** @internal */\n  static uid: () => string = (function () {\n    let nextId = 1;\n    return function uid(): string {\n      const id = ~~nextId;\n      nextId += 1;\n      return \"component\" + id;\n    };\n  })();\n\n  /** @internal */\n  declare static readonly fieldInitializers?: {[name: PropertyKey]: Function[]};\n  /** @internal */\n  declare static readonly instanceInitializers?: Function[];\n\n  /** @internal */\n  static initDecorators(): void {\n    // Ensure each component class has its own metadata and decorator initializer fields.\n    if (!Object.hasOwnProperty.call(this, Symbol.metadata)) {\n      const superMetadata: Record<PropertyKey, unknown> & object /*DecoratorMetadataObject*/ | undefined = Object.getPrototypeOf(this)[Symbol.metadata];\n      Object.defineProperty(this, Symbol.metadata, {\n        value: Object.create(superMetadata !== void 0 ? superMetadata : null),\n        writable: true,\n        enumerable: true,\n        configurable: true,\n      });\n    }\n    if (!Object.hasOwnProperty.call(this, \"fieldInitializers\")) {\n      Object.defineProperty(this, \"fieldInitializers\", {\n        value: {},\n        enumerable: true,\n        configurable: true,\n      });\n    }\n    if (!Object.hasOwnProperty.call(this, \"instanceInitializers\")) {\n      Object.defineProperty(this, \"instanceInitializers\", {\n        value: [],\n        enumerable: true,\n        configurable: true,\n      });\n    }\n  }\n\n  /** @internal */\n  static defineField<S extends Class<Instance<S, Component>>, C extends InstanceType<S>, K extends keyof C>(this: S, name: K, decorators: C[K] extends Fastener<any, any, any> ? FastenerDecorator<C[K]>[] : never): void {\n    const componentClass = this as unknown as typeof Component;\n    componentClass.initDecorators();\n    __esDecorate(null, null, decorators as Function[], {\n      kind: \"field\",\n      name,\n      static: false,\n      private: false,\n      access: {\n        has(obj: C): boolean {\n          return name in obj;\n        },\n        get(obj: C): C[K] {\n          return obj[name];\n        },\n        set(obj: C, value: C[K]): void {\n          obj[name] = value;\n        },\n      },\n      metadata: componentClass[Symbol.metadata],\n    }, componentClass.fieldInitializers![name] = [], componentClass.instanceInitializers!);\n  }\n\n  /** @internal */\n  static defineGetter<S extends Class<Instance<S, Component>>, C extends InstanceType<S>, K extends keyof C>(this: S, name: K, decorators: C[K] extends Fastener<any, any, any> ? FastenerDecorator<C[K]>[] : never): void {\n    const componentClass = this as unknown as typeof Component;\n    componentClass.initDecorators();\n    Object.defineProperty(componentClass.prototype, name, {\n      get: Fastener.getter,\n      enumerable: true,\n      configurable: true,\n    });\n    __esDecorate(componentClass, null, decorators as Function[], {\n      kind: \"getter\",\n      name,\n      static: false,\n      private: false,\n      access: {\n        has(obj: C): boolean {\n          return name in obj;\n        },\n        get(obj: C): C[K] {\n          return obj[name];\n        },\n        set(obj: C, value: C[K]): void {\n          obj[name] = value;\n        },\n      },\n      metadata: componentClass[Symbol.metadata],\n    }, null, componentClass.instanceInitializers!);\n  }\n\n  /** @internal */\n  static initFasteners<S extends Class<Instance<S, Component>>>(this: S, fastener: InstanceType<S>): void {\n    const componentClass = this as unknown as typeof Component;\n    if (!Object.hasOwnProperty.call(componentClass, \"fieldInitializers\")\n        || !Object.hasOwnProperty.call(componentClass, \"instanceInitializers\")) {\n      return;\n    }\n    __runInitializers(fastener, componentClass.instanceInitializers!);\n    for (const key in componentClass.fieldInitializers!) {\n      (fastener as any)[key] = __runInitializers(fastener, componentClass.fieldInitializers[key]!, void 0);\n    }\n  }\n\n  /** @internal */\n  static readonly MountedFlag: ComponentFlags = 1 << 0;\n  /** @internal */\n  static readonly InsertingFlag: ComponentFlags = 1 << 1;\n  /** @internal */\n  static readonly RemovingFlag: ComponentFlags = 1 << 2;\n\n  /** @internal */\n  static readonly FlagShift: number = 3;\n  /** @internal */\n  static readonly FlagMask: ComponentFlags = (1 << this.FlagShift) - 1;\n\n  static readonly MountFlags: ComponentFlags = 0;\n  static readonly InsertChildFlags: ComponentFlags = 0;\n  static readonly RemoveChildFlags: ComponentFlags = 0;\n  static readonly ReinsertChildFlags: ComponentFlags = 0;\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport type {Proto} from \"@swim/util\";\nimport type {LikeType} from \"@swim/util\";\nimport type {Observes} from \"@swim/util\";\nimport type {FastenerDescriptor} from \"./Fastener\";\nimport type {FastenerClass} from \"./Fastener\";\nimport {Fastener} from \"./Fastener\";\nimport type {ComponentFactory} from \"./Component\";\nimport {Component} from \"./Component\";\n\n/** @public */\nexport interface ComponentRelationDescriptor<R, C extends Component<any>> extends FastenerDescriptor<R> {\n  extends?: Proto<ComponentRelation<any, any, any>> | boolean | null;\n}\n\n/** @public */\nexport interface ComponentRelationClass<F extends ComponentRelation<any, any, any> = ComponentRelation> extends FastenerClass<F> {\n}\n\n/** @public */\nexport interface ComponentRelation<R = any, C extends Component<any> = Component, I extends any[] = [C | null]> extends Fastener<R, C | null, I> {\n  /** @override */\n  get descriptorType(): Proto<ComponentRelationDescriptor<R, C>>;\n\n  /** @override */\n  get fastenerType(): Proto<ComponentRelation<any, any, any>>;\n\n  get componentType(): ComponentFactory<C> | null;\n\n  get observes(): boolean;\n\n  /** @override */\n  get parent(): ComponentRelation<any, C, any> | null;\n\n  /** @internal */\n  readonly outlets: ReadonlySet<Fastener<any, any, any>> | null;\n\n  /** @internal @override */\n  attachOutlet(outlet: Fastener<any, any, any>): void;\n\n  /** @internal @override */\n  detachOutlet(outlet: Fastener<any, any, any>): void;\n\n  /** @internal @protected */\n  decohereOutlets(): void;\n\n  /** @protected */\n  initComponent(component: C): void;\n\n  /** @protected */\n  willAttachComponent(component: C, target: Component<any> | null): void;\n\n  /** @protected */\n  onAttachComponent(component: C, target: Component<any> | null): void;\n\n  /** @protected */\n  didAttachComponent(component: C, target: Component<any> | null): void;\n\n  /** @protected */\n  deinitComponent(component: C): void;\n\n  /** @protected */\n  willDetachComponent(component: C): void;\n\n  /** @protected */\n  onDetachComponent(component: C): void;\n\n  /** @protected */\n  didDetachComponent(component: C): void;\n\n  /** @protected */\n  get parentComponent(): Component<any> | null;\n\n  /** @protected */\n  insertChild(parent: Component<any>, child: C, target: Component<any> | null, key: string | undefined): void;\n\n  /** @internal */\n  bindComponent(component: Component<any>, target: Component<any> | null): void;\n\n  /** @internal */\n  unbindComponent(component: Component<any>): void;\n\n  detectComponent(component: Component<any>): C | null;\n\n  createComponent(): C;\n\n  fromLike(value: C | LikeType<C>): C;\n}\n\n/** @public */\nexport const ComponentRelation = (<R, C extends Component<any>, I extends any[], F extends ComponentRelation<any, any, any>>() => Fastener.extend<ComponentRelation<R, C, I>, ComponentRelationClass<F>>(\"ComponentRelation\", {\n  get fastenerType(): Proto<ComponentRelation<any, any, any>> {\n    return ComponentRelation;\n  },\n\n  componentType: null,\n\n  observes: false,\n\n  attachOutlet(outlet: Fastener<any, any, any>): void {\n    let outlets = this.outlets as Set<Fastener<any, any, any>> | null;\n    if (outlets === null) {\n      outlets = new Set<Fastener<any, any, any>>();\n      (this as Mutable<typeof this>).outlets = outlets;\n    }\n    outlets.add(outlet);\n  },\n\n  detachOutlet(outlet: Fastener<any, any, any>): void {\n    const outlets = this.outlets as Set<Fastener<any, any, any>> | null;\n    if (outlets !== null) {\n      outlets.delete(outlet);\n    }\n  },\n\n  decohereOutlets(): void {\n    const outlets = this.outlets;\n    if (outlets !== null) {\n      for (const outlet of outlets) {\n        outlet.decohere(this);\n      }\n    }\n  },\n\n  initComponent(component: C): void {\n    // hook\n  },\n\n  willAttachComponent(component: C, target: Component<any> | null): void {\n    // hook\n  },\n\n  onAttachComponent(component: C, target: Component<any> | null): void {\n    if (this.observes) {\n      component.observe(this as Observes<C>);\n    }\n  },\n\n  didAttachComponent(component: C, target: Component<any> | null): void {\n    // hook\n  },\n\n  deinitComponent(component: C): void {\n    // hook\n  },\n\n  willDetachComponent(component: C): void {\n    // hook\n  },\n\n  onDetachComponent(component: C): void {\n    if (this.observes) {\n      component.unobserve(this as Observes<C>);\n    }\n  },\n\n  didDetachComponent(component: C): void {\n    // hook\n  },\n\n  get parentComponent(): Component<any> | null {\n    const owner = this.owner;\n    return owner instanceof Component ? owner : null;\n  },\n\n  insertChild(parent: Component<any>, child: C, target: Component<any> | null, key: string | undefined): void {\n    parent.insertChild(child, target, key);\n  },\n\n  bindComponent(component: Component<any>, target: Component<any> | null): void {\n    // hook\n  },\n\n  unbindComponent(component: Component<any>): void {\n    // hook\n  },\n\n  detectComponent(component: Component<any>): C | null {\n    return null;\n  },\n\n  createComponent(): C {\n    let component: C | undefined;\n    const componentType = this.componentType;\n    if (componentType !== null) {\n      component = componentType.create();\n    }\n    if (component === void 0 || component === null) {\n      let message = \"unable to create \";\n      const name = this.name.toString();\n      if (name.length !== 0) {\n        message += name + \" \";\n      }\n      message += \"component\";\n      throw new Error(message);\n    }\n    return component;\n  },\n\n  fromLike(value: C | LikeType<C>): C {\n    const componentType = this.componentType;\n    if (componentType !== null) {\n      return componentType.fromLike(value);\n    }\n    return Component.fromLike(value) as C;\n  },\n},\n{\n  construct(fastener: F | null, owner: F extends Fastener<infer R, any, any> ? R : never): F {\n    fastener = super.construct(fastener, owner) as F;\n    (fastener as Mutable<typeof fastener>).outlets = null;\n    return fastener;\n  },\n}))();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport type {Proto} from \"@swim/util\";\nimport type {LikeType} from \"@swim/util\";\nimport {Affinity} from \"./Affinity\";\nimport {FastenerContext} from \"./FastenerContext\";\nimport type {FastenerClass} from \"./Fastener\";\nimport {Fastener} from \"./Fastener\";\nimport type {Component} from \"./Component\";\nimport type {ComponentRelationDescriptor} from \"./ComponentRelation\";\nimport type {ComponentRelationClass} from \"./ComponentRelation\";\nimport {ComponentRelation} from \"./ComponentRelation\";\n\n/** @public */\nexport interface ComponentRefDescriptor<R, C extends Component<any>> extends ComponentRelationDescriptor<R, C> {\n  extends?: Proto<ComponentRef<any, any, any>> | boolean | null;\n  componentKey?: string | boolean;\n}\n\n/** @public */\nexport interface ComponentRefClass<F extends ComponentRef<any, any, any> = ComponentRef> extends ComponentRelationClass<F> {\n  tryComponent<R, K extends keyof R, F extends R[K] = R[K]>(owner: R, fastenerName: K): (F extends {readonly component: infer C | null} ? C | null : never) | null;\n}\n\n/** @public */\nexport interface ComponentRef<R = any, C extends Component<any> = Component, I extends any[] = [C | null]> extends ComponentRelation<R, C, I> {\n  /** @override */\n  get descriptorType(): Proto<ComponentRefDescriptor<R, C>>;\n\n  /** @override */\n  get fastenerType(): Proto<ComponentRef<any, any, any>>;\n\n  /** @override */\n  get parent(): ComponentRef<any, C, any> | null;\n\n  get inletComponent(): C | null;\n\n  getInletComponent(): C;\n\n  get(): C | null;\n\n  set(component: C | LikeType<C> | Fastener<any, I[0], any> | null): R;\n\n  setIntrinsic(component: C | LikeType<C> | Fastener<any, I[0], any> | null): R;\n\n  get componentKey(): string | undefined;\n\n  readonly component: C | null;\n\n  getComponent(): C;\n\n  setComponent(component: C | LikeType<C> | null, target?: Component<any> | null, key?: string): C | null;\n\n  attachComponent(component?: C | LikeType<C> | null, target?: Component<any> | null): C;\n\n  detachComponent(): C | null;\n\n  insertComponent(parent?: Component<any> | null, component?: C | LikeType<C>, target?: Component<any> | null, key?: string): C;\n\n  removeComponent(): C | null;\n\n  deleteComponent(): C | null;\n\n  /** @internal @override */\n  bindComponent(component: Component<any>, target: Component<any> | null): void;\n\n  /** @internal @override */\n  unbindComponent(component: Component<any>): void;\n\n  /** @override */\n  detectComponent(component: Component<any>): C | null;\n\n  /** @override */\n  recohere(t: number): void;\n}\n\n/** @public */\nexport const ComponentRef = (<R, C extends Component<any>, I extends any[], F extends ComponentRef<any, any, any>>() => ComponentRelation.extend<ComponentRef<R, C, I>, ComponentRefClass<F>>(\"ComponentRef\", {\n  get fastenerType(): Proto<ComponentRef<any, any, any>> {\n    return ComponentRef;\n  },\n\n  get inletComponent(): C | null {\n    const inlet = this.inlet;\n    return inlet instanceof ComponentRef ? inlet.component : null;\n  },\n\n  getInletComponent(): C {\n    const inletComponent = this.inletComponent;\n    if (inletComponent === void 0 || inletComponent === null) {\n      let message = inletComponent + \" \";\n      const name = this.name.toString();\n      if (name.length !== 0) {\n        message += name + \" \";\n      }\n      message += \"inlet component\";\n      throw new TypeError(message);\n    }\n    return inletComponent;\n  },\n\n  get(): C | null {\n    return this.component;\n  },\n\n  set(component: C | LikeType<C> | Fastener<any, I[0], any> | null): R {\n    if (component instanceof Fastener) {\n      this.bindInlet(component);\n    } else {\n      this.setComponent(component);\n    }\n    return this.owner;\n  },\n\n  setIntrinsic(component: C | LikeType<C> | Fastener<any, I[0], any> | null): R {\n    if (component instanceof Fastener) {\n      this.bindInlet(component);\n    } else {\n      this.setComponent(component);\n    }\n    return this.owner;\n  },\n\n  componentKey: void 0,\n\n  getComponent(): C {\n    const component = this.component;\n    if (component === null) {\n      let message = component + \" \";\n      const name = this.name.toString();\n      if (name.length !== 0) {\n        message += name + \" \";\n      }\n      message += \"component\";\n      throw new TypeError(message);\n    }\n    return component;\n  },\n\n  setComponent(newComponent: C  | null, target?: Component<any> | null, key?: string): C | null {\n    if (newComponent !== null) {\n      newComponent = this.fromLike(newComponent);\n    }\n    let oldComponent = this.component;\n    if (oldComponent === newComponent) {\n      this.setCoherent(true);\n      return oldComponent;\n    } else if (target === void 0) {\n      target = null;\n    }\n    let parent: Component<any> | null;\n    if (this.binds && (parent = this.parentComponent, parent !== null)) {\n      if (oldComponent !== null && oldComponent.parent === parent) {\n        if (target === null) {\n          target = oldComponent.nextSibling as Component<any> | null;\n        }\n        oldComponent.remove();\n      }\n      if (newComponent !== null) {\n        if (key === void 0) {\n          key = this.componentKey;\n        }\n        this.insertChild(parent, newComponent, target, key);\n      }\n      oldComponent = this.component;\n      if (oldComponent === newComponent) {\n        return oldComponent;\n      }\n    }\n    if (oldComponent !== null) {\n      (this as Mutable<typeof this>).component = null;\n      this.willDetachComponent(oldComponent);\n      this.onDetachComponent(oldComponent);\n      this.deinitComponent(oldComponent);\n      this.didDetachComponent(oldComponent);\n    }\n    if (newComponent !== null) {\n      (this as Mutable<typeof this>).component = newComponent;\n      this.willAttachComponent(newComponent, target);\n      this.onAttachComponent(newComponent, target);\n      this.initComponent(newComponent);\n      this.didAttachComponent(newComponent, target);\n    }\n    this.setCoherent(true);\n    this.decohereOutlets();\n    return oldComponent;\n  },\n\n  attachComponent(newComponent?: C | LikeType<C>, target?: Component<any> | null): C {\n    const oldComponent = this.component;\n    if (newComponent !== void 0 && newComponent !== null) {\n      newComponent = this.fromLike(newComponent);\n    } else if (oldComponent === null) {\n      newComponent = this.createComponent();\n    } else {\n      newComponent = oldComponent;\n    }\n    if (target === void 0) {\n      target = null;\n    }\n    if (oldComponent === newComponent) {\n      return newComponent;\n    } else if (oldComponent !== null) {\n      (this as Mutable<typeof this>).component = null;\n      this.willDetachComponent(oldComponent);\n      this.onDetachComponent(oldComponent);\n      this.deinitComponent(oldComponent);\n      this.didDetachComponent(oldComponent);\n    }\n    (this as Mutable<typeof this>).component = newComponent;\n    this.willAttachComponent(newComponent, target);\n    this.onAttachComponent(newComponent, target);\n    this.initComponent(newComponent);\n    this.didAttachComponent(newComponent, target);\n    this.setCoherent(true);\n    this.decohereOutlets();\n    return newComponent;\n  },\n\n  detachComponent(): C | null {\n    const oldComponent = this.component;\n    if (oldComponent === null) {\n      return null;\n    }\n    (this as Mutable<typeof this>).component = null;\n    this.willDetachComponent(oldComponent);\n    this.onDetachComponent(oldComponent);\n    this.deinitComponent(oldComponent);\n    this.didDetachComponent(oldComponent);\n    this.setCoherent(true);\n    this.decohereOutlets();\n    return oldComponent;\n  },\n\n  insertComponent(parent?: Component<any> | null, newComponent?: C | LikeType<C>, target?: Component<any> | null, key?: string): C {\n    let oldComponent = this.component;\n    if (newComponent !== void 0 && newComponent !== null) {\n      newComponent = this.fromLike(newComponent);\n    } else if (oldComponent === null) {\n      newComponent = this.createComponent();\n    } else {\n      newComponent = oldComponent;\n    }\n    if (parent === void 0) {\n      parent = null;\n    }\n    if (!this.binds && oldComponent === newComponent && newComponent.parent !== null && parent === null && key === void 0) {\n      return newComponent;\n    }\n    if (parent === null) {\n      parent = this.parentComponent;\n    }\n    if (target === void 0) {\n      target = null;\n    }\n    if (key === void 0) {\n      key = this.componentKey;\n    }\n    if (parent !== null && (newComponent.parent !== parent || newComponent.key !== key)) {\n      this.insertChild(parent, newComponent, target, key);\n    }\n    oldComponent = this.component;\n    if (oldComponent === newComponent) {\n      return newComponent;\n    } else if (oldComponent !== null) {\n      (this as Mutable<typeof this>).component = null;\n      this.willDetachComponent(oldComponent);\n      this.onDetachComponent(oldComponent);\n      this.deinitComponent(oldComponent);\n      this.didDetachComponent(oldComponent);\n      if (this.binds && parent !== null && oldComponent.parent === parent) {\n        oldComponent.remove();\n      }\n    }\n    (this as Mutable<typeof this>).component = newComponent;\n    this.willAttachComponent(newComponent, target);\n    this.onAttachComponent(newComponent, target);\n    this.initComponent(newComponent);\n    this.didAttachComponent(newComponent, target);\n    this.setCoherent(true);\n    this.decohereOutlets();\n    return newComponent;\n  },\n\n  removeComponent(): C | null {\n    const component = this.component;\n    if (component === null) {\n      return null;\n    }\n    component.remove();\n    return component;\n  },\n\n  deleteComponent(): C | null {\n    const component = this.detachComponent();\n    if (component === null) {\n      return null;\n    }\n    component.remove();\n    return component;\n  },\n\n  bindComponent(component: Component<any>, target: Component<any> | null): void {\n    if (!this.binds || this.component !== null) {\n      return;\n    }\n    const newComponent = this.detectComponent(component);\n    if (newComponent === null) {\n      return;\n    }\n    (this as Mutable<typeof this>).component = newComponent;\n    this.willAttachComponent(newComponent, target);\n    this.onAttachComponent(newComponent, target);\n    this.initComponent(newComponent);\n    this.didAttachComponent(newComponent, target);\n    this.setCoherent(true);\n    this.decohereOutlets();\n  },\n\n  unbindComponent(component: Component<any>): void {\n    if (!this.binds) {\n      return;\n    }\n    const oldComponent = this.detectComponent(component);\n    if (oldComponent === null || this.component !== oldComponent) {\n      return;\n    }\n    (this as Mutable<typeof this>).component = null;\n    this.willDetachComponent(oldComponent);\n    this.onDetachComponent(oldComponent);\n    this.deinitComponent(oldComponent);\n    this.didDetachComponent(oldComponent);\n    this.setCoherent(true);\n    this.decohereOutlets();\n  },\n\n  detectComponent(component: Component<any>): C | null {\n    const key = this.componentKey;\n    if (key !== void 0 && key === component.key) {\n      return component as C;\n    }\n    return null;\n  },\n\n  recohere(t: number): void {\n    this.setCoherentTime(t);\n    const inlet = this.inlet;\n    if (inlet instanceof ComponentRef) {\n      this.setDerived((this.flags & Affinity.Mask) <= Math.min(inlet.flags & Affinity.Mask, Affinity.Intrinsic));\n      if ((this.flags & Fastener.DerivedFlag) !== 0) {\n        this.setComponent(inlet.component);\n      }\n    } else {\n      this.setDerived(false);\n    }\n  },\n},\n{\n  tryComponent<R, K extends keyof R, F extends R[K]>(owner: R, fastenerName: K): (F extends {readonly component: infer C | null} ? C | null : never) | null {\n    const metaclass = FastenerContext.getMetaclass(owner);\n    const componentRef = metaclass !== null ? metaclass.tryFastener(owner, fastenerName) : null;\n    return componentRef instanceof ComponentRef ? componentRef.component : null;\n  },\n\n  construct(fastener: F | null, owner: F extends Fastener<infer R, any, any> ? R : never): F {\n    fastener = super.construct(fastener, owner) as F;\n    (fastener as Mutable<typeof fastener>).component = null;\n    return fastener;\n  },\n\n  refine(fastenerClass: FastenerClass<ComponentRef<any, any, any>>): void {\n    super.refine(fastenerClass);\n    const fastenerPrototype = fastenerClass.prototype;\n\n    const componentKeyDescriptor = Object.getOwnPropertyDescriptor(fastenerPrototype, \"componentKey\");\n    if (componentKeyDescriptor !== void 0 && \"value\" in componentKeyDescriptor) {\n      if (componentKeyDescriptor.value === true) {\n        componentKeyDescriptor.value = fastenerClass.name;\n        Object.defineProperty(fastenerPrototype, \"componentKey\", componentKeyDescriptor);\n      } else if (componentKeyDescriptor.value === false) {\n        componentKeyDescriptor.value = void 0;\n        Object.defineProperty(fastenerPrototype, \"componentKey\", componentKeyDescriptor);\n      }\n    }\n  },\n}))();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport type {Proto} from \"@swim/util\";\nimport type {Comparator} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport type {LikeType} from \"@swim/util\";\nimport {Affinity} from \"./Affinity\";\nimport type {FastenerFlags} from \"./Fastener\";\nimport type {FastenerClass} from \"./Fastener\";\nimport {Fastener} from \"./Fastener\";\nimport type {Component} from \"./Component\";\nimport type {ComponentRelationDescriptor} from \"./ComponentRelation\";\nimport type {ComponentRelationClass} from \"./ComponentRelation\";\nimport {ComponentRelation} from \"./ComponentRelation\";\n\n/** @public */\nexport interface ComponentSetDescriptor<R, C extends Component<any>> extends ComponentRelationDescriptor<R, C> {\n  extends?: Proto<ComponentSet<any, any, any>> | boolean | null;\n  ordered?: boolean;\n  sorted?: boolean;\n}\n\n/** @public */\nexport interface ComponentSetClass<F extends ComponentSet<any, any, any> = ComponentSet> extends ComponentRelationClass<F> {\n  /** @internal */\n  readonly OrderedFlag: FastenerFlags;\n  /** @internal */\n  readonly SortedFlag: FastenerFlags;\n\n  /** @internal @override */\n  readonly FlagShift: number;\n  /** @internal @override */\n  readonly FlagMask: FastenerFlags;\n}\n\n/** @public */\nexport interface ComponentSet<R = any, C extends Component<any> = Component, I extends any[] = [C | null]> extends ComponentRelation<R, C, I> {\n  /** @override */\n  get descriptorType(): Proto<ComponentSetDescriptor<R, C>>;\n\n  /** @override */\n  get fastenerType(): Proto<ComponentSet<any, any, any>>;\n\n  /** @override */\n  get parent(): ComponentSet<any, C, any> | null;\n\n  /** @protected */\n  componentKey(component: C): string | undefined;\n\n  /** @internal */\n  readonly components: {readonly [componentId: string]: C | undefined};\n\n  readonly componentCount: number;\n\n  /** @internal */\n  insertComponentMap(newComponent: C, target: Component<any> | null): void;\n\n  /** @internal */\n  removeComponentMap(oldComponent: C): void;\n\n  hasComponent(component: Component<any>): boolean;\n\n  addComponent(component?: C | LikeType<C>, target?: Component<any> | null, key?: string): C;\n\n  addComponents(components: {readonly [componentId: string]: C | undefined}, target?: Component<any> | null): void;\n\n  setComponents(components: {readonly [componentId: string]: C | undefined}, target?: Component<any> | null): void;\n\n  attachComponent(component?: C | LikeType<C> | null, target?: Component<any> | null): C;\n\n  attachComponents(components: {readonly [componentId: string]: C | undefined}, target?: Component<any> | null): void;\n\n  detachComponent(component: C): C | null;\n\n  detachComponents(components?: {readonly [componentId: string]: C | undefined}): void;\n\n  insertComponent(parent?: Component<any> | null, component?: C | LikeType<C>, target?: Component<any> | null, key?: string): C;\n\n  insertComponents(parent: Component<any> | null, components: {readonly [componentId: string]: C | undefined}, target?: Component<any> | null): void;\n\n  removeComponent(component: C): C | null;\n\n  removeComponents(components?: {readonly [componentId: string]: C | undefined}): void;\n\n  deleteComponent(component: C): C | null;\n\n  deleteComponents(components?: {readonly [componentId: string]: C | undefined}): void;\n\n  reinsertComponent(component: C, target?: Component<any> | null): void;\n\n  /** @internal @override */\n  bindComponent(component: Component<any>, target: Component<any> | null): void;\n\n  /** @internal @override */\n  unbindComponent(component: Component<any>): void;\n\n  /** @override */\n  detectComponent(component: Component<any>): C | null;\n\n  /** @override */\n  recohere(t: number): void;\n\n  get ordered(): boolean;\n\n  order(ordered?: boolean): this;\n\n  get sorted(): boolean;\n\n  sort(sorted?: boolean): this;\n\n  /** @protected */\n  willSort(parent: Component<any> | null): void;\n\n  /** @protected */\n  onSort(parent: Component<any> | null): void;\n\n  /** @protected */\n  didSort(parent: Component<any> | null): void;\n\n  /** @internal */\n  sortChildren(parent: Component<any>, comparator?: Comparator<C>): void;\n\n  /** @internal */\n  getTargetChild(parent: Component<any>, child: C): Component<any> | null;\n\n  /** @internal */\n  compareChildren(a: Component<any>, b: Component<any>): number;\n\n  /** @internal */\n  compareTargetChild(a: Component<any>, b: Component<any>): number;\n\n  /** @protected */\n  compare(a: C, b: C): number;\n}\n\n/** @public */\nexport const ComponentSet = (<R, C extends Component<any>, I extends any[], F extends ComponentSet<any, any, any>>() => ComponentRelation.extend<ComponentSet<R, C, I>, ComponentSetClass<F>>(\"ComponentSet\", {\n  get fastenerType(): Proto<ComponentSet<any, any, any>> {\n    return ComponentSet;\n  },\n\n  componentKey(component: C): string | undefined {\n    return void 0;\n  },\n\n  insertComponentMap(newComponent: C, target: Component<any> | null): void {\n    const components = this.components as {[componentId: string]: C | undefined};\n    if (target !== null && (this.flags & ComponentSet.OrderedFlag) !== 0) {\n      (this as Mutable<typeof this>).components = Objects.inserted(components, newComponent.uid, newComponent, target);\n    } else {\n      components[newComponent.uid] = newComponent;\n    }\n  },\n\n  removeComponentMap(oldComponent: C): void {\n    const components = this.components as {[componentId: string]: C | undefined};\n    delete components[oldComponent.uid];\n  },\n\n  hasComponent(component: Component<any>): boolean {\n    return this.components[component.uid] !== void 0;\n  },\n\n  addComponent(newComponent?: C | LikeType<C>, target?: Component<any> | null, key?: string): C {\n    if (newComponent !== void 0 && newComponent !== null) {\n      newComponent = this.fromLike(newComponent);\n    } else {\n      newComponent = this.createComponent();\n    }\n    if (target === void 0) {\n      target = null;\n    }\n    let parent: Component<any> | null;\n    if (this.binds && (parent = this.parentComponent, parent !== null)) {\n      if (target === null) {\n        if (newComponent.parent === parent) {\n          target = newComponent.nextSibling as Component<any> | null;\n        } else {\n          target = this.getTargetChild(parent, newComponent);\n        }\n      }\n      if (key === void 0) {\n        key = this.componentKey(newComponent);\n      }\n      if (newComponent.parent !== parent || newComponent.nextSibling !== target || newComponent.key !== key) {\n        this.insertChild(parent, newComponent, target, key);\n      }\n    }\n    if (this.components[newComponent.uid] !== void 0) {\n      return newComponent;\n    }\n    this.insertComponentMap(newComponent, target);\n    (this as Mutable<typeof this>).componentCount += 1;\n    this.willAttachComponent(newComponent, target);\n    this.onAttachComponent(newComponent, target);\n    this.initComponent(newComponent);\n    this.didAttachComponent(newComponent, target);\n    this.setCoherent(true);\n    this.decohereOutlets();\n    return newComponent;\n  },\n\n  addComponents(newComponents: {readonly [componentId: string]: C | undefined}, target?: Component<any> | null): void {\n    for (const componentId in newComponents) {\n      this.addComponent(newComponents[componentId]!, target);\n    }\n  },\n\n  setComponents(newComponents: {readonly [componentId: string]: C | undefined}, target?: Component<any> | null): void {\n    const binds = this.binds;\n    const parent = binds ? this.parentComponent : null;\n    const components = this.components;\n    for (const componentId in components) {\n      if (newComponents[componentId] === void 0) {\n        const oldComponent = this.detachComponent(components[componentId]!);\n        if (oldComponent !== null && binds && parent !== null && oldComponent.parent === parent) {\n          oldComponent.remove();\n        }\n      }\n    }\n    if ((this.flags & ComponentSet.OrderedFlag) !== 0) {\n      const orderedComponents = new Array<C>();\n      for (const componentId in newComponents) {\n        orderedComponents.push(newComponents[componentId]!);\n      }\n      for (let i = 0, n = orderedComponents.length; i < n; i += 1) {\n        const newComponent = orderedComponents[i]!;\n        if (components[newComponent.uid] === void 0) {\n          const targetComponent = i < n + 1 ? orderedComponents[i + 1] : target;\n          this.addComponent(newComponent, targetComponent);\n        }\n      }\n    } else {\n      for (const componentId in newComponents) {\n        if (components[componentId] === void 0) {\n          this.addComponent(newComponents[componentId]!, target);\n        }\n      }\n    }\n  },\n\n  attachComponent(newComponent?: C | LikeType<C> | null, target?: Component<any> | null): C {\n    if (newComponent !== void 0 && newComponent !== null) {\n      newComponent = this.fromLike(newComponent);\n    } else {\n      newComponent = this.createComponent();\n    }\n    if (this.components[newComponent.uid] !== void 0) {\n      return newComponent;\n    } else if (target === void 0) {\n      target = null;\n    }\n    this.insertComponentMap(newComponent, target);\n    (this as Mutable<typeof this>).componentCount += 1;\n    this.willAttachComponent(newComponent, target);\n    this.onAttachComponent(newComponent, target);\n    this.initComponent(newComponent);\n    this.didAttachComponent(newComponent, target);\n    this.setCoherent(true);\n    this.decohereOutlets();\n    return newComponent;\n  },\n\n  attachComponents(newComponents: {readonly [componentId: string]: C | undefined}, target?: Component<any> | null): void {\n    for (const componentId in newComponents) {\n      this.attachComponent(newComponents[componentId]!, target);\n    }\n  },\n\n  detachComponent(oldComponent: C): C | null {\n    if (this.components[oldComponent.uid] === void 0) {\n      return null;\n    }\n    (this as Mutable<typeof this>).componentCount -= 1;\n    this.removeComponentMap(oldComponent);\n    this.willDetachComponent(oldComponent);\n    this.onDetachComponent(oldComponent);\n    this.deinitComponent(oldComponent);\n    this.didDetachComponent(oldComponent);\n    this.setCoherent(true);\n    this.decohereOutlets();\n    return oldComponent;\n  },\n\n  detachComponents(components?: {readonly [componentId: string]: C | undefined}): void {\n    if (components === void 0) {\n      components = this.components;\n    }\n    for (const componentId in components) {\n      this.detachComponent(components[componentId]!);\n    }\n  },\n\n  insertComponent(parent?: Component<any> | null, newComponent?: C | LikeType<C>, target?: Component<any> | null, key?: string): C {\n    if (newComponent !== void 0 && newComponent !== null) {\n      newComponent = this.fromLike(newComponent);\n    } else {\n      newComponent = this.createComponent();\n    }\n    if (parent === void 0) {\n      parent = null;\n    }\n    if (!this.binds && this.components[newComponent.uid] !== void 0 && newComponent.parent !== null && parent === null && key === void 0) {\n      return newComponent;\n    }\n    if (parent === null) {\n      parent = this.parentComponent;\n    }\n    if (target === void 0) {\n      target = null;\n    }\n    if (key === void 0) {\n      key = this.componentKey(newComponent);\n    }\n    if (parent !== null && (newComponent.parent !== parent || newComponent.key !== key)) {\n      if (target === null) {\n        target = this.getTargetChild(parent, newComponent);\n      }\n      this.insertChild(parent, newComponent, target, key);\n    }\n    if (this.components[newComponent.uid] !== void 0) {\n      return newComponent;\n    }\n    this.insertComponentMap(newComponent, target);\n    (this as Mutable<typeof this>).componentCount += 1;\n    this.willAttachComponent(newComponent, target);\n    this.onAttachComponent(newComponent, target);\n    this.initComponent(newComponent);\n    this.didAttachComponent(newComponent, target);\n    this.setCoherent(true);\n    this.decohereOutlets();\n    return newComponent;\n  },\n\n  insertComponents(parent: Component<any> | null, newComponents: {readonly [componentId: string]: C | undefined}, target?: Component<any> | null): void {\n    for (const componentId in newComponents) {\n      this.insertComponent(parent, newComponents[componentId]!, target);\n    }\n  },\n\n  removeComponent(component: C): C | null {\n    if (!this.hasComponent(component)) {\n      return null;\n    }\n    component.remove();\n    return component;\n  },\n\n  removeComponents(components?: {readonly [componentId: string]: C | undefined}): void {\n    if (components === void 0) {\n      components = this.components;\n    }\n    for (const componentId in components) {\n      this.removeComponent(components[componentId]!);\n    }\n  },\n\n  deleteComponent(component: C): C | null {\n    const oldComponent = this.detachComponent(component);\n    if (oldComponent === null) {\n      return null;\n    }\n    oldComponent.remove();\n    return oldComponent;\n  },\n\n  deleteComponents(components?: {readonly [componentId: string]: C | undefined}): void {\n    if (components === void 0) {\n      components = this.components;\n    }\n    for (const componentId in components) {\n      this.deleteComponent(components[componentId]!);\n    }\n  },\n\n  reinsertComponent(component: C, target?: Component<any> | null): void {\n    if (this.components[component.uid] === void 0 || (target === void 0 && (this.flags & ComponentSet.SortedFlag) === 0)) {\n      return;\n    }\n    const parent = component.parent;\n    if (parent === null) {\n      return;\n    } else if (target === void 0) {\n      target = this.getTargetChild(parent, component);\n    }\n    parent.reinsertChild(component, target);\n  },\n\n  bindComponent(component: Component<any>, target: Component<any> | null): void {\n    if (!this.binds) {\n      return;\n    }\n    const newComponent = this.detectComponent(component);\n    if (newComponent === null || this.components[newComponent.uid] !== void 0) {\n      return;\n    }\n    this.insertComponentMap(newComponent, target);\n    (this as Mutable<typeof this>).componentCount += 1;\n    this.willAttachComponent(newComponent, target);\n    this.onAttachComponent(newComponent, target);\n    this.initComponent(newComponent);\n    this.didAttachComponent(newComponent, target);\n    this.setCoherent(true);\n    this.decohereOutlets();\n  },\n\n  unbindComponent(component: Component<any>): void {\n    if (!this.binds) {\n      return;\n    }\n    const oldComponent = this.detectComponent(component);\n    if (oldComponent === null || this.components[oldComponent.uid] === void 0) {\n      return;\n    }\n    (this as Mutable<typeof this>).componentCount -= 1;\n    this.removeComponentMap(oldComponent);\n    this.willDetachComponent(oldComponent);\n    this.onDetachComponent(oldComponent);\n    this.deinitComponent(oldComponent);\n    this.didDetachComponent(oldComponent);\n    this.setCoherent(true);\n    this.decohereOutlets();\n  },\n\n  detectComponent(component: Component<any>): C | null {\n    if (typeof this.componentType === \"function\" && component instanceof this.componentType) {\n      return component as C;\n    }\n    return null;\n  },\n\n  recohere(t: number): void {\n    this.setCoherentTime(t);\n    const inlet = this.inlet;\n    if (inlet instanceof ComponentSet) {\n      this.setDerived((this.flags & Affinity.Mask) <= Math.min(inlet.flags & Affinity.Mask, Affinity.Intrinsic));\n      if ((this.flags & Fastener.DerivedFlag) !== 0) {\n        this.setComponents(inlet.components);\n      }\n    } else {\n      this.setDerived(false);\n    }\n  },\n\n  get ordered(): boolean {\n    return (this.flags & ComponentSet.OrderedFlag) !== 0;\n  },\n\n  order(ordered?: boolean): typeof this {\n    if (ordered === void 0) {\n      ordered = true;\n    }\n    if (ordered) {\n      this.setFlags(this.flags | ComponentSet.OrderedFlag);\n    } else {\n      this.setFlags(this.flags & ~ComponentSet.OrderedFlag);\n    }\n    return this;\n  },\n\n  get sorted(): boolean {\n    return (this.flags & ComponentSet.SortedFlag) !== 0;\n  },\n\n  sort(sorted?: boolean): typeof this {\n    if (sorted === void 0) {\n      sorted = true;\n    }\n    if (sorted) {\n      const parent = this.parentComponent;\n      this.willSort(parent);\n      this.setFlags(this.flags | ComponentSet.SortedFlag);\n      this.onSort(parent);\n      this.didSort(parent);\n    } else {\n      this.setFlags(this.flags & ~ComponentSet.SortedFlag);\n    }\n    return this;\n  },\n\n  willSort(parent: Component<any> | null): void {\n    // hook\n  },\n\n  onSort(parent: Component<any> | null): void {\n    if (parent !== null) {\n      this.sortChildren(parent);\n    }\n  },\n\n  didSort(parent: Component<any> | null): void {\n    // hook\n  },\n\n  sortChildren(parent: Component<any>, comparator?: Comparator<C>): void {\n    parent.sortChildren(this.compareChildren.bind(this));\n  },\n\n  getTargetChild(parent: Component<any>, child: C): Component<any> | null {\n    if ((this.flags & ComponentSet.SortedFlag) !== 0) {\n      return parent.getTargetChild(child, this.compareTargetChild.bind(this));\n    }\n    return null;\n  },\n\n  compareChildren(a: Component<any>, b: Component<any>): number {\n    const components = this.components;\n    const x = components[a.uid];\n    const y = components[b.uid];\n    if (x !== void 0 && y !== void 0) {\n      return this.compare(x, y);\n    }\n    return x !== void 0 ? 1 : y !== void 0 ? -1 : 0;\n  },\n\n  compareTargetChild(a: C, b: Component<any>): number {\n    const components = this.components;\n    const y = components[b.uid];\n    if (y !== void 0) {\n      return this.compare(a, y);\n    }\n    return y !== void 0 ? -1 : 0;\n  },\n\n  compare(a: C, b: C): number {\n    return a.uid < b.uid ? -1 : a.uid > b.uid ? 1 : 0;\n  },\n},\n{\n  construct(fastener: F | null, owner: F extends Fastener<infer R, any, any> ? R : never): F {\n    fastener = super.construct(fastener, owner) as F;\n    (fastener as Mutable<typeof fastener>).components = {};\n    (fastener as Mutable<typeof fastener>).componentCount = 0;\n    return fastener;\n  },\n\n  refine(fastenerClass: FastenerClass<ComponentSet<any, any, any>>): void {\n    super.refine(fastenerClass);\n    const fastenerPrototype = fastenerClass.prototype;\n\n    let flagsInit = fastenerPrototype.flagsInit;\n    if (Object.prototype.hasOwnProperty.call(fastenerPrototype, \"ordered\")) {\n      if (fastenerPrototype.ordered) {\n        flagsInit |= ComponentSet.OrderedFlag;\n      } else {\n        flagsInit &= ~ComponentSet.OrderedFlag;\n      }\n      delete (fastenerPrototype as ComponentSetDescriptor<any, any>).ordered;\n    }\n    if (Object.prototype.hasOwnProperty.call(fastenerPrototype, \"sorted\")) {\n      if (fastenerPrototype.sorted) {\n        flagsInit |= ComponentSet.SortedFlag;\n      } else {\n        flagsInit &= ~ComponentSet.SortedFlag;\n      }\n      delete (fastenerPrototype as ComponentSetDescriptor<any, any>).sorted;\n    }\n    Object.defineProperty(fastenerPrototype, \"flagsInit\", {\n      value: flagsInit,\n      enumerable: true,\n      configurable: true,\n    });\n  },\n\n  OrderedFlag: 1 << (ComponentRelation.FlagShift + 0),\n  SortedFlag: 1 << (ComponentRelation.FlagShift + 1),\n\n  FlagShift: ComponentRelation.FlagShift + 2,\n  FlagMask: (1 << (ComponentRelation.FlagShift + 2)) - 1,\n}))();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Class} from \"@swim/util\";\nimport type {Creatable} from \"@swim/util\";\nimport type {ComponentObserver} from \"./Component\";\nimport {Component} from \"./Component\";\n\n/** @public */\nexport interface ServiceFactory<S extends Service = Service> extends Creatable<S> {\n  global(): S;\n}\n\n/** @public */\nexport interface ServiceClass<S extends Service = Service> extends Function, ServiceFactory<S> {\n  readonly prototype: S;\n}\n\n/** @public */\nexport interface ServiceConstructor<S extends Service = Service> extends ServiceClass<S> {\n  new(): S;\n}\n\n/** @public */\nexport interface ServiceObserver<S extends Service = Service> extends ComponentObserver<S> {\n  serviceWillAttachParent?(parent: Service, service: S): void;\n\n  serviceDidAttachParent?(parent: Service, service: S): void;\n\n  serviceWillDetachParent?(parent: Service, service: S): void;\n\n  serviceDidDetachParent?(parent: Service, service: S): void;\n\n  serviceWillInsertChild?(child: Service, target: Service | null, service: S): void;\n\n  serviceDidInsertChild?(child: Service, target: Service | null, service: S): void;\n\n  serviceWillRemoveChild?(child: Service, service: S): void;\n\n  serviceDidRemoveChild?(child: Service, service: S): void;\n\n  serviceWillReinsertChild?(child: Service, target: Service | null, service: S): void;\n\n  serviceDidReinsertChild?(child: Service, target: Service | null, service: S): void;\n\n  serviceWillMount?(service: S): void;\n\n  serviceDidMount?(service: S): void;\n\n  serviceWillUnmount?(service: S): void;\n\n  serviceDidUnmount?(service: S): void;\n}\n\n/** @public */\nexport class Service extends Component<Service> {\n  override get componentType(): Class<Service> {\n    return Service;\n  }\n\n  declare readonly observerType?: Class<ServiceObserver>;\n\n  protected override willAttachParent(parent: Service): void {\n    this.callObservers(\"serviceWillAttachParent\", parent, this);\n  }\n\n  protected override onAttachParent(parent: Service): void {\n    // hook\n  }\n\n  protected override didAttachParent(parent: Service): void {\n    this.callObservers(\"serviceDidAttachParent\", parent, this);\n  }\n\n  protected override willDetachParent(parent: Service): void {\n    this.callObservers(\"serviceWillDetachParent\", parent, this);\n  }\n\n  protected override onDetachParent(parent: Service): void {\n    // hook\n  }\n\n  protected override didDetachParent(parent: Service): void {\n    this.callObservers(\"serviceDidDetachParent\", parent, this);\n  }\n\n  protected override willInsertChild(child: Service, target: Service | null): void {\n    super.willInsertChild(child, target);\n    this.callObservers(\"serviceWillInsertChild\", child, target, this);\n  }\n\n  protected override didInsertChild(child: Service, target: Service | null): void {\n    this.callObservers(\"serviceDidInsertChild\", child, target, this);\n    super.didInsertChild(child, target);\n  }\n\n  protected override willRemoveChild(child: Service): void {\n    super.willRemoveChild(child);\n    this.callObservers(\"serviceWillRemoveChild\", child, this);\n  }\n\n  protected override didRemoveChild(child: Service): void {\n    this.callObservers(\"serviceDidRemoveChild\", child, this);\n    super.didRemoveChild(child);\n  }\n\n  protected override willReinsertChild(child: Service, target: Service | null): void {\n    super.willReinsertChild(child, target);\n    this.callObservers(\"serviceWillReinsertChild\", child, target, this);\n  }\n\n  protected override didReinsertChild(child: Service, target: Service | null): void {\n    this.callObservers(\"serviceDidReinsertChild\", child, target, this);\n    super.didReinsertChild(child, target);\n  }\n\n  protected override willMount(): void {\n    super.willMount();\n    this.callObservers(\"serviceWillMount\", this);\n  }\n\n  protected override didMount(): void {\n    this.callObservers(\"serviceDidMount\", this);\n    super.didMount();\n  }\n\n  protected override willUnmount(): void {\n    super.willUnmount();\n    this.callObservers(\"serviceWillUnmount\", this);\n  }\n\n  protected override didUnmount(): void {\n    this.callObservers(\"serviceDidUnmount\", this);\n    super.didUnmount();\n  }\n\n  static override create<S extends new () => InstanceType<S>>(this: S): InstanceType<S> {\n    return new this();\n  }\n\n  /** @internal */\n  static Global?: Service;\n  static global<S extends new () => InstanceType<S>>(this: S): InstanceType<S> {\n    let service: InstanceType<S> | undefined;\n    if (Object.hasOwnProperty.call(this, \"Global\")) {\n      service = (this as unknown as typeof Service).Global as InstanceType<S> | undefined;\n    }\n    if (service === void 0) {\n      service = (this as unknown as Creatable<InstanceType<S>>).create();\n      Object.defineProperty(this, \"Global\", {\n        value: service,\n        configurable: true,\n      });\n      if (this.prototype instanceof Service) {\n        const serviceClass = Object.getPrototypeOf(this) as typeof Service;\n        const rootService = serviceClass.global();\n        rootService.appendChild(service as Service);\n      } else { // mount root service\n        (service as Service).mount();\n      }\n    }\n    return service;\n  }\n\n  /** @internal */\n  static override uid: () => string = (function () {\n    let nextId = 1;\n    return function uid(): string {\n      const id = ~~nextId;\n      nextId += 1;\n      return \"service\" + id;\n    };\n  })();\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\n\n/** @internal */\nexport abstract class NodeCursor<T, P> extends Cursor<T> {\n  constructor(pages: readonly P[], index: number,\n              childIndex: number, childCursor: Cursor<T> | null) {\n    super();\n    this.pages = pages;\n    this.index = index;\n    this.childIndex = childIndex;\n    this.childCursor = childCursor;\n  }\n\n  /** @internal */\n  readonly pages: readonly P[];\n\n  /** @internal */\n  index: number;\n\n  /** @internal */\n  childIndex: number;\n\n  /** @internal */\n  childCursor: Cursor<T> | null;\n\n  protected abstract pageSize(page: P): number;\n\n  protected abstract pageCursor(page: P): Cursor<T>;\n\n  protected abstract reversePageCursor(page: P): Cursor<T>;\n\n  override isEmpty(): boolean {\n    do {\n      if (this.childCursor !== null) {\n        if (!this.childCursor.isEmpty()) {\n          return false;\n        }\n        this.childCursor = null;\n      } else if (this.childIndex < this.pages.length) {\n        this.childCursor = this.pageCursor(this.pages[this.childIndex]!);\n        this.childIndex += 1;\n      } else {\n        this.childIndex = this.pages.length;\n        return true;\n      }\n    } while (true);\n  }\n\n  override head(): T {\n    do {\n      if (this.childCursor !== null) {\n        if (!this.childCursor.isEmpty()) {\n          return this.childCursor.head();\n        }\n        this.childCursor = null;\n      } else if (this.childIndex < this.pages.length) {\n        this.childCursor = this.pageCursor(this.pages[this.childIndex]!);\n        this.childIndex += 1;\n      } else {\n        this.childIndex = this.pages.length;\n        throw new Error(\"empty\");\n      }\n    } while (true);\n  }\n\n  override step(): void {\n    do {\n      if (this.childCursor !== null) {\n        if (!this.childCursor.isEmpty()) {\n          this.index += 1;\n          return;\n        }\n        this.childCursor = null;\n      } else if (this.childIndex < this.pages.length) {\n        this.childCursor = this.pageCursor(this.pages[this.childIndex]!);\n        this.childIndex += 1;\n      } else {\n        this.childIndex = this.pages.length;\n        throw new Error(\"empty\");\n      }\n    } while (true);\n  }\n\n  override skip(count: number): void {\n    while (count > 0) {\n      if (this.childCursor !== null) {\n        if (this.childCursor.hasNext()) {\n          this.index += 1;\n          count -= 1;\n          this.childCursor.next();\n        } else {\n          this.childCursor = null;\n        }\n      } else if (this.childIndex < this.pages.length) {\n        const page = this.pages[this.childIndex]!;\n        const pageSize = this.pageSize(page);\n        this.childIndex += 1;\n        if (pageSize < count) {\n          this.childCursor = this.pageCursor(page);\n          if (count > 0) {\n            this.index += count;\n            this.childCursor!.skip(count);\n            count = 0;\n          }\n          break;\n        }\n        this.index += pageSize;\n        count -= pageSize;\n      } else {\n        break;\n      }\n    }\n  }\n\n  override hasNext(): boolean {\n    do {\n      if (this.childCursor !== null) {\n        if (this.childCursor.hasNext()) {\n          return true;\n        }\n        this.childCursor = null;\n      } else if (this.childIndex < this.pages.length) {\n        this.childCursor = this.pageCursor(this.pages[this.childIndex]!);\n        this.childIndex += 1;\n      } else {\n        this.childIndex = this.pages.length;\n        return false;\n      }\n    } while (true);\n  }\n\n  override nextIndex(): number {\n    return this.index;\n  }\n\n  override next(): IteratorResult<T> {\n    do {\n      if (this.childCursor !== null) {\n        if (this.childCursor.hasNext()) {\n          this.index += 1;\n          return this.childCursor.next();\n        }\n        this.childCursor = null;\n      } else if (this.childIndex < this.pages.length) {\n        this.childCursor = this.pageCursor(this.pages[this.childIndex]!);\n        this.childIndex += 1;\n      } else {\n        this.childIndex = this.pages.length;\n        return {done: true, value: void 0};\n      }\n    } while (true);\n  }\n\n  override hasPrevious(): boolean {\n    do {\n      if (this.childCursor !== null) {\n        if (this.childCursor.hasPrevious()) {\n          return true;\n        }\n        this.childCursor = null;\n      } else if (this.childIndex > 0) {\n        this.childCursor = this.reversePageCursor(this.pages[this.childIndex - 1]!);\n        this.childIndex -= 1;\n      } else {\n        this.childIndex = 0;\n        return false;\n      }\n    } while (true);\n  }\n\n  override previousIndex(): number {\n    return this.index - 1;\n  }\n\n  override previous(): IteratorResult<T> {\n    do {\n      if (this.childCursor !== null) {\n        if (this.childCursor.hasPrevious()) {\n          this.index -= 1;\n          return this.childCursor.previous();\n        }\n        this.childCursor = null;\n      } else if (this.childIndex > 0) {\n        this.childCursor = this.reversePageCursor(this.pages[this.childIndex - 1]!);\n        this.childIndex -= 1;\n      } else {\n        this.childIndex = 0;\n        return {done: true, value: void 0};\n      }\n    } while (true);\n  }\n\n  override set(newValue: T): void {\n    this.childCursor!.set(newValue);\n  }\n\n  override delete(): void {\n    this.childCursor!.delete();\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Values} from \"@swim/util\";\nimport type {BTreePage} from \"./BTreePage\";\n\n/** @public */\nexport abstract class BTreeContext<K, V> {\n  pageSplitSize: number = 32;\n\n  compare(x: K, y: K): number {\n    return Values.compare(x, y);\n  }\n\n  /** @internal */\n  pageShouldSplit(page: BTreePage<K, V, unknown>): boolean {\n    return page.arity > this.pageSplitSize;\n  }\n\n  /** @internal */\n  pageShouldMerge(page: BTreePage<K, V, unknown>): boolean {\n    return page.arity < this.pageSplitSize >>> 1;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Cursor} from \"@swim/util\";\nimport type {ReducedMap} from \"@swim/util\";\nimport {BTreeContext} from \"./BTreeContext\";\nimport {BTreePage} from \"./\"; // forward import\n\n/** @public */\nexport class BTree<K = unknown, V = unknown, U = never> extends BTreeContext<K, V> implements ReducedMap<K, V, U> {\n  /** @internal */\n  root: BTreePage<K, V, U>;\n\n  constructor();\n  /** @internal */\n  constructor(root: BTreePage<K, V, U>);\n  constructor(root?: BTreePage<K, V, U>) {\n    super();\n    if (root === void 0) {\n      root = BTreePage.empty();\n    }\n    this.root = root;\n  }\n\n  get size(): number {\n    return this.root.size;\n  }\n\n  isEmpty(): boolean {\n    return this.root.isEmpty();\n  }\n\n  has(key: K): boolean {\n    return this.root.has(key, this);\n  }\n\n  get(key: K): V | undefined {\n    return this.root.get(key, this);\n  }\n\n  getEntry(index: number): [K, V] | undefined {\n    return this.root.getEntry(index);\n  }\n\n  firstKey(): K | undefined {\n    const entry = this.root.firstEntry();\n    return entry !== void 0 ? entry[0] : void 0;\n  }\n\n  firstValue(): V | undefined {\n    const entry = this.root.firstEntry();\n    return entry !== void 0 ? entry[1] : void 0;\n  }\n\n  firstEntry(): [K, V] | undefined {\n    return this.root.firstEntry();\n  }\n\n  lastKey(): K | undefined {\n    const entry = this.root.lastEntry();\n    return entry !== void 0 ? entry[0] : void 0;\n  }\n\n  lastValue(): V | undefined {\n    const entry = this.root.lastEntry();\n    return entry !== void 0 ? entry[1] : void 0;\n  }\n\n  lastEntry(): [K, V] | undefined {\n    return this.root.lastEntry();\n  }\n\n  nextKey(key: K): K | undefined {\n    const entry = this.root.nextEntry(key, this);\n    return entry !== void 0 ? entry[0] : void 0;\n  }\n\n  nextValue(key: K): V | undefined {\n    const entry = this.root.nextEntry(key, this);\n    return entry !== void 0 ? entry[1] : void 0;\n  }\n\n  nextEntry(key: K): [K, V] | undefined {\n    return this.root.nextEntry(key, this);\n  }\n\n  previousKey(key: K): K | undefined {\n    const entry = this.root.previousEntry(key, this);\n    return entry !== void 0 ? entry[0] : void 0;\n  }\n\n  previousValue(key: K): V | undefined {\n    const entry = this.root.previousEntry(key, this);\n    return entry !== void 0 ? entry[1] : void 0;\n  }\n\n  previousEntry(key: K): [K, V] | undefined {\n    return this.root.previousEntry(key, this);\n  }\n\n  set(key: K, newValue: V): this {\n    const oldRoot = this.root;\n    let newRoot = this.root.updated(key, newValue, this);\n    if (oldRoot === newRoot) {\n      return this;\n    } else if (newRoot.size > oldRoot.size) {\n      newRoot = newRoot.balanced(this);\n    }\n    this.root = newRoot;\n    return this;\n  }\n\n  delete(key: K): boolean {\n    const oldRoot = this.root;\n    const newRoot = this.root.removed(key, this);\n    if (oldRoot === newRoot) {\n      return false;\n    }\n    this.root = newRoot;\n    return true;\n  }\n\n  drop(lower: number): this {\n    if (lower > 0 && this.root.size !== 0) {\n      if (lower >= this.root.size) {\n        this.root = BTreePage.empty();\n      } else {\n        this.root = this.root.drop(lower, this);\n      }\n    }\n    return this;\n  }\n\n  take(upper: number): this {\n    if (upper < this.root.size && this.root.size !== 0) {\n      if (upper <= 0) {\n        this.root = BTreePage.empty();\n      } else {\n        this.root = this.root.take(upper, this);\n      }\n    }\n    return this;\n  }\n\n  clear(): void {\n    this.root = BTreePage.empty();\n  }\n\n  updated(key: K, newValue: V): BTree<K, V, U> {\n    const oldRoot = this.root;\n    let newRoot = oldRoot.updated(key, newValue, this);\n    if (oldRoot === newRoot) {\n      return this;\n    } else if (newRoot.size > oldRoot.size) {\n      newRoot = newRoot.balanced(this);\n    }\n    return this.copy(newRoot);\n  }\n\n  removed(key: K): BTree<K, V, U> {\n    const oldRoot = this.root;\n    const newRoot = oldRoot.removed(key, this);\n    if (oldRoot === newRoot) {\n      return this;\n    }\n    return this.copy(newRoot);\n  }\n\n  cleared(): BTree<K, V, U> {\n    if (this.root.isEmpty()) {\n      return this;\n    }\n    return this.copy(BTreePage.empty());\n  }\n\n  reduced(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): U {\n    const oldRoot = this.root;\n    const newRoot = oldRoot.reduced(identity, accumulator, combiner);\n    if (oldRoot !== newRoot) {\n      this.root = newRoot;\n    }\n    return newRoot.fold!;\n  }\n\n  forEach<T>(callback: (value: V, key: K, tree: BTree<K, V, U>) => T | void): T | undefined;\n  forEach<T, S>(callback: (this: S, value: V, key: K, tree: BTree<K, V, U>) => T | void, thisArg?: S): T | undefined;\n  forEach<T, S>(callback: (this: S | undefined, value: V, key: K, tree: BTree<K, V, U>) => T | void, thisArg?: S): T | undefined {\n    return this.root.forEach(callback, thisArg, this);\n  }\n\n  forEachKey<T>(callback: (key: K, tree: BTree<K, V, U>) => T | void): T | undefined;\n  forEachKey<T, S>(callback: (this: S, key: K, tree: BTree<K, V, U>) => T | void, thisArg: S): T | undefined;\n  forEachKey<T, S>(callback: (this: S | undefined, key: K, tree: BTree<K, V, U>) => T | void, thisArg?: S): T | undefined {\n    return this.root.forEachKey(callback, thisArg, this);\n  }\n\n  forEachValue<T>(callback: (value: V, tree: BTree<K, V, U>) => T | void): T | undefined;\n  forEachValue<T, S>(callback: (this: S, value: V, tree: BTree<K, V, U>) => T | void, thisArg: S): T | undefined;\n  forEachValue<T, S>(callback: (this: S | undefined, value: V, tree: BTree<K, V, U>) => T | void, thisArg?: S): T | undefined {\n    return this.root.forEachValue(callback, thisArg, this);\n  }\n\n  [Symbol.iterator](): Cursor<[K, V]> {\n    return this.root.entries();\n  }\n\n  keys(): Cursor<K> {\n    return this.root.keys();\n  }\n\n  values(): Cursor<V> {\n    return this.root.values();\n  }\n\n  entries(): Cursor<[K, V]> {\n    return this.root.entries();\n  }\n\n  reverseKeys(): Cursor<K> {\n    return this.root.reverseKeys();\n  }\n\n  reverseValues(): Cursor<V> {\n    return this.root.reverseValues();\n  }\n\n  reverseEntries(): Cursor<[K, V]> {\n    return this.root.reverseEntries();\n  }\n\n  clone(): BTree<K, V, U> {\n    return this.copy(this.root);\n  }\n\n  /** @internal */\n  protected copy(root: BTreePage<K, V, U>): BTree<K, V, U> {\n    const tree = new BTree(root);\n    if (tree.pageSplitSize !== this.pageSplitSize) {\n      tree.pageSplitSize = this.pageSplitSize;\n    }\n    if (tree.compare !== this.compare) {\n      tree.compare = this.compare;\n    }\n    return tree;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return \"BTree\";\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport {Cursor} from \"@swim/util\";\nimport type {BTreeContext} from \"./BTreeContext\";\nimport type {BTree} from \"./BTree\";\nimport {BTreeLeaf} from \"./\"; // forward import\n\n/** @internal */\nexport abstract class BTreePage<K, V, U> {\n  abstract readonly arity: number;\n\n  abstract readonly size: number;\n\n  abstract isEmpty(): boolean;\n\n  abstract readonly fold: U | undefined;\n\n  abstract minKey(): K;\n\n  abstract maxKey(): K;\n\n  abstract has(key: K, tree: BTreeContext<K, V>): boolean;\n\n  abstract get(key: K, tree: BTreeContext<K, V>): V | undefined;\n\n  abstract getEntry(index: number): [K, V] | undefined;\n\n  abstract firstEntry(): [K, V] | undefined;\n\n  abstract lastEntry(): [K, V] | undefined;\n\n  abstract nextEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined;\n\n  abstract previousEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined;\n\n  abstract updated(key: K, newValue: V, tree: BTreeContext<K, V>): BTreePage<K, V, U>;\n\n  abstract removed(key: K, tree: BTreeContext<K, V>): BTreePage<K, V, U>;\n\n  abstract drop(lower: number, tree: BTreeContext<K, V>): BTreePage<K, V, U>;\n\n  abstract take(upper: number, tree: BTreeContext<K, V>): BTreePage<K, V, U>;\n\n  abstract balanced(tree: BTreeContext<K, V>): BTreePage<K, V, U>;\n\n  abstract split(index: number): BTreePage<K, V, U>;\n\n  abstract splitLeft(index: number): BTreePage<K, V, U>;\n\n  abstract splitRight(index: number): BTreePage<K, V, U>;\n\n  abstract reduced(identity: U, accumulator: (result: U, element: V) => U,\n                   combiner: (result: U, result2: U) => U): BTreePage<K, V, U>;\n\n  abstract forEach<T, S>(callback: (this: S, value: V, key: K, tree: BTree<K, V, U>) => T | void,\n                         thisArg: S, tree: BTree<K, V, U>): T | undefined;\n\n  abstract forEachKey<T, S>(callback: (this: S, key: K, tree: BTree<K, V, U>) => T | void,\n                            thisArg: S, tree: BTree<K, V, U>): T | undefined;\n\n  abstract forEachValue<T, S>(callback: (this: S, value: V, tree: BTree<K, V, U>) => T | void,\n                              thisArg: S, tree: BTree<K, V, U>): T | undefined;\n\n  keys(): Cursor<K> {\n    return Cursor.keys(this.entries());\n  }\n\n  values(): Cursor<V> {\n    return Cursor.values(this.entries());\n  }\n\n  abstract entries(): Cursor<[K, V]>;\n\n  reverseKeys(): Cursor<K> {\n    return Cursor.keys(this.reverseEntries());\n  }\n\n  reverseValues(): Cursor<V> {\n    return Cursor.values(this.reverseEntries());\n  }\n\n  abstract reverseEntries(): Cursor<[K, V]>;\n\n  @Lazy\n  static empty<K, V, U>(): BTreeLeaf<K, V, U> {\n    return new BTreeLeaf<K, V, U>([], void 0);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport type {BTreeContext} from \"./BTreeContext\";\nimport type {BTree} from \"./BTree\";\nimport {BTreePage} from \"./BTreePage\";\nimport {BTreeNode} from \"./\"; // forward import\n\n/** @internal */\nexport class BTreeLeaf<K, V, U> extends BTreePage<K, V, U> {\n  constructor(slots: readonly [K, V][], fold: U | undefined) {\n    super();\n    this.slots = slots;\n    this.fold = fold;\n  }\n\n  /** @internal */\n  readonly slots: readonly [K, V][];\n\n  override get arity(): number {\n    return this.slots.length;\n  }\n\n  override get size(): number {\n    return this.slots.length;\n  }\n\n  override isEmpty(): boolean {\n    return this.slots.length === 0;\n  }\n\n  override readonly fold: U | undefined;\n\n  override minKey(): K {\n    return this.slots[0]![0];\n  }\n\n  override maxKey(): K {\n    return this.slots[this.slots.length - 1]![0];\n  }\n\n  override has(key: K, tree: BTreeContext<K, V>): boolean {\n    return this.lookup(key, tree) >= 0;\n  }\n\n  override get(key: K, tree: BTreeContext<K, V>): V | undefined {\n    const x = this.lookup(key, tree);\n    if (x < 0) {\n      return void 0;\n    }\n    return this.slots[x]![1];\n  }\n\n  override getEntry(index: number): [K, V] | undefined {\n    return this.slots[index];\n  }\n\n  override firstEntry(): [K, V] | undefined {\n    const slots = this.slots;\n    if (slots.length === 0) {\n      return void 0;\n    }\n    return slots[0];\n  }\n\n  override lastEntry(): [K, V] | undefined {\n    const slots = this.slots;\n    if (slots.length === 0) {\n      return void 0;\n    }\n    return slots[slots.length - 1];\n  }\n\n  override nextEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined {\n    let x = this.lookup(key, tree);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    return this.slots[x];\n  }\n\n  override previousEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined {\n    let x = this.lookup(key, tree);\n    if (x >= 0) {\n      x -= 1;\n    } else {\n      x = -(x + 2);\n    }\n    return this.slots[x];\n  }\n\n  override updated(key: K, newValue: V, tree: BTreeContext<K, V>): BTreeLeaf<K, V, U> {\n    let x = this.lookup(key, tree);\n    if (x >= 0) {\n      return this.updatedSlot(x, key, newValue);\n    }\n    x = -(x + 1);\n    return this.insertedSlot(x, key, newValue);\n  }\n\n  /** @internal */\n  updatedSlot(x: number, key: K, newValue: V): BTreeLeaf<K, V, U> {\n    const oldSlots = this.slots;\n    if (newValue === oldSlots[x]![1]) {\n      return this;\n    }\n    const newSlots = oldSlots.slice(0);\n    newSlots[x] = [key, newValue];\n    return new BTreeLeaf<K, V, U>(newSlots, void 0);\n  }\n\n  /** @internal */\n  insertedSlot(x: number, key: K, newValue: V): BTreeLeaf<K, V, U> {\n    const oldSlots = this.slots;\n    const n = oldSlots.length + 1;\n    const newSlots = new Array<[K, V]>(n);\n    for (let i = 0; i < x; i += 1) {\n      newSlots[i] = oldSlots[i]!;\n    }\n    newSlots[x] = [key, newValue];\n    for (let i = x; i < n - 1; i += 1) {\n      newSlots[i + 1] = oldSlots[i]!;\n    }\n    return new BTreeLeaf<K, V, U>(newSlots, void 0);\n  }\n\n  override removed(key: K, tree: BTreeContext<K, V>): BTreeLeaf<K, V, U> {\n    const x = this.lookup(key, tree);\n    if (x < 0) {\n      return this;\n    } else if (this.slots.length <= 1) {\n      return BTreePage.empty();\n    }\n    return this.removedSlot(x);\n  }\n\n  /** @internal */\n  removedSlot(x: number): BTreeLeaf<K, V, U> {\n    const oldSlots = this.slots;\n    const newSlots = new Array<[K, V]>(oldSlots.length - 1);\n    for (let i = 0; i < x; i += 1) {\n      newSlots[i] = oldSlots[i]!;\n    }\n    for (let i = x; i < newSlots.length; i += 1) {\n      newSlots[i] = oldSlots[i + 1]!;\n    }\n    return new BTreeLeaf<K, V, U>(newSlots, void 0);\n  }\n\n  override drop(lower: number, tree: BTreeContext<K, V>): BTreeLeaf<K, V, U> {\n    const oldSlots = this.slots;\n    if (lower <= 0) {\n      return this;\n    } else if (lower >= oldSlots.length) {\n      return BTreePage.empty();\n    }\n    const size = oldSlots.length - lower;\n    const newSlots = new Array<[K, V]>(size);\n    for (let i = 0; i < size; i += 1) {\n      newSlots[i] = oldSlots[i + lower]!;\n    }\n    return new BTreeLeaf<K, V, U>(newSlots, void 0);\n  }\n\n  override take(upper: number, tree: BTreeContext<K, V>): BTreeLeaf<K, V, U> {\n    const oldSlots = this.slots;\n    if (upper >= oldSlots.length) {\n      return this;\n    } else if (upper <= 0) {\n      return BTreePage.empty();\n    }\n    const newSlots = new Array<[K, V]>(upper);\n    for (let i = 0; i < upper; i += 1) {\n      newSlots[i] = oldSlots[i]!;\n    }\n    return new BTreeLeaf<K, V, U>(newSlots, void 0);\n  }\n\n  override balanced(tree: BTreeContext<K, V>): BTreePage<K, V, U> {\n    const n = this.slots.length;\n    if (n <= 1 || !tree.pageShouldSplit(this)) {\n      return this;\n    }\n    return this.split(n >>> 1);\n  }\n\n  override split(x: number): BTreeNode<K, V, U> {\n    const newPages = new Array<BTreePage<K, V, U>>(2);\n    const newLeftPage = this.splitLeft(x);\n    const newRightPage = this.splitRight(x);\n    newPages[0] = newLeftPage;\n    newPages[1] = newRightPage;\n\n    const newKnots = new Array<K>(1);\n    newKnots[0] = newRightPage.minKey();\n\n    return new BTreeNode(newPages, newKnots, void 0, this.slots.length);\n  }\n\n  override splitLeft(x: number): BTreeLeaf<K, V, U> {\n    const oldSlots = this.slots;\n    const newSlots = new Array<[K, V]>(x);\n    for (let i = 0; i < x; i += 1) {\n      newSlots[i] = oldSlots[i]!;\n    }\n    return new BTreeLeaf<K, V, U>(newSlots, void 0);\n  }\n\n  override splitRight(x: number): BTreeLeaf<K, V, U> {\n    const oldSlots = this.slots;\n    const y = oldSlots.length - x;\n    const newSlots = new Array<[K, V]>(y);\n    for (let i = 0; i < y; i += 1) {\n      newSlots[i] = oldSlots[i + x]!;\n    }\n    return new BTreeLeaf<K, V, U>(newSlots, void 0);\n  }\n\n  override reduced(identity: U, accumulator: (result: U, element: V) => U,\n                   combiner: (result: U, result2: U) => U): BTreeLeaf<K, V, U> {\n    if (this.fold !== void 0) {\n      return this;\n    }\n    const slots = this.slots;\n    let fold = identity;\n    for (let i = 0; i < slots.length; i += 1) {\n      fold = accumulator(fold, slots[i]![1]);\n    }\n    return new BTreeLeaf<K, V, U>(slots, fold);\n  }\n\n  override forEach<T, S>(callback: (this: S, value: V, key: K, tree: BTree<K, V, U>) => T | void,\n                         thisArg: S, tree: BTree<K, V, U>): T | undefined {\n    const slots = this.slots;\n    for (let i = 0; i < slots.length; i += 1) {\n      const slot = slots[i]!;\n      const result = callback.call(thisArg, slot[1], slot[0], tree);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return void 0;\n  }\n\n  override forEachKey<T, S>(callback: (this: S, key: K, tree: BTree<K, V, U>) => T | void,\n                            thisArg: S, tree: BTree<K, V, U>): T | undefined {\n    const slots = this.slots;\n    for (let i = 0; i < slots.length; i += 1) {\n      const slot = slots[i]!;\n      const result = callback.call(thisArg, slot[0], tree);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return void 0;\n  }\n\n  override forEachValue<T, S>(callback: (this: S, value: V, tree: BTree<K, V, U>) => T | void,\n                              thisArg: S, tree: BTree<K, V, U>): T | undefined {\n    const slots = this.slots;\n    for (let i = 0; i < slots.length; i += 1) {\n      const slot = slots[i]!;\n      const result = callback.call(thisArg, slot[1], tree);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return void 0;\n  }\n\n  override entries(): Cursor<[K, V]> {\n    return Cursor.array(this.slots);\n  }\n\n  override reverseEntries(): Cursor<[K, V]> {\n    return Cursor.array(this.slots, this.slots.length);\n  }\n\n  /** @internal */\n  lookup(key: K, tree: BTreeContext<K, V>): number {\n    let lo = 0;\n    let hi = this.slots.length - 1;\n    while (lo <= hi) {\n      const mid = (lo + hi) >>> 1;\n      const order = tree.compare(key, this.slots[mid]![0]);\n      if (order > 0) {\n        lo = mid + 1;\n      } else if (order < 0) {\n        hi = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n    return -(lo + 1);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Cursor} from \"@swim/util\";\nimport {NodeCursor} from \"./NodeCursor\";\nimport type {BTreeContext} from \"./BTreeContext\";\nimport type {BTree} from \"./BTree\";\nimport {BTreePage} from \"./BTreePage\";\n\n/** @internal */\nexport class BTreeNode<K, V, U> extends BTreePage<K, V, U> {\n  constructor(pages: readonly BTreePage<K, V, U>[], knots: readonly K[],\n              fold: U | undefined, size: number) {\n    super();\n    this.pages = pages;\n    this.knots = knots;\n    this.fold = fold;\n    this.size = size;\n  }\n\n  /** @internal */\n  readonly pages: readonly BTreePage<K, V, U>[];\n\n  /** @internal */\n  readonly knots: readonly K[];\n\n  override get arity(): number {\n    return this.pages.length;\n  }\n\n  override readonly size: number;\n\n  override isEmpty(): boolean {\n    return this.size === 0;\n  }\n\n  override readonly fold: U | undefined;\n\n  override minKey(): K {\n    return this.pages[0]!.minKey();\n  }\n\n  override maxKey(): K {\n    return this.pages[this.pages.length - 1]!.maxKey();\n  }\n\n  override has(key: K, tree: BTreeContext<K, V>): boolean {\n    let x = this.lookup(key, tree);\n    if (x === 0) {\n      return true;\n    } else if (x > 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    return this.pages[x]!.has(key, tree);\n  }\n\n  override get(key: K, tree: BTreeContext<K, V>): V | undefined {\n    let x = this.lookup(key, tree);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    return this.pages[x]!.get(key, tree);\n  }\n\n  override getEntry(x: number): [K, V] | undefined {\n    const pages = this.pages;\n    for (let i = 0; i < pages.length; i += 1) {\n      const page = pages[i]!;\n      if (x < page.size) {\n        return page.getEntry(x);\n      }\n      x -= page.size;\n    }\n    return void 0;\n  }\n\n  override firstEntry(): [K, V] | undefined {\n    const pages = this.pages;\n    if (pages.length === 0) {\n      return void 0;\n    }\n    return pages[0]!.firstEntry();\n  }\n\n  override lastEntry(): [K, V] | undefined {\n    const pages = this.pages;\n    if (pages.length === 0) {\n      return void 0;\n    }\n    return pages[pages.length - 1]!.lastEntry();\n  }\n\n  override nextEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined {\n    let x = this.lookup(key, tree);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const pages = this.pages;\n    let entry = pages[x]!.nextEntry(key, tree);\n    if (entry === void 0 && x + 1 < pages.length) {\n      entry = pages[x + 1]!.nextEntry(key, tree);\n    }\n    return entry;\n  }\n\n  override previousEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined {\n    let x = this.lookup(key, tree);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const pages = this.pages;\n    let entry = pages[x]!.previousEntry(key, tree);\n    if (entry === void 0 && x > 0) {\n      entry = pages[x - 1]!.previousEntry(key, tree);\n    }\n    return entry;\n  }\n\n  override updated(key: K, newValue: V, tree: BTreeContext<K, V>): BTreeNode<K, V, U> {\n    let x = this.lookup(key, tree);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const oldPage = this.pages[x]!;\n    const newPage = oldPage.updated(key, newValue, tree);\n    if (oldPage === newPage) {\n      return this;\n    } else if (oldPage.size !== newPage.size && tree.pageShouldSplit(newPage)) {\n      return this.updatedPageSplit(x, newPage, oldPage);\n    }\n    return this.updatedPage(x, newPage, oldPage);\n  }\n\n  /** @internal */\n  updatedPage(x: number, newPage: BTreePage<K, V, U>, oldPage: BTreePage<K, V, U>): BTreeNode<K, V, U> {\n    const oldPages = this.pages;\n    const newPages = oldPages.slice(0);\n    newPages[x] = newPage;\n\n    const oldKnots = this.knots;\n    let newKnots: K[];\n    if (oldKnots.length === 0) {\n      newKnots = [];\n    } else {\n      newKnots = oldKnots.slice(0);\n      if (x > 0) {\n        newKnots[x - 1] = newPage.minKey();\n      }\n    }\n\n    const newSize = this.size - oldPage.size + newPage.size;\n    return new BTreeNode(newPages, newKnots, void 0, newSize);\n  }\n\n  /** @internal */\n  updatedPageSplit(x: number, newPage: BTreePage<K, V, U>, oldPage: BTreePage<K, V, U>): BTreeNode<K, V, U> {\n    const oldPages = this.pages;\n    const newPages = new Array<BTreePage<K, V, U>>(oldPages.length + 1);\n    for (let i = 0; i < x; i += 1) {\n      newPages[i] = oldPages[i]!;\n    }\n\n    const newLeftPage = newPage.splitLeft(newPage.arity >>> 1);\n    const newRightPage = newPage.splitRight(newPage.arity >>> 1);\n    newPages[x] = newLeftPage;\n    newPages[x + 1] = newRightPage;\n    for (let i = x + 1; i < oldPages.length; i += 1) {\n      newPages[i + 1] = oldPages[i]!;\n    }\n\n    const oldKnots = this.knots;\n    const newKnots = new Array<K>(oldPages.length);\n    if (x <= 0) {\n      newKnots[0] = newRightPage.minKey();\n      for (let i = 0; i < oldKnots.length; i += 1) {\n        newKnots[i + 1] = oldKnots[i]!;\n      }\n    } else {\n      for (let i = 0; i < x - 1; i += 1) {\n        newKnots[i] = oldKnots[i]!;\n      }\n      newKnots[x - 1] = newLeftPage.minKey();\n      newKnots[x] = newRightPage.minKey();\n      for (let i = x; i < oldKnots.length; i += 1) {\n        newKnots[i + 1] = oldKnots[i]!;\n      }\n    }\n\n    const newSize = this.size - oldPage.size + newPage.size;\n    return new BTreeNode(newPages, newKnots, void 0, newSize);\n  }\n\n  /** @internal */\n  updatedPageMerge(x: number, newPage: BTreeNode<K, V, U>, oldPage: BTreePage<K, V, U>): BTreeNode<K, V, U> {\n    const oldPages = this.pages;\n    const midPages = newPage.pages;\n    const newPages = new Array<BTreePage<K, V, U>>(oldPages.length + midPages.length - 1);\n    for (let i = 0; i < x; i += 1) {\n      newPages[i] = oldPages[i]!;\n    }\n    for (let i = 0; i < midPages.length; i += 1) {\n      newPages[i + x] = midPages[i]!;\n    }\n    for (let i = x + 1; i < oldPages.length; i += 1) {\n      newPages[i + midPages.length - 1] = oldPages[i]!;\n    }\n\n    const oldKnots = this.knots;\n    const midKnots = newPage.knots;\n    const newKnots = new Array<K>(newPages.length - 1);\n    if (x <= 0) {\n      for (let i = 0; i < midKnots.length; i += 1) {\n        newKnots[i] = midKnots[i]!;\n      }\n      newKnots[midKnots.length] = oldPages[1]!.minKey();\n      for (let i = 1; i < oldKnots.length; i += 1) {\n        newKnots[i + midKnots.length] = oldKnots[i]!;\n      }\n    } else {\n      for (let i = 0; i < x - 1; i += 1) {\n        newKnots[i] = oldKnots[i]!;\n      }\n      newKnots[x - 1] = midPages[0]!.minKey();\n      for (let i = 0; i < midKnots.length; i += 1) {\n        newKnots[i + x] = midKnots[i]!;\n      }\n      for (let i = x; i < oldKnots.length; i += 1) {\n        newKnots[i + midKnots.length] = oldKnots[i]!;\n      }\n    }\n\n    const newSize = this.size - oldPage.size + newPage.size;\n    return new BTreeNode(newPages, newKnots, void 0, newSize);\n  }\n\n  override removed(key: K, tree: BTreeContext<K, V>): BTreePage<K, V, U> {\n    let x = this.lookup(key, tree);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const oldPage = this.pages[x]!;\n    const newPage = oldPage.removed(key, tree);\n    if (oldPage === newPage) {\n      return this;\n    }\n    return this.replacedPage(x, newPage, oldPage, tree);\n  }\n\n  /** @internal */\n  replacedPage(x: number, newPage: BTreePage<K, V, U>, oldPage: BTreePage<K, V, U>,\n               tree: BTreeContext<K, V>): BTreePage<K, V, U> {\n    if (!newPage.isEmpty()) {\n      if (newPage instanceof BTreeNode && tree.pageShouldMerge(newPage)) {\n        return this.updatedPageMerge(x, newPage, oldPage);\n      } else {\n        return this.updatedPage(x, newPage, oldPage);\n      }\n    } else if (this.pages.length > 2) {\n      return this.removedPage(x, newPage, oldPage);\n    } else if (this.pages.length > 1) {\n      if (x === 0) {\n        return this.pages[1]!;\n      } else {\n        return this.pages[0]!;\n      }\n    }\n    return BTreePage.empty();\n  }\n\n  /** @internal */\n  removedPage(x: number, newPage: BTreePage<K, V, U>, oldPage: BTreePage<K, V, U>): BTreeNode<K, V, U> {\n    const oldPages = this.pages;\n    const newPages = new Array<BTreePage<K, V, U>>(oldPages.length - 1);\n    for (let i = 0; i < x; i += 1) {\n      newPages[i] = oldPages[i]!;\n    }\n    for (let i = x + 1; i < oldPages.length; i += 1) {\n      newPages[i - 1] = oldPages[i]!;\n    }\n\n    const oldKnots = this.knots;\n    const newKnots = new Array<K>(oldKnots.length - 1);\n    if (x <= 0) {\n      for (let i = 1; i < oldKnots.length; i += 1) {\n        newKnots[i - 1] = oldKnots[i]!;\n      }\n    } else {\n      for (let i = 0; i < x - 1; i += 1) {\n        newKnots[i] = oldKnots[i]!;\n      }\n      for (let i = x; i < oldKnots.length; i += 1) {\n        newKnots[i - 1] = oldKnots[i]!;\n      }\n    }\n\n    const newSize = this.size - oldPage.size;\n    return new BTreeNode(newPages, newKnots, void 0, newSize);\n  }\n\n  override drop(lower: number, tree: BTreeContext<K, V>): BTreePage<K, V, U> {\n    if (lower <= 0) {\n      return this;\n    }\n    let newSize = this.size;\n    if (lower >= newSize) {\n      return BTreePage.empty();\n    }\n    const oldPages = this.pages;\n    let x = 0;\n    while (x < oldPages.length) {\n      const size = oldPages[x]!.size;\n      if (size > lower) {\n        break;\n      }\n      newSize -= size;\n      lower -= size;\n      x += 1;\n    }\n    const newArity = oldPages.length - x;\n    if (newArity <= 1) {\n      return oldPages[x]!.drop(lower, tree);\n    }\n    let newNode: BTreeNode<K, V, U>;\n    if (x <= 0) {\n      newNode = this;\n    } else {\n      const newPages = new Array<BTreePage<K, V, U>>(newArity);\n      for (let i = 0; i < newArity; i += 1) {\n        newPages[i] = oldPages[i + x]!;\n      }\n      const newKnots = new Array<K>(newArity - 1);\n      for (let i = 0; i < newKnots.length; i += 1) {\n        newKnots[i] = this.knots[i + x]!;\n      }\n      newNode = new BTreeNode(newPages, newKnots, void 0, newSize);\n    }\n    if (lower <= 0) {\n      return newNode;\n    }\n    const oldPage = oldPages[x]!;\n    const newPage = oldPage.drop(lower, tree);\n    return newNode.replacedPage(0, newPage, oldPage, tree);\n  }\n\n  override take(upper: number, tree: BTreeContext<K, V>): BTreePage<K, V, U> {\n    if (upper >= this.size) {\n      return this;\n    } else if (upper <= 0) {\n      return BTreePage.empty();\n    }\n    const oldPages = this.pages;\n    let x = 0;\n    let newSize = 0;\n    while (x < oldPages.length && upper > 0) {\n      const size = oldPages[x]!.size;\n      newSize += size;\n      x += 1;\n      if (size > upper) {\n        break;\n      }\n      upper -= size;\n    }\n    const newArity = upper === 0 ? x : x + 1;\n    if (newArity <= 1) {\n       if (upper > 0) {\n        return oldPages[0]!.take(upper, tree);\n      }\n      return oldPages[0]!;\n    }\n    let newNode: BTreeNode<K, V, U>;\n    if (x >= oldPages.length) {\n      newNode = this;\n    } else {\n      const newPages = new Array<BTreePage<K, V, U>>(newArity);\n      for (let i = 0; i < newArity; i += 1) {\n        newPages[i] = oldPages[i]!;\n      }\n      const newKnots = new Array<K>(newArity - 1);\n      for (let i = 0; i < newKnots.length; i += 1) {\n        newKnots[i] = this.knots[i]!;\n      }\n      newNode = new BTreeNode(newPages, newKnots, void 0, newSize);\n    }\n    if (upper <= 0) {\n      return newNode;\n    }\n    const oldPage = oldPages[x - 1]!;\n    const newPage = oldPage.take(upper, tree);\n    return newNode.replacedPage(x - 1, newPage, oldPage, tree);\n  }\n\n  override balanced(tree: BTreeContext<K, V>): BTreeNode<K, V, U> {\n    if (this.pages.length <= 1 || !tree.pageShouldSplit(this)) {\n      return this;\n    }\n    return this.split(this.knots.length >>> 1);\n  }\n\n  override split(x: number): BTreeNode<K, V, U> {\n    const newPages = new Array<BTreePage<K, V, U>>(2);\n    const newLeftPage = this.splitLeft(x);\n    const newRightPage = this.splitRight(x);\n    newPages[0] = newLeftPage;\n    newPages[1] = newRightPage;\n\n    const newKnots = new Array<K>(1);\n    newKnots[0] = newRightPage.minKey();\n\n    return new BTreeNode(newPages, newKnots, void 0, this.size);\n  }\n\n  override splitLeft(x: number): BTreeNode<K, V, U> {\n    const oldPages = this.pages;\n    const newPages = new Array<BTreePage<K, V, U>>(x + 1);\n    for (let i = 0; i < x + 1; i += 1) {\n      newPages[i] = oldPages[i]!;\n    }\n\n    const oldKnots = this.knots;\n    const newKnots = new Array<K>(x);\n    for (let i = 0; i < x; i += 1) {\n      newKnots[i] = oldKnots[i]!;\n    }\n\n    let newSize = 0;\n    for (let i = 0; i <= x; i += 1) {\n      newSize += newPages[i]!.size;\n    }\n\n    return new BTreeNode(newPages, newKnots, void 0, newSize);\n  }\n\n  override splitRight(x: number): BTreeNode<K, V, U> {\n    const oldPages = this.pages;\n    const newArity = oldPages.length - (x + 1);\n    const newPages = new Array<BTreePage<K, V, U>>(newArity);\n    for (let i = 0; i < newArity; i += 1) {\n      newPages[i] = oldPages[i + (x + 1)]!;\n    }\n\n    const oldKnots = this.knots;\n    const newKnots = new Array<K>(newArity - 1);\n    for (let i = 0; i < newKnots.length; i += 1) {\n      newKnots[i] = oldKnots[i + (x + 1)]!;\n    }\n\n    let newSize = 0;\n    for (let i = 0; i < newArity; i += 1) {\n      newSize += newPages[i]!.size;\n    }\n\n    return new BTreeNode(newPages, newKnots, void 0, newSize);\n  }\n\n  override reduced(identity: U, accumulator: (result: U, element: V) => U,\n                   combiner: (result: U, result2: U) => U): BTreeNode<K, V, U> {\n    if (this.fold !== void 0) {\n      return this;\n    }\n    const oldPages = this.pages;\n    const n = oldPages.length;\n    const newPages = new Array<BTreePage<K, V, U>>(n);\n    for (let i = 0; i < n; i += 1) {\n      newPages[i] = oldPages[i]!.reduced(identity, accumulator, combiner);\n    }\n    // assert n > 0;\n    let fold: U = newPages[0]!.fold!;\n    for (let i = 1; i < n; i += 1) {\n      fold = combiner(fold, newPages[i]!.fold!);\n    }\n    return new BTreeNode(newPages, this.knots, fold, this.size);\n  }\n\n  override forEach<T, S>(callback: (this: S, value: V, key: K, tree: BTree<K, V, U>) => T | void,\n                         thisArg: S, tree: BTree<K, V, U>): T | undefined {\n    const pages = this.pages;\n    for (let i = 0; i < pages.length; i += 1) {\n      const result = pages[i]!.forEach(callback, thisArg, tree);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return void 0;\n  }\n\n  override forEachKey<T, S>(callback: (this: S, key: K, tree: BTree<K, V, U>) => T | void,\n                            thisArg: S, tree: BTree<K, V, U>): T | undefined {\n    const pages = this.pages;\n    for (let i = 0; i < pages.length; i += 1) {\n      const result = pages[i]!.forEachKey(callback, thisArg, tree);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return void 0;\n  }\n\n  override forEachValue<T, S>(callback: (this: S, value: V, tree: BTree<K, V, U>) => T | void,\n                              thisArg: S, tree: BTree<K, V, U>): T | undefined {\n    const pages = this.pages;\n    for (let i = 0; i < pages.length; i += 1) {\n      const result = pages[i]!.forEachValue(callback, thisArg, tree);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return void 0;\n  }\n\n  override entries(): Cursor<[K, V]> {\n    return new BTreeNodeCursor(this.pages);\n  }\n\n  override reverseEntries(): Cursor<[K, V]> {\n    return new BTreeNodeCursor(this.pages, this.size, this.pages.length);\n  }\n\n  /** @internal */\n  lookup(key: K, tree: BTreeContext<K, V>): number {\n    let lo = 0;\n    let hi = this.knots.length - 1;\n    while (lo <= hi) {\n      const mid = (lo + hi) >>> 1;\n      const order = tree.compare(key, this.knots[mid]!);\n      if (order > 0) {\n        lo = mid + 1;\n      } else if (order < 0) {\n        hi = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n    return -(lo + 1);\n  }\n}\n\n/** @internal */\nexport class BTreeNodeCursor<K, V, U> extends NodeCursor<[K, V], BTreePage<K, V, U>> {\n  constructor(pages: readonly BTreePage<K, V, U>[], index: number = 0,\n              childIndex: number = 0, childCursor: Cursor<[K, V]> | null = null) {\n    super(pages, index, childIndex, childCursor);\n  }\n\n  protected override pageSize(page: BTreePage<K, V, U>): number {\n    return page.size;\n  }\n\n  protected override pageCursor(page: BTreePage<K, V, U>): Cursor<[K, V]> {\n    return page.entries();\n  }\n\n  protected override reversePageCursor(page: BTreePage<K, V, U>): Cursor<[K, V]> {\n    return page.reverseEntries();\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Random} from \"@swim/util\";\nimport {Values} from \"@swim/util\";\nimport type {STreePage} from \"./STreePage\";\n\n/** @public */\nexport abstract class STreeContext<V, I> {\n  pageSplitSize: number = 32;\n\n  identify(value: V): I {\n    const id = new Uint8Array(6);\n    Random.fillBytes(id);\n    return id as unknown as I;\n  }\n\n  compare(x: I, y: I): number {\n    return Values.compare(x, y);\n  }\n\n  /** @internal */\n  pageShouldSplit(page: STreePage<V, I>): boolean {\n    return page.arity > this.pageSplitSize;\n  }\n\n  /** @internal */\n  pageShouldMerge(page: STreePage<V, I>): boolean {\n    return page.arity < this.pageSplitSize >>> 1;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Cursor} from \"@swim/util\";\nimport {STreeContext} from \"./STreeContext\";\nimport {STreePage} from \"./\"; // forward import\n\n/** @public */\nexport class STree<V = unknown, I = unknown> extends STreeContext<V, I> {\n  /** @internal */\n  root: STreePage<V, I>;\n\n  constructor();\n  /** @internal */\n  constructor(root: STreePage<V, I>);\n  constructor(root?: STreePage<V, I>) {\n    super();\n    if (root === void 0) {\n      root = STreePage.empty();\n    }\n    this.root = root;\n  }\n\n  get length(): number {\n    return this.root.size;\n  }\n\n  isEmpty(): boolean {\n    return this.root.isEmpty();\n  }\n\n  get(index: number, id?: I): V | undefined {\n    if (id !== void 0) {\n      index = this.lookup(id, index);\n      if (index < 0) {\n        return void 0;\n      }\n    }\n    return this.root.get(index);\n  }\n\n  getEntry(index: number, id?: I): [I, V] | undefined {\n    if (id !== void 0) {\n      index = this.lookup(id, index);\n      if (index < 0) {\n        return void 0;\n      }\n    }\n    return this.root.getEntry(index);\n  }\n\n  set(index: number, newValue: V, id?: I): this {\n    if (id !== void 0) {\n      index = this.lookup(id, index);\n      if (index < 0) {\n        throw new RangeError(\"\" + id);\n      }\n    }\n    const oldRoot = this.root;\n    if (index < 0 || index >= oldRoot.size) {\n      throw new RangeError(\"\" + index);\n    }\n    this.root = oldRoot.updated(index, newValue, this);\n    return this;\n  }\n\n  insert(index: number, newValue: V, id?: I): this {\n    const oldRoot = this.root;\n    if (index < 0 || index > oldRoot.size) {\n      throw new RangeError(\"\" + index);\n    }\n    this.root = oldRoot.inserted(index, newValue, id, this).balanced(this);\n    return this;\n  }\n\n  remove(index: number, id?: I): this {\n    if (id !== void 0) {\n      index = this.lookup(id, index);\n      if (index < 0) {\n        throw new RangeError(\"\" + id);\n      }\n    }\n    const oldRoot = this.root;\n    if (index < 0 || index > oldRoot.size) {\n      throw new RangeError(\"\" + index);\n    }\n    this.root = oldRoot.removed(index, this);\n    return this;\n  }\n\n  push(...newValues: V[]): number {\n    let newRoot = this.root;\n    for (let i = 0; i < newValues.length; i += 1) {\n      newRoot = newRoot.inserted(newRoot.size, newValues[i]!, void 0, this).balanced(this);\n    }\n    this.root = newRoot;\n    return newRoot.size;\n  }\n\n  pop(): V | undefined {\n    const oldRoot = this.root;\n    const index = oldRoot.size - 1;\n    if (index < 0) {\n      return void 0;\n    }\n    const oldValue = oldRoot.get(index);\n    this.root = oldRoot.removed(index, this);\n    return oldValue;\n  }\n\n  unshift(...newValues: V[]): number {\n    let newRoot = this.root;\n    for (let i = newValues.length - 1; i >= 0; i -= 1) {\n      newRoot = newRoot.inserted(0, newValues[i]!, void 0, this).balanced(this);\n    }\n    this.root = newRoot;\n    return newRoot.size;\n  }\n\n  shift(): V | undefined {\n    const oldRoot = this.root;\n    if (oldRoot.size === 0) {\n      return void 0;\n    }\n    const oldValue = oldRoot.get(0);\n    this.root = oldRoot.removed(0, this);\n    return oldValue;\n  }\n\n  move(fromIndex: number, toIndex: number, id?: I): this {\n    if (id !== void 0) {\n      fromIndex = this.lookup(id, fromIndex);\n      if (fromIndex < 0) {\n        throw new RangeError(\"\" + id);\n      }\n    }\n    const oldRoot = this.root;\n    if (fromIndex < 0 || fromIndex >= oldRoot.size) {\n      throw new RangeError(\"\" + fromIndex);\n    }\n    if (toIndex < 0 || toIndex >= oldRoot.size) {\n      throw new RangeError(\"\" + toIndex);\n    }\n    if (fromIndex !== toIndex) {\n      const entry = oldRoot.getEntry(fromIndex)!;\n      this.root = oldRoot.removed(fromIndex, this)\n                         .inserted(toIndex, entry[1], entry[0], this)\n                         .balanced(this);\n    }\n    return this;\n  }\n\n  splice(start: number, deleteCount?: number, ...newValues: V[]): V[] {\n    let newRoot = this.root;\n    if (start < 0) {\n      start = newRoot.size + start;\n    }\n    start = Math.min(Math.max(0, start), newRoot.size);\n    if (deleteCount === void 0) {\n      deleteCount = newRoot.size - start;\n    }\n    const deleted = [] as V[];\n    for (let i = start, n = start + deleteCount; i < n; i += 1) {\n      deleted.push(newRoot.get(start)!);\n      newRoot = newRoot.removed(start, this);\n    }\n    for (let i = 0; i < newValues.length; i += 1) {\n      newRoot = newRoot.inserted(start + i, newValues[i]!, void 0, this).balanced(this);\n    }\n    this.root = newRoot;\n    return deleted;\n  }\n\n  drop(lower: number): this {\n    const oldRoot = this.root;\n    if (lower > 0 && oldRoot.size > 0) {\n      if (lower >= oldRoot.size) {\n        this.root = STreePage.empty();\n      } else {\n        this.root = oldRoot.drop(lower, this);\n      }\n    }\n    return this;\n  }\n\n  take(upper: number): this {\n    const oldRoot = this.root;\n    if (upper < oldRoot.size && oldRoot.size > 0) {\n      if (upper <= 0) {\n        this.root = STreePage.empty();\n      } else {\n        this.root = oldRoot.take(upper, this);\n      }\n    }\n    return this;\n  }\n\n  clear(): void {\n    this.root = STreePage.empty();\n  }\n\n  forEach<T>(callback: (value: V, index: number, id: I, tree: STree<V, I>) => T | void): T | undefined;\n  forEach<T, S>(callback: (this: S, value: V, index: number, id: I, tree: STree<V, I>) => T | void, thisArg: S): T | undefined;\n  forEach<T, S>(callback: (this: S | undefined, value: V, index: number, id: I, tree: STree<V, I>) => T | void, thisArg?: S): T | undefined {\n    return this.root.forEach(callback, thisArg, 0, this);\n  }\n\n  [Symbol.iterator](): Cursor<V> {\n    return this.root.values();\n  }\n\n  keys(): Cursor<I> {\n    return this.root.keys();\n  }\n\n  values(): Cursor<V> {\n    return this.root.values();\n  }\n\n  entries(): Cursor<[I, V]> {\n    return this.root.entries();\n  }\n\n  reverseKeys(): Cursor<I> {\n    return this.root.reverseKeys();\n  }\n\n  reverseValues(): Cursor<V> {\n    return this.root.reverseValues();\n  }\n\n  reverseEntries(): Cursor<[I, V]> {\n    return this.root.reverseEntries();\n  }\n\n  clone(): STree<V, I> {\n    return this.copy(this.root);\n  }\n\n  /** @internal */\n  protected copy(root: STreePage<V, I>): STree<V, I> {\n    const tree = new STree(root);\n    if (tree.pageSplitSize !== this.pageSplitSize) {\n      tree.pageSplitSize = this.pageSplitSize;\n    }\n    if (tree.identify !== this.identify) {\n      tree.identify = this.identify;\n    }\n    if (tree.compare !== this.compare) {\n      tree.compare = this.compare;\n    }\n    return tree;\n  }\n\n  lookup(id: I, start: number = 0): number {\n    const root = this.root;\n    start = Math.min(Math.max(0, start), root.size - 1);\n    let index = start;\n    do {\n      const entry = root.getEntry(index);\n      if (entry !== void 0 && this.compare(entry[0], id) === 0) {\n        return index;\n      }\n      index = (index + 1) % root.size;\n    } while (isFinite(index) && index !== start);\n    return -1;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport {Cursor} from \"@swim/util\";\nimport type {STreeContext} from \"./STreeContext\";\nimport type {STree} from \"./STree\";\nimport {STreeLeaf} from \"./\"; // forward import\n\n/** @internal */\nexport abstract class STreePage<V = unknown, I = unknown> {\n  abstract readonly arity: number;\n\n  abstract readonly size: number;\n\n  abstract isEmpty(): boolean;\n\n  abstract get(index: number): V | undefined;\n\n  abstract getEntry(index: number): [I, V] | undefined;\n\n  abstract updated(index: number, newValue: V, tree: STreeContext<V, I>): STreePage<V, I>;\n\n  abstract inserted(index: number, newValue: V, id: I | undefined, tree: STreeContext<V, I>): STreePage<V, I>;\n\n  abstract removed(index: number, tree: STreeContext<V, I>): STreePage<V, I>;\n\n  abstract drop(lower: number, tree: STreeContext<V, I>): STreePage<V, I>;\n\n  abstract take(upper: number, tree: STreeContext<V, I>): STreePage<V, I>;\n\n  abstract balanced(tree: STreeContext<V, I>): STreePage<V, I>;\n\n  abstract split(index: number): STreePage<V, I>;\n\n  abstract splitLeft(index: number): STreePage<V, I>;\n\n  abstract splitRight(index: number): STreePage<V, I>;\n\n  abstract forEach<T, S>(callback: (this: S, value: V, index: number, id: I, tree: STree<V, I>) => T | void,\n                         thisArg: S, offset: number, tree: STree<V, I>): T | undefined;\n\n  keys(): Cursor<I> {\n    return Cursor.keys(this.entries());\n  }\n\n  values(): Cursor<V> {\n    return Cursor.values(this.entries());\n  }\n\n  abstract entries(): Cursor<[I, V]>;\n\n  reverseKeys(): Cursor<I> {\n    return Cursor.keys(this.reverseEntries());\n  }\n\n  reverseValues(): Cursor<V> {\n    return Cursor.values(this.reverseEntries());\n  }\n\n  abstract reverseEntries(): Cursor<[I, V]>;\n\n  @Lazy\n  static empty<V, I>(): STreeLeaf<V, I> {\n    return new STreeLeaf<V, I>([]);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport type {STreeContext} from \"./STreeContext\";\nimport type {STree} from \"./STree\";\nimport {STreePage} from \"./STreePage\";\nimport {STreeNode} from \"./\"; // forward import\n\n/** @internal */\nexport class STreeLeaf<V, I> extends STreePage<V, I> {\n  constructor(slots: readonly [I, V][]) {\n    super();\n    this.slots = slots;\n  }\n\n  /** @internal */\n  readonly slots: readonly [I, V][];\n\n  override get arity(): number {\n    return this.slots.length;\n  }\n\n  override get size(): number {\n    return this.slots.length;\n  }\n\n  override isEmpty(): boolean {\n    return this.slots.length === 0;\n  }\n\n  override get(index: number): V | undefined {\n    const slot = this.slots[index];\n    if (slot === void 0) {\n      return void 0;\n    }\n    return slot[1];\n  }\n\n  override getEntry(index: number): [I, V] | undefined {\n    return this.slots[index];\n  }\n\n  override updated(index: number, newValue: V, tree: STreeContext<V, I>): STreeLeaf<V, I> {\n    if (index < 0 || index >= this.slots.length) {\n      throw new RangeError(\"\" + index);\n    }\n    return this.updatedItem(index, newValue);\n  }\n\n  /** @internal */\n  updatedItem(index: number, newValue: V): STreeLeaf<V, I> {\n    const oldItems = this.slots;\n    const oldSlot = oldItems[index];\n    if (oldSlot === void 0 || newValue === oldSlot[1]) {\n      return this;\n    }\n    const newValues = oldItems.slice(0);\n    newValues[index] = [oldSlot[0], newValue];\n    return new STreeLeaf<V, I>(newValues);\n  }\n\n  override inserted(index: number, newValue: V, id: I | undefined, tree: STreeContext<V, I>): STreeLeaf<V, I> {\n    if (index < 0 || index > this.slots.length) {\n      throw new RangeError(\"\" + index);\n    }\n    return this.insertedItem(index, newValue, id, tree);\n  }\n\n  /** @internal */\n  insertedItem(index: number, newValue: V, id: I | undefined, tree: STreeContext<V, I>): STreeLeaf<V, I> {\n    if (id === void 0) {\n      id = tree.identify(newValue);\n    }\n    const oldSlots = this.slots;\n    const newSlots = new Array<[I, V]>(oldSlots.length + 1);\n    for (let i = 0; i < index; i += 1) {\n      newSlots[i] = oldSlots[i]!;\n    }\n    newSlots[index] = [id, newValue];\n    for (let i = index; i < oldSlots.length; i += 1) {\n      newSlots[i + 1] = oldSlots[i]!;\n    }\n    return new STreeLeaf<V, I>(newSlots);\n  }\n\n  override removed(index: number, tree: STreeContext<V, I>): STreeLeaf<V, I> {\n    if (index < 0 || index >= this.slots.length) {\n      throw new RangeError(\"\" + index);\n    }\n    if (this.slots.length <= 1) {\n      return STreePage.empty();\n    }\n    return this.removedSlot(index);\n  }\n\n  /** @internal */\n  removedSlot(index: number): STreeLeaf<V, I> {\n    const oldSlots = this.slots;\n    const newSlots = new Array<[I, V]>(oldSlots.length - 1);\n    for (let i = 0; i < index; i += 1) {\n      newSlots[i] = oldSlots[i]!;\n    }\n    for (let i = index; i < newSlots.length; i += 1) {\n      newSlots[i] = oldSlots[i + 1]!;\n    }\n    return new STreeLeaf<V, I>(newSlots);\n  }\n\n  override drop(lower: number, tree: STreeContext<V, I>): STreeLeaf<V, I> {\n    const oldSlots = this.slots;\n    if (lower <= 0 || oldSlots.length === 0) {\n      return this;\n    } else if (lower >= oldSlots.length) {\n      return STreePage.empty();\n    }\n    const size = oldSlots.length - lower;\n    const newSlots = new Array<[I, V]>(size);\n    for (let i = 0; i < size; i += 1) {\n      newSlots[i] = oldSlots[i + lower]!;\n    }\n    return new STreeLeaf<V, I>(newSlots);\n  }\n\n  override take(upper: number, tree: STreeContext<V, I>): STreeLeaf<V, I> {\n    const oldSlots = this.slots;\n    if (upper >= oldSlots.length || oldSlots.length === 0) {\n      return this;\n    } else if (upper <= 0) {\n      return STreePage.empty();\n    }\n    const newSlots = new Array<[I, V]>(upper);\n    for (let i = 0; i < upper; i += 1) {\n      newSlots[i] = oldSlots[i]!;\n    }\n    return new STreeLeaf<V, I>(newSlots);\n  }\n\n  override balanced(tree: STreeContext<V, I>): STreePage<V, I> {\n    const size = this.slots.length;\n    if (size <= 1 || !tree.pageShouldSplit(this)) {\n      return this;\n    }\n    return this.split(size >>> 1);\n  }\n\n  override split(index: number): STreeNode<V, I> {\n    const newPages = new Array<STreePage<V, I>>(2);\n    const newLeftPage = this.splitLeft(index);\n    const newRightPage = this.splitRight(index);\n    newPages[0] = newLeftPage;\n    newPages[1] = newRightPage;\n\n    const newKnots = new Array<number>(1);\n    newKnots[0] = index;\n\n    return new STreeNode(newPages, newKnots, this.slots.length);\n  }\n\n  override splitLeft(index: number): STreeLeaf<V, I> {\n    const oldSlots = this.slots;\n    const newSlots = new Array<[I, V]>(index);\n    for (let i = 0; i < index; i += 1) {\n      newSlots[i] = oldSlots[i]!;\n    }\n    return new STreeLeaf<V, I>(newSlots);\n  }\n\n  override splitRight(index: number): STreeLeaf<V, I> {\n    const oldSlots = this.slots;\n    const newSize = oldSlots.length - index;\n    const newSlots = new Array<[I, V]>(newSize);\n    for (let i = 0; i < newSize; i += 1) {\n      newSlots[i] = oldSlots[i + index]!;\n    }\n    return new STreeLeaf<V, I>(newSlots);\n  }\n\n  override forEach<T, S>(callback: (this: S, value: V, index: number, id: I, tree: STree<V, I>) => T | void,\n                         thisArg: S, offset: number, tree: STree<V, I>): T | undefined {\n    for (let i = 0; i < this.slots.length; i += 1) {\n      const slot = this.slots[i]!;\n      const result = callback.call(thisArg, slot[1], offset + i, slot[0], tree);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return void 0;\n  }\n\n  override entries(): Cursor<[I, V]> {\n    return Cursor.array(this.slots);\n  }\n\n  override reverseEntries(): Cursor<[I, V]> {\n    return Cursor.array(this.slots, this.slots.length);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Cursor} from \"@swim/util\";\nimport {NodeCursor} from \"./NodeCursor\";\nimport type {STreeContext} from \"./STreeContext\";\nimport type {STree} from \"./STree\";\nimport {STreePage} from \"./STreePage\";\n\n/** @internal */\nexport class STreeNode<V, I> extends STreePage<V, I> {\n  constructor(pages: readonly STreePage<V, I>[], knots: readonly number[], size: number) {\n    super();\n    this.pages = pages;\n    this.knots = knots;\n    this.size = size;\n  }\n\n  /** @internal */\n  readonly pages: readonly STreePage<V, I>[];\n\n  /** @internal */\n  readonly knots: readonly number[];\n\n  override get arity(): number {\n    return this.pages.length;\n  }\n\n  override readonly size: number;\n\n  override isEmpty(): boolean {\n    return this.size === 0;\n  }\n\n  override get(index: number): V | undefined {\n    let x = this.lookup(index);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const i = x === 0 ? index : index - this.knots[x - 1]!;\n    return this.pages[x]!.get(i);\n  }\n\n  override getEntry(index: number): [I, V] | undefined {\n    let x = this.lookup(index);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const i = x === 0 ? index : index - this.knots[x - 1]!;\n    return this.pages[x]!.getEntry(i);\n  }\n\n  override updated(index: number, newValue: V, tree: STreeContext<V, I>): STreeNode<V, I> {\n    let x = this.lookup(index);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const i = x === 0 ? index : index - this.knots[x - 1]!;\n    const oldPage = this.pages[x]!;\n    const newPage = oldPage.updated(i, newValue, tree);\n    if (oldPage === newPage) {\n      return this;\n    } else if (oldPage.size !== newPage.size && tree.pageShouldSplit(newPage)) {\n      return this.updatedPageSplit(x, newPage, oldPage);\n    }\n    return this.updatedPage(x, newPage, oldPage);\n  }\n\n  /** @internal */\n  updatedPage(x: number, newPage: STreePage<V, I>, oldPage: STreePage<V, I>): STreeNode<V, I> {\n    const oldPages = this.pages;\n    const newPages = oldPages.slice(0);\n    newPages[x] = newPage;\n\n    const oldKnots = this.knots;\n    let newKnots: number[];\n    let newSize: number;\n    if (oldPages.length - 1 <= 0) {\n      newKnots = [];\n      newSize = 0;\n    } else {\n      newKnots = oldKnots.slice(0);\n      if (x > 0) {\n        newSize = oldKnots[x - 1]!;\n      } else {\n        newSize = 0;\n      }\n      for (let i = x; i < newKnots.length; i += 1) {\n        newSize += newPages[i]!.size;\n        newKnots[i] = newSize;\n      }\n      newSize += newPages[newKnots.length]!.size;\n    }\n\n    return new STreeNode(newPages, newKnots, newSize);\n  }\n\n  /** @internal */\n  updatedPageSplit(x: number, newPage: STreePage<V, I>, oldPage: STreePage<V, I>): STreeNode<V, I> {\n    const oldPages = this.pages;\n    const newPages = new Array<STreePage<V, I>>(oldPages.length + 1);\n    for (let i = 0; i < x; i += 1) {\n      newPages[i] = oldPages[i]!;\n    }\n\n    const newLeftPage = newPage.splitLeft(newPage.arity >>> 1);\n    const newRightPage = newPage.splitRight(newPage.arity >>> 1);\n    newPages[x] = newLeftPage;\n    newPages[x + 1] = newRightPage;\n    for (let i = x + 1; i < oldPages.length; i += 1) {\n      newPages[i + 1] = oldPages[i]!;\n    }\n\n    return STreeNode.create(newPages);\n  }\n\n  /** @internal */\n  updatedPageMerge(x: number, newPage: STreeNode<V, I>, oldPage: STreePage<V, I>): STreeNode<V, I> {\n    const oldPages = this.pages;\n    const midPages = newPage.pages;\n    const newPages = new Array<STreePage<V, I>>(oldPages.length + midPages.length - 1);\n    for (let i = 0; i < x; i += 1) {\n      newPages[i] = oldPages[i]!;\n    }\n    for (let i = 0; i < midPages.length; i += 1) {\n      newPages[i + x] = midPages[i]!;\n    }\n    for (let i = x + 1; i < oldPages.length; i += 1) {\n      newPages[i + midPages.length - 1] = oldPages[i]!;\n    }\n\n    return STreeNode.create(newPages);\n  }\n\n  override inserted(index: number, newValue: V, id: I | undefined, tree: STreeContext<V, I>): STreeNode<V, I> {\n    let x = this.lookup(index);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const subIndex = x === 0 ? index : index - this.knots[x - 1]!;\n    const oldPage = this.pages[x]!;\n    const newPage = oldPage.inserted(subIndex, newValue, id, tree);\n    if (oldPage === newPage) {\n      return this;\n    } else if (tree.pageShouldSplit(newPage)) {\n      return this.updatedPageSplit(x, newPage, oldPage);\n    }\n    return this.updatedPage(x, newPage, oldPage);\n  }\n\n  override removed(index: number, tree: STreeContext<V, I>): STreePage<V, I> {\n    let x = this.lookup(index);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const subIndex = x === 0 ? index : index - this.knots[x - 1]!;\n    const oldPage = this.pages[x]!;\n    const newPage = oldPage.removed(subIndex, tree);\n    if (oldPage === newPage) {\n      return this;\n    }\n    return this.replacedPage(x, newPage, oldPage, tree);\n  }\n\n  /** @internal */\n  replacedPage(x: number, newPage: STreePage<V, I>, oldPage: STreePage<V, I>,\n               tree: STreeContext<V, I>): STreePage<V, I> {\n    if (!newPage.isEmpty()) {\n      if (newPage instanceof STreeNode && tree.pageShouldMerge(newPage)) {\n        return this.updatedPageMerge(x, newPage, oldPage);\n      }\n      return this.updatedPage(x, newPage, oldPage);\n    } else if (this.pages.length > 2) {\n      return this.removedPage(x, newPage, oldPage);\n    } else if (this.pages.length > 1) {\n      if (x === 0) {\n        return this.pages[1]!;\n      } else {\n        return this.pages[0]!;\n      }\n    }\n    return STreePage.empty();\n  }\n\n  /** @internal */\n  removedPage(x: number, newPage: STreePage<V, I>, oldPage: STreePage<V, I>): STreeNode<V, I> {\n    const oldPages = this.pages;\n    const newPages = new Array<STreePage<V, I>>(oldPages.length - 1);\n    for (let i = 0; i < x; i += 1) {\n      newPages[i] = oldPages[i]!;\n    }\n    for (let i = x + 1; i < oldPages.length; i += 1) {\n      newPages[i - 1] = oldPages[i]!;\n    }\n\n    const oldKnots = this.knots;\n    const newKnots = new Array<number>(oldKnots.length - 1);\n    let newSize: number;\n    if (x <= 0) {\n      newSize = 0;\n    } else {\n      for (let i = 0; i < x; i += 1) {\n        newKnots[i] = oldKnots[i]!;\n      }\n      newSize = oldKnots[x - 1]!;\n    }\n    for (let i = x; i < newKnots.length; i += 1) {\n      newSize += newPages[i]!.size;\n      newKnots[i] = newSize;\n    }\n    newSize += newPages[newKnots.length]!.size;\n\n    return new STreeNode(newPages, newKnots, newSize);\n  }\n\n  override drop(lower: number, tree: STreeContext<V, I>): STreePage<V, I> {\n    if (lower <= 0) {\n      return this;\n    } else if (lower >= this.size) {\n      return STreePage.empty();\n    }\n    let x = this.lookup(lower);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    lower = x === 0 ? lower : lower - this.knots[x - 1]!;\n    const oldPages = this.pages;\n    const n = oldPages.length - x;\n    if (n <= 1) {\n      return oldPages[x]!.drop(lower, tree);\n    }\n    let newNode: STreeNode<V, I>;\n    if (x <= 0) {\n      newNode = this;\n    } else {\n      const newPages = new Array<STreePage<V, I>>(n);\n      for (let i = 0; i < n; i += 1) {\n        newPages[i] = oldPages[i + x]!;\n      }\n      newNode = STreeNode.create(newPages);\n    }\n    if (lower <= 0) {\n      return newNode;\n    }\n    const oldPage = oldPages[x]!;\n    const newPage = oldPage.drop(lower, tree);\n    return newNode.replacedPage(0, newPage, oldPage, tree);\n  }\n\n  override take(upper: number, tree: STreeContext<V, I>): STreePage<V, I> {\n    if (upper >= this.size) {\n      return this;\n    } else if (upper <= 0) {\n      return STreePage.empty();\n    }\n    let x = this.lookup(upper);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    upper = x === 0 ? upper : upper - this.knots[x - 1]!;\n    const oldPages = this.pages;\n    const n = upper === 0 ? x : x + 1;\n    if (n <= 1) {\n      if (upper > 0) {\n        return oldPages[0]!.take(upper, tree);\n      } else {\n        return oldPages[0]!;\n      }\n    }\n    let newNode: STreeNode<V, I>;\n    if (x >= oldPages.length) {\n      newNode = this;\n    } else {\n      const newPages = new Array<STreePage<V, I>>(n);\n      for (let i = 0; i < n; i += 1) {\n        newPages[i] = oldPages[i]!;\n      }\n      const newKnots = new Array<number>(n - 1);\n      for (let i = 0; i < newKnots.length; i += 1) {\n        newKnots[i] = this.knots[i]!;\n      }\n      const newSize = newKnots[n - 2]! + newPages[n - 1]!.size;\n      newNode = new STreeNode(newPages, newKnots, newSize);\n    }\n    if (upper <= 0) {\n      return newNode;\n    }\n    const oldPage = oldPages[x]!;\n    const newPage = oldPage.take(upper, tree);\n    return newNode.replacedPage(x, newPage, oldPage, tree);\n  }\n\n  override balanced(tree: STreeContext<V, I>): STreeNode<V, I> {\n    if (this.pages.length <= 1 || !tree.pageShouldSplit(this)) {\n      return this;\n    }\n    return this.split(this.knots.length >>> 1);\n  }\n\n  override split(x: number): STreeNode<V, I> {\n    const newPages = new Array<STreePage<V, I>>(2);\n    const newLeftPage = this.splitLeft(x);\n    const newRightPage = this.splitRight(x);\n    newPages[0] = newLeftPage;\n    newPages[1] = newRightPage;\n\n    const newKnots = new Array<number>(1);\n    newKnots[0] = newLeftPage.size;\n\n    return new STreeNode(newPages, newKnots, this.size);\n  }\n\n  override splitLeft(x: number): STreeNode<V, I> {\n    const oldPages = this.pages;\n    const newPages = new Array<STreePage<V, I>>(x + 1);\n    for (let i = 0; i < x + 1; i += 1) {\n      newPages[i] = oldPages[i]!;\n    }\n\n    const oldKnots = this.knots;\n    const newKnots = new Array<number>(x);\n    for (let i = 0; i < x; i += 1) {\n      newKnots[i] = oldKnots[i]!;\n    }\n\n    let newSize = 0;\n    for (let i = 0; i <= x; i += 1) {\n      newSize += newPages[i]!.size;\n    }\n\n    return new STreeNode(newPages, newKnots, newSize);\n  }\n\n  override splitRight(x: number): STreeNode<V, I> {\n    const oldPages = this.pages;\n    const y = oldPages.length - (x + 1);\n    const newPages = new Array<STreePage<V, I>>(y);\n    for (let i = 0; i < y; i += 1) {\n      newPages[i] = oldPages[i + (x + 1)]!;\n    }\n\n    const newKnots = new Array<number>(y - 1);\n    let newSize;\n    if (y <= 0) {\n      newSize = 0;\n    } else {\n      newSize = newPages[0]!.size;\n      for (let i = 1; i < y; i += 1) {\n        newKnots[i - 1] = newSize;\n        newSize += newPages[i]!.size;\n      }\n    }\n\n    return new STreeNode(newPages, newKnots, newSize);\n  }\n\n  override forEach<T, S>(callback: (this: S, value: V, index: number, id: I, tree: STree<V, I>) => T | void,\n                         thisArg: S, offset: number, tree: STree<V, I>): T | undefined {\n    for (let i = 0; i < this.pages.length; i += 1) {\n      const page = this.pages[i]!;\n      const result = page.forEach(callback, thisArg, offset, tree);\n      if (result !== void 0) {\n        return result;\n      }\n      offset += page.size;\n    }\n    return void 0;\n  }\n\n  override entries(): Cursor<[I, V]> {\n    return new STreeNodeCursor(this.pages);\n  }\n\n  override reverseEntries(): Cursor<[I, V]> {\n    return new STreeNodeCursor(this.pages, this.size, this.pages.length);\n  }\n\n  /** @internal */\n  lookup(index: number): number {\n    let lo = 0;\n    let hi = this.knots.length - 1;\n    while (lo <= hi) {\n      const mid = (lo + hi) >>> 1;\n      if (index > this.knots[mid]!) {\n        lo = mid + 1;\n      } else if (index < this.knots[mid]!) {\n        hi = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n    return -(lo + 1);\n  }\n\n  static create<V, I>(pages: readonly STreePage<V, I>[]): STreeNode<V, I> {\n    const knots = new Array<number>(pages.length - 1);\n    let size = 0;\n    for (let i = 0, n  = knots.length; i < n; i += 1) {\n      size += pages[i]!.size;\n      knots[i] = size;\n    }\n    size += pages[knots.length]!.size;\n    return new STreeNode(pages, knots, size);\n  }\n}\n\n/** @internal */\nexport class STreeNodeCursor<V, I> extends NodeCursor<[I, V], STreePage<V, I>> {\n  constructor(pages: readonly STreePage<V, I>[], index: number = 0,\n              childIndex: number = 0, childCursor: Cursor<[I, V]> | null = null) {\n    super(pages, index, childIndex, childCursor);\n  }\n\n  protected override pageSize(page: STreePage<V, I>): number {\n    return page.size;\n  }\n\n  protected override pageCursor(page: STreePage<V, I>): Cursor<[I, V]> {\n    return page.entries();\n  }\n\n  protected override reversePageCursor(page: STreePage<V, I>): Cursor<[I, V]> {\n    return page.reverseEntries();\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport type {Constraint} from \"./Constraint\";\nimport type {ConstraintSolver} from \"./ConstraintSolver\";\n\n/** @public */\nexport interface ConstraintSymbol {\n  /** @internal */\n  isExternal(): boolean;\n\n  /** @internal */\n  isDummy(): boolean;\n\n  /** @internal */\n  isInvalid(): boolean;\n\n  /** @internal */\n  addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;\n\n  /** @internal */\n  removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;\n\n  /** @internal */\n  updateConstraintSolution(value: number): void;\n}\n\n/** @public */\nexport const ConstraintSymbol = {\n  /** @internal */\n  invalid: Lazy(function (): ConstraintSymbol {\n    return new ConstraintInvalid();\n  }),\n};\n\n/** @internal */\nexport class ConstraintSlack implements ConstraintSymbol {\n  isExternal(): boolean {\n    return false;\n  }\n\n  isDummy(): boolean {\n    return false;\n  }\n\n  isInvalid(): boolean {\n    return false;\n  }\n\n  addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void {\n    // nop\n  }\n\n  removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void {\n    // nop\n  }\n\n  updateConstraintSolution(value: number): void {\n    // nop\n  }\n}\n\n/** @internal */\nexport class ConstraintDummy implements ConstraintSymbol {\n  isExternal(): boolean {\n    return false;\n  }\n\n  isDummy(): boolean {\n    return true;\n  }\n\n  isInvalid(): boolean {\n    return false;\n  }\n\n  addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void {\n    // nop\n  }\n\n  removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void {\n    // nop\n  }\n\n  updateConstraintSolution(value: number): void {\n    // nop\n  }\n}\n\n/** @internal */\nexport class ConstraintError implements ConstraintSymbol {\n  isExternal(): boolean {\n    return false;\n  }\n\n  isDummy(): boolean {\n    return false;\n  }\n\n  isInvalid(): boolean {\n    return false;\n  }\n\n  addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void {\n    // nop\n  }\n\n  removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void {\n    // nop\n  }\n\n  updateConstraintSolution(value: number): void {\n    // nop\n  }\n}\n\n/** @internal */\nexport class ConstraintInvalid implements ConstraintSymbol {\n  isExternal(): boolean {\n    return false;\n  }\n\n  isDummy(): boolean {\n    return false;\n  }\n\n  isInvalid(): boolean {\n    return true;\n  }\n\n  addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void {\n    // nop\n  }\n\n  removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void {\n    // nop\n  }\n\n  updateConstraintSolution(value: number): void {\n    // nop\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport type {ConstraintVariable} from \"./ConstraintVariable\";\nimport {ConstraintSum} from \"./\"; // forward import\nimport {ConstraintTerm} from \"./\"; // forward import\nimport {ConstraintProduct} from \"./\"; // forward import\nimport {ConstraintConstant} from \"./\"; // forward import\n\n/** @public */\nexport type ConstraintExpressionLike = ConstraintExpression | number;\n\n/** @public */\nexport const ConstraintExpressionLike = {\n  [Symbol.hasInstance](instance: unknown): instance is ConstraintExpressionLike {\n    return ConstraintExpression[Symbol.hasInstance](instance)\n        || typeof instance === \"number\";\n  },\n};\n\n/** @public */\nexport interface ConstraintExpression {\n  readonly terms: ReadonlyMap<ConstraintVariable, number>;\n\n  readonly constant: number;\n\n  isConstant(): boolean;\n\n  plus(that: ConstraintExpressionLike): ConstraintExpression;\n\n  negative(): ConstraintExpression;\n\n  minus(that: ConstraintExpressionLike): ConstraintExpression;\n\n  times(scalar: number): ConstraintExpression;\n\n  divide(scalar: number): ConstraintExpression;\n}\n\n/** @public */\nexport const ConstraintExpression = {\n  zero: Lazy(function (): ConstraintConstant {\n    return new ConstraintConstant(0);\n  }),\n\n  constant(value: number): ConstraintConstant {\n    if (value === 0) {\n      return ConstraintExpression.zero();\n    }\n    return new ConstraintConstant(value);\n  },\n\n  sum(...expressions: ConstraintExpressionLike[]): ConstraintSum {\n    const terms = new Map<ConstraintVariable, number>();\n    let constant = 0;\n    for (let i = 0; i < expressions.length; i += 1) {\n      const expression = expressions[i]!;\n      if (typeof expression === \"number\") {\n        constant += expression;\n      } else if (ConstraintTerm[Symbol.hasInstance](expression)) {\n        const variable = expression.variable;\n        if (variable === null) {\n          constant += expression.constant;\n        } else {\n          let value = terms.get(variable);\n          if (value === void 0) {\n            value = 0;\n          }\n          terms.set(variable, value + expression.coefficient);\n        }\n      } else {\n        for (const [variable, coefficient] of expression.terms) {\n          let value = terms.get(variable);\n          if (value === void 0) {\n            value = 0;\n          }\n          terms.set(variable, value + coefficient);\n        }\n        constant += expression.constant;\n      }\n    }\n    return new ConstraintSum(terms, constant);\n  },\n\n  product(coefficient: number, variable: ConstraintVariable): ConstraintProduct {\n    return new ConstraintProduct(coefficient, variable);\n  },\n\n  fromLike<T extends ConstraintExpressionLike | null | undefined>(value: T): ConstraintExpression | Uninitable<T> {\n    if (value == void 0 || value === null || ConstraintExpression[Symbol.hasInstance](value)) {\n      return value as ConstraintExpression | Uninitable<T>;\n    } else if (typeof value === \"number\") {\n      return ConstraintExpression.constant(value);\n    }\n    throw new TypeError(\"\" + value);\n  },\n\n  [Symbol.hasInstance](instance: unknown): instance is ConstraintExpression {\n    return Objects.hasAllKeys<ConstraintExpression>(instance, \"terms\", \"constant\");\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport type {ConstraintExpressionLike} from \"./ConstraintExpression\";\nimport {ConstraintExpression} from \"./ConstraintExpression\";\nimport type {ConstraintVariable} from \"./ConstraintVariable\";\n\n/** @public */\nexport class ConstraintSum implements ConstraintExpression, Debug {\n  constructor(terms: ReadonlyMap<ConstraintVariable, number>, constant: number) {\n    this.terms = terms;\n    this.constant = constant;\n  }\n\n  isConstant(): boolean {\n    return this.terms.size === 0;\n  }\n\n  readonly terms: ReadonlyMap<ConstraintVariable, number>;\n\n  readonly constant: number;\n\n  plus(that: ConstraintExpressionLike): ConstraintExpression {\n    return ConstraintExpression.sum(this, that);\n  }\n\n  negative(): ConstraintExpression {\n    const terms = new Map<ConstraintVariable, number>();\n    for (const [variable, coefficient] of this.terms) {\n      terms.set(variable, -coefficient);\n    }\n    return new ConstraintSum(terms, -this.constant);\n  }\n\n  minus(that: ConstraintExpressionLike): ConstraintExpression {\n    that = ConstraintExpression.fromLike(that).negative();\n    return ConstraintExpression.sum(this, that);\n  }\n\n  times(scalar: number): ConstraintExpression {\n    const terms = new Map<ConstraintVariable, number>();\n    for (const [variable, coefficient] of this.terms) {\n      terms.set(variable, coefficient * scalar);\n    }\n    return new ConstraintSum(terms, this.constant * scalar);\n  }\n\n  divide(scalar: number): ConstraintExpression {\n    const terms = new Map<ConstraintVariable, number>();\n    for (const [variable, coefficient] of this.terms) {\n      terms.set(variable, coefficient / scalar);\n    }\n    return new ConstraintSum(terms, this.constant / scalar);\n  }\n\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"ConstraintExpression\").write(46/*'.'*/).write(\"sum\").write(40/*'('*/);\n    let i = 0;\n    for (const [variable, coefficient] of this.terms) {\n      if (i > 0) {\n        output = output.write(\", \");\n      }\n      if (coefficient === 1) {\n        output = output.debug(variable);\n      } else {\n        output = output.debug(ConstraintExpression.product(coefficient, variable));\n      }\n      i += 1;\n    }\n    if (this.constant !== 0) {\n      if (i !== 0) {\n        output = output.write(\", \");\n      }\n      output = output.debug(this.constant);\n    }\n    output = output.write(41/*')'*/);\n    return output;\n  }\n\n  toString(): string {\n    return Format.debug(this);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Objects} from \"@swim/util\";\nimport type {ConstraintExpression} from \"./ConstraintExpression\";\nimport type {ConstraintVariable} from \"./ConstraintVariable\";\n\n/** @public */\nexport interface ConstraintTerm extends ConstraintExpression {\n  readonly coefficient: number;\n\n  readonly variable: ConstraintVariable | null;\n\n  negative(): ConstraintTerm;\n}\n\n/** @public */\nexport const ConstraintTerm = {\n  [Symbol.hasInstance](instance: unknown): instance is ConstraintTerm {\n    return Objects.hasAllKeys<ConstraintTerm>(instance, \"coefficient\", \"variable\");\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport type {ConstraintExpressionLike} from \"./ConstraintExpression\";\nimport {ConstraintExpression} from \"./ConstraintExpression\";\nimport type {ConstraintTerm} from \"./ConstraintTerm\";\nimport type {ConstraintVariable} from \"./ConstraintVariable\";\n\n/** @public */\nexport class ConstraintProduct implements ConstraintTerm, Debug {\n  constructor(coefficient: number, variable: ConstraintVariable) {\n    this.coefficient = coefficient;\n    this.variable = variable;\n  }\n\n  isConstant(): boolean {\n    return false;\n  }\n\n  readonly coefficient: number;\n\n  readonly variable: ConstraintVariable;\n\n  get terms(): ReadonlyMap<ConstraintVariable, number> {\n    const terms = new Map<ConstraintVariable, number>();\n    terms.set(this.variable, this.coefficient);\n    return terms;\n  }\n\n  get constant(): number {\n    return 0;\n  }\n\n  plus(that: ConstraintExpressionLike): ConstraintExpression {\n    that = ConstraintExpression.fromLike(that);\n    if (that instanceof ConstraintProduct && this.variable === that.variable) {\n      return ConstraintExpression.product(this.coefficient + that.coefficient, this.variable);\n    } else if (this.variable === that) {\n      return ConstraintExpression.product(this.coefficient + 1, this.variable);\n    }\n    return ConstraintExpression.sum(this, that);\n  }\n\n  negative(): ConstraintTerm {\n    return ConstraintExpression.product(-this.coefficient, this.variable);\n  }\n\n  minus(that: ConstraintExpressionLike): ConstraintExpression {\n    that = ConstraintExpression.fromLike(that);\n    if (that instanceof ConstraintProduct && this.variable === that.variable) {\n      return ConstraintExpression.product(this.coefficient - that.coefficient, this.variable);\n    } else if (this.variable === that) {\n      return ConstraintExpression.product(this.coefficient - 1, this.variable);\n    }\n    return ConstraintExpression.sum(this, that.negative());\n  }\n\n  times(scalar: number): ConstraintExpression {\n    return ConstraintExpression.product(this.coefficient * scalar, this.variable);\n  }\n\n  divide(scalar: number): ConstraintExpression {\n    return ConstraintExpression.product(this.coefficient / scalar, this.variable);\n  }\n\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"ConstraintExpression\").write(46/*'.'*/).write(\"product\").write(40/*'('*/)\n                   .debug(this.coefficient).write(\", \").debug(this.variable).write(41/*')'*/);\n    return output;\n  }\n\n  toString(): string {\n    return Format.debug(this);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport type {ConstraintExpressionLike} from \"./ConstraintExpression\";\nimport {ConstraintExpression} from \"./ConstraintExpression\";\nimport type {ConstraintTerm} from \"./ConstraintTerm\";\nimport type {ConstraintVariable} from \"./ConstraintVariable\";\n\n/** @public */\nexport class ConstraintConstant implements ConstraintTerm, Debug {\n  constructor(constant: number) {\n    this.constant = constant;\n  }\n\n  isConstant(): boolean {\n    return true;\n  }\n\n  get coefficient(): number {\n    return 0;\n  }\n\n  get variable(): ConstraintVariable | null {\n    return null;\n  }\n\n  get terms(): ReadonlyMap<ConstraintVariable, number> {\n    return new Map<ConstraintVariable, number>();\n  }\n\n  readonly constant: number;\n\n  plus(that: ConstraintExpressionLike): ConstraintExpression {\n    that = ConstraintExpression.fromLike(that);\n    if (that instanceof ConstraintConstant) {\n      return ConstraintExpression.constant(this.constant + that.constant);\n    }\n    return ConstraintExpression.sum(this, that);\n  }\n\n  negative(): ConstraintTerm {\n    return ConstraintExpression.constant(-this.constant);\n  }\n\n  minus(that: ConstraintExpressionLike): ConstraintExpression {\n    that = ConstraintExpression.fromLike(that);\n    if (that instanceof ConstraintConstant) {\n      return ConstraintExpression.constant(this.constant - that.constant);\n    }\n    return ConstraintExpression.sum(this, that.negative());\n  }\n\n  times(scalar: number): ConstraintExpression {\n    return ConstraintExpression.constant(this.constant * scalar);\n  }\n\n  divide(scalar: number): ConstraintExpression {\n    return ConstraintExpression.constant(this.constant / scalar);\n  }\n\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"ConstraintExpression\").write(46/*'.'*/);\n    if (this.constant === 0) {\n      output = output.write(\"zero\").write(40/*'('*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"constant\").write(40/*'('*/).debug(this.constant).write(41/*')'*/);\n    }\n    return output;\n  }\n\n  toString(): string {\n    return Format.debug(this);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport type {Proto} from \"@swim/util\";\nimport {Affinity} from \"@swim/component\";\nimport type {FastenerFlags} from \"@swim/component\";\nimport type {FastenerClass} from \"@swim/component\";\nimport type {Fastener} from \"@swim/component\";\nimport type {PropertyDescriptor} from \"@swim/component\";\nimport type {PropertyClass} from \"@swim/component\";\nimport {Property} from \"@swim/component\";\nimport type {ConstraintExpressionLike} from \"./ConstraintExpression\";\nimport {ConstraintExpression} from \"./ConstraintExpression\";\nimport type {ConstraintTerm} from \"./ConstraintTerm\";\nimport type {ConstraintVariable} from \"./ConstraintVariable\";\nimport type {ConstraintStrengthLike} from \"./Constraint\";\nimport {ConstraintStrength} from \"./\"; // forward import\nimport type {Constraint} from \"./Constraint\";\nimport {ConstraintScope} from \"./\"; // forward import\nimport type {ConstraintSolver} from \"./ConstraintSolver\";\n\n/** @public */\nexport interface ConstraintPropertyDescriptor<R, T> extends PropertyDescriptor<R, T> {\n  extends?: Proto<ConstraintProperty<any, any, any>> | boolean | null;\n  strength?: ConstraintStrengthLike;\n  constrained?: boolean;\n}\n\n/** @public */\nexport interface ConstraintPropertyClass<P extends ConstraintProperty<any, any, any> = ConstraintProperty<any, any, any>> extends PropertyClass<P> {\n  /** @internal */\n  readonly ConstrainedFlag: FastenerFlags;\n  /** @internal */\n  readonly ConstrainingFlag: FastenerFlags;\n\n  /** @internal @override */\n  readonly FlagShift: number;\n  /** @internal @override */\n  readonly FlagMask: FastenerFlags;\n}\n\n/** @public */\nexport interface ConstraintProperty<R = any, T = any, I extends any[] = [T]> extends Property<R, T, I>, ConstraintVariable {\n  /** @override */\n  get descriptorType(): Proto<ConstraintPropertyDescriptor<R, T>>;\n\n  /** @internal @override */\n  isExternal(): boolean;\n\n  /** @internal @override */\n  isDummy(): boolean;\n\n  /** @internal @override */\n  isInvalid(): boolean;\n\n  /** @override */\n  isConstant(): boolean;\n\n  /** @internal @override */\n  evaluateConstraintVariable(): void;\n\n  /** @internal @override */\n  updateConstraintSolution(value: number): void;\n\n  /** @internal @protected */\n  initStrength(): ConstraintStrength;\n\n  /** @override */\n  readonly strength: ConstraintStrength;\n\n  setStrength(strength: ConstraintStrengthLike): void;\n\n  /** @override */\n  get coefficient(): number;\n\n  /** @override */\n  get variable(): ConstraintVariable | null;\n\n  /** @override */\n  get terms(): ReadonlyMap<ConstraintVariable, number>;\n\n  /** @override */\n  get constant(): number;\n\n  /** @override */\n  plus(that: ConstraintExpressionLike): ConstraintExpression;\n\n  /** @override */\n  negative(): ConstraintTerm;\n\n  /** @override */\n  minus(that: ConstraintExpressionLike): ConstraintExpression;\n\n  /** @override */\n  times(scalar: number): ConstraintExpression;\n\n  /** @override */\n  divide(scalar: number): ConstraintExpression;\n\n  get constrained(): boolean;\n\n  constrain(constrained?: boolean): this;\n\n  /** @internal */\n  readonly conditionCount: number;\n\n  /** @internal @override */\n  addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;\n\n  /** @internal @override */\n  removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;\n\n  /** @internal */\n  get constraining(): boolean;\n\n  /** @internal */\n  startConstraining(): void;\n\n  /** @protected */\n  willStartConstraining(): void;\n\n  /** @protected */\n  onStartConstraining(): void;\n\n  /** @protected */\n  didStartConstraining(): void;\n\n  /** @internal */\n  stopConstraining(): void;\n\n  /** @protected */\n  willStopConstraining(): void;\n\n  /** @protected */\n  onStopConstraining(): void;\n\n  /** @protected */\n  didStopConstraining(): void;\n\n  /** @internal */\n  updateConstraintVariable(): void;\n\n  /** @protected @override */\n  onSetValue(newValue: T, oldValue: T): void;\n\n  /** @protected @override */\n  onMount(): void;\n\n  /** @protected @override */\n  onUnmount(): void;\n\n  /** @internal @protected */\n  toNumber(value: T): number;\n}\n\n/** @public */\nexport const ConstraintProperty = (<R, T, I extends any[], P extends ConstraintProperty<any, any, any>>() => Property.extend<ConstraintProperty<R, T, I>, ConstraintPropertyClass<P>>(\"ConstraintProperty\", {\n  isExternal(): boolean {\n    return true;\n  },\n\n  isDummy(): boolean {\n    return false;\n  },\n\n  isInvalid(): boolean {\n    return false;\n  },\n\n  isConstant(): boolean {\n    return false;\n  },\n\n  evaluateConstraintVariable(): void {\n    // hook\n  },\n\n  updateConstraintSolution(value: number): void {\n    if (this.constrained && this.toNumber(this.value) !== value) {\n      this.setValue(value as unknown as T, Affinity.Reflexive);\n    }\n  },\n\n  initStrength(): ConstraintStrength {\n    let strength = (Object.getPrototypeOf(this) as ConstraintProperty<any, any, any>).strength as ConstraintStrength | undefined;\n    if (strength === void 0) {\n      strength = ConstraintStrength.Strong;\n    }\n    return strength;\n  },\n\n  setStrength(strength: ConstraintStrengthLike): void {\n    (this as Mutable<typeof this>).strength = ConstraintStrength.fromLike(strength);\n  },\n\n  get coefficient(): number {\n    return 1;\n  },\n\n  get variable(): ConstraintVariable {\n    return this;\n  },\n\n  get terms(): ReadonlyMap<ConstraintVariable, number> {\n    const terms = new Map<ConstraintVariable, number>();\n    terms.set(this, 1);\n    return terms;\n  },\n\n  get constant(): number {\n    return 0;\n  },\n\n  plus(that: ConstraintExpressionLike): ConstraintExpression {\n    that = ConstraintExpression.fromLike(that);\n    if (this === that) {\n      return ConstraintExpression.product(2, this);\n    }\n    return ConstraintExpression.sum(this, that);\n  },\n\n  negative(): ConstraintTerm {\n    return ConstraintExpression.product(-1, this);\n  },\n\n  minus(that: ConstraintExpressionLike): ConstraintExpression {\n    that = ConstraintExpression.fromLike(that);\n    if (this === that) {\n      return ConstraintExpression.zero();\n    }\n    return ConstraintExpression.sum(this, that.negative());\n  },\n\n  times(scalar: number): ConstraintExpression {\n    return ConstraintExpression.product(scalar, this);\n  },\n\n  divide(scalar: number): ConstraintExpression {\n    return ConstraintExpression.product(1 / scalar, this);\n  },\n\n  get constrained(): boolean {\n    return (this.flags & ConstraintProperty.ConstrainedFlag) !== 0;\n  },\n\n  constrain(constrained?: boolean): typeof this {\n    if (constrained === void 0) {\n      constrained = true;\n    }\n    const flags = this.flags;\n    if (constrained && (flags & ConstraintProperty.ConstrainedFlag) === 0) {\n      this.setFlags(flags | ConstraintProperty.ConstrainedFlag);\n      if (this.conditionCount !== 0 && this.mounted) {\n        this.stopConstraining();\n      }\n    } else if (!constrained && (flags & ConstraintProperty.ConstrainedFlag) !== 0) {\n      this.setFlags(flags & ~ConstraintProperty.ConstrainedFlag);\n      if (this.conditionCount !== 0 && this.mounted) {\n        this.startConstraining();\n        this.updateConstraintVariable();\n      }\n    }\n    return this;\n  },\n\n  addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void {\n    (this as Mutable<typeof this>).conditionCount += 1;\n    if (!this.constrained && this.conditionCount === 1 && this.mounted) {\n      this.startConstraining();\n      this.updateConstraintVariable();\n    }\n  },\n\n  removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void {\n    (this as Mutable<typeof this>).conditionCount -= 1;\n    if (!this.constrained && this.conditionCount === 0 && this.mounted) {\n      this.stopConstraining();\n    }\n  },\n\n  get constraining(): boolean {\n    return (this.flags & ConstraintProperty.ConstrainingFlag) !== 0;\n  },\n\n  startConstraining(): void {\n    if ((this.flags & ConstraintProperty.ConstrainingFlag) !== 0) {\n      return;\n    }\n    this.willStartConstraining();\n    this.setFlags(this.flags | ConstraintProperty.ConstrainingFlag);\n    this.onStartConstraining();\n    this.didStartConstraining();\n  },\n\n  willStartConstraining(): void {\n    // hook\n  },\n\n  onStartConstraining(): void {\n    const constraintScope = this.owner;\n    if (ConstraintScope[Symbol.hasInstance](constraintScope)) {\n      constraintScope.addConstraintVariable(this);\n    }\n  },\n\n  didStartConstraining(): void {\n    // hook\n  },\n\n  stopConstraining(): void {\n    if ((this.flags & ConstraintProperty.ConstrainingFlag) === 0) {\n      return;\n    }\n    this.willStopConstraining();\n    this.setFlags(this.flags & ~ConstraintProperty.ConstrainingFlag);\n    this.onStopConstraining();\n    this.didStopConstraining();\n  },\n\n  willStopConstraining(): void {\n    // hook\n  },\n\n  onStopConstraining(): void {\n    const constraintScope = this.owner;\n    if (ConstraintScope[Symbol.hasInstance](constraintScope)) {\n      constraintScope.removeConstraintVariable(this);\n    }\n  },\n\n  didStopConstraining(): void {\n    // hook\n  },\n\n  updateConstraintVariable(): void {\n    const constraintScope = this.owner;\n    const value = this.value;\n    if (value !== void 0 && ConstraintScope[Symbol.hasInstance](constraintScope)) {\n      constraintScope.setConstraintVariable(this, this.toNumber(value));\n    }\n  },\n\n  onSetValue(newValue: T, oldValue: T): void {\n    super.onSetValue(newValue, oldValue);\n    const constraintScope = this.owner;\n    if (this.constraining && ConstraintScope[Symbol.hasInstance](constraintScope)) {\n      constraintScope.setConstraintVariable(this, newValue !== void 0 && newValue !== null ? this.toNumber(newValue) : 0);\n    }\n  },\n\n  onMount(): void {\n    super.onMount();\n    if (!this.constrained && this.conditionCount !== 0) {\n      this.startConstraining();\n    }\n  },\n\n  onUnmount(): void {\n    if (!this.constrained && this.conditionCount !== 0) {\n      this.stopConstraining();\n    }\n    super.onUnmount();\n  },\n\n  toNumber(value: T): number {\n    return value !== void 0 && value !== null ? +value : 0;\n  },\n},\n{\n  construct(property: P | null, owner: P extends Fastener<infer R, any, any> ? R : never): P {\n    property = super.construct(property, owner) as P;\n    (property as Mutable<typeof property>).strength = property.initStrength();\n    (property as Mutable<typeof property>).conditionCount = 0;\n    return property;\n  },\n\n  refine(propertyClass: FastenerClass<ConstraintProperty<any, any, any>>): void {\n    super.refine(propertyClass);\n    const propertyPrototype = propertyClass.prototype;\n\n    let flagsInit = propertyPrototype.flagsInit;\n    if (Object.prototype.hasOwnProperty.call(propertyPrototype, \"constrained\")) {\n      if (propertyPrototype.constrained) {\n        flagsInit |= ConstraintProperty.ConstrainedFlag;\n      } else {\n        flagsInit &= ~ConstraintProperty.ConstrainedFlag;\n      }\n      delete (propertyPrototype as ConstraintPropertyDescriptor<any, any>).constrained;\n    }\n    Object.defineProperty(propertyPrototype, \"flagsInit\", {\n      value: flagsInit,\n      enumerable: true,\n      configurable: true,\n    });\n\n    const strengthDescriptor = Object.getOwnPropertyDescriptor(propertyPrototype, \"strength\");\n    if (strengthDescriptor !== void 0 && \"value\" in strengthDescriptor) {\n      strengthDescriptor.value = ConstraintStrength.fromLike(strengthDescriptor.value);\n      Object.defineProperty(propertyPrototype, \"strength\", strengthDescriptor);\n    }\n  },\n\n  ConstrainedFlag: 1 << (Property.FlagShift + 0),\n  ConstrainingFlag: 1 << (Property.FlagShift + 1),\n\n  FlagShift: Property.FlagShift + 2,\n  FlagMask: (1 << (Property.FlagShift + 2)) - 1,\n}))();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport type {Proto} from \"@swim/util\";\nimport {Affinity} from \"@swim/component\";\nimport type {FastenerFlags} from \"@swim/component\";\nimport type {FastenerClass} from \"@swim/component\";\nimport type {Fastener} from \"@swim/component\";\nimport type {AnimatorDescriptor} from \"@swim/component\";\nimport type {AnimatorClass} from \"@swim/component\";\nimport {Animator} from \"@swim/component\";\nimport type {ConstraintExpressionLike} from \"./ConstraintExpression\";\nimport {ConstraintExpression} from \"./ConstraintExpression\";\nimport type {ConstraintTerm} from \"./ConstraintTerm\";\nimport type {ConstraintVariable} from \"./ConstraintVariable\";\nimport type {ConstraintStrengthLike} from \"./Constraint\";\nimport {ConstraintStrength} from \"./\"; // forward import\nimport type {Constraint} from \"./Constraint\";\nimport {ConstraintScope} from \"./\"; // forward import\nimport type {ConstraintSolver} from \"./ConstraintSolver\";\n\n/** @public */\nexport interface ConstraintAnimatorDescriptor<R, T> extends AnimatorDescriptor<R, T> {\n  extends?: Proto<ConstraintAnimator<any, any, any>> | boolean | null;\n  strength?: ConstraintStrengthLike;\n  constrained?: boolean;\n}\n\n/** @public */\nexport interface ConstraintAnimatorClass<A extends ConstraintAnimator<any, any, any> = ConstraintAnimator<any, any, any>> extends AnimatorClass<A> {\n  /** @internal */\n  readonly ConstrainedFlag: FastenerFlags;\n  /** @internal */\n  readonly ConstrainingFlag: FastenerFlags;\n\n  /** @internal @override */\n  readonly FlagShift: number;\n  /** @internal @override */\n  readonly FlagMask: FastenerFlags;\n}\n\n/** @public */\nexport interface ConstraintAnimator<R = any, T = any, I extends any[] = [T]> extends Animator<R, T, I>, ConstraintVariable {\n  /** @override */\n  get descriptorType(): Proto<ConstraintAnimatorDescriptor<R, T>>;\n\n  /** @internal @override */\n  isExternal(): boolean;\n\n  /** @internal @override */\n  isDummy(): boolean;\n\n  /** @internal @override */\n  isInvalid(): boolean;\n\n  /** @override */\n  isConstant(): boolean;\n\n  /** @internal @override */\n  evaluateConstraintVariable(): void;\n\n  /** @internal @override */\n  updateConstraintSolution(value: number): void;\n\n  /** @internal @protected */\n  initStrength(): ConstraintStrength;\n\n  /** @override */\n  readonly strength: ConstraintStrength;\n\n  setStrength(strength: ConstraintStrengthLike): void;\n\n  /** @override */\n  get coefficient(): number;\n\n  /** @override */\n  get variable(): ConstraintVariable | null;\n\n  /** @override */\n  get terms(): ReadonlyMap<ConstraintVariable, number>;\n\n  /** @override */\n  get constant(): number;\n\n  /** @override */\n  plus(that: ConstraintExpressionLike): ConstraintExpression;\n\n  /** @override */\n  negative(): ConstraintTerm;\n\n  /** @override */\n  minus(that: ConstraintExpressionLike): ConstraintExpression;\n\n  /** @override */\n  times(scalar: number): ConstraintExpression;\n\n  /** @override */\n  divide(scalar: number): ConstraintExpression;\n\n  get constrained(): boolean;\n\n  constrain(constrained?: boolean): this;\n\n  /** @internal */\n  readonly conditionCount: number;\n\n  /** @internal @override */\n  addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;\n\n  /** @internal @override */\n  removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;\n\n  /** @internal */\n  get constraining(): boolean;\n\n  /** @internal */\n  startConstraining(): void;\n\n  /** @protected */\n  willStartConstraining(): void;\n\n  /** @protected */\n  onStartConstraining(): void;\n\n  /** @protected */\n  didStartConstraining(): void;\n\n  /** @internal */\n  stopConstraining(): void;\n\n  /** @protected */\n  willStopConstraining(): void;\n\n  /** @protected */\n  onStopConstraining(): void;\n\n  /** @protected */\n  didStopConstraining(): void;\n\n  /** @internal */\n  updateConstraintVariable(): void;\n\n  /** @protected @override */\n  onSetValue(newValue: T, oldValue: T): void;\n\n  /** @protected @override */\n  onMount(): void;\n\n  /** @protected @override */\n  onUnmount(): void;\n\n  /** @internal @protected */\n  toNumber(value: T): number;\n}\n\n/** @public */\nexport const ConstraintAnimator = (<R, T, I extends any[], A extends ConstraintAnimator<any, any, any>>() => Animator.extend<ConstraintAnimator<R, T, I>, ConstraintAnimatorClass<A>>(\"ConstraintAnimator\", {\n  isExternal(): boolean {\n    return true;\n  },\n\n  isDummy(): boolean {\n    return false;\n  },\n\n  isInvalid(): boolean {\n    return false;\n  },\n\n  isConstant(): boolean {\n    return false;\n  },\n\n  evaluateConstraintVariable(): void {\n    // hook\n  },\n\n  updateConstraintSolution(state: number): void {\n    if (this.constrained && this.toNumber(this.state) !== state) {\n      this.setState(state as unknown as T, Affinity.Reflexive);\n    }\n  },\n\n  initStrength(): ConstraintStrength {\n    let strength = (Object.getPrototypeOf(this) as ConstraintAnimator).strength as ConstraintStrength | undefined;\n    if (strength === void 0) {\n      strength = ConstraintStrength.Strong;\n    }\n    return strength;\n  },\n\n  setStrength(strength: ConstraintStrengthLike): void {\n    (this as Mutable<typeof this>).strength = ConstraintStrength.fromLike(strength);\n  },\n\n  get coefficient(): number {\n    return 1;\n  },\n\n  get variable(): ConstraintVariable {\n    return this;\n  },\n\n  get terms(): ReadonlyMap<ConstraintVariable, number> {\n    const terms = new Map<ConstraintVariable, number>();\n    terms.set(this, 1);\n    return terms;\n  },\n\n  get constant(): number {\n    return 0;\n  },\n\n  plus(that: ConstraintExpressionLike): ConstraintExpression {\n    that = ConstraintExpression.fromLike(that);\n    if (this === that) {\n      return ConstraintExpression.product(2, this);\n    }\n    return ConstraintExpression.sum(this, that);\n  },\n\n  negative(): ConstraintTerm {\n    return ConstraintExpression.product(-1, this);\n  },\n\n  minus(that: ConstraintExpressionLike): ConstraintExpression {\n    that = ConstraintExpression.fromLike(that);\n    if (this === that) {\n      return ConstraintExpression.zero();\n    }\n    return ConstraintExpression.sum(this, that.negative());\n  },\n\n  times(scalar: number): ConstraintExpression {\n    return ConstraintExpression.product(scalar, this);\n  },\n\n  divide(scalar: number): ConstraintExpression {\n    return ConstraintExpression.product(1 / scalar, this);\n  },\n\n  get constrained(): boolean {\n    return (this.flags & ConstraintAnimator.ConstrainedFlag) !== 0;\n  },\n\n  constrain(constrained?: boolean): typeof this {\n    if (constrained === void 0) {\n      constrained = true;\n    }\n    const flags = this.flags;\n    if (constrained && (flags & ConstraintAnimator.ConstrainedFlag) === 0) {\n      this.setFlags(flags | ConstraintAnimator.ConstrainedFlag);\n      if (this.conditionCount !== 0 && this.mounted) {\n        this.stopConstraining();\n      }\n    } else if (!constrained && (flags & ConstraintAnimator.ConstrainedFlag) !== 0) {\n      this.setFlags(flags & ~ConstraintAnimator.ConstrainedFlag);\n      if (this.conditionCount !== 0 && this.mounted) {\n        this.startConstraining();\n        this.updateConstraintVariable();\n      }\n    }\n    return this;\n  },\n\n  addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void {\n    (this as Mutable<typeof this>).conditionCount += 1;\n    if (!this.constrained && this.conditionCount === 1 && this.mounted) {\n      this.startConstraining();\n      this.updateConstraintVariable();\n    }\n  },\n\n  removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void {\n    (this as Mutable<typeof this>).conditionCount -= 1;\n    if (!this.constrained && this.conditionCount === 0 && this.mounted) {\n      this.stopConstraining();\n    }\n  },\n\n  get constraining(): boolean {\n    return (this.flags & ConstraintAnimator.ConstrainingFlag) !== 0;\n  },\n\n  startConstraining(): void {\n    if ((this.flags & ConstraintAnimator.ConstrainingFlag) !== 0) {\n      return;\n    }\n    this.willStartConstraining();\n    this.setFlags(this.flags | ConstraintAnimator.ConstrainingFlag);\n    this.onStartConstraining();\n    this.didStartConstraining();\n  },\n\n  willStartConstraining(): void {\n    // hook\n  },\n\n  onStartConstraining(): void {\n    const constraintScope = this.owner;\n    if (ConstraintScope[Symbol.hasInstance](constraintScope)) {\n      constraintScope.addConstraintVariable(this);\n    }\n  },\n\n  didStartConstraining(): void {\n    // hook\n  },\n\n  stopConstraining(): void {\n    if ((this.flags & ConstraintAnimator.ConstrainingFlag) === 0) {\n      return;\n    }\n    this.willStopConstraining();\n    this.setFlags(this.flags & ~ConstraintAnimator.ConstrainingFlag);\n    this.onStopConstraining();\n    this.didStopConstraining();\n  },\n\n  willStopConstraining(): void {\n    // hook\n  },\n\n  onStopConstraining(): void {\n    const constraintScope = this.owner;\n    if (ConstraintScope[Symbol.hasInstance](constraintScope)) {\n      constraintScope.removeConstraintVariable(this);\n    }\n  },\n\n  didStopConstraining(): void {\n    // hook\n  },\n\n  updateConstraintVariable(): void {\n    const constraintScope = this.owner;\n    const value = this.value;\n    if (value !== void 0 && ConstraintScope[Symbol.hasInstance](constraintScope)) {\n      constraintScope.setConstraintVariable(this, this.toNumber(value));\n    }\n  },\n\n  onSetValue(newValue: T, oldValue: T): void {\n    super.onSetValue(newValue, oldValue);\n    const constraintScope = this.owner;\n    if (this.constraining && ConstraintScope[Symbol.hasInstance](constraintScope)) {\n      constraintScope.setConstraintVariable(this, newValue !== void 0 && newValue !== null ? this.toNumber(newValue) : 0);\n    }\n  },\n\n  onMount(): void {\n    super.onMount();\n    if (!this.constrained && this.conditionCount !== 0) {\n      this.startConstraining();\n    }\n  },\n\n  onUnmount(): void {\n    if (!this.constrained && this.conditionCount !== 0) {\n      this.stopConstraining();\n    }\n    super.onUnmount();\n  },\n\n  toNumber(value: T): number {\n    return value !== void 0 && value !== null ? +value : 0;\n  },\n},\n{\n  construct(animator: A | null, owner: A extends Fastener<infer R, any, any> ? R : never): A {\n    animator = super.construct(animator, owner) as A;\n    (animator as Mutable<typeof animator>).strength = animator.initStrength();\n    (animator as Mutable<typeof animator>).conditionCount = 0;\n    return animator;\n  },\n\n  refine(animatorClass: FastenerClass<ConstraintAnimator<any, any, any>>): void {\n    super.refine(animatorClass);\n    const animatorPrototype = animatorClass.prototype;\n\n    let flagsInit = animatorPrototype.flagsInit;\n    if (Object.prototype.hasOwnProperty.call(animatorPrototype, \"constrained\")) {\n      if (animatorPrototype.constrained) {\n        flagsInit |= ConstraintAnimator.ConstrainedFlag;\n      } else {\n        flagsInit &= ~ConstraintAnimator.ConstrainedFlag;\n      }\n      delete (animatorPrototype as ConstraintAnimatorDescriptor<any, any>).constrained;\n    }\n    Object.defineProperty(animatorPrototype, \"flagsInit\", {\n      value: flagsInit,\n      enumerable: true,\n      configurable: true,\n    });\n\n    const strengthDescriptor = Object.getOwnPropertyDescriptor(animatorPrototype, \"strength\");\n    if (strengthDescriptor !== void 0 && \"value\" in strengthDescriptor) {\n      strengthDescriptor.value = ConstraintStrength.fromLike(strengthDescriptor.value);\n      Object.defineProperty(animatorPrototype, \"strength\", strengthDescriptor);\n    }\n  },\n\n  ConstrainedFlag: 1 << (Animator.FlagShift + 0),\n  ConstrainingFlag: 1 << (Animator.FlagShift + 1),\n\n  FlagShift: Animator.FlagShift + 2,\n  FlagMask: (1 << (Animator.FlagShift + 2)) - 1,\n}))();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport type {ConstraintExpression} from \"./ConstraintExpression\";\nimport type {ConstraintScope} from \"./ConstraintScope\";\n\n/** @public */\nexport type ConstraintRelation = \"le\" | \"eq\" | \"ge\";\n\n/** @public */\nexport type ConstraintStrengthLike = ConstraintStrength | ConstraintStrengthInit;\n\n/** @public */\nexport type ConstraintStrengthInit = \"required\" | \"strong\" | \"medium\" | \"weak\";\n\n/** @public */\nexport type ConstraintStrength = number;\n\n/** @public */\nexport const ConstraintStrength: {\n  readonly Required: ConstraintStrength;\n  readonly Strong: ConstraintStrength;\n  readonly Medium: ConstraintStrength;\n  readonly Weak: ConstraintStrength;\n  readonly Unbound: ConstraintStrength;\n\n  clip(strength: ConstraintStrength): ConstraintStrength;\n\n  fromLike<T extends ConstraintStrengthLike | null | undefined>(strength: T): ConstraintStrength | Uninitable<T>;\n} = {\n  Required: 1001001000,\n  Strong: 1000000,\n  Medium: 1000,\n  Weak: 1,\n  Unbound: -1,\n\n  clip(strength: ConstraintStrength): ConstraintStrength {\n    return Math.min(Math.max(0, strength), ConstraintStrength.Required);\n  },\n\n  fromLike<T extends ConstraintStrengthLike | null | undefined>(strength: T): ConstraintStrength | Uninitable<T> {\n    if (strength === void 0 || strength === null) {\n      return strength as ConstraintStrength | Uninitable<T>;\n    } else if (typeof strength === \"number\") {\n      return ConstraintStrength.clip(strength);\n    } else if (strength === \"required\") {\n      return ConstraintStrength.Required;\n    } else if (strength === \"strong\") {\n      return ConstraintStrength.Strong;\n    } else if (strength === \"medium\") {\n      return ConstraintStrength.Medium;\n    } else if (strength === \"weak\") {\n      return ConstraintStrength.Weak;\n    }\n    throw new TypeError(\"\" + strength);\n  },\n};\n\n/** @public */\nexport class Constraint implements Debug {\n  constructor(scope: ConstraintScope, expression: ConstraintExpression,\n              relation: ConstraintRelation, strength: ConstraintStrength) {\n    this.scope = scope;\n    this.expression = expression;\n    this.relation = relation;\n    this.strength = strength;\n  }\n\n  readonly scope: ConstraintScope;\n\n  readonly expression: ConstraintExpression;\n\n  readonly relation: ConstraintRelation;\n\n  readonly strength: ConstraintStrength;\n\n  isConstrained(): boolean {\n    return this.scope.hasConstraint(this);\n  }\n\n  constrain(constrained: boolean = true): this {\n    if (constrained) {\n      this.scope.addConstraint(this);\n    } else {\n      this.scope.removeConstraint(this);\n    }\n    return this;\n  }\n\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.scope).write(46/*'.'*/).write(\"constraint\").write(40/*'('*/)\n                   .debug(this.expression).write(\", \").debug(this.relation).write(\", \")\n                   .debug(void 0).write(\", \");\n    if (this.strength === ConstraintStrength.Required) {\n      output = output.debug(\"required\");\n    } else if (this.strength === ConstraintStrength.Strong) {\n      output = output.debug(\"strong\");\n    } else if (this.strength === ConstraintStrength.Medium) {\n      output = output.debug(\"medium\");\n    } else if (this.strength === ConstraintStrength.Weak) {\n      output = output.debug(\"weak\");\n    } else {\n      output = output.debug(this.strength);\n    }\n    output = output.write(41/*')'*/);\n    return output;\n  }\n\n  toString(): string {\n    return Format.debug(this);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Objects} from \"@swim/util\";\nimport type {ConstraintExpressionLike} from \"./ConstraintExpression\";\nimport type {ConstraintVariable} from \"./ConstraintVariable\";\nimport type {ConstraintProperty} from \"./ConstraintProperty\";\nimport type {ConstraintRelation} from \"./Constraint\";\nimport type {ConstraintStrengthLike} from \"./Constraint\";\nimport type {Constraint} from \"./Constraint\";\n\n/** @public */\nexport interface ConstraintScope {\n  constraint(lhs: ConstraintExpressionLike, relation: ConstraintRelation,\n             rhs?: ConstraintExpressionLike, strength?: ConstraintStrengthLike): Constraint;\n\n  hasConstraint(constraint: Constraint): boolean;\n\n  addConstraint(constraint: Constraint): void;\n\n  removeConstraint(constraint: Constraint): void;\n\n  constraintVariable(name: string, value?: number, strength?: ConstraintStrengthLike): ConstraintProperty<unknown, number>;\n\n  hasConstraintVariable(variable: ConstraintVariable): boolean;\n\n  addConstraintVariable(variable: ConstraintVariable): void;\n\n  removeConstraintVariable(variable: ConstraintVariable): void;\n\n  setConstraintVariable(variable: ConstraintVariable, state: number): void;\n}\n\n/** @public */\nexport const ConstraintScope = {\n  [Symbol.hasInstance](instance: unknown): instance is ConstraintScope {\n    return Objects.hasAllKeys<ConstraintScope>(instance, \"constraint\", \"constraintVariable\");\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Objects} from \"@swim/util\";\nimport type {ConstraintVariable} from \"./ConstraintVariable\";\nimport type {Constraint} from \"./Constraint\";\n\n/** @public */\nexport interface ConstraintContext {\n  activateConstraint(constraint: Constraint): void;\n\n  deactivateConstraint(constraint: Constraint): void;\n\n  activateConstraintVariable(variable: ConstraintVariable): void;\n\n  deactivateConstraintVariable(variable: ConstraintVariable): void;\n\n  setConstraintVariable(variable: ConstraintVariable, state: number): void;\n}\n\n/** @public */\nexport const ConstraintContext = {\n  [Symbol.hasInstance](instance: unknown): instance is ConstraintContext {\n    return Objects.hasAllKeys<ConstraintContext>(instance, \"activateConstraint\", \"deactivateConstraint\", \"activateConstraintVariable\", \"deactivateConstraintVariable\", \"setConstraintVariable\");\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Equivalent} from \"@swim/util\";\nimport type {ConstraintSymbol} from \"./ConstraintSymbol\";\nimport {ConstraintDummy} from \"./ConstraintSymbol\";\nimport type {ConstraintSolver} from \"./ConstraintSolver\";\n\n/** @internal */\nexport class ConstraintRow {\n  constructor(solver: ConstraintSolver, symbol: ConstraintSymbol | null,\n              cells: Map<ConstraintSymbol, number>, constant: number) {\n    this.solver = solver;\n    this.symbol = symbol;\n    this.cells = cells;\n    this.constant = constant;\n  }\n\n  readonly solver: ConstraintSolver;\n\n  symbol: ConstraintSymbol | null;\n\n  /** @internal */\n  setSymbol(symbol: ConstraintSymbol | null): void {\n    this.symbol = symbol;\n    this.invalidate();\n  }\n\n  readonly cells: Map<ConstraintSymbol, number>;\n\n  constant: number;\n\n  /** @internal */\n  setConstant(constant: number): void {\n    if (this.constant === constant) {\n      return;\n    }\n    this.constant = constant;\n    this.invalidate();\n  }\n\n  isConstant(): boolean {\n    return this.cells.size === 0;\n  }\n\n  isDummy(): boolean {\n    for (const symbol of this.cells.keys()) {\n      if (!(symbol instanceof ConstraintDummy)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  clone(): ConstraintRow {\n    return new ConstraintRow(this.solver, this.symbol, new Map(this.cells), this.constant);\n  }\n\n  add(value: number): number {\n    const sum = this.constant + value;\n    this.setConstant(sum);\n    return sum;\n  }\n\n  insertSymbol(symbol: ConstraintSymbol, coefficient: number = 1): void {\n    coefficient += this.cells.get(symbol) ?? 0;\n    if (Math.abs(coefficient) < Equivalent.Epsilon) {\n      this.cells.delete(symbol);\n    } else {\n      this.cells.set(symbol, coefficient);\n    }\n  }\n\n  insertRow(that: ConstraintRow, coefficient: number): void {\n    this.setConstant(this.constant + that.constant * coefficient);\n    for (const [symbol, value] of that.cells) {\n      this.insertSymbol(symbol, value * coefficient);\n    }\n  }\n\n  removeSymbol(symbol: ConstraintSymbol): void {\n    this.cells.delete(symbol);\n  }\n\n  negate(): void {\n    this.setConstant(-this.constant);\n    for (const [symbol, value] of this.cells) {\n      this.cells.set(symbol, -value);\n    }\n  }\n\n  solveFor(symbol: ConstraintSymbol): void {\n    const value = this.cells.get(symbol);\n    if (value === void 0) {\n      return;\n    }\n    this.cells.delete(symbol);\n    const coefficient = -1 / value;\n    this.setConstant(this.constant * coefficient);\n    for (const [symbol, value] of this.cells) {\n      this.cells.set(symbol, value * coefficient);\n    }\n  }\n\n  solveForEx(lhs: ConstraintSymbol, rhs: ConstraintSymbol): void {\n    this.insertSymbol(lhs, -1.0);\n    this.solveFor(rhs);\n  }\n\n  coefficientFor(symbol: ConstraintSymbol): number {\n    const value = this.cells.get(symbol);\n    return value !== void 0 ? value : 0;\n  }\n\n  substitute(symbol: ConstraintSymbol, row: ConstraintRow): void {\n    const value = this.cells.get(symbol);\n    if (value !== void 0) {\n      this.cells.delete(symbol);\n      this.insertRow(row, value);\n    }\n  }\n\n  invalidate(): void {\n    const symbol = this.symbol;\n    if (symbol !== null) {\n      this.solver.invalidate(symbol, this);\n    }\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Equivalent} from \"@swim/util\";\nimport type {Compare} from \"@swim/util\";\nimport {Cursor} from \"@swim/util\";\nimport type {Interpolate} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport type {Display} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport type {Field} from \"./Field\";\nimport type {ValueLike} from \"./Value\";\nimport {Value} from \"./\"; // forward import\nimport {Record} from \"./\"; // forward import\nimport type {TextLike} from \"./Text\";\nimport type {NumLike} from \"./Num\";\nimport {Bool} from \"./\"; // forward import\nimport {Extant} from \"./\"; // forward import\nimport {Absent} from \"./\"; // forward import\nimport {Selector} from \"./\"; // forward import\nimport {MathModule} from \"./\"; // forward import\nimport type {InterpreterLike} from \"./interpreter/Interpreter\";\nimport type {Form} from \"./form/Form\";\n\n/** @public */\nexport type ItemLike = Item\n                     | {readonly $key: ValueLike, readonly $value: ValueLike}\n                     | {readonly [key: string]: ValueLike}\n                     | readonly ItemLike[]\n                     | Uint8Array\n                     | string\n                     | number\n                     | boolean\n                     | null\n                     | undefined;\n\n/** @public */\nexport abstract class Item implements Interpolate<Item>, HashCode, Equivalent, Compare, Debug, Display {\n  /** @internal */\n  constructor() {\n    // nop\n  }\n\n  likeType?(like: {readonly $key: ValueLike, readonly $value: ValueLike}\n                | {readonly [key: string]: ValueLike}\n                | readonly ItemLike[]\n                | Uint8Array\n                | string\n                | number\n                | boolean\n                | null\n                | undefined): void;\n\n  /**\n   * Returns `true` if this `Item` is not [[Absent]].\n   */\n  abstract isDefined(): boolean;\n\n  /**\n   * Returns `true` if this `Item` is neither [[Extant]] nor [[Absent]].\n   */\n  abstract isDistinct(): boolean;\n\n  /**\n   * Returns `true` if this `Item` is not one of: an empty `Record`, `False`,\n   * `Extant`, or `Absent`.\n   */\n  abstract isDefinite(): boolean;\n\n  /**\n   * Returns `true` if this `Item` always [[Item.evaluate evaluates]] to the\n   * same `Item`.\n   */\n  abstract isConstant(): boolean;\n\n  /**\n   * Returns the key component of this `Item`, if this `Item` is a [[Field]];\n   * otherwise returns [[Absent]] if this `Item` is a `Value`.\n   */\n  abstract readonly key: Value;\n\n  /**\n   * Returns the value component of this `Item`, if this `Item` is a [[Field]];\n   * otherwise returns `this` if this `Item` is a `Value`.\n   */\n  abstract toValue(): Value;\n\n  /**\n   * Returns the `key` string of the first member of this `Item`, if this `Item`\n   * is a [[Record]], and its first member is an [[Attr]]; otherwise returns\n   * `undefined` if this `Item` is not a `Record`, or if this `Item` is a\n   * `Record` whose first member is not an `Attr`.\n   *\n   * Used to concisely get the name of the discriminating attribute of a\n   * structure. The `tag` can be used to discern the nominal type of a\n   * polymorphic structure, similar to an XML element tag.\n   */\n  abstract readonly tag: string | undefined;\n\n  /**\n   * Returns the [[Item.flattened flattened]] members of this `Item` after all\n   * attributes have been removed, if this `Item` is a [[Record]]; otherwise\n   * returns `this` if this `Item` is a non-`Record` `Value`, or returns\n   * the value component if this `Item` is a `Field`.\n   *\n   * Used to concisely get the scalar value of an attributed structure. An\n   * attributed structure is a `Record` with one or more attributes that modify\n   * one or more other members.\n   */\n  abstract readonly target: Value;\n\n  /**\n   * Returns the sole member of this `Item`, if this `Item` is a [[Record]]\n   * with exactly one member, and its member is a `Value`; returns [[Extant]]\n   * if this `Item` is an empty `Record`; returns [[Absent]] if this `Item` is\n   * a `Field`; otherwise returns `this` if this `Item` is a `Record` with more\n   * than one member, or if this `Item` is a non-`Record` `Value`.\n   *\n   * Used to convert a unary `Record` into its member `Value`. Facilitates\n   * writing code that treats a unary `Record` equivalently to a bare `Value`.\n   */\n  abstract flattened(): Value;\n\n  /**\n   * Returns `this` if this `Item` is a [[Record]]; returns a `Record`\n   * containing just this `Item`, if this `Item` is [[Item.isDistinct\n   * distinct]]; otherwise returns an empty `Record` if this `Item` is\n   * [[Extant]] or [[Absent]]. Facilitates writing code that treats a bare\n   * `Value` equivalently to a unary `Record`.\n   */\n  abstract unflattened(): Record;\n\n  /**\n   * Returns the value of the first member of this `Item`, if this `Item` is a\n   * [[Record]], and its first member is an [[Attr]] whose `key` string is\n   * equal to `tag`; otherwise returns [[Absent]] if this `Item` is not a\n   * `Record`, or if this `Item` is a `Record` whose first member is not an\n   * `Attr`, or if this `Item` is a `Record` whose first member is an `Attr`\n   * whose `key` does not equal the `tag`.\n   *\n   * Used to conditionally get the value of the head `Attr` of a structure, if\n   * and only if the key string of the head `Attr` is equal to the `tag`. Can\n   * be used to check if a structure might conform to a nominal type named\n   * `tag`, while simultaneously getting the value of the `tag` attribute.\n   */\n  abstract header(tag: string): Value;\n\n  /**\n   * Returns the [[Item.unflattened unflattened]] [[Item.header header]] of\n   * this `Item`, if this `Item` is a [[Record]], and its first member is an\n   * [[Attr]] whose `key` string is equal to `tag`; otherwise returns\n   * `undefined`.\n   *\n   * The `headers` of the `tag` attribute of a structure are like the\n   * attributes of an XML element tag; through unlike an XML element, `tag`\n   * attribute headers are not limited to string keys and values.\n   */\n  abstract headers(tag: string): Record | undefined;\n\n  /**\n   * Returns the first member of this `Item`, if this `Item` is a non-empty\n   * [[Record]]; otherwise returns [[Absent]].\n   */\n  abstract head(): Item;\n\n  /**\n   * Returns a view of all but the first member of this `Item`, if this `Item`\n   * is a non-empty [[Record]]; otherwise returns an empty `Record` if this\n   * `Item` is not a `Record`, or if this `Item` is itself an empty `Record`.\n   */\n  abstract tail(): Record;\n\n  /**\n   * Returns the [[Record.flattened flattened]] [[Item.tail tail]] of this\n   * `Item`. Used to recursively deconstruct a structure, terminating with its\n   * last `Value`, rather than a unary `Record` containing its last value, if\n   * the structure ends with a `Value` member.\n   */\n  abstract body(): Value;\n\n  /**\n   * Returns the number of members contained in this `Item`, if this `Item` is\n   * a [[Record]]; otherwise returns `0` if this `Item` is not a `Record`.\n   */\n  abstract readonly length: number;\n\n  /**\n   * Returns `true` if this `Item` is a [[Record]] that has a [[Field]] member\n   * with a key that is equal to the given `key`; otherwise returns `false` if\n   * this `Item` is not a `Record`, or if this `Item` is a `Record`, but has no\n   * `Field` member with a key equal to the given `key`.\n   */\n  abstract has(key: ValueLike): boolean;\n\n  /**\n   * Returns the value of the last [[Field]] member of this `Item` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Item` is not a\n   * [[Record]], or if this `Item` is a `Record`, but has no `Field` member\n   * with a key equal to the given `key`.\n   */\n  abstract get(key: ValueLike): Value;\n\n  /**\n   * Returns the value of the last [[Attr]] member of this `Item` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Item` is not a\n   * [[Record]], or if this `Item` is a `Record`, but has no `Attr` member\n   * with a key equal to the given `key`.\n   */\n  abstract getAttr(key: TextLike): Value;\n\n  /**\n   * Returns the value of the last [[Slot]] member of this `Item` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Item` is not a\n   * [[Record]], or if this `Item` is a `Record`, but has no `Slot` member\n   * with a key equal to the given `key`.\n   */\n  abstract getSlot(key: ValueLike): Value;\n\n  /**\n   * Returns the last [[Field]] member of this `Item` whose key is equal to the\n   * given `key`; returns `undefined` if this `Item` is not a [[Record]], or if\n   * this `Item` is a `Record`, but has no `Field` member with a `key` equal to\n   * the given `key`.\n   */\n  abstract getField(key: ValueLike): Field | undefined;\n\n  /**\n   * Returns the member of this `Item` at the given `index`, if this `Item` is\n   * a [[Record]], and the `index` is greater than or equal to zero, and less\n   * than the [[Record.length length]] of the `Record`; otherwise returns\n   * [[Absent]] if this `Item` is not a `Record`, or if this `Item` is a\n   * `Record`, but the `index` is out of bounds.\n   */\n  abstract getItem(index: NumLike): Item;\n\n  updated(key: ValueLike, value: ValueLike): Record {\n    const record = Record.create(2);\n    record.push(this);\n    record.set(key, value);\n    return record;\n  }\n\n  updatedAttr(key: TextLike, value: ValueLike): Record {\n    const record = Record.create(2);\n    record.push(this);\n    record.setAttr(key, value);\n    return record;\n  }\n\n  updatedSlot(key: ValueLike, value: ValueLike): Record {\n    const record = Record.create(2);\n    record.push(this);\n    record.setSlot(key, value);\n    return record;\n  }\n\n  appended(...items: ItemLike[]): Record {\n    const record = Record.create(1 + arguments.length);\n    record.push(this);\n    record.push(...items);\n    return record;\n  }\n\n  prepended(...items: ItemLike[]): Record {\n    const record = Record.create(arguments.length + 1);\n    record.push(...items);\n    record.push(this);\n    return record;\n  }\n\n  abstract deleted(key: ValueLike): Item;\n\n  concat(...items: ItemLike[]): Record {\n    const record = Record.create();\n    record.push(this);\n    for (let i = 0; i < items.length; i += 1) {\n      Item.fromLike(items[i]).forEach(function (item: Item): void {\n        record.push(item);\n      });\n    }\n    return record;\n  }\n\n  abstract conditional(thenTerm: Item, elseTerm: Item): Item;\n\n  abstract or(that: Item): Item;\n\n  abstract and(that: Item): Item;\n\n  abstract bitwiseOr(that: ItemLike): Item;\n\n  abstract bitwiseXor(that: ItemLike): Item;\n\n  abstract bitwiseAnd(that: ItemLike): Item;\n\n  lt(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    return this.compareTo(that) < 0 ? Bool.from(true) : Item.absent();\n  }\n\n  le(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    return this.compareTo(that) <= 0 ? Bool.from(true) : Item.absent();\n  }\n\n  eq(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    return this.equals(that) ? Bool.from(true) : Item.absent();\n  }\n\n  ne(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    return !this.equals(that) ? Bool.from(true) : Item.absent();\n  }\n\n  ge(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    return this.compareTo(that) >= 0 ? Bool.from(true) : Item.absent();\n  }\n\n  gt(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    return this.compareTo(that) > 0 ? Bool.from(true) : Item.absent();\n  }\n\n  abstract plus(that: ItemLike): Item;\n\n  abstract minus(that: ItemLike): Item;\n\n  abstract times(that: ItemLike): Item;\n\n  abstract divide(that: ItemLike): Item;\n\n  abstract modulo(that: ItemLike): Item;\n\n  abstract not(): Item;\n\n  abstract bitwiseNot(): Item;\n\n  abstract negative(): Item;\n\n  abstract positive(): Item;\n\n  abstract inverse(): Item;\n\n  invoke(args: Value): Item {\n    return Item.absent();\n  }\n\n  abstract lambda(template: Value): Value;\n\n  filter(predicate?: ItemLike): Selector {\n    const selector = Selector.literal(this);\n    if (arguments.length === 0) {\n      return selector.filter();\n    } else {\n      return selector.filter(predicate);\n    }\n  }\n\n  max(that: Item): Item {\n    return this.compareTo(that) >= 0 ? this : that;\n  }\n\n  min(that: Item): Item {\n    return this.compareTo(that) <= 0 ? this : that;\n  }\n\n  evaluate(interpreter: InterpreterLike): Item {\n    return this;\n  }\n\n  substitute(interpreter: InterpreterLike): Item {\n    return this;\n  }\n\n  /**\n   * Converts this `Item` into a `string` value, if possible; otherwise returns\n   * `undefined` if this `Item` can't be converted into a `string` value.\n   */\n  abstract stringValue(): string | undefined;\n\n  /**\n   * Converts this `Item` into a `string` value, if possible; otherwise returns\n   * `orElse` if this `Item` can't be converted into a `string` value.\n   */\n  abstract stringValue<T>(orElse: T): string | T;\n\n  /**\n   * Converts this `Item` into a `number` value, if possible; otherwise returns\n   * `undefined` if this `Item` can't be converted into a `number` value.\n   */\n  abstract numberValue(): number | undefined;\n\n  /**\n   * Converts this `Item` into a `number` value, if possible; otherwise returns\n   * `orElse` if this `Item` can't be converted into a `number` value.\n   */\n  abstract numberValue<T>(orElse: T): number | T;\n\n  /**\n   * Converts this `Item` into a `boolean` value, if possible; otherwise returns\n   * `undefined` if this `Item` can't be converted into a `boolean` value.\n   */\n  abstract booleanValue(): boolean | undefined;\n\n  /**\n   * Converts this `Item` into a `boolean` value, if possible; otherwise returns\n   * `orElse` if this `Item` can't be converted into a `boolean` value.\n   */\n  abstract booleanValue<T>(orElse: T): boolean | T;\n\n  cast<T>(form: Form<T, unknown>): T | undefined;\n\n  cast<T, E = T>(form: Form<T, unknown>, orElse: E): T | E;\n\n  cast<T, E = T>(form: Form<T, unknown>, orElse?: E): T | E | undefined {\n    let object: T | E | undefined = form.cast(this);\n    if (object === void 0) {\n      object = orElse;\n    }\n    return object;\n  }\n\n  coerce<T>(form: Form<T, unknown>): T;\n\n  coerce<T, E = T>(form: Form<T, unknown>, orElse: E): T | E;\n\n  coerce<T, E = T>(form: Form<T, unknown>, orElse?: E): T | E {\n    let object: T | E | undefined = form.cast(this);\n    if (object === void 0) {\n      object = form.unit;\n    }\n    if (object === void 0) {\n      object = orElse;\n    }\n    return object!;\n  }\n\n  abstract toLike(): ItemLike;\n\n  abstract isAliased(): boolean;\n\n  abstract isMutable(): boolean;\n\n  abstract alias(): void;\n\n  abstract branch(): Item;\n\n  abstract clone(): Item;\n\n  abstract commit(): this;\n\n  /** @internal */\n  get precedence(): number {\n    return 11;\n  }\n\n  forEach<T>(callback: (item: Item, index: number) => T | void): T | undefined;\n  forEach<T, S>(callback: (this: S, item: Item, index: number) => T | void, thisArg: S): T | undefined;\n  forEach<T, S>(callback: (this: S | undefined, item: Item, index: number) => T | undefined, thisArg?: S): T | undefined {\n    return callback.call(thisArg, this, 0);\n  }\n\n  iterator(): Cursor<Item> {\n    return Cursor.unary(this);\n  }\n\n  [Symbol.iterator](): Cursor<Item> {\n    return this.iterator();\n  }\n\n  /** @override */\n  interpolateTo(that: Item): Interpolator<Item>;\n  interpolateTo(that: unknown): Interpolator<Item> | null;\n  interpolateTo(that: unknown): Interpolator<Item> | null {\n    if (that instanceof Item) {\n      return ItemInterpolator(this, that);\n    }\n    return null;\n  }\n\n  /**\n   * Returns the heterogeneous sort order of this `Item`. Used to impose a\n   * total order on the set of all items. When comparing two items of\n   * different types, the items order according to their `typeOrder`.\n   */\n  abstract readonly typeOrder: number;\n\n  /** @override */\n  abstract compareTo(that: unknown): number;\n\n  /** @override */\n  abstract equivalentTo(that: unknown, epsilon?: number): boolean;\n\n  abstract keyEquals(key: unknown): boolean;\n\n  /** @override */\n  abstract equals(that: unknown): boolean;\n\n  /** @override */\n  abstract hashCode(): number;\n\n  /** @override */\n  abstract debug<T>(output: Output<T>): Output<T>;\n\n  /** @override */\n  display<T>(output: Output<T>): Output<T> {\n    return this.debug(output);\n  }\n\n  /** @override */\n  toString(): string {\n    return Format.debug(this);\n  }\n\n  static empty(): Item {\n    return Record.empty();\n  }\n\n  static extant(): Item {\n    return Extant.extant();\n  }\n\n  static absent(): Item {\n    return Absent.absent();\n  }\n\n  static fromLike(item: ItemLike): Item {\n    if (item instanceof Item) {\n      return item;\n    }\n    return Value.fromLike(item);\n  }\n\n  @Lazy\n  static globalScope(): Item {\n    return Record.create(1)\n        .slot(\"math\", MathModule.scope)\n        .commit();\n  }\n}\n\n/** @internal */\nexport const ItemInterpolator = (function (_super: typeof Interpolator) {\n  const ItemInterpolator = function <Y extends Item>(y0: Y, y1: Y): Interpolator<Y> {\n    const interpolator = function (u: number): Y {\n      return u < 1 ? interpolator[0] : interpolator[1];\n    } as Interpolator<Y>;\n    Object.setPrototypeOf(interpolator, ItemInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = y0.commit();\n    (interpolator as Mutable<typeof interpolator>)[1] = y1.commit();\n    return interpolator;\n  } as {\n    <Y extends Item>(y0: Y, y1: Y): Interpolator<Y>;\n\n    /** @internal */\n    prototype: Interpolator<any>;\n  };\n\n  ItemInterpolator.prototype = Object.create(_super.prototype);\n  ItemInterpolator.prototype.constructor = ItemInterpolator;\n\n  return ItemInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {ItemLike} from \"./Item\";\nimport {Item} from \"./Item\";\nimport {Attr} from \"./\"; // forward import\nimport {Slot} from \"./\"; // forward import\nimport type {ValueLike} from \"./Value\";\nimport {Value} from \"./\"; // forward import\nimport {Record} from \"./\"; // forward import\nimport type {TextLike} from \"./Text\";\nimport {Text} from \"./\"; // forward import\nimport type {NumLike} from \"./Num\";\n\n/** @public */\nexport type FieldLike = Field\n                      | {readonly $key: ValueLike, readonly $value: ValueLike}\n                      | {[key: string]: ValueLike};\n\n/** @public */\nexport abstract class Field extends Item {\n  /** @internal */\n  constructor() {\n    super();\n  }\n\n  override likeType?(like: {readonly $key: ValueLike, readonly $value: ValueLike}\n                         | {[key: string]: ValueLike}): void;\n\n  /**\n   * Always returns `true` because a `Field` can never be [[Absent]].\n   */\n  override isDefined(): boolean {\n    return true;\n  }\n\n  /**\n   * Always returns `true` because a `Field` can be neither [[Extant]] nor\n   * [[Absent]].\n   */\n  override isDistinct(): boolean {\n    return true;\n  }\n\n  /**\n   * Always returns `true` because a `Field` cannot be one of:\n   * an empty `Record`, `False`, `Extant`, or `Absent`.\n   */\n  override isDefinite(): boolean {\n    return true;\n  }\n\n  /**\n   * Returns the key component of this `Field`.\n   */\n  abstract override readonly key: Value;\n\n  /**\n   * Returns the value component of this `Field`.\n   */\n  abstract readonly value: Value;\n\n  /**\n   * Sets the value of this `Field` to the new `value`, returning the old value.\n   *\n   * @throws `Error` if this `Field` is immutable.\n   */\n  abstract setValue(value: ValueLike): Value;\n\n  /**\n   * Returns a copy of this `Field` with the updated `value`.\n   */\n  abstract updatedValue(value: ValueLike): Field;\n\n  /**\n   * Returns the value component of this `Field`.\n   */\n  override toValue(): Value {\n    return this.value;\n  }\n\n  /**\n   * Always returns `undefined` because a `Field` can't be a `Record`, so it\n   * can't have a first member `Attr` whose key string could be returned.\n   */\n  override get tag(): string | undefined {\n    return void 0;\n  }\n\n  /**\n   * Always returns the value component of this `Field`.\n   */\n  override get target(): Value {\n    return this.value;\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Field` can't be flattened into a\n   * `Value`.\n   */\n  override flattened(): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Returns a `Record` containing just this `Field`.\n   */\n  override unflattened(): Record {\n    return Record.of(this);\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Field` can't be a `Record`, so it\n   * can't have a head `Attr` whose value could be returned if its key were\n   * equal to the `tag`.\n   */\n  override header(tag: string): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Always returns `undefined` because a `Field` can't be a `Record`, so it\n   * can't have a head `Attr` whose value could be returned as a `Record` if\n   * its key were equal to the `tag`.\n   */\n  override headers(tag: string): Record | undefined {\n    return void 0;\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Field` can't be a `Record`, so it\n   * can't have a first member.\n   */\n  override head(): Item {\n    return Item.absent();\n  }\n\n  /**\n   * Always returns an empty `Record` because a `Field` can't itself be a\n   * `Record`, so it can't have any non-first members.\n   */\n  override tail(): Record {\n    return Record.empty();\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Field` can't be a `Record`, so it\n   * can't have any non-first members to flatten, and because a `Field` isn't\n   * a distinct `Value`, so it can't return `Extant`.\n   */\n  override body(): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Always returns `0` because a `Field` can't be a `Record`, so it can't\n   * contain any members.\n   */\n  override get length(): number {\n    return 0;\n  }\n\n  /**\n   * Always returns `false` because a `Field` can't be a `Record`, so it can't\n   * have a `Field` member whose key is equal to the given `key`.\n   */\n  override has(key: ValueLike): boolean {\n    return false;\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Field` can't be a `Record`, so it\n   * can't have a `Field` member whose key is equal to the given `key`.\n   */\n  override get(key: ValueLike): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Field` can't be a `Record`, so it\n   * can't have an `Attr` member whose key is equal to the given `key`.\n   */\n  override getAttr(key: TextLike): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Field` can't be a `Record`, so it\n   * can't have a `Slot` member whose key is equal to the given `key`.\n   */\n  override getSlot(key: ValueLike): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Always returns `undefined` because a `Field` can't be a `Record`, so it\n   * can't have a `Field` member whose key is equal to the given `key`.\n   */\n  override getField(key: ValueLike): Field | undefined {\n    return void 0;\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Field` can't be a `Record`, so it\n   * can't have a member at the given `index`.\n   */\n  override getItem(index: NumLike): Item {\n    return Item.absent();\n  }\n\n  override deleted(key: ValueLike): Field {\n    return this;\n  }\n\n  override conditional(thenTerm: Field, elseTerm: Field): Field;\n  override conditional(thenTerm: ItemLike, elseTerm: ItemLike): Item;\n  override conditional(thenTerm: ItemLike, elseTerm: ItemLike): Item {\n    thenTerm = Item.fromLike(thenTerm);\n    return thenTerm;\n  }\n\n  override or(that: Field): Field;\n  override or(that: ItemLike): Item;\n  override or(that: ItemLike): Item {\n    return this;\n  }\n\n  override and(that: Field): Field;\n  override and(that: ItemLike): Item;\n  override and(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    return that;\n  }\n\n  override lambda(template: Value): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Converts the value of this `Field` into a `string` value, if possible.\n   *\n   * @throws `Error` if the value of this `Field` can't be converted into a\n   *         `string` value.\n   */\n  override stringValue(): string | undefined;\n  /**\n   * Converts the value of this `Field` into a `string` value, if possible;\n   * otherwise returns `orElse` if the value of this `Field` can't be converted\n   * into a `string` value.\n   */\n  override stringValue<T>(orElse: T): string | T;\n  override stringValue<T>(orElse?: T): string | T | undefined {\n    return this.value.stringValue(orElse);\n  }\n\n  /**\n   * Converts the value of this `Field` into a `number` value, if possible.\n   *\n   * @throws `Error` if the value of this `Field` can't be converted into a\n   *         `number` value.\n   */\n  override numberValue(): number | undefined;\n  /**\n   * Converts the value of this `Field` into a `number` value, if possible;\n   * otherwise returns `orElse` if the value of this `Field` can't be converted\n   * into a `number` value.\n   */\n  override numberValue<T>(orElse: T): number | T;\n  override numberValue<T>(orElse?: T): number | T | undefined {\n    return this.value.numberValue(orElse);\n  }\n\n  /**\n   * Converts the value of this `Field` into a `boolean` value, if possible.\n   *\n   * @throws `Error` if the value of this `Field` can't be converted into a\n   *         `boolean` value.\n   */\n  override booleanValue(): boolean | undefined;\n  /**\n   * Converts the value of this `Field` into a `boolean` value, if possible;\n   * otherwise returns `orElse` if the value of this `Field` can't be converted\n   * into a `boolean` value.\n   */\n  override booleanValue<T>(orElse: T): boolean | T;\n  override booleanValue<T>(orElse?: T): boolean | T | undefined {\n    return this.value.booleanValue(orElse);\n  }\n\n  abstract override toLike(): FieldLike;\n\n  abstract override branch(): Field;\n\n  abstract override clone(): Field;\n\n  abstract override commit(): this;\n\n  override interpolateTo(that: Field): Interpolator<Field>;\n  override interpolateTo(that: Item): Interpolator<Item>;\n  override interpolateTo(that: unknown): Interpolator<Item> | null;\n  override interpolateTo(that: unknown): Interpolator<Item> | null {\n    if (that instanceof Field) {\n      return FieldInterpolator(this, that);\n    }\n    return super.interpolateTo(that);\n  }\n\n  /** @internal */\n  static readonly ImmutableFlag: number = 1 << 0;\n\n  static of(key: ValueLike, value?: ValueLike): Field {\n    let name: string | undefined;\n    if (typeof key === \"string\") {\n      name = key;\n    } else if (key instanceof Text) {\n      name = key.value;\n    }\n    if (name !== void 0 && name.charCodeAt(0) === 64/*'@'*/) {\n      name = name.slice(1);\n      if (arguments.length === 1) {\n        return Attr.of(name);\n      } else {\n        return Attr.of(name, value);\n      }\n    } else if (arguments.length === 1) {\n      return Slot.of(key);\n    } else {\n      return Slot.of(key, value);\n    }\n  }\n\n  static override fromLike(field: FieldLike): Field {\n    if (field instanceof Field) {\n      return field;\n    } else if (typeof field === \"object\" && field !== null) {\n      if ((field as any).$key !== void 0) {\n        return Field.of((field as any).$key, (field as any).$value);\n      } else {\n        for (const key in field) {\n          return Field.of(key, (field as any)[key]);\n        }\n      }\n    }\n    throw new TypeError(\"\" + field);\n  }\n}\n\n/** @internal */\nexport interface FieldInterpolator extends Interpolator<Field> {\n  /** @internal */\n  readonly keyInterpolator: Interpolator<Value>;\n  /** @internal */\n  readonly valueInterpolator: Interpolator<Value>;\n\n  readonly 0: Field;\n\n  readonly 1: Field;\n\n  equals(that: unknown): boolean;\n}\n\n/** @internal */\nexport const FieldInterpolator = (function (_super: typeof Interpolator) {\n  const FieldInterpolator = function (y0: Field, y1: Field): FieldInterpolator {\n    const interpolator = function (u: number): Field {\n      const key = interpolator.keyInterpolator(u);\n      const value = interpolator.valueInterpolator(u);\n      return Slot.of(key, value);\n    } as FieldInterpolator;\n    Object.setPrototypeOf(interpolator, FieldInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>).keyInterpolator = y0.key.interpolateTo(y1.key);\n    (interpolator as Mutable<typeof interpolator>).valueInterpolator = y0.value.interpolateTo(y1.value);\n    return interpolator;\n  } as {\n    (y0: Field, y1: Field): FieldInterpolator;\n\n    /** @internal */\n    prototype: FieldInterpolator;\n  };\n\n  FieldInterpolator.prototype = Object.create(_super.prototype);\n  FieldInterpolator.prototype.constructor = FieldInterpolator;\n\n  Object.defineProperty(FieldInterpolator.prototype, 0, {\n    get(this: FieldInterpolator): Field {\n      return Slot.of(this.keyInterpolator[0], this.valueInterpolator[0]);\n    },\n    configurable: true,\n  });\n\n  Object.defineProperty(FieldInterpolator.prototype, 1, {\n    get(this: FieldInterpolator): Field {\n      return Slot.of(this.keyInterpolator[1], this.valueInterpolator[1]);\n    },\n    configurable: true,\n  });\n\n  FieldInterpolator.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof FieldInterpolator) {\n      return this.keyInterpolator.equals(that.keyInterpolator)\n          && this.valueInterpolator.equals(that.valueInterpolator);\n    }\n    return false;\n  };\n\n  return FieldInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {ItemLike} from \"./Item\";\nimport {Item} from \"./Item\";\nimport type {FieldLike} from \"./Field\";\nimport {Field} from \"./Field\";\nimport {Slot} from \"./\"; // forward import\nimport type {ValueLike} from \"./Value\";\nimport {Value} from \"./\"; // forward import\nimport type {TextLike} from \"./Text\";\nimport {Text} from \"./\"; // forward import\nimport {Extant} from \"./\"; // forward import\nimport {Expression} from \"./\"; // forward import\nimport {BitwiseOrOperator} from \"./\"; // forward import\nimport {BitwiseXorOperator} from \"./\"; // forward import\nimport {BitwiseAndOperator} from \"./\"; // forward import\nimport {PlusOperator} from \"./\"; // forward import\nimport {MinusOperator} from \"./\"; // forward import\nimport {TimesOperator} from \"./\"; // forward import\nimport {DivideOperator} from \"./\"; // forward import\nimport {ModuloOperator} from \"./\"; // forward import\nimport type {InterpreterLike} from \"./interpreter/Interpreter\";\nimport {Interpreter} from \"./\"; // forward import\n\n/** @public */\nexport class Attr extends Field {\n  constructor(key: Text, value: Value, flags?: number) {\n    super();\n    this.key = key;\n    this.value = value;\n    this.flags = flags !== void 0 ? flags : 0;\n  }\n\n  override isConstant(): boolean {\n    return this.key.isConstant() && this.value.isConstant();\n  }\n\n  get name(): string {\n    return this.key.value;\n  }\n\n  override readonly key: Text;\n\n  override readonly value: Value;\n\n  /** @internal */\n  readonly flags: number;\n\n  override setValue(newValue: Value): Value {\n    if ((this.flags & Field.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    const oldValue = this.value;\n    (this as Mutable<this>).value = newValue;\n    return oldValue;\n  }\n\n  override updatedValue(value: Value): Attr {\n    return new Attr(this.key, value);\n  }\n\n  override bitwiseOr(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new BitwiseOrOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Attr && this.key.equals(that.key)) {\n      newValue = this.value.bitwiseOr(that.value);\n    } else if (that instanceof Value) {\n      newValue = this.value.bitwiseOr(that);\n    } else {\n      newValue = Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Attr(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override bitwiseXor(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new BitwiseXorOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Attr && this.key.equals(that.key)) {\n      newValue = this.value.bitwiseXor(that.value);\n    } else if (that instanceof Value) {\n      newValue = this.value.bitwiseXor(that);\n    } else {\n      newValue = Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Attr(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override bitwiseAnd(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new BitwiseAndOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Attr && this.key.equals(that.key)) {\n      newValue = this.value.bitwiseAnd(that.value);\n    } else if (that instanceof Value) {\n      newValue = this.value.bitwiseAnd(that);\n    } else {\n      newValue = Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Attr(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override plus(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new PlusOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Attr && this.key.equals(that.key)) {\n      newValue = this.value.plus(that.value);\n    } else if (that instanceof Value) {\n      newValue = this.value.plus(that);\n    } else {\n      newValue = Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Attr(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override minus(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new MinusOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Attr && this.key.equals(that.key)) {\n      newValue = this.value.minus(that.value);\n    } else if (that instanceof Value) {\n      newValue = this.value.minus(that);\n    } else {\n      newValue = Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Attr(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override times(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new TimesOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Attr && this.key.equals(that.key)) {\n      newValue = this.value.times(that.value);\n    } else if (that instanceof Value) {\n      newValue = this.value.times(that);\n    } else {\n      newValue = Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Attr(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override divide(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new DivideOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Attr && this.key.equals(that.key)) {\n      newValue = this.value.divide(that.value);\n    } else if (that instanceof Value) {\n      newValue = this.value.divide(that);\n    } else {\n      newValue = Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Attr(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override modulo(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new ModuloOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Attr && this.key.equals(that.key)) {\n      newValue = this.value.modulo(that.value);\n    } else if (that instanceof Value) {\n      newValue = this.value.modulo(that);\n    } else {\n      newValue = Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Attr(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override not(): Item {\n    const newValue = this.value.not();\n    if (newValue.isDefined()) {\n      return new Attr(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override bitwiseNot(): Item {\n    const newValue = this.value.bitwiseNot();\n    if (newValue.isDefined()) {\n      return new Attr(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override negative(): Item {\n    const newValue = this.value.negative();\n    if (newValue.isDefined()) {\n      return new Attr(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override positive(): Item {\n    const newValue = this.value.positive();\n    if (newValue.isDefined()) {\n      return new Attr(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override inverse(): Item {\n    const newValue = this.value.inverse();\n    if (newValue.isDefined()) {\n      return new Attr(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const key = this.key.evaluate(interpreter).toValue();\n    const value = this.value.evaluate(interpreter).toValue();\n    if (key === this.key && value === this.value) {\n      return this;\n    } else if (key.isDefined() && value.isDefined()) {\n      if (key instanceof Text) {\n        return new Attr(key, value);\n      } else {\n        return new Slot(key, value);\n      }\n    }\n    return Item.absent();\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const key = this.key.substitute(interpreter).toValue();\n    const value = this.value.substitute(interpreter).toValue();\n    if (key === this.key && value === this.value) {\n      return this;\n    } else if (key.isDefined() && value.isDefined()) {\n      if (key instanceof Text) {\n        return new Attr(key, value);\n      } else {\n        return new Slot(key, value);\n      }\n    }\n    return Item.absent();\n  }\n\n  override toLike(): FieldLike {\n    const field = {} as {[key: string]: ValueLike};\n    field[\"@\" + this.key.value] = this.value.toLike();\n    return field;\n  }\n\n  override isAliased(): boolean {\n    return false;\n  }\n\n  override isMutable(): boolean {\n    return (this.flags & Field.ImmutableFlag) === 0;\n  }\n\n  override alias(): void {\n    (this as Mutable<this>).flags |= Field.ImmutableFlag;\n  }\n\n  override branch(): Attr {\n    if ((this.flags & Field.ImmutableFlag) === 0) {\n      return this;\n    }\n    return new Attr(this.key, this.value, this.flags & ~Field.ImmutableFlag);\n  }\n\n  override clone(): Attr {\n    return new Attr(this.key.clone(), this.value.clone());\n  }\n\n  override commit(): this {\n    (this as Mutable<this>).flags |= Field.ImmutableFlag;\n    this.value.commit();\n    return this;\n  }\n\n  override interpolateTo(that: Attr): Interpolator<Attr>;\n  override interpolateTo(that: Item): Interpolator<Item>;\n  override interpolateTo(that: unknown): Interpolator<Item> | null;\n  override interpolateTo(that: unknown): Interpolator<Item> | null {\n    if (that instanceof Attr) {\n      return AttrInterpolator(this, that);\n    }\n    return super.interpolateTo(that);\n  }\n\n  override get typeOrder(): number {\n    return 1;\n  }\n\n  override compareTo(that: Item): number {\n    if (that instanceof Attr) {\n      let order = this.key.compareTo(that.key);\n      if (order === 0) {\n        order = this.value.compareTo(that.value);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Attr) {\n      return this.key.equals(that.key) && this.value.equivalentTo(that.value, epsilon);\n    }\n    return false;\n  }\n\n  override keyEquals(key: unknown): boolean {\n    if (typeof key === \"string\") {\n      return this.key.value === key;\n    } else if (key instanceof Field) {\n      return this.key.equals(key.key);\n    } else {\n      return this.key.equals(key);\n    }\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Attr) {\n      return this.key.equals(that.key) && this.value.equals(that.value);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(Attr),\n        this.key.hashCode()), this.value.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Attr\").write(46/*'.'*/).write(\"of\").write(40/*'('*/).display(this.key);\n    if (!(this.value instanceof Extant)) {\n      output = output.write(44/*','*/).write(32/*' '*/).display(this.value);\n    }\n    output = output.write(41/*')'*/);\n    return output;\n  }\n\n  static override of(key: TextLike, value?: ValueLike): Attr {\n    key = Text.fromLike(key);\n    if (arguments.length === 1) {\n      value = Value.extant();\n    } else {\n      value = Value.fromLike(value);\n    }\n    return new Attr(key, value);\n  }\n}\n\n/** @internal */\nexport interface AttrInterpolator extends Interpolator<Attr> {\n  /** @internal */\n  readonly keyInterpolator: Interpolator<Text>;\n  /** @internal */\n  readonly valueInterpolator: Interpolator<Value>;\n\n  readonly 0: Attr;\n\n  readonly 1: Attr;\n\n  equals(that: unknown): boolean;\n}\n\n/** @internal */\nexport const AttrInterpolator = (function (_super: typeof Interpolator) {\n  const AttrInterpolator = function (y0: Attr, y1: Attr): AttrInterpolator {\n    const interpolator = function (u: number): Attr {\n      const key = interpolator.keyInterpolator(u);\n      const value = interpolator.valueInterpolator(u);\n      return Attr.of(key, value);\n    } as AttrInterpolator;\n    Object.setPrototypeOf(interpolator, AttrInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>).keyInterpolator = y0.key.interpolateTo(y1.key);\n    (interpolator as Mutable<typeof interpolator>).valueInterpolator = y0.value.interpolateTo(y1.value);\n    return interpolator;\n  } as {\n    (y0: Attr, y1: Attr): AttrInterpolator;\n\n    /** @internal */\n    prototype: AttrInterpolator;\n  };\n\n  AttrInterpolator.prototype = Object.create(_super.prototype);\n  AttrInterpolator.prototype.constructor = AttrInterpolator;\n\n  Object.defineProperty(AttrInterpolator.prototype, 0, {\n    get(this: AttrInterpolator): Attr {\n      return Attr.of(this.keyInterpolator[0], this.valueInterpolator[0]);\n    },\n    configurable: true,\n  });\n\n  Object.defineProperty(AttrInterpolator.prototype, 1, {\n    get(this: AttrInterpolator): Attr {\n      return Attr.of(this.keyInterpolator[1], this.valueInterpolator[1]);\n    },\n    configurable: true,\n  });\n\n  AttrInterpolator.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof AttrInterpolator) {\n      return this.keyInterpolator.equals(that.keyInterpolator)\n          && this.valueInterpolator.equals(that.valueInterpolator);\n    }\n    return false;\n  };\n\n  return AttrInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {ItemLike} from \"./Item\";\nimport {Item} from \"./Item\";\nimport type {FieldLike} from \"./Field\";\nimport {Field} from \"./Field\";\nimport type {ValueLike} from \"./Value\";\nimport {Value} from \"./\"; // forward import\nimport {Text} from \"./\"; // forward import\nimport {Extant} from \"./\"; // forward import\nimport {Expression} from \"./\"; // forward import\nimport {BitwiseOrOperator} from \"./\"; // forward import\nimport {BitwiseXorOperator} from \"./\"; // forward import\nimport {BitwiseAndOperator} from \"./\"; // forward import\nimport {PlusOperator} from \"./\"; // forward import\nimport {MinusOperator} from \"./\"; // forward import\nimport {TimesOperator} from \"./\"; // forward import\nimport {DivideOperator} from \"./\"; // forward import\nimport {ModuloOperator} from \"./\"; // forward import\nimport type {InterpreterLike} from \"./interpreter/Interpreter\";\nimport {Interpreter} from \"./\"; // forward import\n\n/** @public */\nexport class Slot extends Field {\n  constructor(key: Value, value: Value, flags?: number) {\n    super();\n    this.key = key.commit();\n    this.value = value;\n    this.flags = flags !== void 0 ? flags : 0;\n  }\n\n  override readonly key: Value;\n\n  override readonly value: Value;\n\n  /** @internal */\n  readonly flags: number;\n\n  override isConstant(): boolean {\n    return this.key.isConstant() && this.value.isConstant();\n  }\n\n  override setValue(newValue: Value): Value {\n    if ((this.flags & Field.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    const oldValue = this.value;\n    (this as Mutable<this>).value = newValue;\n    return oldValue;\n  }\n\n  override updatedValue(value: Value): Slot {\n    return new Slot(this.key, value);\n  }\n\n  override bitwiseOr(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new BitwiseOrOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Slot && this.key.equals(that.key)) {\n      newValue = this.value.bitwiseOr(that.value);\n    } else if (that instanceof Value) {\n      newValue = this.value.bitwiseOr(that);\n    } else {\n      newValue = Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Slot(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override bitwiseXor(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new BitwiseXorOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Slot && this.key.equals(that.key)) {\n      newValue = this.value.bitwiseXor(that.value);\n    } else if (that instanceof Value) {\n      newValue = this.value.bitwiseXor(that);\n    } else {\n      newValue = Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Slot(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override bitwiseAnd(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new BitwiseAndOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Slot && this.key.equals(that.key)) {\n      newValue = this.value.bitwiseAnd(that.value);\n    } else if (that instanceof Value) {\n      newValue = this.value.bitwiseAnd(that);\n    } else {\n      newValue = Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Slot(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override plus(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new PlusOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Slot && this.key.equals(that.key)) {\n      newValue = this.value.plus(that.value);\n    } else if (that instanceof Value) {\n      newValue = this.value.plus(that);\n    } else {\n      newValue = Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Slot(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override minus(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new MinusOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Slot && this.key.equals(that.key)) {\n      newValue = this.value.minus(that.value);\n    } else if (that instanceof Value) {\n      newValue = this.value.minus(that);\n    } else {\n      newValue = Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Slot(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override times(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new TimesOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Slot && this.key.equals(that.key)) {\n      newValue = this.value.times(that.value);\n    } else if (that instanceof Value) {\n      newValue = this.value.times(that);\n    } else {\n      newValue = Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Slot(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override divide(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new DivideOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Slot && this.key.equals(that.key)) {\n      newValue = this.value.divide(that.value);\n    } else if (that instanceof Value) {\n      newValue = this.value.divide(that);\n    } else {\n      newValue = Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Slot(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override modulo(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new ModuloOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Slot && this.key.equals(that.key)) {\n      newValue = this.value.modulo(that.value);\n    } else if (that instanceof Value) {\n      newValue = this.value.modulo(that);\n    } else {\n      newValue = Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Slot(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override not(): Item {\n    const newValue = this.value.not();\n    if (newValue.isDefined()) {\n      return new Slot(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override bitwiseNot(): Item {\n    const newValue = this.value.bitwiseNot();\n    if (newValue.isDefined()) {\n      return new Slot(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override negative(): Item {\n    const newValue = this.value.negative();\n    if (newValue.isDefined()) {\n      return new Slot(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override positive(): Item {\n    const newValue = this.value.positive();\n    if (newValue.isDefined()) {\n      return new Slot(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override inverse(): Item {\n    const newValue = this.value.inverse();\n    if (newValue.isDefined()) {\n      return new Slot(this.key, newValue);\n    }\n    return Item.absent();\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const key = this.key.evaluate(interpreter).toValue();\n    const value = this.value.evaluate(interpreter).toValue();\n    if (key === this.key && value === this.value) {\n      return this;\n    } else if (key.isDefined() && value.isDefined()) {\n      return new Slot(key, value);\n    }\n    return Item.absent();\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const key = this.key.substitute(interpreter).toValue();\n    const value = this.value.substitute(interpreter).toValue();\n    if (key === this.key && value === this.value) {\n      return this;\n    } else if (key.isDefined() && value.isDefined()) {\n      return new Slot(key, value);\n    }\n    return Item.absent();\n  }\n\n  override toLike(): FieldLike {\n    const field = {} as {[key: string]: ValueLike};\n    if (this.key instanceof Text) {\n      field[this.key.value] = this.value.toLike();\n    } else {\n      field.$key = this.key.toLike();\n      field.$value = this.value.toLike();\n    }\n    return field;\n  }\n\n  override isAliased(): boolean {\n    return false;\n  }\n\n  override isMutable(): boolean {\n    return (this.flags & Field.ImmutableFlag) === 0;\n  }\n\n  override alias(): void {\n    (this as Mutable<this>).flags |= Field.ImmutableFlag;\n  }\n\n  override branch(): Slot {\n    if ((this.flags & Field.ImmutableFlag) === 0) {\n      return this;\n    }\n    return new Slot(this.key, this.value, this.flags & ~Field.ImmutableFlag);\n  }\n\n  override clone(): Slot {\n    return new Slot(this.key.clone(), this.value.clone());\n  }\n\n  override commit(): this {\n    (this as Mutable<this>).flags |= Field.ImmutableFlag;\n    this.value.commit();\n    return this;\n  }\n\n  override interpolateTo(that: Slot): Interpolator<Slot>;\n  override interpolateTo(that: Item): Interpolator<Item>;\n  override interpolateTo(that: unknown): Interpolator<Item> | null;\n  override interpolateTo(that: unknown): Interpolator<Item> | null {\n    if (that instanceof Slot) {\n      return SlotInterpolator(this, that);\n    }\n    return super.interpolateTo(that);\n  }\n\n  override get typeOrder(): number {\n    return 2;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Slot) {\n      let order = this.key.compareTo(that.key);\n      if (order === 0) {\n        order = this.value.compareTo(that.value);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Slot) {\n      return this.key.equals(that.key) && this.value.equivalentTo(that.value, epsilon);\n    }\n    return false;\n  }\n\n  override keyEquals(key: unknown): boolean {\n    if (typeof key === \"string\" && this.key instanceof Text) {\n      return this.key.value === key;\n    } else if (key instanceof Field) {\n      return this.key.equals(key.key);\n    } else {\n      return this.key.equals(key);\n    }\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Slot) {\n      return this.key.equals(that.key) && this.value.equals(that.value);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(Slot),\n        this.key.hashCode()), this.value.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Slot\").write(46/*'.'*/).write(\"of\").write(40/*'('*/).display(this.key);\n    if (!(this.value instanceof Extant)) {\n      output = output.write(44/*','*/).write(32/*' '*/).display(this.value);\n    }\n    output = output.write(41/*')'*/);\n    return output;\n  }\n\n  static override of(key: ValueLike, value?: ValueLike): Slot {\n    key = Value.fromLike(key);\n    if (arguments.length === 1) {\n      value = Value.extant();\n    } else {\n      value = Value.fromLike(value);\n    }\n    return new Slot(key, value);\n  }\n}\n\n/** @internal */\nexport interface SlotInterpolator extends Interpolator<Slot> {\n  /** @internal */\n  readonly keyInterpolator: Interpolator<Value>;\n  /** @internal */\n  readonly valueInterpolator: Interpolator<Value>;\n\n  readonly 0: Slot;\n\n  readonly 1: Slot;\n\n  equals(that: unknown): boolean;\n}\n\n/** @internal */\nexport const SlotInterpolator = (function (_super: typeof Interpolator) {\n  const SlotInterpolator = function (y0: Slot, y1: Slot): SlotInterpolator {\n    const interpolator = function (u: number): Slot {\n      const key = interpolator.keyInterpolator(u);\n      const value = interpolator.valueInterpolator(u);\n      return Slot.of(key, value);\n    } as SlotInterpolator;\n    Object.setPrototypeOf(interpolator, SlotInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>).keyInterpolator = y0.key.interpolateTo(y1.key);\n    (interpolator as Mutable<typeof interpolator>).valueInterpolator = y0.value.interpolateTo(y1.value);\n    return interpolator;\n  } as {\n    (y0: Slot, y1: Slot): SlotInterpolator;\n\n    /** @internal */\n    prototype: SlotInterpolator;\n  };\n\n  SlotInterpolator.prototype = Object.create(_super.prototype);\n  SlotInterpolator.prototype.constructor = SlotInterpolator;\n\n  Object.defineProperty(SlotInterpolator.prototype, 0, {\n    get(this: SlotInterpolator): Slot {\n      return Slot.of(this.keyInterpolator[0], this.valueInterpolator[0]);\n    },\n    configurable: true,\n  });\n\n  Object.defineProperty(SlotInterpolator.prototype, 1, {\n    get(this: SlotInterpolator): Slot {\n      return Slot.of(this.keyInterpolator[1], this.valueInterpolator[1]);\n    },\n    configurable: true,\n  });\n\n  SlotInterpolator.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof SlotInterpolator) {\n      return this.keyInterpolator.equals(that.keyInterpolator)\n          && this.valueInterpolator.equals(that.valueInterpolator);\n    }\n    return false;\n  };\n\n  return SlotInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Interpolator} from \"@swim/util\";\nimport type {Builder} from \"@swim/util\";\nimport type {ItemLike} from \"./Item\";\nimport {Item} from \"./Item\";\nimport {Field} from \"./\"; // forward import\nimport {Attr} from \"./Attr\";\nimport {Slot} from \"./Slot\";\nimport {Record} from \"./\"; // forward import\nimport {Data} from \"./\"; // forward import\nimport type {TextLike} from \"./Text\";\nimport {Text} from \"./\"; // forward import\nimport type {NumLike} from \"./Num\";\nimport {Num} from \"./\"; // forward import\nimport {Bool} from \"./\"; // forward import\nimport {Extant} from \"./\"; // forward import\nimport {Absent} from \"./\"; // forward import\nimport {Expression} from \"./\"; // forward import\nimport {BitwiseOrOperator} from \"./\"; // forward import\nimport {BitwiseXorOperator} from \"./\"; // forward import\nimport {BitwiseAndOperator} from \"./\"; // forward import\nimport {LtOperator} from \"./\"; // forward import\nimport {LeOperator} from \"./\"; // forward import\nimport {EqOperator} from \"./\"; // forward import\nimport {NeOperator} from \"./\"; // forward import\nimport {GeOperator} from \"./\"; // forward import\nimport {GtOperator} from \"./\"; // forward import\nimport {PlusOperator} from \"./\"; // forward import\nimport {MinusOperator} from \"./\"; // forward import\nimport {TimesOperator} from \"./\"; // forward import\nimport {DivideOperator} from \"./\"; // forward import\nimport {ModuloOperator} from \"./\"; // forward import\nimport {LambdaFunc} from \"./\"; // forward import\n\n/** @public */\nexport type ValueLike = Value\n                      | {readonly [key: string]: ValueLike}\n                      | readonly ItemLike[]\n                      | Uint8Array\n                      | string\n                      | number\n                      | boolean\n                      | null\n                      | undefined;\n\n/** @public */\nexport abstract class Value extends Item {\n  /** @internal */\n  constructor() {\n    super();\n  }\n\n  override likeType?(like: {readonly [key: string]: ValueLike}\n                         | readonly ItemLike[]\n                         | Uint8Array\n                         | string\n                         | number\n                         | boolean\n                         | null\n                         | undefined): void;\n\n  /**\n   * Returns `true` if this `Value` is not [[Absent]].\n   */\n  override isDefined(): boolean {\n    return true;\n  }\n\n  /**\n   * Returns `true` if this `Value` is neither [[Extant]] nor [[Absent]].\n   */\n  override isDistinct(): boolean {\n    return true;\n  }\n\n  /**\n   * Returns `true` if this `Value` is not one of: an empty `Record`, `False`,\n   * `Extant`, or `Absent`.\n   */\n  override isDefinite(): boolean {\n    return true;\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Value` can't be a `Field`, so it\n   * can't have a key component.\n   */\n  override get key(): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Always returns `this` because every `Value` is its own value component.\n   */\n  override toValue(): Value {\n    return this;\n  }\n\n  /**\n   * Returns the `key` string of the first member of this `Value`, if this\n   * `Value` is a [[Record]], and its first member is an [[Attr]]; otherwise\n   * returns `undefined` if this `Value` is not a `Record`, or if this `Value`\n   * is a `Record` whose first member is not an `Attr`.\n   *\n   * Used to concisely get the name of the discriminating attribute of a\n   * structure. The `tag` can be used to discern the nominal type of a\n   * polymorphic structure, similar to an XML element tag.\n   */\n  override get tag(): string | undefined {\n    return void 0;\n  }\n\n  /**\n   * Returns the [[Value.flattened flattened]] members of this `Value` after\n   * all attributes have been removed, if this `Value` is a [[Record]];\n   * otherwise returns `this` if this `Value` is not a `Record`.\n   *\n   * Used to concisely get the scalar value of an attributed structure. An\n   * attributed structure is a `Record` with one or more attributes that modify\n   * one or more other members.\n   */\n  override get target(): Value {\n    return this;\n  }\n\n  /**\n   * Returns the sole member of this `Value`, if this `Value` is a [[Record]]\n   * with exactly one member, and its member is a `Value`; returns [[Extant]]\n   * if this `Value` is an empty `Record`; otherwise returns `this` if this\n   * `Value` is a `Record` with more than one member, or if this `Value` is a\n   * not a `Record`.\n   *\n   * Used to convert a unary `Record` into its member `Value`. Facilitates\n   * writing code that treats a unary `Record` equivalently to a bare `Value`.\n   */\n  override flattened(): Value {\n    return this;\n  }\n\n  /**\n   * Returns `this` if this `Value` is a [[Record]]; returns a `Record`\n   * containing just this `Value`, if this `Value` is [[Value.isDistinct\n   * distinct]]; otherwise returns an empty `Record` if this `Value` is\n   * [[Extant]] or [[Absent]]. Facilitates writing code that treats a bare\n   * `Value` equivalently to a unary `Record`.\n   */\n  override unflattened(): Record {\n    return Record.of(this);\n  }\n\n  /**\n   * Returns the value of the first member of this `Value`, if this `Value` is\n   * a `Record`, and its first member is an [[Attr]] whose `key` string is\n   * equal to `tag`; otherwise returns [[Absent]] if this `Value` is not a\n   * `Record`, or if this `Value` is a `Record` whose first member is not an\n   * `Attr`, or if this `Value` is a `Record` whose first member is an `Attr`\n   * whose `key` does not equal the `tag`.\n   *\n   * Used to conditionally get the value of the head `Attr` of a structure, if\n   * and only if the key string of the head `Attr` is equal to the `tag`. Can\n   * be used to check if a structure might conform to a nominal type named\n   * `tag`, while simultaneously getting the value of the `tag` attribute.\n   */\n  override header(tag: string): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Returns the [[Value.unflattened unflattened]] [[Value.header header]] of\n   * this `Value`, if this `Value` is a [[Record]], and its first member is an\n   * [[Attr]] whose `key` string is equal to `tag`; otherwise returns\n   * `undefined`.\n   *\n   * The `headers` of the `tag` attribute of a structure are like the\n   * attributes of an XML element tag; through unlike an XML element, `tag`\n   * attribute headers are not limited to string keys and values.\n   */\n  override headers(tag: string): Record | undefined {\n    return void 0;\n  }\n\n  /**\n   * Returns the first member of this `Value`, if this `Value` is a non-empty\n   * [[Record]]; otherwise returns [[Absent]].\n   */\n  override head(): Item {\n    return Item.absent();\n  }\n\n  /**\n   * Returns a view of all but the first member of this `Value`, if this\n   * `Value` is a non-empty [[Record]]; otherwise returns an empty `Record`\n   * if this `Value` is not a `Record`, of if this `Value` is itself an\n   * empty `Record`.\n   */\n  override tail(): Record {\n    return Record.empty();\n  }\n\n  /**\n   * Returns the [[Record.flattened flattened]] [[Value.tail tail]] of this\n   * `Value`. Used to recursively deconstruct a structure, terminating with\n   * its last `Value`, rather than a unary `Record` containing its last value,\n   * if the structure ends with a `Value` member.\n   */\n  override body(): Value {\n    return Value.extant();\n  }\n\n  /**\n   * Returns the number of members contained in this `Value`, if this `Value`\n   * is a [[Record]]; otherwise returns `0` if this `Value` is not a `Record`.\n   */\n  override get length(): number {\n    return 0;\n  }\n\n  /**\n   * Returns `true` if this `Value` is a [[Record]] that has a [[Field]] member\n   * with a key that is equal to the given `key`; otherwise returns `false` if\n   * this `Value` is not a `Record`, or if this `Value` is a `Record`, but has\n   * no `Field` member with a key equal to the given `key`.\n   */\n  override has(key: ValueLike): boolean {\n    return false;\n  }\n\n  /**\n   * Returns the value of the last [[Field]] member of this `Value` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Value` is not a\n   * [[Record]], or if this `Value` is a `Record`, but has no `Field` member\n   * with a key equal to the given `key`.\n   */\n  override get(key: ValueLike): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Returns the value of the last [[Attr]] member of this `Value` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Value` is not a\n   * [[Record]], or if this `Value` is a `Record`, but has no `Attr` member\n   * with a key equal to the given `key`.\n   */\n  override getAttr(key: TextLike): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Returns the value of the last [[Slot]] member of this `Value` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Value` is not a\n   * [[Record]], or if this `Value` is a `Record`, but has no `Slot` member\n   * with a key equal to the given `key`.\n   */\n  override getSlot(key: ValueLike): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Returns the last [[Field]] member of this `Value` whose key is equal to\n   * the given `key`; returns `undefined` if this `Value` is not a [[Record]],\n   * or if this `Value` is a `Record`, but has no `Field` member with a `key`\n   * equal to the given `key`.\n   */\n  override getField(key: ValueLike): Field | undefined {\n    return void 0;\n  }\n\n  /**\n   * Returns the member of this `Value` at the given `index`, if this `Value`\n   * is a [[Record]], and the `index` is greater than or equal to zero, and\n   * less than the [[Record.length length]] of the `Record`; otherwise returns\n   * [[Absent]] if this `Value` is not a `Record`, or if this `Value` is a\n   * `Record`, but the `index` is out of bounds.\n   */\n  override getItem(index: NumLike): Item {\n    return Item.absent();\n  }\n\n  override deleted(key: ValueLike): Value {\n    return this;\n  }\n\n  override conditional(thenTerm: ValueLike, elseTerm: ValueLike): Value;\n  override conditional(thenTerm: ItemLike, elseTerm: ItemLike): Item;\n  override conditional(thenTerm: ItemLike, elseTerm: ItemLike): Item {\n    thenTerm = Item.fromLike(thenTerm);\n    return thenTerm;\n  }\n\n  override or(that: ValueLike): Value;\n  override or(that: ItemLike): Item;\n  override or(that: ItemLike): Item {\n    return this;\n  }\n\n  override and(that: ValueLike): Value;\n  override and(that: ItemLike): Item;\n  override and(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    return that;\n  }\n\n  override bitwiseOr(that: ValueLike): Value;\n  override bitwiseOr(that: ItemLike): Item;\n  override bitwiseOr(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new BitwiseOrOperator(this, that);\n    } else if (that instanceof Attr) {\n      const newValue = this.bitwiseOr(that.value);\n      if (newValue.isDefined()) {\n        return new Attr(that.key, newValue);\n      }\n    } else if (that instanceof Slot) {\n      const newValue = this.bitwiseOr(that.value);\n      if (newValue.isDefined()) {\n        return new Slot(that.key, newValue);\n      }\n    }\n    return Item.absent();\n  }\n\n  override bitwiseXor(that: ValueLike): Value;\n  override bitwiseXor(that: ItemLike): Item;\n  override bitwiseXor(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new BitwiseXorOperator(this, that);\n    } else if (that instanceof Attr) {\n      const newValue = this.bitwiseXor(that.value);\n      if (newValue.isDefined()) {\n        return new Attr(that.key, newValue);\n      }\n    } else if (that instanceof Slot) {\n      const newValue = this.bitwiseXor(that.value);\n      if (newValue.isDefined()) {\n        return new Slot(that.key, newValue);\n      }\n    }\n    return Item.absent();\n  }\n\n  override bitwiseAnd(that: ValueLike): Value;\n  override bitwiseAnd(that: ItemLike): Item;\n  override bitwiseAnd(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new BitwiseAndOperator(this, that);\n    } else if (that instanceof Attr) {\n      const newValue = this.bitwiseAnd(that.value);\n      if (newValue.isDefined()) {\n        return new Attr(that.key, newValue);\n      }\n    } else if (that instanceof Slot) {\n      const newValue = this.bitwiseAnd(that.value);\n      if (newValue.isDefined()) {\n        return new Slot(that.key, newValue);\n      }\n    }\n    return Item.absent();\n  }\n\n  override lt(that: ValueLike): Value;\n  override lt(that: ItemLike): Item;\n  override lt(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new LtOperator(this, that);\n    }\n    return super.lt(that);\n  }\n\n  override le(that: ValueLike): Value;\n  override le(that: ItemLike): Item;\n  override le(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new LeOperator(this, that);\n    }\n    return super.le(that);\n  }\n\n  override eq(that: ValueLike): Value;\n  override eq(that: ItemLike): Item;\n  override eq(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new EqOperator(this, that);\n    }\n    return super.eq(that);\n  }\n\n  override ne(that: ValueLike): Value;\n  override ne(that: ItemLike): Item;\n  override ne(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new NeOperator(this, that);\n    }\n    return super.ne(that);\n  }\n\n  override ge(that: ValueLike): Value;\n  override ge(that: ItemLike): Item;\n  override ge(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new GeOperator(this, that);\n    }\n    return super.ge(that);\n  }\n\n  override gt(that: ValueLike): Value;\n  override gt(that: ItemLike): Item;\n  override gt(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new GtOperator(this, that);\n    }\n    return super.gt(that);\n  }\n\n  override plus(that: ValueLike): Value;\n  override plus(that: ItemLike): Item;\n  override plus(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new PlusOperator(this, that);\n    } else if (that instanceof Attr) {\n      const newValue = this.plus(that.value);\n      if (newValue.isDefined()) {\n        return new Attr(that.key, newValue);\n      }\n    } else if (that instanceof Slot) {\n      const newValue = this.plus(that.value);\n      if (newValue.isDefined()) {\n        return new Slot(that.key, newValue);\n      }\n    }\n    return Item.absent();\n  }\n\n  override minus(that: ValueLike): Value;\n  override minus(that: ItemLike): Item;\n  override minus(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new MinusOperator(this, that);\n    } else if (that instanceof Attr) {\n      const newValue = this.minus(that.value);\n      if (newValue.isDefined()) {\n        return new Attr(that.key, newValue);\n      }\n    } else if (that instanceof Slot) {\n      const newValue = this.minus(that.value);\n      if (newValue.isDefined()) {\n        return new Slot(that.key, newValue);\n      }\n    }\n    return Item.absent();\n  }\n\n  override times(that: ValueLike): Value;\n  override times(that: ItemLike): Item;\n  override times(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new TimesOperator(this, that);\n    } else if (that instanceof Attr) {\n      const newValue = this.times(that.value);\n      if (newValue.isDefined()) {\n        return new Attr(that.key, newValue);\n      }\n    } else if (that instanceof Slot) {\n      const newValue = this.times(that.value);\n      if (newValue.isDefined()) {\n        return new Slot(that.key, newValue);\n      }\n    }\n    return Item.absent();\n  }\n\n  override divide(that: ValueLike): Value;\n  override divide(that: ItemLike): Item;\n  override divide(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new DivideOperator(this, that);\n    } else if (that instanceof Attr) {\n      const newValue = this.divide(that.value);\n      if (newValue.isDefined()) {\n        return new Attr(that.key, newValue);\n      }\n    } else if (that instanceof Slot) {\n      const newValue = this.divide(that.value);\n      if (newValue.isDefined()) {\n        return new Slot(that.key, newValue);\n      }\n    }\n    return Item.absent();\n  }\n\n  override modulo(that: ValueLike): Value;\n  override modulo(that: ItemLike): Item;\n  override modulo(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Expression) {\n      return new ModuloOperator(this, that);\n    } else if (that instanceof Attr) {\n      const newValue = this.modulo(that.value);\n      if (newValue.isDefined()) {\n        return new Attr(that.key, newValue);\n      }\n    } else if (that instanceof Slot) {\n      const newValue = this.modulo(that.value);\n      if (newValue.isDefined()) {\n        return new Slot(that.key, newValue);\n      }\n    }\n    return Item.absent();\n  }\n\n  override not(): Value {\n    return Value.absent();\n  }\n\n  override bitwiseNot(): Value {\n    return Value.absent();\n  }\n\n  override negative(): Value {\n    return Value.absent();\n  }\n\n  override positive(): Value {\n    return Value.absent();\n  }\n\n  override inverse(): Value {\n    return Value.absent();\n  }\n\n  override lambda(template: Value): Value {\n    return new LambdaFunc(this, template);\n  }\n\n  /**\n   * Converts this `Value` into a `string` value, if possible; otherwise returns\n   * `undefined` if this `Value` can't be converted into a `string` value.\n   */\n  override stringValue(): string | undefined;\n  /**\n   * Converts this `Value` into a `string` value, if possible; otherwise returns\n   * `orElse` if this `Value` can't be converted into a `string` value.\n   */\n  override stringValue<T>(orElse: T): string | T;\n  override stringValue<T>(orElse?: T): string | T | undefined {\n    return orElse;\n  }\n\n  /**\n   * Converts this `Value` into a `number` value, if possible; otherwise returns\n   * `undefined` if this `Value` can't be converted into a `number` value.\n   */\n  override numberValue(): number | undefined;\n  /**\n   * Converts this `Value` into a `number` value, if possible; otherwise returns\n   * `orElse` if this `Value` can't be converted into a `number` value.\n   */\n  override numberValue<T>(orElse: T): number | T;\n  override numberValue<T>(orElse?: T): number | T | undefined {\n    return orElse;\n  }\n\n  /**\n   * Converts this `Value` into a `boolean` value, if possible; otherwise\n   * returns `undefined` if this `Value` can't be converted into a `boolean`\n   * value.\n   */\n  override booleanValue(): boolean | undefined;\n  /**\n   * Converts this `Value` into a `boolean` value, if possible; otherwise\n   * returns `orElse` if this `Value` can't be converted into a `boolean` value.\n   */\n  override booleanValue<T>(orElse: T): boolean | T;\n  override booleanValue<T>(orElse?: T): boolean | T | undefined {\n    return orElse;\n  }\n\n  abstract override toLike(): ValueLike;\n\n  override isAliased(): boolean {\n    return false;\n  }\n\n  override isMutable(): boolean {\n    return false;\n  }\n\n  override alias(): void {\n    // nop\n  }\n\n  override branch(): Value {\n    return this;\n  }\n\n  override clone(): Value {\n    return this;\n  }\n\n  override commit(): this {\n    return this;\n  }\n\n  override interpolateTo(that: Value): Interpolator<Value>;\n  override interpolateTo(that: Item): Interpolator<Item>;\n  override interpolateTo(that: unknown): Interpolator<Item> | null;\n  override interpolateTo(that: unknown): Interpolator<Item> | null {\n    return super.interpolateTo(that);\n  }\n\n  override keyEquals(key: unknown): boolean {\n    return false;\n  }\n\n  static builder(): Builder<Item, Value> {\n    return new ValueBuilder();\n  }\n\n  static override empty(): Value {\n    return Record.empty();\n  }\n\n  static override extant(): Value {\n    return Extant.extant();\n  }\n\n  static override absent(): Value {\n    return Absent.absent();\n  }\n\n  static override fromLike(value: ValueLike): Value {\n    if (value instanceof Value) {\n      return value;\n    } else if (value instanceof Item) {\n      return Record.create(1).item(value);\n    } else if (value === void 0) {\n      return Absent.absent();\n    } else if (value === null) {\n      return Extant.extant();\n    } else if (typeof value === \"boolean\") {\n      return Bool.from(value);\n    } else if (typeof value === \"number\") {\n      return Num.from(value);\n    } else if (typeof value === \"string\") {\n      return Text.from(value);\n    } else if (value instanceof Uint8Array) {\n      return Data.wrap(value);\n    } else if (Array.isArray(value)) {\n      return Record.fromArray(value);\n    } else if (typeof value === \"object\") {\n      return Record.fromObject(value as {[key: string]: ValueLike});\n    }\n    throw new TypeError(\"\" + value);\n  }\n}\n\n/** @internal */\nexport class ValueBuilder implements Builder<Item, Value> {\n  /** @internal */\n  record: Record | null;\n  /** @internal */\n  value: Value | null;\n\n  constructor() {\n    this.record = null;\n    this.value = null;\n  }\n\n  push(...items: Item[]): void {\n    for (let i = 0; i < items.length; i += 1) {\n      const item = items[i]!;\n      if (item instanceof Field) {\n        return this.pushField(item);\n      } else if (item instanceof Value) {\n        return this.pushValue(item);\n      } else {\n        throw new TypeError(\"\" + item);\n      }\n    }\n  }\n\n  /** @internal */\n  pushField(item: Field): void {\n    if (this.record === null) {\n      this.record = Record.create();\n      if (this.value !== null) {\n        this.record.push(this.value);\n        this.value = null;\n      }\n    }\n    this.record.push(item);\n  }\n\n  /** @internal */\n  pushValue(item: Value): void {\n    if (this.record !== null) {\n      this.record.push(item);\n    } else if (this.value === null) {\n      this.value = item;\n    } else {\n      this.record = Record.create();\n      this.record.push(this.value);\n      this.value = null;\n      this.record.push(item);\n    }\n  }\n\n  build(): Value {\n    if (this.record !== null) {\n      return this.record;\n    } else if (this.value !== null) {\n      return this.value;\n    }\n    return Value.absent();\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport {Cursor} from \"@swim/util\";\nimport type {Builder} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {ItemLike} from \"./Item\";\nimport {Item} from \"./Item\";\nimport {Field} from \"./Field\";\nimport {Attr} from \"./Attr\";\nimport {Slot} from \"./Slot\";\nimport type {ValueLike} from \"./Value\";\nimport {Value} from \"./Value\";\nimport {RecordMap} from \"./\"; // forward import\nimport type {TextLike} from \"./Text\";\nimport {Text} from \"./\"; // forward import\nimport type {NumLike} from \"./Num\";\nimport type {InterpreterLike} from \"./interpreter/Interpreter\";\nimport {Interpreter} from \"./\"; // forward import\n\n/** @public */\nexport type RecordLike = Record\n                       | {readonly [key: string]: ValueLike}\n                       | readonly ItemLike[];\n\n/** @public */\nexport abstract class Record extends Value implements Builder<Item, Record> {\n  /** @internal */\n  constructor() {\n    super();\n  }\n\n  override likeType?(like: {readonly [key: string]: ValueLike}\n                         | readonly ItemLike[]): void;\n\n  override isDefinite(): boolean {\n    return !this.isEmpty();\n  }\n\n  /**\n   * Returns `true` if this `Record` has no members.\n   */\n  abstract isEmpty(): boolean;\n\n  /**\n   * Returns `true` if this `Record` has only [[Value]] members–no `Field`\n   * members.\n   */\n  isArray(): boolean {\n    return this.fieldCount === 0;\n  }\n\n  /**\n   * Returns `true` if this `Record` has only [[Field]] members–no `Value`\n   * members.\n   */\n  isObject(): boolean {\n    return this.valueCount === 0;\n  }\n\n  /**\n   * Returns the number of members contained in this `Record`.\n   */\n  abstract override get length(): number;\n\n  /**\n   * Returns the number of [[Field]] members contained in this `Record`.\n   */\n  declare readonly fieldCount: number; // getter defined below to work around useDefineForClassFields lunacy\n\n  /**\n   * Returns the number of [[Value]] members contained in this `Record`.\n   */\n  get valueCount(): number {\n    let count = 0;\n    this.forEach(function (member: Item): void {\n      if (member instanceof Value) {\n        count += 1;\n      }\n    }, this);\n    return count;\n  }\n\n  override isConstant(): boolean {\n    return this.forEach(function (member: Item): boolean | undefined {\n      return member.isConstant() ? void 0 : false;\n    }, this) === void 0;\n  }\n\n  /**\n   * Returns the `key` string of the first member of this `Record`, if the\n   * first member is an [[Attr]]; otherwise returns `undefined` if the first\n   * member is not an `Attr`.\n   *\n   * Used to concisely get the name of the discriminating attribute of a\n   * structure. The `tag` can be used to discern the nominal type of a\n   * polymorphic structure, similar to an XML element tag.\n   */\n  override get tag(): string | undefined {\n    const item = this.head();\n    if (item instanceof Attr) {\n      return item.key.value;\n    }\n    return void 0;\n  }\n\n  /**\n   * Returns the [[Record.flattened flattened]] members of this `Record` after\n   * all attributes have been removed.\n   *\n   * Used to concisely get the scalar value of an attributed structure. An\n   * attributed structure is a `Record` with one or more attributes that modify\n   * one or more other members.\n   */\n  override get target(): Value {\n    let value: Value | undefined;\n    let record: Record | undefined;\n    let modified = false;\n    this.forEach(function (item: Item): void {\n      if (item instanceof Attr) {\n        modified = true;\n      } else if (value === void 0 && item instanceof Value) {\n        value = item;\n      } else {\n        if (record === void 0) {\n          record = Record.create();\n          if (value !== void 0) {\n            record.push(value);\n          }\n        }\n        record.push(item);\n      }\n    }, this);\n    if (value === void 0) {\n      return Value.extant();\n    } else if (record === void 0) {\n      return value;\n    } else if (modified) {\n      return record;\n    }\n    return this;\n  }\n\n  /**\n   * Returns the sole member of this `Record`, if this `Record` has exactly one\n   * member, and its member is a `Value`; returns [[Extant]] if this `Record`\n   * is empty; otherwise returns `this` if this `Record` has more than one\n   * member.\n   *\n   * Used to convert a unary `Record` into its member `Value`. Facilitates\n   * writing code that treats a unary `Record` equivalently to a bare `Value`.\n   */\n  override flattened(): Value {\n    if (this.isEmpty()) {\n      return Value.extant();\n    }\n    const items = this.iterator();\n    const head = items.head();\n    items.step();\n    if (items.isEmpty() && head instanceof Value) {\n      return head;\n    } else {\n      return this.branch();\n    }\n  }\n\n  /**\n   * Returns this `Record`.\n   */\n  override unflattened(): Record {\n    return this;\n  }\n\n  /**\n   * Returns the value of the first member of this `Record`, if the first\n   * member is an [[Attr]] whose `key` string is equal to `tag`; otherwise\n   * returns [[Absent]] if the first member of this `Record` is not an `Attr`,\n   * or if the first member of this `Record` is an `Attr` whose `key` does not\n   * equal the `tag`.\n   *\n   * Used to conditionally get the value of the head `Attr` of a structure, if\n   * and only if the key string of the head `Attr` is equal to the `tag`. Can\n   * be used to check if a structure might conform to a nominal type named\n   * `tag`, while simultaneously getting the value of the `tag` attribute.\n   */\n  override header(tag: string): Value {\n    const head = this.head();\n    if (!(head instanceof Attr) || head.key.value !== tag) {\n      return Value.absent();\n    }\n    return head.value;\n  }\n\n  /**\n   * Returns the [[Record.unflattened unflattened]] [[Record.header header]] of\n   * this `Record`. The `headers` of the `tag` attribute of a structure are\n   * like the attributes of an XML element tag; through unlike an XML element,\n   * `tag` attribute headers are not limited to string keys and values.\n   */\n  override headers(tag: string): Record | undefined {\n    const head = this.head();\n    if (!(head instanceof Attr) || head.key.value !== tag) {\n      return void 0;\n    }\n    const header = head.value;\n    if (header instanceof Record) {\n      return header;\n    }\n    return Record.of(header);\n  }\n\n  /**\n   * Returns the first member of this `Record`, if this `Record` is non-empty;\n   * otherwise returns [[Absent]].\n   */\n  override head(): Item {\n    return this.forEach(function (item: Item): Item {\n      return item;\n    }, this) || Item.absent();\n  }\n\n  /**\n   * Returns a view of all but the first member of this `Record`, if this\n   * `Record` is non-empty; otherwise returns an empty `Record`, if this\n   * `Record` is itself empty.\n   */\n  override tail(): Record {\n    const tail = Record.create();\n    this.forEach(function (item: Item, index: number): void {\n      if (index > 0) {\n        tail.push(item);\n      }\n    }, this);\n    return tail;\n  }\n\n  /**\n   * Returns the [[Record.flattened flattened]] [[Record.tail tail]] of this\n   * `Record`. Used to recursively deconstruct a structure, terminating\n   * with its last `Value`, rather than a unary `Record` containing its last\n   * value, if the structure ends with a `Value` member.\n   */\n  override body(): Value {\n    const tail = this.tail();\n    if (tail.isEmpty()) {\n      return Value.absent();\n    }\n    return tail.flattened();\n  }\n\n  /**\n   * Returns `true` if this `Record` has a [[Field]] member with a key that is\n   * equal to the given `key`; otherwise returns `false` if this `Record` has\n   * no `Field` member with a key equal to the given `key`.\n   */\n  override has(key: ValueLike): boolean {\n    key = Value.fromLike(key);\n    return this.forEach(function (item: Item): boolean | undefined {\n      return item instanceof Field && item.key.equals(key) ? true : void 0;\n    }, this) || false;\n  }\n\n  indexOf(item: ItemLike, index: number = 0): number {\n    item = Item.fromLike(item);\n    if (index < 0) {\n      index = Math.max(0, this.length + index);\n    }\n    const i = this.forEach(function (member: Item, i: number): number | undefined {\n      return i >= index && (item as Item).equals(member) ? i : void 0;\n    }, this);\n    return i !== void 0 ? i : -1;\n  }\n\n  lastIndexOf(item: ItemLike, index?: number): number {\n    item = Item.fromLike(item);\n    const n = this.length;\n    if (index === void 0) {\n      index = n - 1;\n    } else if (index < 0) {\n      index = n + index;\n    }\n    index = Math.min(index, n - 1);\n    while (index >= 0) {\n      if (item.equals(this.getItem(index))) {\n        return index;\n      }\n      index -= 1;\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the value of the last [[Field]] member of this `Record` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Record` has no\n   * `Field` member with a key equal to the given `key`.\n   */\n  override get(key: ValueLike): Value {\n    key = Value.fromLike(key);\n    return this.forEach(function (item: Item): Value | undefined {\n      return item instanceof Field && item.key.equals(key) ? item.value : void 0;\n    }, this) || Value.absent();\n  }\n\n  /**\n   * Returns the value of the last [[Attr]] member of this `Record` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Record` has no\n   * `Attr` member with a key equal to the given `key`.\n   */\n  override getAttr(key: TextLike): Value {\n    key = Text.fromLike(key);\n    return this.forEach(function (item: Item): Value | undefined {\n      return item instanceof Attr && item.key.equals(key) ? item.value : void 0;\n    }, this) || Value.absent();\n  }\n\n  /**\n   * Returns the value of the last [[Slot]] member of this `Record` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Record` has no\n   * `Slot` member with a key equal to the given `key`.\n   */\n  override getSlot(key: ValueLike): Value {\n    key = Value.fromLike(key);\n    return this.forEach(function (item: Item): Value | undefined {\n      return item instanceof Slot && item.key.equals(key) ? item.value : void 0;\n    }, this) || Value.absent();\n  }\n\n  /**\n   * Returns the last [[Field]] member of this `Record` whose key is equal to\n   * the given `key`; returns `undefined` if this `Record` has no `Field` member\n   * with a `key` equal to the given `key`.\n   */\n  override getField(key: ValueLike): Field | undefined {\n    key = Value.fromLike(key);\n    return this.forEach(function (item: Item): Field | undefined {\n      return item instanceof Field && item.key.equals(key) ? item : void 0;\n    }, this);\n  }\n\n  /**\n   * Returns the member of this `Record` at the given `index`, if the `index`\n   * is greater than or equal to zero, and less than the [[Record.length\n   * length]] of this `Record`; otherwise returns [[Absent]] if the `index` is\n   * out of bounds.\n   */\n  abstract override getItem(index: NumLike): Item;\n\n  set(key: ValueLike, newValue: ValueLike): this {\n    key = Value.fromLike(key);\n    newValue = Value.fromLike(newValue);\n    const items = this.iterator();\n    while (!items.isEmpty()) {\n      const item = items.head();\n      if (item instanceof Field && item.key.equals(key)) {\n        if (item.isMutable()) {\n          item.setValue(newValue);\n        } else {\n          items.set(item.updatedValue(newValue));\n        }\n        return this;\n      }\n      items.step();\n    }\n    this.push(new Slot(key, newValue));\n    return this;\n  }\n\n  setAttr(key: TextLike, newValue: ValueLike): this {\n    key = Text.fromLike(key);\n    newValue = Value.fromLike(newValue);\n    const items = this.iterator();\n    while (!items.isEmpty()) {\n      const item = items.head();\n      if (item instanceof Field && item.key.equals(key)) {\n        if (item instanceof Attr && item.isMutable()) {\n          item.setValue(newValue);\n        } else {\n          items.set(new Attr(key, newValue));\n        }\n        return this;\n      }\n      items.step();\n    }\n    this.push(new Attr(key, newValue));\n    return this;\n  }\n\n  setSlot(key: ValueLike, newValue: ValueLike): this {\n    key = Value.fromLike(key);\n    newValue = Value.fromLike(newValue);\n    const items = this.iterator();\n    while (!items.isEmpty()) {\n      const item = items.head();\n      if (item instanceof Field && item.key.equals(key)) {\n        if (item instanceof Slot && item.isMutable()) {\n          item.setValue(newValue);\n        } else {\n          items.set(new Slot(key, newValue));\n        }\n        return this;\n      }\n      items.step();\n    }\n    this.push(new Slot(key, newValue));\n    return this;\n  }\n\n  /**\n   * Replaces the member of this `Record` at the given `index` with a new\n   * `item`, returning `this` `Record`, if the `index` is greater than or\n   * equal to zero, and less than the [[Record.length length]] of this `Record`.\n   *\n   * @throws `Error` if this is an immutable `Record`.\n   * @throws `RangeError` if the `index` is out of bounds.\n   */\n  abstract setItem(index: number, item: ItemLike): this;\n\n  override updated(key: ValueLike, value: ValueLike): Record {\n    key = Value.fromLike(key);\n    value = Value.fromLike(value);\n    const record = this.isMutable() ? this : this.branch();\n    const items = record.iterator();\n    while (!items.isEmpty()) {\n      const item = items.head();\n      if (item.key.equals(key)) {\n        if (item instanceof Field && item.isMutable()) {\n          item.setValue(value);\n        } else {\n          items.set(new Slot(key, value));\n        }\n        return record;\n      }\n      items.step();\n    }\n    record.push(new Slot(key, value));\n    return record;\n  }\n\n  override updatedAttr(key: TextLike, value: ValueLike): Record {\n    key = Text.fromLike(key);\n    value = Value.fromLike(value);\n    const record = this.isMutable() ? this : this.branch();\n    const items = record.iterator();\n    while (!items.isEmpty()) {\n      const item = items.head();\n      if (item.key.equals(key)) {\n        if (item instanceof Attr && item.isMutable()) {\n          item.setValue(value);\n        } else {\n          items.set(new Attr(key, value));\n        }\n        return record;\n      }\n      items.step();\n    }\n    record.push(new Attr(key, value));\n    return record;\n  }\n\n  override updatedSlot(key: ValueLike, value: ValueLike): Record {\n    key = Value.fromLike(key);\n    value = Value.fromLike(value);\n    const record = this.isMutable() ? this : this.branch();\n    const items = record.iterator();\n    while (!items.isEmpty()) {\n      const item = items.head();\n      if (item.key.equals(key)) {\n        if (item instanceof Slot && item.isMutable()) {\n          item.setValue(value);\n        } else {\n          items.set(new Slot(key, value));\n        }\n        return record;\n      }\n      items.step();\n    }\n    record.push(new Slot(key, value));\n    return record;\n  }\n\n  abstract push(...items: ItemLike[]): number;\n\n  abstract splice(start: number, deleteCount?: number, ...newItems: ItemLike[]): Item[];\n\n  abstract delete(key: ValueLike): Item;\n\n  abstract clear(): void;\n\n  override appended(...items: ItemLike[]): Record {\n    const record = this.isMutable() ? this : this.branch();\n    record.push(...items);\n    return record;\n  }\n\n  override prepended(...items: ItemLike[]): Record {\n    const record = this.isMutable() ? this : this.branch();\n    record.splice(0, 0, ...items);\n    return record;\n  }\n\n  override deleted(key: ValueLike): Record {\n    const record = this.isMutable() ? this : this.branch();\n    record.delete(key);\n    return record;\n  }\n\n  override concat(...items: ItemLike[]): Record {\n    const record = this.isMutable() ? this : this.branch();\n    for (let i = 0; i < items.length; i += 1) {\n      Item.fromLike(items[i]).forEach(function (item: Item): void {\n        record.push(item);\n      });\n    }\n    return record;\n  }\n\n  slice(lower?: number, upper?: number): Record {\n    return this.subRecord(lower, upper).branch();\n  }\n\n  attr(key: TextLike, value?: ValueLike): this {\n    let field: Field;\n    if (arguments.length === 1) {\n      field = Attr.of(key);\n    } else {\n      field = Attr.of(key, value);\n    }\n    this.push(field);\n    return this;\n  }\n\n  slot(key: ValueLike, value?: ValueLike): this {\n    let field: Field;\n    if (arguments.length === 1) {\n      field = Slot.of(key);\n    } else {\n      field = Slot.of(key, value);\n    }\n    this.push(field);\n    return this;\n  }\n\n  item(item: ItemLike): this {\n    this.push(item);\n    return this;\n  }\n\n  items(...items: ItemLike[]): this {\n    this.push(this, ...items);\n    return this;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Record {\n    interpreter = Interpreter.fromLike(interpreter);\n    const scope = Record.create();\n    interpreter.pushScope(scope);\n    let changed = false;\n    this.forEach(function (oldItem: Item): void {\n      const newItem = oldItem.evaluate(interpreter);\n      if (newItem.isDefined()) {\n        scope.push(newItem);\n      }\n      if (oldItem !== newItem) {\n        changed = true;\n      }\n    }, this);\n    interpreter.popScope();\n    return changed ? scope : this;\n  }\n\n  override substitute(interpreter: InterpreterLike): Record {\n    interpreter = Interpreter.fromLike(interpreter);\n    const scope = Record.create();\n    interpreter.pushScope(scope);\n    let changed = false;\n    this.forEach(function (oldItem: Item) {\n      const newItem = oldItem.substitute(interpreter);\n      if (newItem.isDefined()) {\n        scope.push(newItem);\n      }\n      if (oldItem !== newItem) {\n        changed = true;\n      }\n    }, this);\n    interpreter.popScope();\n    return changed ? scope : this;\n  }\n\n  override stringValue(): string | undefined;\n  override stringValue<T>(orElse: T): string | T;\n  override stringValue<T>(orElse?: T): string | T | undefined {\n    let recordString = \"\";\n    const defined = this.forEach(function (item: Item): null | void {\n      if (item instanceof Value) {\n        const itemString = item.stringValue();\n        if (itemString !== void 0) {\n          recordString += itemString;\n          return;\n        }\n      }\n      return null; // break\n    }, this) === void 0;\n    return defined ? recordString : void 0;\n  }\n\n  override toLike(): ValueLike {\n    if (!this.isEmpty() && this.isArray()) {\n      return this.toArray();\n    }\n    return this.toObject();\n  }\n\n  toArray(): ItemLike[] {\n    const array = new Array<ItemLike>(this.length);\n    this.forEach(function (item: Item, index: number): void {\n      if (item instanceof Value) {\n        array[index] = item.toLike();\n      } else if (item instanceof Field) {\n        array[index] = {\n          $key: item.key.toLike(),\n          $value: item.value.toLike(),\n        };\n      }\n    }, this);\n    return array;\n  }\n\n  toObject(): {[key: string]: ValueLike} {\n    const object = {} as {[key: string]: ValueLike};\n    this.forEach(function (item: Item, index: number): void {\n      if (item instanceof Attr) {\n        object[\"@\" + item.key.value] = item.value.toLike();\n      } else if (item instanceof Slot) {\n        if (item.key instanceof Text) {\n          object[item.key.value] = item.value.toLike();\n        } else {\n          object[\"$\" + index] = {\n            $key: item.key.toLike(),\n            $value: item.value.toLike(),\n          };\n        }\n      } else if (item instanceof Value) {\n        object[\"$\" + index] = item.toLike();\n      }\n    }, this);\n    return object;\n  }\n\n  override isAliased(): boolean {\n    return false;\n  }\n\n  override isMutable(): boolean {\n    return true;\n  }\n\n  override alias(): void {\n    // nop\n  }\n\n  override branch(): Record {\n    const branch = Record.create();\n    this.forEach(function (item: Item): void {\n      branch.push(item);\n    }, this);\n    return branch;\n  }\n\n  override clone(): Record {\n    const clone = Record.create();\n    this.forEach(function (item: Item): void {\n      clone.push(item.clone());\n    }, this);\n    return clone;\n  }\n\n  override commit(): this {\n    return this;\n  }\n\n  build(): Record {\n    return this;\n  }\n\n  subRecord(lower?: number, upper?: number): Record {\n    const n = this.length;\n    if (lower === void 0) {\n      lower = 0;\n    } else if (lower < 0) {\n      lower = n + lower;\n    }\n    lower = Math.min(Math.max(0, lower), n);\n    if (upper === void 0) {\n      upper = n;\n    } else if (upper < 0) {\n      upper = n + upper;\n    }\n    const record = Record.create();\n    this.forEach(function (item: Item, index: number): null | void {\n      if (index < lower!) {\n        return;\n      } else if (index < upper!) {\n        record.push(item);\n        return;\n      } else {\n        return null;\n      }\n    }, this);\n    return record;\n  }\n\n  abstract override forEach<T>(callback: (item: Item, index: number) => T | void): T | undefined;\n  abstract override forEach<T, S>(callback: (this: S, item: Item, index: number) => T | void, thisArg: S): T | undefined;\n\n  override iterator(): Cursor<Item> {\n    return new RecordCursor(this);\n  }\n\n  override interpolateTo(that: Record): Interpolator<Record>;\n  override interpolateTo(that: Item): Interpolator<Item>;\n  override interpolateTo(that: unknown): Interpolator<Item> | null;\n  override interpolateTo(that: unknown): Interpolator<Item> | null {\n    if (that instanceof Record) {\n      return RecordInterpolator(this, that);\n    }\n    return super.interpolateTo(that);\n  }\n\n  override get typeOrder(): number {\n    return 3;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Record) {\n      const xs = this.iterator();\n      const ys = that.iterator();\n      let order = 0;\n      do {\n        if (!xs.isEmpty() && !ys.isEmpty()) {\n          order = xs.head().compareTo(ys.head());\n          xs.step();\n          ys.step();\n        } else {\n          break;\n        }\n      } while (order === 0);\n      if (order !== 0) {\n        return order;\n      } else if (xs.isEmpty() && !ys.isEmpty()) {\n        return -1;\n      } else if (!xs.isEmpty() && ys.isEmpty()) {\n        return 1;\n      } else {\n        return 0;\n      }\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Record) {\n      const xs = this.iterator();\n      const ys = that.iterator();\n      while (!xs.isEmpty() && !ys.isEmpty()) {\n        if (!xs.head().equivalentTo(ys.head(), epsilon)) {\n          return false;\n        }\n        xs.step();\n        ys.step();\n      }\n      return xs.isEmpty() && ys.isEmpty();\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Record) {\n      const xs = this.iterator();\n      const ys = that.iterator();\n      while (!xs.isEmpty() && !ys.isEmpty()) {\n        if (!xs.head().equals(ys.head())) {\n          return false;\n        }\n        xs.step();\n        ys.step();\n      }\n      return xs.isEmpty() && ys.isEmpty();\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    let hashValue = Constructors.hash(Record);\n    this.forEach(function (item: Item): void {\n      hashValue = Murmur3.mix(hashValue, item.hashCode());\n    }, this);\n    return hashValue;\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Record\").write(46/*'.'*/);\n    if (this.isEmpty()) {\n      output = output.write(\"empty\").write(40/*'('*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"of\").write(40/*'('*/);\n      this.forEach(function (item: Item, index: number): void {\n        if (index !== 0) {\n          output = output.write(44/*','*/).write(32/*' '*/);\n        }\n        output = output.display(item);\n      }, this);\n      output = output.write(41/*')'*/);\n    }\n    return output;\n  }\n\n  /** @internal */\n  static readonly AliasedFlag: number = 1;\n  /** @internal */\n  static readonly ImmutableFlag: number = 2;\n\n  static override empty(): Record {\n    return RecordMap.empty();\n  }\n\n  static create(initialCapacity?: number): Record {\n    return RecordMap.create(initialCapacity);\n  }\n\n  static of(...items: ItemLike[]): Record {\n    return RecordMap.of(...items);\n  }\n\n  static override fromLike(value: RecordLike): Record {\n    if (value instanceof Record) {\n      return value;\n    } else if (Array.isArray(value)) {\n      return Record.fromArray(value);\n    } else if (typeof value === \"object\" && value !== null) {\n      return Record.fromObject(value as {[key: string]: ValueLike});\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromArray(array: {[index: number]: ItemLike, length?: number}): Record {\n    const n = array.length || 0;\n    const record = Record.create(n);\n    for (let i = 0; i < n; i += 1) {\n      record.push(Item.fromLike(array[i]));\n    }\n    return record;\n  }\n\n  static fromObject(object: {[key: string]: ValueLike}): Record {\n    const record = Record.create();\n    for (const key in object) {\n      const value = object[key];\n      if (key.charCodeAt(0) === 36/*'$'*/) {\n        if (!value || typeof value !== \"object\" || !Object.prototype.hasOwnProperty.call(value, \"$key\")) {\n          record.push(Value.fromLike(value));\n        } else {\n          record.push(Field.of((value as any).$key, (value as any).$value));\n        }\n      } else {\n        record.push(Field.of(key, value));\n      }\n    }\n    return record;\n  }\n\n  /** @internal */\n  static expand(n: number): number {\n    n = Math.max(8, n) - 1;\n    n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16;\n    return n + 1;\n  }\n}\nObject.defineProperty(Record.prototype, \"fieldCount\", {\n  get(this: Record): number {\n    let count = 0;\n    this.forEach(function (member: Item): void {\n      if (member instanceof Field) {\n        count += 1;\n      }\n    }, this);\n    return count;\n  },\n  configurable: true,\n});\n\n/** @internal */\nexport interface RecordInterpolator extends Interpolator<Record> {\n  /** @internal */\n  readonly interpolators: readonly Interpolator<Item>[];\n\n  readonly 0: Record;\n\n  readonly 1: Record;\n\n  equals(that: unknown): boolean;\n}\n\n/** @internal */\nexport const RecordInterpolator = (function (_super: typeof Interpolator) {\n  const RecordInterpolator = function (y0: Record, y1: Record): RecordInterpolator {\n    const interpolator = function (u: number): Record {\n      const interpolators = interpolator.interpolators;\n      const interpolatorCount = interpolators.length;\n      const record = Record.create(interpolatorCount);\n      for (let i = 0; i < interpolatorCount; i += 1) {\n        record.push(interpolators[i]!(u));\n      }\n      return record;\n    } as RecordInterpolator;\n    Object.setPrototypeOf(interpolator, RecordInterpolator.prototype);\n    const interpolatorCount = Math.min(y0.length, y1.length);\n    const interpolators = new Array<Interpolator<Item>>(interpolatorCount);\n    for (let i = 0; i < interpolatorCount; i += 1) {\n      interpolators[i] = y0.getItem(i)!.interpolateTo(y1.getItem(i)!);\n    }\n    (interpolator as Mutable<typeof interpolator>).interpolators = interpolators;\n    return interpolator;\n  } as {\n    (y0: Record, y1: Record): RecordInterpolator;\n\n    /** @internal */\n    prototype: RecordInterpolator;\n  };\n\n  RecordInterpolator.prototype = Object.create(_super.prototype);\n  RecordInterpolator.prototype.constructor = RecordInterpolator;\n\n  Object.defineProperty(RecordInterpolator.prototype, 0, {\n    get(this: RecordInterpolator): Record {\n      const interpolators = this.interpolators;\n      const interpolatorCount = interpolators.length;\n      const record = Record.create(interpolatorCount);\n      for (let i = 0; i < interpolatorCount; i += 1) {\n        record.push(interpolators[i]![0]);\n      }\n      return record;\n    },\n    configurable: true,\n  });\n\n  Object.defineProperty(RecordInterpolator.prototype, 1, {\n    get(this: RecordInterpolator): Record {\n      const interpolators = this.interpolators;\n      const interpolatorCount = interpolators.length;\n      const record = Record.create(interpolatorCount);\n      for (let i = 0; i < interpolatorCount; i += 1) {\n        record.push(interpolators[i]![1]);\n      }\n      return record;\n    },\n    configurable: true,\n  });\n\n  RecordInterpolator.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof RecordInterpolator) {\n      const n = this.interpolators.length;\n      if (n === that.interpolators.length) {\n        for (let i = 0; i < n; i += 1) {\n          if (!this.interpolators[i]!.equals(that.interpolators[i]!)) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return RecordInterpolator;\n})(Interpolator);\n\n/** @internal */\nexport class RecordCursor extends Cursor<Item> {\n  constructor(record: Record, lower?: number, upper?: number, index?: number) {\n    super();\n    if (lower === void 0) {\n      lower = 0;\n    }\n    if (upper === void 0) {\n      upper = record.length;\n    }\n    if (index === void 0) {\n      index = lower;\n    }\n    this.record = record;\n    this.lower = lower;\n    this.upper = upper;\n    this.index = index;\n    this.direction = 0;\n  }\n\n  /** @internal */\n  readonly record: Record;\n\n  /** @internal */\n  readonly lower: number;\n\n  /** @internal */\n  readonly upper: number;\n\n  /** @internal */\n  readonly index: number;\n\n  /** @internal */\n  readonly direction: number;\n\n  override isEmpty(): boolean {\n    return this.index >= this.upper;\n  }\n\n  override head(): Item {\n    (this as Mutable<this>).direction = 0;\n    if (this.index >= this.upper) {\n      throw new Error(\"empty\");\n    }\n    return this.record.getItem(this.index);\n  }\n\n  override step(): void {\n    (this as Mutable<this>).direction = 0;\n    const index = this.index;\n    if (index >= this.upper) {\n      throw new Error(\"empty\");\n    }\n    (this as Mutable<this>).index = index + 1;\n  }\n\n  override skip(count: number): void {\n    (this as Mutable<this>).index = Math.min(Math.max(this.lower, this.index + count, this.upper));\n  }\n\n  override hasNext(): boolean {\n    return this.index < this.upper;\n  }\n\n  override nextIndex(): number {\n    return this.index - this.lower;\n  }\n\n  override next(): IteratorResult<Item> {\n    (this as Mutable<this>).direction = 1;\n    const index = this.index;\n    if (index >= this.upper) {\n      (this as Mutable<this>).index = this.upper;\n      return {done: true, value: void 0};\n    }\n    (this as Mutable<this>).index = index + 1;\n    return {done: this.index === this.upper, value: this.record.getItem(index)};\n  }\n\n  override hasPrevious(): boolean {\n    return this.index > this.lower;\n  }\n\n  override previousIndex(): number {\n    return this.index - this.lower - 1;\n  }\n\n  override previous(): IteratorResult<Item> {\n    (this as Mutable<this>).direction = -1;\n    const index = this.index - 1;\n    if (index < this.lower) {\n      (this as Mutable<this>).index = 0;\n      return {done: true, value: void 0};\n    }\n    (this as Mutable<this>).index = index;\n    return {done: index === this.lower, value: this.record.getItem(index)};\n  }\n\n  override set(newItem: Item): void {\n    if (this.direction > 0) {\n      this.record.setItem(this.index - 1, newItem);\n    } else {\n      this.record.setItem(this.index, newItem);\n    }\n  }\n\n  override delete(): void {\n    let index = this.index;\n    if (this.direction > 0) {\n      index -= 1;\n      (this as Mutable<this>).index = index;\n    }\n    this.record.splice(index, 1);\n    (this as Mutable<this>).direction = 0;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {ItemLike} from \"./Item\";\nimport {Item} from \"./Item\";\nimport {Field} from \"./Field\";\nimport {Attr} from \"./Attr\";\nimport {Slot} from \"./Slot\";\nimport type {ValueLike} from \"./Value\";\nimport {Value} from \"./Value\";\nimport {Record} from \"./Record\";\nimport {RecordMapView} from \"./\"; // forward import\nimport type {TextLike} from \"./Text\";\nimport {Text} from \"./\"; // forward import\nimport type {NumLike} from \"./Num\";\nimport {Num} from \"./\"; // forward import\nimport type {InterpreterLike} from \"./interpreter/Interpreter\"; // forward import\nimport {Interpreter} from \"./\"; // forward import\n\n/** @internal */\nexport class RecordMap extends Record {\n  constructor(array: Array<Item> | null, table: Array<Field> | null,\n              length: number, fieldCount: number, flags: number) {\n    super();\n    this.array = array;\n    this.table = table;\n    Object.defineProperty(this, \"length\", {\n      value: length,\n      writable: true,\n      enumerable: true,\n      configurable: true,\n    });\n    Object.defineProperty(this, \"fieldCount\", {\n      value: fieldCount,\n      writable: true,\n      enumerable: true,\n      configurable: true,\n    });\n    this.flags = flags;\n  }\n\n  /** @internal */\n  readonly array: Array<Item> | null;\n\n  /** @internal */\n  readonly table: Array<Field> | null;\n\n  override isEmpty(): boolean {\n    return this.length === 0;\n  }\n\n  override readonly length!: number;\n\n  override readonly fieldCount!: number;\n\n  override get valueCount(): number {\n    return this.length - this.fieldCount;\n  }\n\n  /** @internal */\n  readonly flags: number;\n\n  override isConstant(): boolean {\n    const array = this.array;\n    for (let i = 0; i < this.length; i += 1) {\n      if (!array![i]!.isConstant()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  override get tag(): string | undefined {\n    if (this.fieldCount === 0) {\n      return void 0;\n    }\n    const head = this.array![0];\n    if (!(head instanceof Attr)) {\n      return void 0;\n    }\n    return head.key.value;\n  }\n\n  override get target(): Value {\n    let value: Value | undefined;\n    let record: Record | undefined;\n    let modified = false;\n    const array = this.array!;\n    for (let i = 0; i < this.length; i += 1) {\n      const item = array[i];\n      if (item instanceof Attr) {\n        modified = true;\n      } else if (value === void 0 && item instanceof Value) {\n        value = item;\n      } else {\n        if (record === void 0) {\n          record = Record.create();\n          if (value !== void 0) {\n            record.push(value);\n          }\n        }\n        record.push(item);\n      }\n    }\n    if (value === void 0) {\n      return Value.extant();\n    } else if (record === void 0) {\n      return value;\n    } else if (modified) {\n      return record;\n    }\n    return this;\n  }\n\n  override head(): Item {\n    if (this.length === 0) {\n      return Item.absent();\n    }\n    return this.array![0]!;\n  }\n\n  override tail(): Record {\n    const n = this.length;\n    if (n === 0) {\n      return Record.empty();\n    }\n    return new RecordMapView(this, 1, n);\n  }\n\n  override body(): Value {\n    const n = this.length;\n    if (n === 0 || n === 1) {\n      return Value.absent();\n    } else if (n === 2) {\n      const item = this.array![1];\n      if (item instanceof Value) {\n        return item;\n      }\n      return Record.of(item);\n    }\n    return new RecordMapView(this, 1, n).branch();\n  }\n\n  override has(key: ValueLike): boolean {\n    if (this.fieldCount === 0) {\n      return false;\n    }\n    key = Value.fromLike(key);\n    const table = this.hashTable()!;\n    const n = table.length;\n    //assert(n > 0);\n    const x = Math.abs(key.hashCode() % n);\n    let i = x;\n    do {\n      const field = table[i];\n      if (field === void 0) {\n        break;\n      } else if (field.key.equals(key)) {\n        return true;\n      }\n      i = (i + 1) % n;\n    } while (i !== x);\n    return false;\n  }\n\n  override indexOf(item: ItemLike, index: number = 0): number {\n    item = Item.fromLike(item);\n    const array = this.array!;\n    const n = this.length;\n    if (index < 0) {\n      index = Math.max(0, n + index);\n    }\n    while (index < n) {\n      if (item.equals(array[index])) {\n        return index;\n      }\n      index += 1;\n    }\n    return -1;\n  }\n\n  override lastIndexOf(item: ItemLike, index?: number): number {\n    item = Item.fromLike(item);\n    const array = this.array!;\n    const n = this.length;\n    if (index === void 0) {\n      index = n - 1;\n    } else if (index < 0) {\n      index = n + index;\n    }\n    index = Math.min(index, n - 1);\n    while (index >= 0) {\n      if (item.equals(array[index])) {\n        return index;\n      }\n      index -= 1;\n    }\n    return -1;\n  }\n\n  override get(key: ValueLike): Value {\n    if (this.fieldCount === 0) {\n      return Value.absent();\n    }\n    key = Value.fromLike(key);\n    const table = this.hashTable()!;\n    const n = table.length;\n    //assert(n > 0);\n    const x = Math.abs(key.hashCode() % n);\n    let i = x;\n    do {\n      const field = table[i];\n      if (field === void 0) {\n        break;\n      } else if (field.key.equals(key)) {\n        return field.value;\n      }\n      i = (i + 1) % n;\n    } while (i !== x);\n    return Value.absent();\n  }\n\n  override getAttr(key: TextLike): Value {\n    if (this.fieldCount === 0) {\n      return Value.absent();\n    }\n    key = Text.fromLike(key);\n    const table = this.hashTable()!;\n    const n = table.length;\n    //assert(n > 0);\n    const x = Math.abs(key.hashCode() % n);\n    let i = x;\n    do {\n      const field = table[i];\n      if (field === void 0) {\n        break;\n      } else if (field instanceof Attr && field.key.equals(key)) {\n        return field.value;\n      }\n      i = (i + 1) % n;\n    } while (i !== x);\n    return Value.absent();\n  }\n\n  override getSlot(key: ValueLike): Value {\n    if (this.fieldCount === 0) {\n      return Value.absent();\n    }\n    key = Value.fromLike(key);\n    const table = this.hashTable()!;\n    const n = table.length;\n    //assert(n > 0);\n    const x = Math.abs(key.hashCode() % n);\n    let i = x;\n    do {\n      const field = table[i];\n      if (field === void 0) {\n        break;\n      } else if (field instanceof Slot && field.key.equals(key)) {\n        return field.value;\n      }\n      i = (i + 1) % n;\n    } while (i !== x);\n    return Value.absent();\n  }\n\n  override getField(key: ValueLike): Field | undefined {\n    if (this.fieldCount === 0) {\n      return void 0;\n    }\n    key = Value.fromLike(key);\n    const table = this.hashTable()!;\n    const n = table.length;\n    //assert(n > 0);\n    const x = Math.abs(key.hashCode() % n);\n    let i = x;\n    do {\n      const field = table[i];\n      if (field === void 0) {\n        break;\n      } else if (field.key.equals(key)) {\n        return field;\n      }\n      i = (i + 1) % n;\n    } while (i !== x);\n    return void 0;\n  }\n\n  override getItem(index: NumLike): Item {\n    if (index instanceof Num) {\n      index = index.value;\n    }\n    const n = this.length;\n    if (index < 0) {\n      index = n + index;\n    }\n    if (index < 0 || index >= n) {\n      return Item.absent();\n    }\n    return this.array![index]!;\n  }\n\n  override set(key: ValueLike, newValue: Value): this {\n    if ((this.flags & Record.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    key = Value.fromLike(key);\n    newValue = Value.fromLike(newValue);\n    if ((this.flags & Record.AliasedFlag) !== 0) {\n      if (this.fieldCount > 0) {\n        this.setAliased(key, newValue);\n      } else {\n        this.pushAliased(new Slot(key, newValue));\n      }\n    } else if (this.fieldCount > 0) {\n      if (this.table !== null) {\n        this.setMutable(key, newValue);\n      } else {\n        this.updateMutable(key, newValue);\n      }\n    } else {\n      this.pushMutable(new Slot(key, newValue));\n    }\n    return this;\n  }\n\n  /** @internal */\n  setAliased(key: Value, newValue: Value): void {\n    const n = this.length;\n    const oldArray = this.array!;\n    const newArray = new Array(Record.expand(n + 1));\n    for (let i = 0; i < n; i += 1) {\n      const item = oldArray[i];\n      if (item instanceof Field && item.key.equals(key)) {\n        newArray[i] = item.updatedValue(newValue);\n        i += 1;\n        while (i < n) {\n          newArray[i] = oldArray[i];\n          i += 1;\n        }\n        (this as Mutable<this>).array = newArray;\n        (this as Mutable<this>).table = null;\n        (this as Mutable<this>).flags &= ~Record.AliasedFlag;\n        return;\n      }\n      newArray[i] = item;\n    }\n    newArray[n] = new Slot(key, newValue);\n    (this as Mutable<this>).array = newArray;\n    (this as Mutable<this>).table = null;\n    (this as Mutable<this>).length = n + 1;\n    (this as Mutable<this>).fieldCount += 1;\n    (this as Mutable<this>).flags &= ~Record.AliasedFlag;\n  }\n\n  /** @internal */\n  setMutable(key: Value, newValue: Value): void {\n    const table = this.table!;\n    const n = table.length;\n    //assert(n > 0);\n    const x = Math.abs(key.hashCode() % n);\n    let i = x;\n    do {\n      const field = table[i];\n      if (field === void 0) {\n        break;\n      } else if (field.key.equals(key)) {\n        if (field.isMutable()) {\n          field.setValue(newValue);\n        } else {\n          this.updateMutable(key, newValue);\n        }\n        return;\n      }\n      i = (i + 1) % n;\n    } while (i !== x);\n    const field = new Slot(key, newValue);\n    this.pushMutable(field);\n    RecordMap.put(table, field);\n  }\n\n  /** @internal */\n  updateMutable(key: Value, newValue: Value): void {\n    const array = this.array!;\n    for (let i = 0; i < this.length; i += 1) {\n      const item = array[i];\n      if (item instanceof Field && item.key.equals(key)) {\n        array[i] = item.updatedValue(newValue);\n        (this as Mutable<this>).table = null;\n        return;\n      }\n    }\n    const field = new Slot(key, newValue);\n    this.pushMutable(field);\n    RecordMap.put(this.table, field);\n  }\n\n  override setAttr(key: TextLike, newValue: Value): this {\n    if ((this.flags & Record.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    key = Text.fromLike(key);\n    newValue = Value.fromLike(newValue);\n    if ((this.flags & Record.AliasedFlag) !== 0) {\n      if (this.fieldCount > 0) {\n        this.setAttrAliased(key, newValue);\n      } else {\n        this.pushAliased(new Attr(key, newValue));\n      }\n    } else if (this.fieldCount > 0) {\n      if (this.table !== null) {\n        this.setAttrMutable(key, newValue);\n      } else {\n        this.updateAttrMutable(key, newValue);\n      }\n    } else {\n      this.pushMutable(new Attr(key, newValue));\n    }\n    return this;\n  }\n\n  /** @internal */\n  setAttrAliased(key: Text, newValue: Value): void {\n    const n = this.length;\n    const oldArray = this.array!;\n    const newArray = new Array(Record.expand(n + 1));\n    for (let i = 0; i < n; i += 1) {\n      const item = oldArray[i];\n      if (item instanceof Field && item.key.equals(key)) {\n        newArray[i] = new Attr(key, newValue);\n        i += 1;\n        while (i < n) {\n          newArray[i] = oldArray[i];\n          i += 1;\n        }\n        (this as Mutable<this>).array = newArray;\n        (this as Mutable<this>).table = null;\n        (this as Mutable<this>).flags &= ~Record.AliasedFlag;\n        return;\n      }\n      newArray[i] = item;\n    }\n    newArray[n] = new Attr(key, newValue);\n    (this as Mutable<this>).array = newArray;\n    (this as Mutable<this>).table = null;\n    (this as Mutable<this>).length = n + 1;\n    (this as Mutable<this>).fieldCount += 1;\n    (this as Mutable<this>).flags &= ~Record.AliasedFlag;\n  }\n\n  /** @internal */\n  setAttrMutable(key: Text, newValue: Value): void {\n    const table = this.table!;\n    const n = table.length;\n    //assert(n > 0);\n    const x = Math.abs(key.hashCode() % n);\n    let i = x;\n    do {\n      const field = table[i];\n      if (field === void 0) {\n        break;\n      } else if (field.key.equals(key)) {\n        if (field instanceof Attr && field.isMutable()) {\n          field.setValue(newValue);\n        } else {\n          this.updateAttrMutable(key, newValue);\n        }\n        return;\n      }\n      i = (i + 1) % n;\n    } while (i !== x);\n    const field = new Attr(key, newValue);\n    this.push(field);\n    RecordMap.put(table, field);\n  }\n\n  /** @internal */\n  updateAttrMutable(key: Text, newValue: Value): void {\n    const array = this.array!;\n    for (let i = 0; i < this.length; i += 1) {\n      const item = array[i];\n      if (item instanceof Field && item.key.equals(key)) {\n        array[i] = new Attr(key, newValue);\n        (this as Mutable<this>).table = null;\n        return;\n      }\n    }\n    const field = new Attr(key, newValue);\n    this.push(field);\n    RecordMap.put(this.table, field);\n  }\n\n  override setSlot(key: ValueLike, newValue: Value): this {\n    if ((this.flags & Record.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    key = Value.fromLike(key);\n    newValue = Value.fromLike(newValue);\n    if ((this.flags & Record.AliasedFlag) !== 0) {\n      if (this.fieldCount > 0) {\n        this.setSlotAliased(key, newValue);\n      } else {\n        this.pushAliased(new Slot(key, newValue));\n      }\n    } else if (this.fieldCount > 0) {\n      if (this.table !== null) {\n        this.setSlotMutable(key, newValue);\n      } else {\n        this.updateSlotMutable(key, newValue);\n      }\n    } else {\n      this.pushMutable(new Slot(key, newValue));\n    }\n    return this;\n  }\n\n  /** @internal */\n  setSlotAliased(key: Value, newValue: Value): void {\n    const n = this.length;\n    const oldArray = this.array!;\n    const newArray = new Array(Record.expand(n + 1));\n    for (let i = 0; i < n; i += 1) {\n      const item = oldArray[i];\n      if (item instanceof Field && item.key.equals(key)) {\n        newArray[i] = new Slot(key, newValue);\n        i += 1;\n        while (i < n) {\n          newArray[i] = oldArray[i];\n          i += 1;\n        }\n        (this as Mutable<this>).array = newArray;\n        (this as Mutable<this>).table = null;\n        (this as Mutable<this>).flags &= ~Record.AliasedFlag;\n        return;\n      }\n      newArray[i] = item;\n    }\n    newArray[n] = new Slot(key, newValue);\n    (this as Mutable<this>).array = newArray;\n    (this as Mutable<this>).table = null;\n    (this as Mutable<this>).length = n + 1;\n    (this as Mutable<this>).fieldCount += 1;\n    (this as Mutable<this>).flags &= ~Record.AliasedFlag;\n  }\n\n  /** @internal */\n  setSlotMutable(key: Value, newValue: Value): void {\n    const table = this.table!;\n    const n = table.length;\n    //assert(n > 0);\n    const x = Math.abs(key.hashCode() % n);\n    let i = x;\n    do {\n      const field = table[i];\n      if (field === void 0) {\n        break;\n      } else if (field.key.equals(key)) {\n        if (field instanceof Slot && field.isMutable()) {\n          field.setValue(newValue);\n        } else {\n          this.updateSlotMutable(key, newValue);\n        }\n        return;\n      }\n      i = (i + 1) % n;\n    } while (i !== x);\n    const field = new Slot(key, newValue);\n    this.push(field);\n    RecordMap.put(table, field);\n  }\n\n  /** @internal */\n  updateSlotMutable(key: Value, newValue: Value): void {\n    const array = this.array!;\n    for (let i = 0; i < this.length; i += 1) {\n      const item = array[i];\n      if (item instanceof Field && item.key.equals(key)) {\n        array[i] = new Slot(key, newValue);\n        (this as Mutable<this>).table = null;\n        return;\n      }\n    }\n    const field = new Slot(key, newValue);\n    this.push(field);\n    RecordMap.put(this.table, field);\n  }\n\n  override setItem(index: number, newItem: ItemLike): this {\n    if ((this.flags & Record.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    newItem = Item.fromLike(newItem);\n    const n = this.length;\n    if (index < 0) {\n      index = n + index;\n    }\n    if (index < 0 || index > n) {\n      throw new RangeError(\"\" + index);\n    }\n    if ((this.flags & Record.AliasedFlag) !== 0) {\n      this.setItemAliased(index, newItem);\n    } else {\n      this.setItemMutable(index, newItem);\n    }\n    return this;\n  }\n\n  /** @internal */\n  setItemAliased(index: number, newItem: Item): void {\n    const n = this.length;\n    const oldArray = this.array!;\n    const newArray = new Array(Record.expand(n));\n    for (let i = 0; i < n; i += 1) {\n      newArray[i] = oldArray[i];\n    }\n    const oldItem = oldArray[index];\n    newArray[index] = newItem;\n    (this as Mutable<this>).array = newArray;\n    (this as Mutable<this>).table = null;\n    if (newItem instanceof Field) {\n      if (!(oldItem instanceof Field)) {\n        (this as Mutable<this>).fieldCount += 1;\n      }\n    } else if (oldItem instanceof Field) {\n      (this as Mutable<this>).fieldCount -= 1;\n    }\n    (this as Mutable<this>).flags &= ~Record.AliasedFlag;\n  }\n\n  /** @internal */\n  setItemMutable(index: number, newItem: Item): void {\n    const array = this.array!;\n    const oldItem = array[index];\n    array[index] = newItem;\n    if (newItem instanceof Field) {\n      (this as Mutable<this>).table = null;\n      if (!(oldItem instanceof Field)) {\n        (this as Mutable<this>).fieldCount += 1;\n      }\n    } else if (oldItem instanceof Field) {\n      (this as Mutable<this>).table = null;\n      (this as Mutable<this>).fieldCount -= 1;\n    }\n  }\n\n  override updated(key: ValueLike, newValue: ValueLike): Record {\n    key = Value.fromLike(key);\n    newValue = Value.fromLike(newValue);\n    const record = (this.flags & Record.ImmutableFlag) === 0 ? this : this.branch();\n    if ((record.flags & Record.AliasedFlag) !== 0) {\n      if (record.fieldCount > 0) {\n        record.setAliased(key, newValue);\n      } else {\n        record.pushAliased(new Slot(key, newValue));\n      }\n    } else if (record.fieldCount > 0) {\n      if (record.table !== null) {\n        record.setMutable(key, newValue);\n      } else {\n        record.updateMutable(key, newValue);\n      }\n    } else {\n      record.pushMutable(new Slot(key, newValue));\n    }\n    return record;\n  }\n\n  override updatedAttr(key: TextLike, newValue: ValueLike): Record {\n    key = Text.fromLike(key);\n    newValue = Value.fromLike(newValue);\n    const record = (this.flags & Record.ImmutableFlag) === 0 ? this : this.branch();\n    if ((record.flags & Record.AliasedFlag) !== 0) {\n      if (record.fieldCount > 0) {\n        record.setAttrAliased(key, newValue);\n      } else {\n        record.pushAliased(new Attr(key, newValue));\n      }\n    } else if (record.fieldCount > 0) {\n      if (record.table !== null) {\n        record.setAttrMutable(key, newValue);\n      } else {\n        record.updateAttrMutable(key, newValue);\n      }\n    } else {\n      record.pushMutable(new Attr(key, newValue));\n    }\n    return record;\n  }\n\n  override updatedSlot(key: ValueLike, newValue: ValueLike): Record {\n    key = Value.fromLike(key);\n    newValue = Value.fromLike(newValue);\n    const record = (this.flags & Record.ImmutableFlag) === 0 ? this : this.branch();\n    if ((record.flags & Record.AliasedFlag) !== 0) {\n      if (record.fieldCount > 0) {\n        record.setSlotAliased(key, newValue);\n      } else {\n        record.pushAliased(new Slot(key, newValue));\n      }\n    } else if (record.fieldCount > 0) {\n      if (record.table !== null) {\n        record.setSlotMutable(key, newValue);\n      } else {\n        record.updateSlotMutable(key, newValue);\n      }\n    } else {\n      record.pushMutable(new Slot(key, newValue));\n    }\n    return record;\n  }\n\n  override push(...newItems: ItemLike[]): number {\n    if ((this.flags & Record.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    if ((this.flags & Record.AliasedFlag) !== 0) {\n      this.pushAliased(...newItems);\n    } else {\n      this.pushMutable(...newItems);\n    }\n    return this.length;\n  }\n\n  /** @internal */\n  pushAliased(...newItems: ItemLike[]): void {\n    const k = newItems.length;\n    let m = this.length;\n    let n = this.fieldCount;\n    const oldArray = this.array;\n    const newArray = new Array(Record.expand(m + k));\n    if (oldArray !== null) {\n      for (let i = 0; i < m; i += 1) {\n        newArray[i] = oldArray[i];\n      }\n    }\n    for (let i = 0; i < k; i += 1) {\n      const newItem = Item.fromLike(newItems[i]);\n      newArray[m] = newItem;\n      m += 1;\n      if (newItem instanceof Field) {\n        n += 1;\n      }\n    }\n    (this as Mutable<this>).array = newArray;\n    (this as Mutable<this>).table = null;\n    (this as Mutable<this>).length = m;\n    (this as Mutable<this>).fieldCount = n;\n    (this as Mutable<this>).flags &= ~Record.AliasedFlag;\n  }\n\n  /** @internal */\n  pushMutable(...newItems: ItemLike[]): void {\n    const k = newItems.length;\n    let m = this.length;\n    let n = this.fieldCount;\n    const oldArray = this.array;\n    let newArray;\n    if (oldArray === null || m + k > oldArray.length) {\n      newArray = new Array(Record.expand(m + k));\n      if (oldArray !== null) {\n        for (let i = 0; i < m; i += 1) {\n          newArray[i] = oldArray[i];\n        }\n      }\n    } else {\n      newArray = oldArray;\n    }\n    for (let i = 0; i < k; i += 1) {\n      const newItem = Item.fromLike(newItems[i]);\n      newArray[m] = newItem;\n      m += 1;\n      if (newItem instanceof Field) {\n        n += 1;\n        (this as Mutable<this>).table = null;\n      }\n    }\n    (this as Mutable<this>).array = newArray;\n    (this as Mutable<this>).length = m;\n    (this as Mutable<this>).fieldCount = n;\n  }\n\n  splice(start: number, deleteCount: number = 0, ...newItems: ItemLike[]): Item[] {\n    if ((this.flags & Record.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    const n = this.length;\n    if (start < 0) {\n      start = n + start;\n    }\n    start = Math.min(Math.max(0, start), n);\n    deleteCount = Math.min(Math.max(0, deleteCount), n - start);\n    if ((this.flags & Record.AliasedFlag) !== 0) {\n      return this.spliceAliased(start, deleteCount, ...newItems);\n    } else {\n      return this.spliceMutable(start, deleteCount, ...newItems);\n    }\n  }\n\n  /** @internal */\n  spliceAliased(start: number, deleteCount: number, ...newItems: ItemLike[]): Item[] {\n    const k = newItems.length;\n    let m = this.length;\n    let n = this.fieldCount;\n    const oldArray = this.array!;\n    const newArray = new Array(Record.expand(m - deleteCount + k));\n    for (let i = 0; i < start; i += 1) {\n      newArray[i] = oldArray[i];\n    }\n    const oldItems: Item[] = [];\n    for (let i = start; i < start + deleteCount; i += 1) {\n      const oldItem = oldArray[i]!;\n      oldItems.push(oldItem);\n      m -= 1;\n      if (oldItem instanceof Field) {\n        n -= 1;\n      }\n    }\n    for (let i = start; i < m; i += 1) {\n      newArray[i + k] = oldArray[i + deleteCount];\n    }\n    for (let i = 0; i < k; i += 1) {\n      const newItem = Item.fromLike(newItems[i]);\n      newArray[i + start] = newItem;\n      m += 1;\n      if (newItem instanceof Field) {\n        n += 1;\n      }\n    }\n    (this as Mutable<this>).array = newArray;\n    (this as Mutable<this>).table = null;\n    (this as Mutable<this>).length = m;\n    (this as Mutable<this>).fieldCount = n;\n    (this as Mutable<this>).flags &= ~Record.AliasedFlag;\n    return oldItems;\n  }\n\n  /** @internal */\n  spliceMutable(start: number, deleteCount: number, ...newItems: ItemLike[]): Item[] {\n    const k = newItems.length;\n    let m = this.length;\n    let n = this.fieldCount;\n    const oldArray = this.array!;\n    let newArray;\n    if (oldArray === null || m - deleteCount + k > oldArray.length) {\n      newArray = new Array(Record.expand(m - deleteCount + k));\n      if (oldArray !== null) {\n        for (let i = 0; i < start; i += 1) {\n          newArray[i] = oldArray[i];\n        }\n      }\n    } else {\n      newArray = oldArray;\n    }\n    const oldItems: Item[] = [];\n    for (let i = start; i < start + deleteCount; i += 1) {\n      const oldItem = oldArray[i]!;\n      oldItems.push(oldItem);\n      m -= 1;\n      if (oldItem instanceof Field) {\n        n -= 1;\n      }\n    }\n    if (k > deleteCount) {\n      for (let i = m - 1; i >= start; i -= 1) {\n        newArray[i + k] = oldArray[i + deleteCount];\n      }\n    } else {\n      for (let i = start; i < m; i += 1) {\n        newArray[i + k] = oldArray[i + deleteCount];\n      }\n    }\n    for (let i = 0; i < k; i += 1) {\n      const newItem = Item.fromLike(newItems[i]);\n      newArray[i + start] = newItem;\n      m += 1;\n      if (newItem instanceof Field) {\n        n += 1;\n      }\n    }\n    (this as Mutable<this>).array = newArray;\n    (this as Mutable<this>).length = m;\n    (this as Mutable<this>).fieldCount = n;\n    return oldItems;\n  }\n\n  override delete(key: ValueLike): Item {\n    if ((this.flags & Record.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    key = Value.fromLike(key);\n    if ((this.flags & Record.AliasedFlag) !== 0) {\n      return this.deleteAliased(key);\n    } else {\n      return this.deleteMutable(key);\n    }\n  }\n\n  /** @internal */\n  deleteAliased(key: Value): Item {\n    const n = this.length;\n    const oldArray = this.array!;\n    const newArray = new Array(Record.expand(n));\n    for (let i = 0; i < n; i += 1) {\n      const item = oldArray[i];\n      if (item instanceof Field && item.key.equals(key)) {\n        for (let j = i + 1; j < n; j += 1, i += 1) {\n          newArray[i] = oldArray[j];\n        }\n        (this as Mutable<this>).array = newArray;\n        (this as Mutable<this>).table = null;\n        (this as Mutable<this>).length = n - 1;\n        (this as Mutable<this>).fieldCount -= 1;\n        (this as Mutable<this>).flags &= ~Record.AliasedFlag;\n        return item;\n      }\n      newArray[i] = item;\n    }\n    return Item.absent();\n  }\n\n  /** @internal */\n  deleteMutable(key: Value): Item {\n    const n = this.length;\n    const array = this.array!;\n    for (let i = 0; i < n; i += 1) {\n      const item = array[i]!;\n      if (item instanceof Field && item.key.equals(key)) {\n        for (let j = i + 1; j < n; j += 1, i += 1) {\n          array[i] = array[j]!;\n        }\n        array[n - 1] = void 0 as unknown as Item;\n        (this as Mutable<this>).table = null;\n        (this as Mutable<this>).length = n - 1;\n        (this as Mutable<this>).fieldCount -= 1;\n        return item;\n      }\n    }\n    return Item.absent();\n  }\n\n  override clear(): void {\n    if ((this.flags & Record.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    (this as Mutable<this>).array = null;\n    (this as Mutable<this>).table = null;\n    (this as Mutable<this>).length = 0;\n    (this as Mutable<this>).fieldCount = 0;\n    (this as Mutable<this>).flags = 0;\n  }\n\n  override isAliased(): boolean {\n    return (this.flags & Record.AliasedFlag) !== 0;\n  }\n\n  override isMutable(): boolean {\n    return (this.flags & Record.ImmutableFlag) === 0;\n  }\n\n  override alias(): void {\n    (this as Mutable<this>).flags |= Record.AliasedFlag;\n  }\n\n  override branch(): RecordMap {\n    if ((this.flags & (Record.AliasedFlag | Record.ImmutableFlag)) === 0) {\n      const array = this.array!;\n      for (let i = 0; i < this.length; i += 1) {\n        array[i]!.alias();\n      }\n    }\n    (this as Mutable<this>).flags |= Record.AliasedFlag;\n    return new RecordMap(this.array, this.table, this.length, this.fieldCount, Record.AliasedFlag);\n  }\n\n  override clone(): RecordMap {\n    const itemCount = this.length;\n    const oldArray = this.array!;\n    const newArray = new Array(itemCount);\n    for (let i = 0; i < itemCount; i += 1) {\n      newArray[i] = oldArray[i]!.clone();\n    }\n    return new RecordMap(newArray, null, itemCount, this.fieldCount, 0);\n  }\n\n  override commit(): this {\n    if ((this.flags & Record.ImmutableFlag) !== 0) {\n      return this;\n    }\n    (this as Mutable<this>).flags |= Record.ImmutableFlag;\n    const array = this.array!;\n    for (let i = 0; i < this.length; i += 1) {\n      array[i]!.commit();\n    }\n    return this;\n  }\n\n  hashTable(): Array<Field> | null {\n    const n = this.fieldCount;\n    let table = this.table;\n    if (n !== 0 && table === null) {\n      table = new Array(Record.expand(Math.max(n, n * 10 / 7)));\n      const array = this.array!;\n      for (let i = 0; i < this.length; i += 1) {\n        const item = array[i];\n        if (item instanceof Field) {\n          RecordMap.put(table, item);\n        }\n      }\n      (this as Mutable<this>).table = table;\n    }\n    return table;\n  }\n\n  /** @internal */\n  static put(table: Field[] | null, field: Field): void {\n    if (table === null) {\n      return;\n    }\n    const n = table.length;\n    const x = Math.abs(field.key.hashCode() % n);\n    let i = x;\n    do {\n      const item = table[i];\n      if (item === void 0 || field.key.equals(item.key)) {\n        table[i] = field;\n        return;\n      }\n      i = (i + 1) % n;\n    } while (i !== x);\n    throw new Error();\n  }\n\n  override evaluate(interpreter: InterpreterLike): Record {\n    interpreter = Interpreter.fromLike(interpreter);\n    const array = this.array!;\n    const n = this.length;\n    const scope = Record.create(n);\n    interpreter.pushScope(scope);\n    let changed = false;\n    for (let i = 0; i < n; i += 1) {\n      const oldItem = array[i]!;\n      const newItem = oldItem.evaluate(interpreter);\n      if (newItem.isDefined()) {\n        scope.push(newItem);\n      }\n      if (oldItem !== newItem) {\n        changed = true;\n      }\n    }\n    interpreter.popScope();\n    return changed ? scope : this;\n  }\n\n  override substitute(interpreter: InterpreterLike): Record {\n    interpreter = Interpreter.fromLike(interpreter);\n    const array = this.array!;\n    const n = this.length;\n    const scope = Record.create(n);\n    interpreter.pushScope(scope);\n    let changed = false;\n    for (let i = 0; i < n; i += 1) {\n      const oldItem = array[i]!;\n      const newItem = oldItem.substitute(interpreter);\n      if (newItem.isDefined()) {\n        scope.push(newItem);\n      }\n      if (oldItem !== newItem) {\n        changed = true;\n      }\n    }\n    interpreter.popScope();\n    return changed ? scope : this;\n  }\n\n  override subRecord(lower?: number, upper?: number): Record {\n    const n = this.length;\n    if (lower === void 0) {\n      lower = 0;\n    } else if (lower < 0) {\n      lower = n + lower;\n    }\n    if (upper === void 0) {\n      upper = n;\n    } else if (upper < 0) {\n      upper = n + upper;\n    }\n    if (lower < 0 || upper > n || lower > upper) {\n      throw new RangeError(lower + \", \" + upper);\n    }\n    return new RecordMapView(this, lower, upper);\n  }\n\n  override forEach<T>(callback: (item: Item, index: number) => T | void): T | undefined;\n  override forEach<T, S>(callback: (this: S, item: Item, index: number) => T | void, thisArg: S): T | undefined;\n  override forEach<T, S>(callback: (this: S | undefined, item: Item, index: number) => T | void, thisArg?: S): T | undefined {\n    const array = this.array!;\n    for (let i = 0; i < this.length; i += 1) {\n      const result = callback.call(thisArg, array[i]!, i);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return void 0;\n  }\n\n  @Lazy\n  static override empty(): RecordMap {\n    return new RecordMap(null, null, 0, 0, Record.AliasedFlag | Record.ImmutableFlag);\n  }\n\n  static override create(initialCapacity?: number): RecordMap {\n    if (initialCapacity === void 0) {\n      return new RecordMap(null, null, 0, 0, Record.AliasedFlag);\n    }\n    return new RecordMap(new Array(initialCapacity), null, 0, 0, 0);\n  }\n\n  static override of(...items: ItemLike[]): RecordMap {\n    const n = items.length;\n    if (n === 0) {\n      return new RecordMap(null, null, 0, 0, Record.AliasedFlag);\n    }\n    const array = new Array(n);\n    let itemCount = 0;\n    let fieldCount = 0;\n    for (let i = 0; i < n; i += 1) {\n      const item = Item.fromLike(items[i]);\n      array[i] = item;\n      itemCount += 1;\n      if (item instanceof Field) {\n        fieldCount += 1;\n      }\n    }\n    return new RecordMap(array, null, itemCount, fieldCount, 0);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport type {ItemLike} from \"./Item\";\nimport {Item} from \"./Item\";\nimport {Field} from \"./Field\";\nimport {Attr} from \"./Attr\";\nimport type {ValueLike} from \"./Value\";\nimport {Value} from \"./Value\";\nimport {Record} from \"./Record\";\nimport {RecordMap} from \"./RecordMap\";\nimport type {NumLike} from \"./Num\";\nimport {Num} from \"./\"; // forward import\n\n/** @internal */\nexport class RecordMapView extends Record {\n  constructor(record: RecordMap, lower: number, upper: number) {\n    super();\n    this.record = record;\n    this.lower = lower;\n    this.upper = upper;\n  }\n\n  /** @internal */\n  readonly record: RecordMap;\n\n  /** @internal */\n  readonly lower: number;\n\n  /** @internal */\n  readonly upper: number;\n\n  override isEmpty(): boolean {\n    return this.lower === this.upper;\n  }\n\n  override isArray(): boolean {\n    const array = this.record.array;\n    for (let i = this.lower; i < this.upper; i += 1) {\n      if (array![i] instanceof Field) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  override isObject(): boolean {\n    const array = this.record.array;\n    for (let i = this.lower; i < this.upper; i += 1) {\n      if (array![i] instanceof Value) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  override get length(): number {\n    return this.upper - this.lower;\n  }\n\n  declare readonly fieldCount: number; // getter defined below to work around useDefineForClassFields lunacy\n\n  override get valueCount(): number {\n    let k = 0;\n    const array = this.record.array;\n    for (let i = this.lower; i < this.upper; i += 1) {\n      if (array![i] instanceof Value) {\n        k += 1;\n      }\n    }\n    return k;\n  }\n\n  override isConstant(): boolean {\n    const array = this.record.array;\n    for (let i = this.lower; i < this.upper; i += 1) {\n      if (!array![i]!.isConstant()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  override get tag(): string | undefined {\n    if (this.length === 0) {\n      return void 0;\n    }\n    const item = this.record.array![this.lower];\n    if (!(item instanceof Attr)) {\n      return void 0;\n    }\n    return item.key.value;\n  }\n\n  override get target(): Value {\n    let value: Value | undefined;\n    let record: Record | undefined;\n    let modified = false;\n    const array = this.record.array;\n    for (let i = this.lower; i < this.upper; i += 1) {\n      const item = array![i];\n      if (item instanceof Attr) {\n        modified = true;\n      } else if (value === void 0 && item instanceof Value) {\n        value = item;\n      } else {\n        if (record === void 0) {\n          record = Record.create();\n          if (value !== void 0) {\n            record.push(value);\n          }\n        }\n        record.push(item);\n      }\n    }\n    if (value === void 0) {\n      return Value.extant();\n    } else if (record === void 0) {\n      return value;\n    } else if (modified) {\n      return record;\n    }\n    return this;\n  }\n\n  override head(): Item {\n    if (this.length === 0) {\n      return Item.absent();\n    }\n    return this.record.array![this.lower]!;\n  }\n\n  override tail(): Record {\n    if (this.length === 0) {\n      return Record.empty();\n    }\n    return new RecordMapView(this.record, this.lower + 1, this.upper);\n  }\n\n  override body(): Value {\n    const n = this.length;\n    if (n === 0 || n === 1) {\n      return Value.absent();\n    } else if (n === 2) {\n      const item = this.record.array![this.lower + 1];\n      if (item instanceof Value) {\n        return item;\n      }\n      return Record.of(item);\n    }\n    return new RecordMapView(this.record, this.lower + 1, this.upper).branch();\n  }\n\n  override indexOf(item: ItemLike, index: number = 0): number {\n    item = Item.fromLike(item);\n    const array = this.record.array;\n    const n = this.length;\n    if (index < 0) {\n      index = Math.max(0, n + index);\n    }\n    index = this.lower + index;\n    while (index < this.upper) {\n      if (item.equals(array![index])) {\n        return index - this.lower;\n      }\n      index += 1;\n    }\n    return -1;\n  }\n\n  override lastIndexOf(item: ItemLike, index?: number): number {\n    item = Item.fromLike(item);\n    const array = this.record.array;\n    const n = this.length;\n    if (index === void 0) {\n      index = n - 1;\n    } else if (index < 0) {\n      index = n + index;\n    }\n    index = this.lower + Math.min(index, n - 1);\n    while (index >= this.lower) {\n      if (item.equals(array![index])) {\n        return index - this.lower;\n      }\n      index -= 1;\n    }\n    return -1;\n  }\n\n  override getItem(index: NumLike): Item {\n    if (index instanceof Num) {\n      index = index.value;\n    }\n    const n = this.length;\n    if (index < 0) {\n      index = n + index;\n    }\n    if (index < 0 || index >= n) {\n      return Item.absent();\n    }\n    return this.record.array![this.lower + index]!;\n  }\n\n  override setItem(index: number, newItem: ItemLike): this {\n    if ((this.record.flags & Record.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    newItem = Item.fromLike(newItem);\n    const n = this.length;\n    if (index < 0) {\n      index = n + index;\n    }\n    if (index < 0 || index > n) {\n      throw new RangeError(\"\" + index);\n    }\n    if ((this.record.flags & Record.AliasedFlag) !== 0) {\n      this.setItemAliased(index, newItem);\n    } else {\n      this.setItemMutable(index, newItem);\n    }\n    return this;\n  }\n\n  /** @internal */\n  setItemAliased(index: number, newItem: Item): void {\n    const record = this.record;\n    const n = record.length;\n    const oldArray = record.array;\n    const newArray = new Array(Record.expand(n));\n    for (let i = 0; i < n; i += 1) {\n      newArray[i] = oldArray![i];\n    }\n    const oldItem = oldArray !== null ? oldArray[this.lower + index] : null;\n    newArray[this.lower + index] = newItem;\n    (record as Mutable<RecordMap>).array = newArray;\n    (record as Mutable<RecordMap>).table = null;\n    if (newItem instanceof Field) {\n      if (!(oldItem instanceof Field)) {\n        (record as Mutable<RecordMap>).fieldCount += 1;\n      }\n    } else if (oldItem instanceof Field) {\n      (record as Mutable<RecordMap>).fieldCount -= 1;\n    }\n    (record as Mutable<RecordMap>).flags &= ~Record.AliasedFlag;\n  }\n\n  /** @internal */\n  setItemMutable(index: number, newItem: Item): void {\n    const record = this.record;\n    const array = record.array!;\n    const oldItem = array[this.lower + index];\n    array[this.lower + index] = newItem;\n    if (newItem instanceof Field) {\n      (record as Mutable<RecordMap>).table = null;\n      if (!(oldItem instanceof Field)) {\n        (record as Mutable<RecordMap>).fieldCount += 1;\n      }\n    } else if (oldItem instanceof Field) {\n      (record as Mutable<RecordMap>).table = null;\n      (record as Mutable<RecordMap>).fieldCount -= 1;\n    }\n  }\n\n  override push(...newItems: ItemLike[]): number {\n    if ((this.record.flags & Record.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    if ((this.record.flags & Record.AliasedFlag) !== 0) {\n      this.pushAliased(...newItems);\n    } else {\n      this.pushMutable(...newItems);\n    }\n    return this.length;\n  }\n\n  /** @internal */\n  pushAliased(...newItems: ItemLike[]): void {\n    const record = this.record;\n    const k = newItems.length;\n    let m = record.length;\n    let n = record.fieldCount;\n    const oldArray = record.array;\n    const newArray = new Array(Record.expand(m + k));\n    if (oldArray !== null) {\n      for (let i = 0; i < this.upper; i += 1) {\n        newArray[i] = oldArray[i];\n      }\n      for (let i = this.upper; i < m; i += 1) {\n        newArray[i + k] = oldArray[i];\n      }\n    }\n    for (let i = 0; i < k; i += 1) {\n      const newItem = Item.fromLike(newItems[i]);\n      newArray[i + this.upper] = newItem;\n      m += 1;\n      if (newItem instanceof Field) {\n        n += 1;\n      }\n    }\n    (record as Mutable<RecordMap>).array = newArray;\n    (record as Mutable<RecordMap>).table = null;\n    (record as Mutable<RecordMap>).length = m;\n    (record as Mutable<RecordMap>).fieldCount = n;\n    (record as Mutable<RecordMap>).flags &= ~Record.AliasedFlag;\n    (this as Mutable<this>).upper += k;\n  }\n\n  /** @internal */\n  pushMutable(...newItems: ItemLike[]): void {\n    const record = this.record;\n    const k = newItems.length;\n    let m = record.length;\n    let n = record.fieldCount;\n    const oldArray = record.array!;\n    let newArray;\n    if (oldArray === null || m + k > oldArray.length) {\n      newArray = new Array(Record.expand(m + k));\n      if (oldArray !== null) {\n        for (let i = 0; i < this.upper; i += 1) {\n          newArray[i] = oldArray[i];\n        }\n      }\n    } else {\n      newArray = oldArray;\n    }\n    for (let i = m - 1; i >= this.upper; i -= 1) {\n      newArray[i + k] = oldArray[i];\n    }\n    for (let i = 0; i < k; i += 1) {\n      const newItem = Item.fromLike(newItems[i]);\n      newArray[i + this.upper] = newItem;\n      m += 1;\n      if (newItem instanceof Field) {\n        n += 1;\n        (record as Mutable<RecordMap>).table = null;\n      }\n    }\n    (record as Mutable<RecordMap>).array = newArray;\n    (record as Mutable<RecordMap>).length = m;\n    (record as Mutable<RecordMap>).fieldCount = n;\n    (this as Mutable<this>).upper += k;\n  }\n\n  override splice(start: number, deleteCount: number = 0, ...newItems: ItemLike[]): Item[] {\n    if ((this.record.flags & Record.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    const n = this.length;\n    if (start < 0) {\n      start = n + start;\n    }\n    start = Math.min(Math.max(0, start), n);\n    deleteCount = Math.min(Math.max(0, deleteCount), n - start);\n    let deleted;\n    if ((this.record.flags & Record.AliasedFlag) !== 0) {\n      deleted = this.record.spliceAliased(this.lower + start, deleteCount, ...newItems);\n    } else {\n      deleted = this.record.spliceMutable(this.lower + start, deleteCount, ...newItems);\n    }\n    (this as Mutable<this>).upper += newItems.length - deleted.length;\n    return deleted;\n  }\n\n  override delete(key: ValueLike): Item {\n    if ((this.record.flags & Record.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    key = Value.fromLike(key);\n    if ((this.record.flags & Record.AliasedFlag) !== 0) {\n      return this.deleteAliased(key);\n    } else {\n      return this.deleteMutable(key);\n    }\n  }\n\n  /** @internal */\n  deleteAliased(key: Value): Item {\n    const record = this.record;\n    const n = record.length;\n    const oldArray = record.array;\n    const newArray = new Array(Record.expand(n));\n    for (let i = this.lower; i < this.upper; i += 1) {\n      const item = oldArray![i];\n      if (item instanceof Field && item.key.equals(key)) {\n        for (let j = i + 1; j < n; j += 1, i += 1) {\n          newArray[i] = oldArray![j];\n        }\n        (record as Mutable<RecordMap>).array = newArray;\n        (record as Mutable<RecordMap>).table = null;\n        (record as Mutable<RecordMap>).length = n - 1;\n        (record as Mutable<RecordMap>).fieldCount -= 1;\n        (record as Mutable<RecordMap>).flags &= ~Record.AliasedFlag;\n        (this as Mutable<this>).upper -= 1;\n        return item;\n      }\n      newArray[i] = item;\n    }\n    return Item.absent();\n  }\n\n  /** @internal */\n  deleteMutable(key: Value): Item {\n    const record = this.record;\n    const n = record.length;\n    const array = record.array;\n    for (let i = this.lower; i < this.upper; i += 1) {\n      const item = array![i]!;\n      if (item instanceof Field && item.key.equals(key)) {\n        for (let j = i + 1; j < n; j += 1, i += 1) {\n          array![i] = array![j]!;\n        }\n        array![n - 1] = void 0 as any;\n        (record as Mutable<RecordMap>).table = null;\n        (record as Mutable<RecordMap>).length = n - 1;\n        (record as Mutable<RecordMap>).fieldCount -= 1;\n        (this as Mutable<this>).upper -= 1;\n        return item;\n      }\n    }\n    return Item.absent();\n  }\n\n  override clear(): void {\n    if ((this.record.flags & Record.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    if ((this.record.flags & Record.AliasedFlag) !== 0) {\n      this.clearAliased();\n    } else {\n      this.clearMutable();\n    }\n  }\n\n  /** @internal */\n  clearAliased(): void {\n    const record = this.record;\n    const m = record.length;\n    let n = record.fieldCount;\n    const l = m - this.length;\n    const oldArray = record.array;\n    const newArray = new Array(Record.expand(l));\n    let i = 0;\n    while (i < this.lower) {\n      newArray[i] = oldArray![i];\n      i += 1;\n    }\n    while (i < this.upper) {\n      if (oldArray![i] instanceof Field) {\n        n -= 1;\n      }\n      i += 1;\n    }\n    i = this.lower;\n    let j = this.upper;\n    while (j < m) {\n      newArray[i] = oldArray![j];\n      i += 1;\n      j += 1;\n    }\n    (record as Mutable<RecordMap>).array = newArray;\n    (record as Mutable<RecordMap>).table = null;\n    (record as Mutable<RecordMap>).length = l;\n    (record as Mutable<RecordMap>).fieldCount = n;\n    (record as Mutable<RecordMap>).flags &= ~Record.AliasedFlag;\n    (this as Mutable<this>).upper = this.lower;\n  }\n\n  /** @internal */\n  clearMutable(): void {\n    const record = this.record;\n    const m = record.length;\n    let n = record.fieldCount;\n    const array = record.array;\n    let i = this.lower;\n    while (i < this.upper) {\n      if (array![i] instanceof Field) {\n        n -= 1;\n      }\n      i += 1;\n    }\n    i = this.lower;\n    let j = this.upper;\n    while (j < m) {\n      const item = array![j]!;\n      if (item instanceof Field) {\n        (record as Mutable<RecordMap>).table = null;\n      }\n      array![i] = item;\n      i += 1;\n      j += 1;\n    }\n    (record as Mutable<RecordMap>).length = i;\n    (record as Mutable<RecordMap>).fieldCount = n;\n    while (i < m) {\n      array![i] = void 0 as any;\n      i += 1;\n    }\n    (this as Mutable<this>).upper = this.lower;\n  }\n\n  override isAliased(): boolean {\n    return (this.record.flags & Record.AliasedFlag) !== 0;\n  }\n\n  override isMutable(): boolean {\n    return (this.record.flags & Record.ImmutableFlag) === 0;\n  }\n\n  override alias(): void {\n    (this.record as Mutable<RecordMap>).flags |= Record.AliasedFlag;\n  }\n\n  override branch(): RecordMap {\n    const m = this.length;\n    let n = 0;\n    const oldArray = this.record.array;\n    const newArray = new Array(Record.expand(m));\n    let i = this.lower;\n    let j = 0;\n    while (j < m) {\n      const item = oldArray![i];\n      newArray[j] = item;\n      if (item instanceof Field) {\n        n += 1;\n      }\n      i += 1;\n      j += 1;\n    }\n    return new RecordMap(newArray, null, m, n, 0);\n  }\n\n  override clone(): RecordMap {\n    const m = this.length;\n    let n = 0;\n    const oldArray = this.record.array;\n    const newArray = new Array(Record.expand(m));\n    let i = this.lower;\n    let j = 0;\n    while (j < m) {\n      const item = oldArray![i]!;\n      newArray[j] = item.clone();\n      if (item instanceof Field) {\n        n += 1;\n      }\n      i += 1;\n      j += 1;\n    }\n    return new RecordMap(newArray, null, m, n, 0);\n  }\n\n  override commit(): this {\n    this.record.commit();\n    return this;\n  }\n\n  override subRecord(lower?: number, upper?: number): Record {\n    const n = this.length;\n    if (lower === void 0) {\n      lower = 0;\n    } else if (lower < 0) {\n      lower = n + lower;\n    }\n    if (upper === void 0) {\n      upper = n;\n    } else if (upper < 0) {\n      upper = n + upper;\n    }\n    if (lower < 0 || upper > n || lower > upper) {\n      throw new RangeError(lower + \", \" + upper);\n    }\n    return new RecordMapView(this.record, this.lower + lower, this.upper + upper);\n  }\n\n  override forEach<T>(callback: (item: Item, index: number) => T | void): T | undefined;\n  override forEach<T, S>(callback: (this: S, item: Item, index: number) => T | void, thisArg?: S): T | undefined;\n  override forEach<T, S>(callback: (this: S | undefined, item: Item, index: number) => T | void, thisArg?: S): T | undefined {\n    const array = this.record.array;\n    for (let i = this.lower; i < this.upper; i += 1) {\n      const result = callback.call(thisArg, array![i]!, i);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return void 0;\n  }\n}\nObject.defineProperty(RecordMapView.prototype, \"fieldCount\", {\n  get(this: RecordMapView): number {\n    const array = this.record.array;\n    let k = 0;\n    for (let i = this.lower; i < this.upper; i += 1) {\n      if (array![i] instanceof Field) {\n        k += 1;\n      }\n    }\n    return k;\n  },\n  configurable: true,\n});\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport {Random} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Interpolator} from \"@swim/util\";\nimport type {Input} from \"@swim/codec\";\nimport type {OutputSettingsLike} from \"@swim/codec\";\nimport {OutputSettings} from \"@swim/codec\";\nimport {Output} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Base16} from \"@swim/codec\";\nimport {Base64} from \"@swim/codec\";\nimport {Item} from \"./Item\";\nimport {Value} from \"./Value\";\n\n/** @public */\nexport type DataLike = Data | Uint8Array;\n\n/** @public */\nexport class Data extends Value {\n  constructor(array: Uint8Array | null, size: number, flags: number) {\n    super();\n    this.array = array;\n    this.size = size;\n    this.flags = flags;\n  }\n\n  override likeType?(like: Uint8Array): void;\n\n  /** @internal */\n  readonly array: Uint8Array | null;\n\n  override isConstant(): boolean {\n    return true;\n  }\n\n  readonly size: number;\n\n  /** @internal */\n  readonly flags: number;\n\n  getByte(index: number): number {\n    if (index < 0 || index >= this.size) {\n      throw new RangeError(\"\" + index);\n    }\n    return this.array![index]!;\n  }\n\n  setByte(index: number, value: number): Data {\n    const flags = this.flags;\n    if ((flags & Data.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    } else if (index < 0 || index >= this.size) {\n      throw new RangeError(\"\" + index);\n    }\n    if ((flags & Data.AliasedFlag) !== 0) {\n      return this.setByteAliased(index, value);\n    } else {\n      return this.setByteMutable(index, value);\n    }\n  }\n\n  /** @internal */\n  setByteAliased(index: number, value: number): Data {\n    const n = this.size;\n    const oldArray = this.array!;\n    const newArray = new Uint8Array(Data.expand(n));\n    newArray.set(oldArray, 0);\n    newArray[index] = value;\n    (this as Mutable<this>).array = newArray;\n    (this as Mutable<this>).flags &= ~Data.AliasedFlag;\n    return this;\n  }\n\n  /** @internal */\n  setByteMutable(index: number, value: number): Data {\n    this.array![index] = value;\n    return this;\n  }\n\n  addByte(value: number): Data {\n    const flags = this.flags;\n    if ((flags & Data.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    if ((flags & Data.AliasedFlag) !== 0) {\n      return this.addByteAliased(value);\n    } else {\n      return this.addByteMutable(value);\n    }\n  }\n\n  /** @internal */\n  addByteAliased(value: number): Data {\n    const n = this.size;\n    const oldArray = this.array;\n    const newArray = new Uint8Array(Data.expand(n + 1));\n    if (oldArray !== null) {\n      newArray.set(oldArray, 0);\n    }\n    newArray[n] = value;\n    (this as Mutable<this>).array = newArray;\n    (this as Mutable<this>).size = n + 1;\n    (this as Mutable<this>).flags &= ~Data.AliasedFlag;\n    return this;\n  }\n\n  /** @internal */\n  addByteMutable(value: number): Data {\n    const n = this.size;\n    const oldArray = this.array;\n    let newArray;\n    if (oldArray === null || n + 1 > oldArray.length) {\n      newArray = new Uint8Array(Data.expand(n + 1));\n      if (oldArray !== null) {\n        newArray.set(oldArray, 0);\n      }\n      (this as Mutable<this>).array = newArray;\n    } else {\n      newArray = oldArray;\n    }\n    newArray[n] = value;\n    (this as Mutable<this>).size = n + 1;\n    return this;\n  }\n\n  addData(data: Data): Data {\n    let array = data.array;\n    if (array === null) {\n      return this;\n    }\n    const size = data.size;\n    if (array.length > size) {\n      array = array.slice(0, size);\n    }\n    return this.addUint8Array(array);\n  }\n\n  addUint8Array(array: Uint8Array): Data {\n    const flags = this.flags;\n    if ((flags & Data.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    if ((flags & Data.AliasedFlag) !== 0) {\n      return this.addUint8ArrayAliased(array);\n    } else {\n      return this.addUint8ArrayMutable(array);\n    }\n  }\n\n  /** @internal */\n  addUint8ArrayAliased(array: Uint8Array): Data {\n    const size = array.length;\n    if (size === 0) {\n      return this;\n    }\n    const n = this.size;\n    const oldArray = this.array;\n    const newArray = new Uint8Array(Data.expand(n + size));\n    if (oldArray !== null) {\n      newArray.set(oldArray, 0);\n    }\n    newArray.set(array, n);\n    (this as Mutable<this>).array = newArray;\n    (this as Mutable<this>).size = n + size;\n    (this as Mutable<this>).flags &= ~Data.AliasedFlag;\n    return this;\n  }\n\n  /** @internal */\n  addUint8ArrayMutable(array: Uint8Array): Data {\n    const size = array.length;\n    if (size === 0) {\n      return this;\n    }\n    const n = this.size;\n    const oldArray = this.array;\n    let newArray;\n    if (oldArray === null || n + size > oldArray.length) {\n      newArray = new Uint8Array(Data.expand(n + size));\n      if (oldArray !== null) {\n        newArray.set(oldArray, 0);\n      }\n      (this as Mutable<this>).array = newArray;\n    } else {\n      newArray = oldArray;\n    }\n    newArray.set(array, n);\n    (this as Mutable<this>).size = n + size;\n    return this;\n  }\n\n  clear(): void {\n    if ((this.flags & Data.ImmutableFlag) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    (this as Mutable<this>).array = null;\n    (this as Mutable<this>).size = 0;\n    (this as Mutable<this>).flags = Data.AliasedFlag;\n  }\n\n  toUint8Array(): Uint8Array {\n    const oldArray = this.array;\n    const flags = this.flags;\n    if ((flags & Data.ImmutableFlag) !== 0) {\n      return oldArray !== null ? oldArray.slice(0) : new Uint8Array(0);\n    } else if ((flags & Data.AliasedFlag) !== 0 || this.size !== oldArray!.length) {\n      const newArray = oldArray !== null ? oldArray.slice(0) : new Uint8Array(0);\n      (this as Mutable<this>).array = newArray;\n      (this as Mutable<this>).flags &= ~Data.AliasedFlag;\n      return newArray;\n    }\n    return oldArray!;\n  }\n\n  asUint8Array(): Uint8Array | undefined {\n    const array = this.array;\n    if (array === null || this.size === 0) {\n      return void 0;\n    } else if (array.length !== this.size) {\n      return new Uint8Array(array.buffer, array.byteOffset, this.size);\n    }\n    return array;\n  }\n\n  override toLike(): DataLike {\n    return this.toUint8Array();\n  }\n\n  override isAliased(): boolean {\n    return (this.flags & Data.AliasedFlag) !== 0;\n  }\n\n  override isMutable(): boolean {\n    return (this.flags & Data.ImmutableFlag) === 0;\n  }\n\n  override branch(): Data {\n    (this as Mutable<this>).flags |= Data.AliasedFlag;\n    return new Data(this.array, this.size, Data.AliasedFlag);\n  }\n\n  override clone(): Data {\n    return this.branch();\n  }\n\n  override commit(): this {\n    (this as Mutable<this>).flags |= Data.ImmutableFlag;\n    return this;\n  }\n\n  writeBase16(output: Output, base16: Base16 = Base16.uppercase): Writer<unknown, unknown> {\n    let array = this.array;\n    const size = this.size;\n    if (array === null || size === 0) {\n      return Writer.end();\n    } else if (array.length !== size) {\n      array = array.slice(0, size);\n    }\n    return base16.writeUint8Array(output, array);\n  }\n\n  toBase16(base16: Base16 = Base16.uppercase): string {\n    const output = Unicode.stringOutput();\n    this.writeBase16(output, base16).bind();\n    return output.bind();\n  }\n\n  writeBase64(output: Output, base64: Base64 = Base64.standard()): Writer<unknown, unknown> {\n    let array = this.array;\n    const size = this.size;\n    if (array === null || size === 0) {\n      return Writer.end();\n    } else if (array.length !== size) {\n      array = array.slice(0, size);\n    }\n    return base64.writeUint8Array(output, array);\n  }\n\n  toBase64(base64: Base64 = Base64.standard()): string {\n    const output = Unicode.stringOutput();\n    this.writeBase64(output, base64);\n    return output.bind();\n  }\n\n  override interpolateTo(that: Data): Interpolator<Data>;\n  override interpolateTo(that: Item): Interpolator<Item>;\n  override interpolateTo(that: unknown): Interpolator<Item> | null;\n  override interpolateTo(that: unknown): Interpolator<Item> | null {\n    return super.interpolateTo(that);\n  }\n\n  override get typeOrder(): number {\n    return 4;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Data) {\n      const xs = this.array!;\n      const ys = that.array!;\n      const xn = this.size;\n      const yn = that.size;\n      let order = 0;\n      let i = 0;\n      do {\n        if (i < xn && i < yn) {\n          order = xs[i]! - ys[i]!;\n          i += 1;\n        } else {\n          break;\n        }\n      } while (order === 0);\n      if (order > 0) {\n        return 1;\n      } else if (order < 0) {\n        return -1;\n      } else if (xn > yn) {\n        return 1;\n      } else if (xn < yn) {\n        return -1;\n      } else {\n        return 0;\n      }\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: Item): boolean {\n    return this.equals(that);\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Data) {\n      const xs = this.array!;\n      const ys = that.array!;\n      const xn = this.size;\n      if (xn !== that.size) {\n        return false;\n      }\n      for (let i = 0; i < xn; i += 1) {\n        if (xs[i] !== ys[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mixUint8Array(Constructors.hash(Data),\n        this.array !== null ? this.array : new Uint8Array(0)));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Data\").write(46/*'.'*/);\n    if (this.size === 0) {\n      output = output.write(\"empty\").write(40/*'('*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"base16\").write(40/*'('*/).write(34/*'\"'*/);\n      const writer = this.writeBase16(output);\n      if (!writer.isDone()) {\n        return Output.error(writer.trap());\n      }\n      output = output.write(34/*'\"'*/).write(41/*')'*/);\n    }\n    return output;\n  }\n\n  /** @internal */\n  static readonly AliasedFlag: number = 1 << 0;\n  /** @internal */\n  static readonly ImmutableFlag: number = 1 << 1;\n\n  @Lazy\n  static override empty(): Data {\n    return new Data(null, 0, Data.AliasedFlag | Data.ImmutableFlag);\n  }\n\n  static create(initialCapacity?: number): Data {\n    if (initialCapacity === void 0) {\n      return new Data(null, 0, Data.AliasedFlag);\n    }\n    return new Data(new Uint8Array(initialCapacity), 0, 0);\n  }\n\n  static wrap(value: Uint8Array): Data {\n    return new Data(value, value.length, Data.AliasedFlag);\n  }\n\n  static fromBase16(input: Input | string): Data {\n    if (typeof input === \"string\") {\n      input = Unicode.stringInput(input);\n    }\n    return Base16.parse(input, Data.output()).bind();\n  }\n\n  static fromBase64(input: Input | string, base64: Base64 = Base64.standard()): Data {\n    if (typeof input === \"string\") {\n      input = Unicode.stringInput(input);\n    }\n    return base64.parse(input, Data.output()).bind();\n  }\n\n  static override fromLike(value: DataLike): Data {\n    if (value instanceof Data) {\n      return value;\n    } else if (value instanceof Uint8Array) {\n      return Data.wrap(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static random(size: number): Data {\n    const array = new Uint8Array(size);\n    Random.fillBytes(array);\n    return Data.wrap(array);\n  }\n\n  static output(): Output<Data>;\n  static output(initialCapacity: number): Output<Data>;\n  static output(data: Data): Output<Data>;\n  static output(data?: number | Data): Output<Data> {\n    if (!(data instanceof Data)) {\n      data = Data.create(data);\n    }\n    return new DataOutput(data, OutputSettings.standard());\n  }\n\n  /** @internal */\n  static expand(n: number): number {\n    n = Math.max(32, n) - 1;\n    n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16;\n    return n + 1;\n  }\n}\n\n/** @internal */\nexport class DataOutput extends Output<Data> {\n  constructor(data: Data, settings: OutputSettings) {\n    super();\n    this.data = data;\n    this.settings = settings;\n  }\n\n  /** @internal */\n  readonly data: Data;\n\n  override isCont(): boolean {\n    return true;\n  }\n\n  override isFull(): boolean {\n    return false;\n  }\n\n  override isDone(): boolean {\n    return false;\n  }\n\n  override isError(): boolean {\n    return false;\n  }\n\n  override isPart(): boolean {\n    return false;\n  }\n\n  override asPart(part: boolean): Output<Data> {\n    return this;\n  }\n\n  override write(b: number | string): Output<Data> {\n    if (typeof b !== \"number\") {\n      throw new TypeError(\"\" + b);\n    }\n    this.data.addByte(b);\n    return this;\n  }\n\n  override writeln(string?: string): Output<Data> {\n    throw new TypeError(\"\" + string);\n  }\n\n  override readonly settings: OutputSettings;\n\n  override withSettings(settings: OutputSettingsLike): Output<Data> {\n    settings = OutputSettings.fromLike(settings);\n    (this as Mutable<this>).settings = settings;\n    return this;\n  }\n\n  override bind(): Data {\n    return this.data;\n  }\n\n  override clone(): Output<Data> {\n    return new DataOutput(this.data.branch(), this.settings);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Strings} from \"@swim/util\";\nimport type {Interpolator} from \"@swim/util\";\nimport type {OutputSettingsLike} from \"@swim/codec\";\nimport {OutputSettings} from \"@swim/codec\";\nimport {Output} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport type {ItemLike} from \"./Item\";\nimport {Item} from \"./Item\";\nimport type {ValueLike} from \"./Value\";\nimport {Value} from \"./Value\";\nimport {Num} from \"./\"; // forward import\n\n/** @public */\nexport type TextLike = Text | string;\n\n/** @public */\nexport class Text extends Value {\n  private constructor(value: string) {\n    super();\n    this.value = value;\n    this.hashValue = void 0;\n  }\n\n  override likeType?(like: string): void;\n\n  override isConstant(): boolean {\n    return true;\n  }\n\n  readonly value: string;\n\n  get size(): number {\n    return this.value.length;\n  }\n\n  override stringValue(): string;\n  override stringValue<T>(orElse: T): string;\n  override stringValue<T>(orElse?: T): string {\n    return this.value;\n  }\n\n  override numberValue(): number | undefined;\n  override numberValue<T>(orElse: T): number | T;\n  override numberValue<T>(orElse?: T): number | T | undefined {\n    try {\n      return Num.parse(this.value).numberValue();\n    } catch (error) {\n      return orElse;\n    }\n  }\n\n  override booleanValue(): boolean | undefined;\n  override booleanValue<T>(orElse: T): boolean | T;\n  override booleanValue<T>(orElse?: T): boolean | T | undefined {\n    if (this.value === \"true\") {\n      return true;\n    } else if (this.value === \"false\") {\n      return false;\n    } else {\n      return orElse;\n    }\n  }\n\n  override toLike(): TextLike {\n    return this.value;\n  }\n\n  override valueOf(): string {\n    return this.value;\n  }\n\n  override plus(that: ValueLike): Value;\n  override plus(that: ItemLike): Item;\n  override plus(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Text) {\n      return Text.from(this.value + that.value);\n    }\n    return super.plus(that);\n  }\n\n  override branch(): Text {\n    return this;\n  }\n\n  override clone(): Text {\n    return this;\n  }\n\n  override commit(): this {\n    return this;\n  }\n\n  override interpolateTo(that: Text): Interpolator<Text>;\n  override interpolateTo(that: Item): Interpolator<Item>;\n  override interpolateTo(that: unknown): Interpolator<Item> | null;\n  override interpolateTo(that: unknown): Interpolator<Item> | null {\n    return super.interpolateTo(that);\n  }\n\n  override get typeOrder(): number {\n    return 5;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Text) {\n      return this.value.localeCompare(that.value);\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown): boolean {\n    return this.equals(that);\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Text) {\n      return this.value === that.value;\n    }\n    return false;\n  }\n\n  /** @internal */\n  readonly hashValue: number | undefined;\n\n  override hashCode(): number {\n    let hashValue = this.hashValue;\n    if (hashValue === void 0) {\n      hashValue = Strings.hash(this.value);\n      (this as Mutable<this>).hashValue = hashValue;\n    }\n    return hashValue;\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Text\").write(46/*'.'*/);\n    if (this.value.length === 0) {\n      output = output.write(\"empty\").write(40/*'('*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"from\").write(40/*'('*/).debug(this.value).write(41/*')'*/);\n    }\n    return output;\n  }\n\n  override display<T>(output: Output<T>): Output<T> {\n    return Format.debugAny(output, this.value);\n  }\n\n  override toString(): string {\n    return this.value;\n  }\n\n  @Lazy\n  static override empty(): Text {\n    return new Text(\"\");\n  }\n\n  static from(value: string): Text {\n    const n = value.length;\n    if (n === 0) {\n      return Text.empty();\n    }\n    return new Text(value);\n  }\n\n  static override fromLike(value: TextLike): Text {\n    if (value instanceof Text) {\n      return value;\n    } else if (typeof value === \"string\") {\n      return Text.from(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static output(settings?: OutputSettings): Output<Text> {\n    if (settings === void 0) {\n      settings = OutputSettings.standard();\n    }\n    return new TextOutput(\"\", settings);\n  }\n}\n\n/** @internal */\nexport class TextOutput extends Output<Text> {\n  constructor(string: string, settings: OutputSettings) {\n    super();\n    this.string = string;\n    this.settings = settings;\n  }\n\n  /** @internal */\n  readonly string: string;\n\n  override isCont(): boolean {\n    return true;\n  }\n\n  override isFull(): boolean {\n    return false;\n  }\n\n  override isDone(): boolean {\n    return false;\n  }\n\n  override isError(): boolean {\n    return false;\n  }\n\n  override isPart(): boolean {\n    return false;\n  }\n\n  override asPart(part: boolean): Output<Text> {\n    return this;\n  }\n\n  override write(token: number | string): Output<Text> {\n    if (typeof token === \"number\") {\n      if ((token >= 0x0000 && token <= 0xd7ff)\n          || (token >= 0xe000 && token <= 0xffff)) { // U+0000..U+D7FF | U+E000..U+FFFF\n        token = String.fromCharCode(token);\n      } else if (token >= 0x10000 && token <= 0x10ffff) { // U+10000..U+10FFFF\n        const u = token - 0x10000;\n        token = String.fromCharCode(0xd800 | (u >>> 10), 0xdc00 | (u & 0x3ff));\n      } else { // invalid code point\n        token = \"\\ufffd\";\n      }\n    }\n    (this as Mutable<this>).string += token;\n    return this;\n  }\n\n  override readonly settings!: OutputSettings;\n\n  override withSettings(settings: OutputSettingsLike): Output<Text> {\n    settings = OutputSettings.fromLike(settings);\n    (this as Mutable<this>).settings = settings;\n    return this;\n  }\n\n  override bind(): Text {\n    return Text.from(this.string);\n  }\n\n  override clone(): Output<Text> {\n    return new TextOutput(this.string, this.settings);\n  }\n\n  override toString(): string {\n    return this.string;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport {Equivalent} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport type {ItemLike} from \"./Item\";\nimport {Item} from \"./Item\";\nimport type {ValueLike} from \"./Value\";\nimport {Value} from \"./Value\";\n\n/** @public */\nexport type NumLike = Num | number;\n\n/** @public */\nexport class Num extends Value {\n  private constructor(value: number, flags?: number) {\n    super();\n    this.value = value;\n    this.flags = flags !== void 0 ? flags : 0;\n  }\n\n  override likeType?(like: number): void;\n\n  override isConstant(): boolean {\n    return true;\n  }\n\n  readonly value: number;\n\n  /** @internal */\n  readonly flags: number;\n\n  isNaN(): boolean {\n    return isNaN(this.value);\n  }\n\n  isInfinite(): boolean {\n    return !isNaN(this.value) && !isFinite(this.value);\n  }\n\n  isUint32(): boolean {\n    return (this.flags & Num.Uint32Flag) !== 0;\n  }\n\n  isUint64(): boolean {\n    return (this.flags & Num.Uint64Flag) !== 0;\n  }\n\n  override stringValue(): string;\n  override stringValue<T>(orElse: T): string;\n  override stringValue<T>(orElse?: T): string {\n    return \"\" + this.value;\n  }\n\n  override numberValue(): number;\n  override numberValue<T>(orElse: T): number;\n  override numberValue<T>(orElse?: T): number {\n    return this.value;\n  }\n\n  override booleanValue(): boolean;\n  override booleanValue<T>(orElse: T): boolean;\n  override booleanValue<T>(orElse?: T): boolean {\n    return !!this.value;\n  }\n\n  override toLike(): NumLike {\n    return this.value;\n  }\n\n  override valueOf(): number {\n    return this.value;\n  }\n\n  override bitwiseOr(that: ValueLike): Value;\n  override bitwiseOr(that: ItemLike): Item;\n  override bitwiseOr(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Num) {\n      return Num.from((this.value | that.value) >>> 0);\n    }\n    return super.bitwiseOr(that);\n  }\n\n  override bitwiseXor(that: ValueLike): Value;\n  override bitwiseXor(that: ItemLike): Item;\n  override bitwiseXor(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Num) {\n      return Num.from((this.value ^ that.value) >>> 0);\n    }\n    return super.bitwiseXor(that);\n  }\n\n  override bitwiseAnd(that: ValueLike): Value;\n  override bitwiseAnd(that: ItemLike): Item;\n  override bitwiseAnd(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Num) {\n      return Num.from((this.value & that.value) >>> 0);\n    }\n    return super.bitwiseAnd(that);\n  }\n\n  override plus(that: ValueLike): Value;\n  override plus(that: ItemLike): Item;\n  override plus(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Num) {\n      return Num.from(this.value + that.value);\n    }\n    return super.plus(that);\n  }\n\n  override minus(that: ValueLike): Value;\n  override minus(that: ItemLike): Item;\n  override minus(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Num) {\n      return Num.from(this.value - that.value);\n    }\n    return super.minus(that);\n  }\n\n  override times(that: ValueLike): Value;\n  override times(that: ItemLike): Item;\n  override times(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Num) {\n      return Num.from(this.value * that.value);\n    }\n    return super.times(that);\n  }\n\n  override divide(that: ValueLike): Value;\n  override divide(that: ItemLike): Item;\n  override divide(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Num) {\n      return Num.from(this.value / that.value);\n    }\n    return super.divide(that);\n  }\n\n  override modulo(that: ValueLike): Value;\n  override modulo(that: ItemLike): Item;\n  override modulo(that: ItemLike): Item {\n    that = Item.fromLike(that);\n    if (that instanceof Num) {\n      return Num.from(this.value % that.value);\n    }\n    return super.modulo(that);\n  }\n\n  override bitwiseNot(): Value {\n    return Num.from(~this.value >>> 0);\n  }\n\n  override negative(): Value {\n    return Num.from(-this.value);\n  }\n\n  override positive(): Value {\n    return this;\n  }\n\n  override inverse(): Value {\n    return Num.from(1 / this.value);\n  }\n\n  abs(): Num {\n    return Num.from(Math.abs(this.value));\n  }\n\n  ceil(): Num {\n    return Num.from(Math.ceil(this.value));\n  }\n\n  floor(): Num {\n    return Num.from(Math.floor(this.value));\n  }\n\n  round(): Num {\n    return Num.from(Math.round(this.value));\n  }\n\n  sqrt(): Num {\n    return Num.from(Math.sqrt(this.value));\n  }\n\n  pow(that: NumLike): Num {\n    that = Num.fromLike(that);\n    return Num.from(Math.pow(this.value, that.value));\n  }\n\n  override max(that: Num): Num;\n  override max(that: Item): Item;\n  override max(that: Item): Item {\n    return this.compareTo(that) >= 0 ? this : that;\n  }\n\n  override min(that: Num): Num;\n  override min(that: Item): Item;\n  override min(that: Item): Item {\n    return this.compareTo(that) <= 0 ? this : that;\n  }\n\n  override interpolateTo(that: Num): Interpolator<Num>;\n  override interpolateTo(that: Item): Interpolator<Item>;\n  override interpolateTo(that: unknown): Interpolator<Item> | null;\n  override interpolateTo(that: unknown): Interpolator<Item> | null {\n    if (that instanceof Num) {\n      return NumInterpolator(this, that);\n    }\n    return super.interpolateTo(that);\n  }\n\n  override get typeOrder(): number {\n    return 6;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Num) {\n      const x = this.value;\n      const y = that.value;\n      return x < y ? -1 : x > y ? 1 : isNaN(y) ? (isNaN(x) ? 0 : -1) : isNaN(x) ? 1 : 0;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Num) {\n      const x = this.value;\n      const y = that.value;\n      return x === y || isNaN(x) && isNaN(y) || Math.abs(y - x) < (epsilon !== void 0 ? epsilon : Equivalent.Epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Num) {\n      const x = this.value;\n      const y = that.value;\n      return x === y || isNaN(x) && isNaN(y);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Numbers.hash(this.value);\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Num\").write(46/*'.'*/).write(\"from\")\n                   .write(40/*'('*/).display(this).write(41/*')'*/);\n    return output;\n  }\n\n  override display<T>(output: Output<T>): Output<T> {\n    return Format.displayNumber(output, this.value);\n  }\n\n  /** @internal */\n  static readonly Uint32Flag: number = 1;\n  /** @internal */\n  static readonly Uint64Flag: number = 2;\n  /** @internal */\n  static readonly TypeMask = 0x3;\n\n  @Lazy\n  static zero(): Num {\n    return new Num(0);\n  }\n\n  @Lazy\n  static negativeZero(): Num {\n    return new Num(-0);\n  }\n\n  @Lazy\n  static one(): Num {\n    return new Num(1);\n  }\n\n  @Lazy\n  static negativeOne(): Num {\n    return new Num(-1);\n  }\n\n  @Lazy\n  static nan(): Num {\n    return new Num(NaN);\n  }\n\n  static uint32(value: number): Num {\n    return new Num(value, Num.Uint32Flag);\n  }\n\n  static uint64(value: number): Num {\n    return new Num(value, Num.Uint64Flag);\n  }\n\n  static from(value: number): Num {\n    if (value === 0) {\n      if (1 / value === -Infinity) {\n        return Num.negativeZero();\n      } else {\n        return Num.zero();\n      }\n    } else if (value === 1) {\n      return Num.one();\n    } else if (value === -1) {\n      return Num.negativeOne();\n    } else if (isNaN(value)) {\n      return Num.nan();\n    }\n    return new Num(value);\n  }\n\n  static override fromLike(value: NumLike): Num {\n    if (value instanceof Num) {\n      return value;\n    } else if (typeof value === \"number\") {\n      return Num.from(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static parse(value: string): Num {\n    if (value === \"NaN\") {\n      return Num.nan();\n    }\n    const num = +value;\n    if (!isFinite(num)) {\n      throw new Error(value);\n    }\n    return Num.from(num);\n  }\n}\n\n/** @internal */\nexport const NumInterpolator = (function (_super: typeof Interpolator) {\n  const NumInterpolator = function (y0: Num, y1: Num): Interpolator<Num> {\n    const interpolator = function (u: number): Num {\n      const y0 = interpolator[0].value;\n      const y1 = interpolator[1].value;\n      return Num.from(y0 + u * (y1 - y0));\n    } as Interpolator<Num>;\n    Object.setPrototypeOf(interpolator, NumInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = y0;\n    (interpolator as Mutable<typeof interpolator>)[1] = y1;\n    return interpolator;\n  } as {\n    (y0: Num, y1: Num): Interpolator<Num>;\n\n    /** @internal */\n    prototype: Interpolator<Num>;\n  };\n\n  NumInterpolator.prototype = Object.create(_super.prototype);\n  NumInterpolator.prototype.constructor = NumInterpolator;\n\n  return NumInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Strings} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {ItemLike} from \"./Item\";\nimport {Item} from \"./Item\";\nimport type {ValueLike} from \"./Value\";\nimport {Value} from \"./Value\";\n\n/** @public */\nexport type BoolLike = Bool | boolean;\n\n/** @public */\nexport class Bool extends Value {\n  private constructor(value: boolean) {\n    super();\n    Object.defineProperty(this, \"value\", {\n      value: value,\n      enumerable: true,\n    });\n    Object.defineProperty(this, \"hashValue\", {\n      value: Strings.hash(value ? \"true\" : \"false\"),\n    });\n  }\n\n  override likeType?(like: boolean): void;\n\n  override isDefinite(): boolean {\n    return this.value;\n  }\n\n  override isConstant(): boolean {\n    return true;\n  }\n\n  readonly value!: boolean;\n\n  override stringValue(): string;\n  override stringValue<T>(orElse: T): string;\n  override stringValue<T>(orElse?: T): string {\n    return this.value ? \"true\" : \"false\";\n  }\n\n  override booleanValue(): boolean;\n  override booleanValue<T>(orElse: T): boolean;\n  override booleanValue<T>(orElse?: T): boolean {\n    return this.value;\n  }\n\n  override toLike(): BoolLike {\n    return this.value;\n  }\n\n  override valueOf(): boolean {\n    return this.value;\n  }\n\n  override conditional(thenTerm: ValueLike, elseTerm: ValueLike): Value;\n  override conditional(thenTerm: ItemLike, elseTerm: ItemLike): Item;\n  override conditional(thenTerm: ItemLike, elseTerm: ItemLike): Item {\n    return this.value ? Item.fromLike(thenTerm) : Item.fromLike(elseTerm);\n  }\n\n  override or(that: ValueLike): Value;\n  override or(that: ItemLike): Item;\n  override or(that: ItemLike): Item {\n    return this.value ? this : Item.fromLike(that);\n  }\n\n  override and(that: ValueLike): Value;\n  override and(that: ItemLike): Item;\n  override and(that: ItemLike): Item {\n    return this.value ? Item.fromLike(that) : this;\n  }\n\n  override not(): Value {\n    return Bool.from(!this.value);\n  }\n\n  override get typeOrder(): number {\n    return 7;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Bool) {\n      if (this.value && !that.value) {\n        return -1;\n      } else if (!this.value && that.value) {\n        return 1;\n      } else {\n        return 0;\n      }\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown): boolean {\n    return this.equals(that);\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Bool) {\n      return this.value === that.value;\n    }\n    return false;\n  }\n\n  /** @internal */\n  readonly hashValue!: number;\n\n  override hashCode(): number {\n    return this.hashValue;\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Bool\").write(46/*'.'*/).write(\"from\").write(40/*'('*/)\n                   .write(this.value ? \"true\" : \"false\").write(41/*')'*/);\n    return output;\n  }\n\n  override display<T>(output: Output<T>): Output<T> {\n    output = output.write(this.value ? \"true\" : \"false\");\n    return output;\n  }\n\n  @Lazy\n  static true(): Bool {\n    return new Bool(true);\n  }\n\n  @Lazy\n  static false(): Bool {\n    return new Bool(false);\n  }\n\n  static from(value: boolean): Bool {\n    return value ? Bool.true() : Bool.false();\n  }\n\n  static override fromLike(value: BoolLike): Bool {\n    if (value instanceof Bool) {\n      return value;\n    } else if (typeof value === \"boolean\") {\n      return Bool.from(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Interpolator} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"./Item\";\nimport {Value} from \"./Value\";\nimport {Record} from \"./Record\";\n\n/** @public */\nexport type ExtantLike = Extant | null;\n\n/** @public */\nexport class Extant extends Value {\n  /** @internal */\n  private constructor() {\n    super();\n  }\n\n  override likeType?(like: null): void;\n\n  /**\n   * Always returns `true` because `Extant` is a defined value.\n   */\n  override isDefined(): boolean {\n    return true;\n  }\n\n  /**\n   * Always returns `false` because `Extant` is not a distinct value.\n   */\n  override isDistinct(): boolean {\n    return false;\n  }\n\n  /**\n   * Always returns `false` because `Extant` is not a definite value.\n   */\n  override isDefinite(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return true;\n  }\n\n  /**\n   * Always returns an empty `Record` because `Extant` is not a distinct value.\n   */\n  override unflattened(): Record {\n    return Record.empty();\n  }\n\n  override not(): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Always returns the empty `string` because `Extant` behaves like an empty\n   * `Record`, which converts to a `string` by concatenating the string values\n   * of all its members, if all its members convert to string values.\n   */\n  override stringValue(): string;\n  /**\n   * Always returns the empty `string` because `Extant` behaves like an empty\n   * `Record`, which converts to a `string` by concatenating the string values\n   * of all its members, if all its members convert to string values.\n   */\n  override stringValue<T>(orElse: T): string;\n  override stringValue<T>(orElse?: T): string {\n    return \"\";\n  }\n\n  /**\n   * Always returns `true` because `Extant` behaves like a truthy value.\n   */\n  override booleanValue(): boolean;\n  /**\n   * Always returns `true` because `Extant` behaves like a truthy value.\n   */\n  override booleanValue<T>(orElse: T): boolean;\n  override booleanValue<T>(orElse?: T): boolean {\n    return true;\n  }\n\n  override toLike(): ExtantLike {\n    return null;\n  }\n\n  override interpolateTo(that: Extant): Interpolator<Extant>;\n  override interpolateTo(that: Item): Interpolator<Item>;\n  override interpolateTo(that: unknown): Interpolator<Item> | null;\n  override interpolateTo(that: unknown): Interpolator<Item> | null {\n    return super.interpolateTo(that);\n  }\n\n  override get typeOrder(): number {\n    return 98;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown): boolean {\n    return this === that;\n  }\n\n  override equals(that: unknown): boolean {\n    return this === that;\n  }\n\n  override hashCode(): number {\n    return Constructors.hash(Extant);\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Value\").write(46/*'.'*/).write(\"extant\").write(40/*'('*/).write(41/*')'*/);\n    return output;\n  }\n\n  override display<T>(output: Output<T>): Output<T> {\n    output = output.write(\"null\");\n    return output;\n  }\n\n  @Lazy\n  static override extant(): Extant {\n    return new Extant();\n  }\n\n  static override fromLike(value: ExtantLike): Extant {\n    if (value instanceof Extant) {\n      return value;\n    } else if (value === null) {\n      return Extant.extant();\n    }\n    throw new TypeError(\"\" + value);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Cursor} from \"@swim/util\";\nimport type {Interpolator} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {ItemLike} from \"./Item\";\nimport {Item} from \"./Item\";\nimport {Attr} from \"./Attr\";\nimport {Slot} from \"./Slot\";\nimport type {ValueLike} from \"./Value\";\nimport {Value} from \"./Value\";\nimport {Record} from \"./Record\";\nimport type {TextLike} from \"./Text\";\n\n/** @public */\nexport type AbsentLike = Absent | undefined;\n\n/** @public */\nexport class Absent extends Value {\n  /** @internal */\n  private constructor() {\n    super();\n  }\n\n  override likeType?(like: undefined): void;\n\n  /**\n   * Always returns `false` because `Absent` represents an undefined value.\n   */\n  override isDefined(): boolean {\n    return false;\n  }\n\n  /**\n   * Always returns `false` because `Absent` is not a distinct value.\n   */\n  override isDistinct(): boolean {\n    return false;\n  }\n\n  /**\n   * Always returns `false` because `Absent` is not a definite value.\n   */\n  override isDefinite(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return true;\n  }\n\n  /**\n   * Always returns an empty `Record` because `Absent` is not a distinct value.\n   */\n  override unflattened(): Record {\n    return Record.empty();\n  }\n\n  override updated(key: ValueLike, value: ValueLike): Record {\n    return Record.of(Slot.of(key, value));\n  }\n\n  override updatedAttr(key: TextLike, value: ValueLike): Record {\n    return Record.of(Attr.of(key, value));\n  }\n\n  override updatedSlot(key: ValueLike, value: ValueLike): Record {\n    return Record.of(Slot.of(key, value));\n  }\n\n  override appended(...items: ItemLike[]): Record {\n    return Record.of(items);\n  }\n\n  override prepended(...items: ItemLike[]): Record {\n    return Record.of(items);\n  }\n\n  override concat(...items: ItemLike[]): Record {\n    const record = Record.create();\n    for (let i = 0; i < items.length; i += 1) {\n      Item.fromLike(items[i]).forEach(function (item: Item): void {\n        record.push(item);\n      });\n    }\n    return record;\n  }\n\n  override conditional(thenTerm: ValueLike, elseTerm: ValueLike): Value;\n  override conditional(thenTerm: ItemLike, elseTerm: ItemLike): Item;\n  override conditional(thenTerm: ItemLike, elseTerm: ItemLike): Item {\n    return Item.fromLike(elseTerm);\n  }\n\n  override or(that: ValueLike): Value;\n  override or(that: ItemLike): Item;\n  override or(that: ItemLike): Item {\n    return Item.fromLike(that);\n  }\n\n  override and(that: ValueLike): Value;\n  override and(that: ItemLike): Item;\n  override and(that: ItemLike): Item {\n    return this;\n  }\n\n  override not(): Value {\n    return Value.extant();\n  }\n\n  /**\n   * Always returns `false` because `Absent` behaves like a falsey value.\n   */\n  override booleanValue(): boolean;\n  /**\n   * Always returns `false` because `Absent` behaves like a falsey value.\n   */\n  override booleanValue<T>(orElse: T): boolean;\n  override booleanValue<T>(orElse?: T): boolean {\n    return false;\n  }\n\n  override toLike(): AbsentLike {\n    return void 0;\n  }\n\n  override forEach<T>(callback: (item: Item, index: number) => T | void): T | undefined;\n  override forEach<T, S>(callback: (this: S, item: Item, index: number) => T | void, thisArg: S): T | undefined;\n  override forEach<T, S>(callback: (this: S | undefined, item: Item, index: number) => T | void, thisArg?: S): T | undefined {\n    return void 0;\n  }\n\n  override iterator(): Cursor<Item> {\n    return Cursor.empty();\n  }\n\n  override interpolateTo(that: Absent): Interpolator<Absent>;\n  override interpolateTo(that: Item): Interpolator<Item>;\n  override interpolateTo(that: unknown): Interpolator<Item> | null;\n  override interpolateTo(that: unknown): Interpolator<Item> | null {\n    return super.interpolateTo(that);\n  }\n\n  override get typeOrder(): number {\n    return 99;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown): boolean {\n    return this === that;\n  }\n\n  override equals(that: unknown): boolean {\n    return this === that;\n  }\n\n  override hashCode(): number {\n    return Constructors.hash(Absent);\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Value\").write(46/*'.'*/).write(\"absent\").write(40/*'('*/).write(41/*')'*/);\n    return output;\n  }\n\n  override display<T>(output: Output<T>): Output<T> {\n    output = output.write(\"undefined\");\n    return output;\n  }\n\n  @Lazy\n  static override absent(): Absent {\n    return new Absent();\n  }\n\n  static override fromLike(value: AbsentLike): Absent {\n    if (value instanceof Absent) {\n      return value;\n    } else if (value === void 0) {\n      return Absent.absent();\n    }\n    throw new TypeError(\"\" + value);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {ItemLike} from \"./Item\";\nimport {Item} from \"./Item\";\nimport type {ValueLike} from \"./Value\";\nimport {Value} from \"./Value\";\nimport {Num} from \"./Num\";\nimport type {Operator} from \"./operator/Operator\";\nimport {ConditionalOperator} from \"./\"; // forward import\nimport {OrOperator} from \"./\"; // forward import\nimport {AndOperator} from \"./\"; // forward import\nimport {BitwiseOrOperator} from \"./\"; // forward import\nimport {BitwiseXorOperator} from \"./\"; // forward import\nimport {BitwiseAndOperator} from \"./\"; // forward import\nimport {LtOperator} from \"./\"; // forward import\nimport {LeOperator} from \"./\"; // forward import\nimport {EqOperator} from \"./\"; // forward import\nimport {NeOperator} from \"./\"; // forward import\nimport {GeOperator} from \"./\"; // forward import\nimport {GtOperator} from \"./\"; // forward import\nimport {PlusOperator} from \"./\"; // forward import\nimport {MinusOperator} from \"./\"; // forward import\nimport {TimesOperator} from \"./\"; // forward import\nimport {DivideOperator} from \"./\"; // forward import\nimport {ModuloOperator} from \"./\"; // forward import\nimport {NotOperator} from \"./\"; // forward import\nimport {BitwiseNotOperator} from \"./\"; // forward import\nimport {NegativeOperator} from \"./\"; // forward import\nimport {PositiveOperator} from \"./\"; // forward import\n\n/** @public */\nexport abstract class Expression extends Value {\n  /** @internal */\n  constructor() {\n    super();\n  }\n\n  override conditional(thenTerm: Value, elseTerm: Value): Value;\n  override conditional(thenTerm: ItemLike, elseTerm: ItemLike): Item;\n  override conditional(thenTerm: ItemLike, elseTerm: ItemLike): Item {\n    thenTerm = Item.fromLike(thenTerm);\n    elseTerm = Item.fromLike(elseTerm);\n    return new ConditionalOperator(this, thenTerm, elseTerm);\n  }\n\n  override or(that: ItemLike): Operator {\n    that = Item.fromLike(that);\n    return new OrOperator(this, that);\n  }\n\n  override and(that: ItemLike): Operator {\n    that = Item.fromLike(that);\n    return new AndOperator(this, that);\n  }\n\n  override bitwiseOr(that: ItemLike): Operator {\n    that = Item.fromLike(that);\n    return new BitwiseOrOperator(this, that);\n  }\n\n  override bitwiseXor(that: ItemLike): Operator {\n    that = Item.fromLike(that);\n    return new BitwiseXorOperator(this, that);\n  }\n\n  override bitwiseAnd(that: ItemLike): Operator {\n    that = Item.fromLike(that);\n    return new BitwiseAndOperator(this, that);\n  }\n\n  override lt(that: ItemLike): Operator {\n    that = Item.fromLike(that);\n    return new LtOperator(this, that);\n  }\n\n  override le(that: ItemLike): Operator {\n    that = Item.fromLike(that);\n    return new LeOperator(this, that);\n  }\n\n  override eq(that: ItemLike): Operator {\n    that = Item.fromLike(that);\n    return new EqOperator(this, that);\n  }\n\n  override ne(that: ItemLike): Operator {\n    that = Item.fromLike(that);\n    return new NeOperator(this, that);\n  }\n\n  override ge(that: ItemLike): Operator {\n    that = Item.fromLike(that);\n    return new GeOperator(this, that);\n  }\n\n  override gt(that: ItemLike): Operator {\n    that = Item.fromLike(that);\n    return new GtOperator(this, that);\n  }\n\n  override plus(that: ItemLike): Operator {\n    that = Item.fromLike(that);\n    return new PlusOperator(this, that);\n  }\n\n  override minus(that: ItemLike): Operator {\n    that = Item.fromLike(that);\n    return new MinusOperator(this, that);\n  }\n\n  override times(that: ItemLike): Operator {\n    that = Item.fromLike(that);\n    return new TimesOperator(this, that);\n  }\n\n  override divide(that: ItemLike): Operator {\n    that = Item.fromLike(that);\n    return new DivideOperator(this, that);\n  }\n\n  override modulo(that: ItemLike): Operator {\n    that = Item.fromLike(that);\n    return new ModuloOperator(this, that);\n  }\n\n  override not(): Operator {\n    return new NotOperator(this);\n  }\n\n  override bitwiseNot(): Operator {\n    return new BitwiseNotOperator(this);\n  }\n\n  override negative(): Operator {\n    return new NegativeOperator(this);\n  }\n\n  override positive(): Operator {\n    return new PositiveOperator(this);\n  }\n\n  override inverse(): Operator {\n    return new DivideOperator(Num.one(), this);\n  }\n\n  override toLike(): ValueLike {\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Item} from \"../Item\";\nimport {Expression} from \"../Expression\";\nimport type {BinaryOperator} from \"./BinaryOperator\";\nimport type {UnaryOperator} from \"./UnaryOperator\";\nimport {OrOperator} from \"../\"; // forward import\nimport {AndOperator} from \"../\"; // forward import\nimport {BitwiseOrOperator} from \"../\"; // forward import\nimport {BitwiseXorOperator} from \"../\"; // forward import\nimport {BitwiseAndOperator} from \"../\"; // forward import\nimport {LtOperator} from \"../\"; // forward import\nimport {LeOperator} from \"../\"; // forward import\nimport {EqOperator} from \"../\"; // forward import\nimport {NeOperator} from \"../\"; // forward import\nimport {GeOperator} from \"../\"; // forward import\nimport {GtOperator} from \"../\"; // forward import\nimport {PlusOperator} from \"../\"; // forward import\nimport {MinusOperator} from \"../\"; // forward import\nimport {TimesOperator} from \"../\"; // forward import\nimport {DivideOperator} from \"../\"; // forward import\nimport {ModuloOperator} from \"../\"; // forward import\nimport {NotOperator} from \"../\"; // forward import\nimport {BitwiseNotOperator} from \"../\"; // forward import\nimport {NegativeOperator} from \"../\"; // forward import\nimport {PositiveOperator} from \"../\"; // forward import\n\n/** @public */\nexport abstract class Operator extends Expression {\n  /** @internal */\n  constructor() {\n    super();\n  }\n\n  static binary(operand1: Item, operator: string, operand2: Item): BinaryOperator {\n    switch (operator) {\n      case \"||\": return new OrOperator(operand1, operand2);\n      case \"&&\": return new AndOperator(operand1, operand2);\n      case \"|\": return new BitwiseOrOperator(operand1, operand2);\n      case \"^\": return new BitwiseXorOperator(operand1, operand2);\n      case \"&\": return new BitwiseAndOperator(operand1, operand2);\n      case \"<\": return new LtOperator(operand1, operand2);\n      case \"<=\": return new LeOperator(operand1, operand2);\n      case \"==\": return new EqOperator(operand1, operand2);\n      case \"!=\": return new NeOperator(operand1, operand2);\n      case \">=\": return new GeOperator(operand1, operand2);\n      case \">\": return new GtOperator(operand1, operand2);\n      case \"+\": return new PlusOperator(operand1, operand2);\n      case \"-\": return new MinusOperator(operand1, operand2);\n      case \"*\": return new TimesOperator(operand1, operand2);\n      case \"/\": return new DivideOperator(operand1, operand2);\n      case \"%\": return new ModuloOperator(operand1, operand2);\n      default: throw new Error(operator);\n    }\n  }\n\n  static unary(operator: string, operand: Item): UnaryOperator {\n    switch (operator) {\n      case \"!\": return new NotOperator(operand);\n      case \"~\": return new BitwiseNotOperator(operand);\n      case \"-\": return new NegativeOperator(operand);\n      case \"+\": return new PositiveOperator(operand);\n      default: throw new Error(operator);\n    }\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Interpolator} from \"@swim/util\";\nimport type {Item} from \"../Item\";\nimport {Operator} from \"./Operator\";\nimport {BinaryOperatorInterpolator} from \"../\"; // forward import\n\n/** @public */\nexport abstract class BinaryOperator extends Operator {\n  constructor(operand1: Item, operand2: Item) {\n    super();\n    this.operand1 = operand1;\n    this.operand2 = operand2;\n  }\n\n  readonly operand1: Item;\n\n  abstract readonly operator: string;\n\n  readonly operand2: Item;\n\n  override isConstant(): boolean {\n    return this.operand1.isConstant() && this.operand2.isConstant();\n  }\n\n  override interpolateTo(that: BinaryOperator): Interpolator<BinaryOperator>;\n  override interpolateTo(that: Item): Interpolator<Item>;\n  override interpolateTo(that: unknown): Interpolator<Item> | null;\n  override interpolateTo(that: unknown): Interpolator<Item> | null {\n    if (that instanceof BinaryOperator && this.operator === that.operator) {\n      return BinaryOperatorInterpolator(this, that);\n    } else {\n      return super.interpolateTo(that);\n    }\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Item} from \"../Item\";\nimport {Operator} from \"./Operator\";\nimport type {BinaryOperator} from \"./BinaryOperator\";\n\n/** @internal */\nexport interface BinaryOperatorInterpolator extends Interpolator<BinaryOperator> {\n  /** @internal */\n  readonly operand1Interpolator: Interpolator<Item>;\n  /** @internal */\n  readonly operator: string;\n  /** @internal */\n  readonly operand2Interpolator: Interpolator<Item>;\n\n  readonly 0: BinaryOperator;\n\n  readonly 1: BinaryOperator;\n\n  equals(that: unknown): boolean;\n}\n\n/** @internal */\nexport const BinaryOperatorInterpolator = (function (_super: typeof Interpolator) {\n  const BinaryOperatorInterpolator = function (y0: BinaryOperator, y1: BinaryOperator): BinaryOperatorInterpolator {\n    const operator = y0.operator;\n    if (operator !== y1.operator) {\n      throw new Error();\n    }\n    const interpolator = function (u: number): BinaryOperator {\n      const operand1 = interpolator.operand1Interpolator(u);\n      const operand2 = interpolator.operand2Interpolator(u);\n      return Operator.binary(operand1, interpolator.operator, operand2);\n    } as BinaryOperatorInterpolator;\n    Object.setPrototypeOf(interpolator, BinaryOperatorInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>).operand1Interpolator = y0.operand1.interpolateTo(y1.operand1);\n    (interpolator as Mutable<typeof interpolator>).operator = operator;\n    (interpolator as Mutable<typeof interpolator>).operand2Interpolator = y0.operand2.interpolateTo(y1.operand2);\n    return interpolator;\n  } as {\n    (y0: BinaryOperator, y1: BinaryOperator): BinaryOperatorInterpolator;\n\n    /** @internal */\n    prototype: BinaryOperatorInterpolator;\n  };\n\n  BinaryOperatorInterpolator.prototype = Object.create(_super.prototype);\n  BinaryOperatorInterpolator.prototype.constructor = BinaryOperatorInterpolator;\n\n  Object.defineProperty(BinaryOperatorInterpolator.prototype, 0, {\n    get(this: BinaryOperatorInterpolator): BinaryOperator {\n      const operand1 = this.operand1Interpolator[0];\n      const operand2 = this.operand2Interpolator[0];\n      return Operator.binary(operand1, this.operator, operand2);\n    },\n    configurable: true,\n  });\n\n  Object.defineProperty(BinaryOperatorInterpolator.prototype, 1, {\n    get(this: BinaryOperatorInterpolator): BinaryOperator {\n      const operand1 = this.operand1Interpolator[1];\n      const operand2 = this.operand2Interpolator[1];\n      return Operator.binary(operand1, this.operator, operand2);\n    },\n    configurable: true,\n  });\n\n  BinaryOperatorInterpolator.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof BinaryOperatorInterpolator) {\n      return this.operator === that.operator\n          && this.operand1Interpolator.equals(that.operand1Interpolator)\n          && this.operand2Interpolator.equals(that.operand2Interpolator);\n    }\n    return false;\n  };\n\n  return BinaryOperatorInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Interpolator} from \"@swim/util\";\nimport type {Item} from \"../Item\";\nimport {Operator} from \"./Operator\";\nimport {UnaryOperatorInterpolator} from \"../\"; // forward import\n\n/** @public */\nexport abstract class UnaryOperator extends Operator {\n  constructor(operand: Item) {\n    super();\n    this.operand = operand;\n  }\n\n  readonly operand: Item;\n\n  abstract readonly operator: string;\n\n  override isConstant(): boolean {\n    return this.operand.isConstant();\n  }\n\n  override interpolateTo(that: UnaryOperator): Interpolator<UnaryOperator>;\n  override interpolateTo(that: Item): Interpolator<Item>;\n  override interpolateTo(that: unknown): Interpolator<Item> | null;\n  override interpolateTo(that: unknown): Interpolator<Item> | null {\n    if (that instanceof UnaryOperator && this.operator === that.operator) {\n      return UnaryOperatorInterpolator(this, that);\n    } else {\n      return super.interpolateTo(that);\n    }\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Item} from \"../Item\";\nimport {Operator} from \"./Operator\";\nimport type {UnaryOperator} from \"./UnaryOperator\";\n\n/** @internal */\nexport interface UnaryOperatorInterpolator extends Interpolator<UnaryOperator> {\n  /** @internal */\n  readonly operator: string;\n  /** @internal */\n  readonly operandInterpolator: Interpolator<Item>;\n\n  readonly 0: UnaryOperator;\n\n  readonly 1: UnaryOperator;\n\n  equals(that: unknown): boolean;\n}\n\n/** @internal */\nexport const UnaryOperatorInterpolator = (function (_super: typeof Interpolator) {\n  const UnaryOperatorInterpolator = function (y0: UnaryOperator, y1: UnaryOperator): UnaryOperatorInterpolator {\n    const operator = y0.operator;\n    if (operator !== y1.operator) {\n      throw new Error();\n    }\n    const interpolator = function (u: number): UnaryOperator {\n      const operand = interpolator.operandInterpolator(u);\n      return Operator.unary(interpolator.operator, operand);\n    } as UnaryOperatorInterpolator;\n    Object.setPrototypeOf(interpolator, UnaryOperatorInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>).operator = operator;\n    (interpolator as Mutable<typeof interpolator>).operandInterpolator = y0.operand.interpolateTo(y1.operand);\n    return interpolator;\n  } as {\n    (y0: UnaryOperator, y1: UnaryOperator): UnaryOperatorInterpolator;\n\n    /** @internal */\n    prototype: UnaryOperatorInterpolator;\n  };\n\n  UnaryOperatorInterpolator.prototype = Object.create(_super.prototype);\n  UnaryOperatorInterpolator.prototype.constructor = UnaryOperatorInterpolator;\n\n  Object.defineProperty(UnaryOperatorInterpolator.prototype, 0, {\n    get(this: UnaryOperatorInterpolator): UnaryOperator {\n      const operand = this.operandInterpolator[0];\n      return Operator.unary(this.operator, operand);\n    },\n    configurable: true,\n  });\n\n  Object.defineProperty(UnaryOperatorInterpolator.prototype, 1, {\n    get(this: UnaryOperatorInterpolator): UnaryOperator {\n      const operand = this.operandInterpolator[1];\n      return Operator.unary(this.operator, operand);\n    },\n    configurable: true,\n  });\n\n  UnaryOperatorInterpolator.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UnaryOperatorInterpolator) {\n      return this.operator === that.operator\n          && this.operandInterpolator.equals(that.operandInterpolator);\n    }\n    return false;\n  };\n\n  return UnaryOperatorInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Interpolator} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Operator} from \"./Operator\";\nimport {ConditionalOperatorInterpolator} from \"../\"; // forward import\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../\"; // forward import\n\n/** @public */\nexport class ConditionalOperator extends Operator {\n  constructor(ifTerm: Item, thenTerm: Item, elseTerm: Item) {\n    super();\n    this.ifTerm = ifTerm.commit();\n    this.thenTerm = thenTerm.commit();\n    this.elseTerm = elseTerm.commit();\n  }\n\n  readonly ifTerm: Item;\n\n  readonly thenTerm: Item;\n\n  readonly elseTerm: Item;\n\n  override isConstant(): boolean {\n    return this.ifTerm.isConstant() && this.thenTerm.isConstant()\n        && this.elseTerm.isConstant();\n  }\n\n  override get precedence(): number {\n    return 2;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    let result;\n    const ifTerm = this.ifTerm.evaluate(interpreter);\n    if (ifTerm.isDefinite()) {\n      const theTerm = this.thenTerm.evaluate(interpreter);\n      result = theTerm;\n    } else {\n      const elseTerm = this.elseTerm.evaluate(interpreter);\n      result = elseTerm;\n    }\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const ifTerm = this.ifTerm.substitute(interpreter);\n    const thenTerm = this.thenTerm.substitute(interpreter);\n    const elseTerm = this.elseTerm.substitute(interpreter);\n    return new ConditionalOperator(ifTerm, thenTerm, elseTerm);\n  }\n\n  override interpolateTo(that: ConditionalOperator): Interpolator<ConditionalOperator>;\n  override interpolateTo(that: Item): Interpolator<Item>;\n  override interpolateTo(that: unknown): Interpolator<Item> | null;\n  override interpolateTo(that: unknown): Interpolator<Item> | null {\n    if (that instanceof ConditionalOperator) {\n      return ConditionalOperatorInterpolator(this, that);\n    } else {\n      return super.interpolateTo(that);\n    }\n  }\n\n  override get typeOrder(): number {\n    return 20;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof ConditionalOperator) {\n      let order = this.ifTerm.compareTo(that.ifTerm);\n      if (order === 0) {\n        order = this.thenTerm.compareTo(that.thenTerm);\n        if (order === 0) {\n          order = this.elseTerm.compareTo(that.elseTerm);\n        }\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof ConditionalOperator) {\n      return this.ifTerm.equivalentTo(that.ifTerm, epsilon)\n          && this.thenTerm.equivalentTo(that.thenTerm, epsilon)\n          && this.elseTerm.equivalentTo(that.elseTerm, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof ConditionalOperator) {\n      return this.ifTerm.equals(that.ifTerm) && this.thenTerm.equals(that.thenTerm)\n          && this.elseTerm.equals(that.elseTerm);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Constructors.hash(ConditionalOperator),\n        this.ifTerm.hashCode()), this.thenTerm.hashCode()), this.elseTerm.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.ifTerm).write(46/*'.'*/).write(\"conditional\").write(40/*'('*/)\n                   .debug(this.thenTerm).write(44/*','*/).write(32/*' '*/)\n                   .debug(this.elseTerm).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): ConditionalOperator {\n    return new ConditionalOperator(this.ifTerm.clone(), this.thenTerm.clone(), this.elseTerm.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Item} from \"../Item\";\nimport {ConditionalOperator} from \"./ConditionalOperator\";\n\n/** @internal */\nexport interface ConditionalOperatorInterpolator extends Interpolator<ConditionalOperator> {\n  /** @internal */\n  readonly ifTermInterpolator: Interpolator<Item>;\n  /** @internal */\n  readonly thenTermInterpolator: Interpolator<Item>;\n  /** @internal */\n  readonly elseTermInterpolator: Interpolator<Item>;\n\n  readonly 0: ConditionalOperator;\n\n  readonly 1: ConditionalOperator;\n\n  equals(that: unknown): boolean;\n}\n\n/** @internal */\nexport const ConditionalOperatorInterpolator = (function (_super: typeof Interpolator) {\n  const ConditionalOperatorInterpolator = function (y0: ConditionalOperator, y1: ConditionalOperator): ConditionalOperatorInterpolator {\n    const interpolator = function (u: number): ConditionalOperator {\n      const ifTerm = interpolator.ifTermInterpolator(u);\n      const thenTerm = interpolator.thenTermInterpolator(u);\n      const elseTerm = interpolator.elseTermInterpolator(u);\n      return new ConditionalOperator(ifTerm, thenTerm, elseTerm);\n    } as ConditionalOperatorInterpolator;\n    Object.setPrototypeOf(interpolator, ConditionalOperatorInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>).ifTermInterpolator = y0.ifTerm.interpolateTo(y1.ifTerm);\n    (interpolator as Mutable<typeof interpolator>).thenTermInterpolator = y0.thenTerm.interpolateTo(y1.thenTerm);\n    (interpolator as Mutable<typeof interpolator>).elseTermInterpolator = y0.elseTerm.interpolateTo(y1.elseTerm);\n    return interpolator;\n  } as {\n    (y0: ConditionalOperator, y1: ConditionalOperator): ConditionalOperatorInterpolator;\n\n    /** @internal */\n    prototype: ConditionalOperatorInterpolator;\n  };\n\n  ConditionalOperatorInterpolator.prototype = Object.create(_super.prototype);\n  ConditionalOperatorInterpolator.prototype.constructor = ConditionalOperatorInterpolator;\n\n  Object.defineProperty(ConditionalOperatorInterpolator.prototype, 0, {\n    get(this: ConditionalOperatorInterpolator): ConditionalOperator {\n      const ifTerm = this.ifTermInterpolator[0];\n      const thenTerm = this.thenTermInterpolator[0];\n      const elseTerm = this.elseTermInterpolator[0];\n      return new ConditionalOperator(ifTerm, thenTerm, elseTerm);\n    },\n    configurable: true,\n  });\n\n  Object.defineProperty(ConditionalOperatorInterpolator.prototype, 1, {\n    get(this: ConditionalOperatorInterpolator): ConditionalOperator {\n      const ifTerm = this.ifTermInterpolator[1];\n      const thenTerm = this.thenTermInterpolator[1];\n      const elseTerm = this.elseTermInterpolator[1];\n      return new ConditionalOperator(ifTerm, thenTerm, elseTerm);\n    },\n    configurable: true,\n  });\n\n  ConditionalOperatorInterpolator.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof ConditionalOperatorInterpolator) {\n      return this.ifTermInterpolator.equals(that.ifTermInterpolator)\n          && this.thenTermInterpolator.equals(that.thenTermInterpolator)\n          && this.elseTermInterpolator.equals(that.elseTermInterpolator);\n    }\n    return false;\n  };\n\n  return ConditionalOperatorInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/** @public */\nexport class InterpreterException extends Error {\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, InterpreterException.prototype);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\n\n/** @public */\nexport class InterpreterSettings implements Debug, HashCode {\n  constructor(maxScopeDepth: number) {\n    this.maxScopeDepth = maxScopeDepth;\n  }\n\n  readonly maxScopeDepth: number;\n\n  withMaxScopeDepth(maxScopeDepth: number): InterpreterSettings {\n    return this.copy(maxScopeDepth);\n  }\n\n  protected copy(maxScopeDepth: number): InterpreterSettings {\n    return new InterpreterSettings(maxScopeDepth);\n  }\n\n  protected canEqual(that: unknown): boolean {\n    return that instanceof InterpreterSettings;\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof InterpreterSettings) {\n      return that.canEqual(this) && this.maxScopeDepth === that.maxScopeDepth;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(InterpreterSettings),\n        Numbers.hash(this.maxScopeDepth)));\n  }\n\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"new\").write(32/*' '*/).write(\"InterpreterSettings\")\n                   .write(40/*'('*/).debug(this.maxScopeDepth).write(41/*')'*/);\n    return output;\n  }\n\n  toString(): string {\n    return Format.debug(this);\n  }\n\n  @Lazy\n  static standard(): InterpreterSettings {\n    const maxScopeDepth = 1024;\n    return new InterpreterSettings(maxScopeDepth);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {InterpreterException} from \"./InterpreterException\";\nimport {InterpreterSettings} from \"./InterpreterSettings\";\nimport type {ItemLike} from \"../Item\";\nimport {Item} from \"../Item\";\nimport type {Operator} from \"../operator/Operator\";\nimport type {Selector} from \"../selector/Selector\";\n\n/** @public */\nexport type InterpreterLike = Interpreter | ItemLike;\n\n/** @public */\nexport class Interpreter {\n  constructor(settings?: InterpreterSettings, scopeStack?: Item[] | null, scopeDepth?: number) {\n    this.settings = settings !== void 0 ? settings : InterpreterSettings.standard();\n    this.scopeStack = scopeStack !== void 0 ? scopeStack : null;\n    this.scopeDepth = scopeDepth !== void 0 ? scopeDepth : 0;\n  }\n\n  likeType?(like: ItemLike): void;\n\n  readonly settings: InterpreterSettings;\n\n  withSettings(settings: InterpreterSettings): this {\n    (this as Mutable<this>).settings = settings;\n    return this;\n  }\n\n  /** @internal */\n  readonly scopeStack: Item[] | null;\n\n  readonly scopeDepth: number;\n\n  peekScope(): Item {\n    const scopeDepth = this.scopeDepth;\n    if (scopeDepth <= 0) {\n      throw new InterpreterException(\"scope stack empty\");\n    }\n    return this.scopeStack![scopeDepth - 1]!;\n  }\n\n  getScope(index: number): Item {\n    if (index < 0 || index >= this.scopeDepth) {\n      throw new RangeError(\"\" + index);\n    }\n    return this.scopeStack![index]!;\n  }\n\n  pushScope(scope: Item): void {\n    const scopeDepth = this.scopeDepth;\n    if (scopeDepth >= this.settings.maxScopeDepth) {\n      throw new InterpreterException(\"scope stack overflow\");\n    }\n    const oldScopeStack = this.scopeStack;\n    let newScopeStack;\n    if (oldScopeStack === null || scopeDepth + 1 > oldScopeStack.length) {\n      newScopeStack = new Array<Item>(Interpreter.expand(scopeDepth + 1));\n      if (oldScopeStack !== null) {\n        for (let i = 0; i < scopeDepth; i += 1) {\n          newScopeStack[i] = oldScopeStack[i]!;\n        }\n      }\n      (this as Mutable<this>).scopeStack = newScopeStack;\n    } else {\n      newScopeStack = oldScopeStack;\n    }\n    newScopeStack[scopeDepth] = scope;\n    (this as Mutable<this>).scopeDepth += 1;\n  }\n\n  popScope(): Item {\n    const scopeDepth = this.scopeDepth;\n    if (scopeDepth <= 0) {\n      throw new InterpreterException(\"scope stack empty\");\n    }\n    const scopeStack = this.scopeStack!;\n    const scope = scopeStack[scopeDepth - 1]!;\n    scopeStack[scopeDepth - 1] = void 0 as any;\n    (this as Mutable<this>).scopeDepth -= 1;\n    return scope;\n  }\n\n  swapScope(newScope: Item): Item {\n    const scopeDepth = this.scopeDepth;\n    if (scopeDepth <= 0) {\n      throw new InterpreterException(\"scope stack empty\");\n    }\n    const scopeStack = this.scopeStack!;\n    const oldScope = scopeStack[scopeDepth - 1]!;\n    scopeStack[scopeDepth - 1] = newScope;\n    return oldScope;\n  }\n\n  willOperate(operator: Operator): void {\n    // hook\n  }\n\n  didOperate(operator: Operator, result: Item): void {\n    // hook\n  }\n\n  willSelect(selector: Selector): void {\n    // hook\n  }\n\n  didSelect(selector: Selector, result: unknown): void {\n    // hook\n  }\n\n  willTransform(selector: Selector): void {\n    // hook\n  }\n\n  didTransform(selector: Selector, result: Item): void {\n    // hook\n  }\n\n  static of(...objects: ItemLike[]): Interpreter {\n    const n = objects.length;\n    const scopes = new Array(Interpreter.expand(n));\n    for (let i = 0; i < n; i += 1) {\n      const scope = Item.fromLike(objects[i]);\n      scopes[i] = scope;\n    }\n    return new Interpreter(InterpreterSettings.standard(), scopes, n);\n  }\n\n  static fromLike(interpreter: InterpreterLike, globalScope: Item = Item.globalScope()): Interpreter {\n    if (!(interpreter instanceof Interpreter)) {\n      const scope = interpreter;\n      interpreter = new Interpreter();\n      if (globalScope !== void 0) {\n        interpreter.pushScope(globalScope);\n      }\n      if (scope !== void 0) {\n        interpreter.pushScope(Item.fromLike(scope));\n      }\n    }\n    return interpreter;\n  }\n\n  private static expand(n: number): number {\n    n = Math.max(32, n) - 1;\n    n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16;\n    return n + 1;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class OrOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  override get operator(): string {\n    return \"||\";\n  }\n\n  override get precedence(): number {\n    return 3;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    let result: Item;\n    const argument1 = this.operand1.evaluate(interpreter);\n    if (argument1.isDefinite()) {\n      result = argument1;\n    } else {\n      const argument2 = this.operand2.evaluate(interpreter);\n      result = argument2;\n    }\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument1 = this.operand1.substitute(interpreter);\n    const argument2 = this.operand2.substitute(interpreter);\n    return argument1.or(argument2);\n  }\n\n  override get typeOrder(): number {\n    return 21;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof OrOperator) {\n      let order = this.operand1.compareTo(that.operand1);\n      if (order === 0) {\n        order = this.operand2.compareTo(that.operand2);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof OrOperator) {\n      return this.operand1.equivalentTo(that.operand1, epsilon)\n          && this.operand2.equivalentTo(that.operand2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof OrOperator) {\n      return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(OrOperator),\n        this.operand1.hashCode()), this.operand2.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand1).write(46/*'.'*/).write(\"or\").write(40/*'('*/)\n                   .debug(this.operand2).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): OrOperator {\n    return new OrOperator(this.operand1.clone(), this.operand2.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class AndOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  override get operator(): string {\n    return \"&&\";\n  }\n\n  override get precedence(): number {\n    return 4;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    let result: Item;\n    const argument1 = this.operand1.evaluate(interpreter);\n    if (argument1.isDefinite()) {\n      const argument2 = this.operand2.evaluate(interpreter);\n      result = argument2;\n    } else {\n      result = argument1;\n    }\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument1 = this.operand1.substitute(interpreter);\n    const argument2 = this.operand2.substitute(interpreter);\n    return argument1.and(argument2);\n  }\n\n  override get typeOrder(): number {\n    return 22;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof AndOperator) {\n      let order = this.operand1.compareTo(that.operand1);\n      if (order === 0) {\n        order = this.operand2.compareTo(that.operand2);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof AndOperator) {\n      return this.operand1.equivalentTo(that.operand1, epsilon)\n          && this.operand2.equivalentTo(that.operand2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof AndOperator) {\n      return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(AndOperator),\n        this.operand1.hashCode()), this.operand2.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand1).write(46/*'.'*/).write(\"and\").write(40/*'('*/)\n                   .debug(this.operand2).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): AndOperator {\n    return new AndOperator(this.operand1.clone(), this.operand2.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class BitwiseOrOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  override get operator(): string {\n    return \"|\";\n  }\n\n  override get precedence(): number {\n    return 5;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this.operand1.evaluate(interpreter);\n    const argument2 = this.operand2.evaluate(interpreter);\n    const result = argument1.bitwiseOr(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument1 = this.operand1.substitute(interpreter);\n    const argument2 = this.operand2.substitute(interpreter);\n    return argument1.bitwiseOr(argument2);\n  }\n\n  override get typeOrder(): number {\n    return 23;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof BitwiseOrOperator) {\n      let order = this.operand1.compareTo(that.operand1);\n      if (order === 0) {\n        order = this.operand2.compareTo(that.operand2);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof BitwiseOrOperator) {\n      return this.operand1.equivalentTo(that.operand1, epsilon)\n          && this.operand2.equivalentTo(that.operand2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof BitwiseOrOperator) {\n      return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(BitwiseOrOperator),\n        this.operand1.hashCode()), this.operand2.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand1).write(46/*'.'*/).write(\"bitwiseOr\").write(40/*'('*/)\n                   .debug(this.operand2).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): BitwiseOrOperator {\n    return new BitwiseOrOperator(this.operand1.clone(), this.operand2.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class BitwiseXorOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  override get operator(): string {\n    return \"^\";\n  }\n\n  override get precedence(): number {\n    return 6;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this.operand1.evaluate(interpreter);\n    const argument2 = this.operand2.evaluate(interpreter);\n    const result = argument1.bitwiseXor(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument1 = this.operand1.substitute(interpreter);\n    const argument2 = this.operand2.substitute(interpreter);\n    return argument1.bitwiseXor(argument2);\n  }\n\n  override get typeOrder(): number {\n    return 24;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof BitwiseXorOperator) {\n      let order = this.operand1.compareTo(that.operand1);\n      if (order === 0) {\n        order = this.operand2.compareTo(that.operand2);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof BitwiseXorOperator) {\n      return this.operand1.equivalentTo(that.operand1, epsilon)\n          && this.operand2.equivalentTo(that.operand2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof BitwiseXorOperator) {\n      return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(BitwiseXorOperator),\n        this.operand1.hashCode()), this.operand2.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand1).write(46/*'.'*/).write(\"bitwiseXor\").write(40/*'('*/)\n                   .debug(this.operand2).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): BitwiseXorOperator {\n    return new BitwiseXorOperator(this.operand1.clone(), this.operand2.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class BitwiseAndOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  override get operator(): string {\n    return \"&\";\n  }\n\n  override get precedence(): number {\n    return 7;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this.operand1.evaluate(interpreter);\n    const argument2 = this.operand2.evaluate(interpreter);\n    const result = argument1.bitwiseAnd(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument1 = this.operand1.substitute(interpreter);\n    const argument2 = this.operand2.substitute(interpreter);\n    return argument1.bitwiseAnd(argument2);\n  }\n\n  override get typeOrder(): number {\n    return 25;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof BitwiseAndOperator) {\n      let order = this.operand1.compareTo(that.operand1);\n      if (order === 0) {\n        order = this.operand2.compareTo(that.operand2);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof BitwiseAndOperator) {\n      return this.operand1.equivalentTo(that.operand1, epsilon)\n          && this.operand2.equivalentTo(that.operand2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof BitwiseAndOperator) {\n      return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(BitwiseAndOperator),\n        this.operand1.hashCode()), this.operand2.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand1).write(46/*'.'*/).write(\"bitwiseAnd\").write(40/*'('*/)\n                   .debug(this.operand2).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): BitwiseAndOperator {\n    return new BitwiseAndOperator(this.operand1.clone(), this.operand2.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class LtOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  override get operator(): string {\n    return \"<\";\n  }\n\n  override get precedence(): number {\n    return 0;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this.operand1.evaluate(interpreter);\n    const argument2 = this.operand2.evaluate(interpreter);\n    const result = argument1.lt(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument1 = this.operand1.substitute(interpreter);\n    const argument2 = this.operand2.substitute(interpreter);\n    return argument1.lt(argument2);\n  }\n\n  override get typeOrder(): number {\n    return 26;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof LtOperator) {\n      let order = this.operand1.compareTo(that.operand1);\n      if (order === 0) {\n        order = this.operand2.compareTo(that.operand2);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof LtOperator) {\n      return this.operand1.equivalentTo(that.operand1, epsilon)\n          && this.operand2.equivalentTo(that.operand2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof LtOperator) {\n      return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(LtOperator),\n        this.operand1.hashCode()), this.operand2.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    return output.debug(this.operand1).write(46/*'.'*/).write(\"lt\").write(40/*'('*/)\n                 .debug(this.operand2).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): LtOperator {\n    return new LtOperator(this.operand1.clone(), this.operand2.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class LeOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  override get operator(): string {\n    return \"<=\";\n  }\n\n  override get precedence(): number {\n    return 0;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this.operand1.evaluate(interpreter);\n    const argument2 = this.operand2.evaluate(interpreter);\n    const result = argument1.le(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument1 = this.operand1.substitute(interpreter);\n    const argument2 = this.operand2.substitute(interpreter);\n    return argument1.le(argument2);\n  }\n\n  override get typeOrder(): number {\n    return 27;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof LeOperator) {\n      let order = this.operand1.compareTo(that.operand1);\n      if (order === 0) {\n        order = this.operand2.compareTo(that.operand2);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof LeOperator) {\n      return this.operand1.equivalentTo(that.operand1, epsilon)\n          && this.operand2.equivalentTo(that.operand2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof LeOperator) {\n      return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(LeOperator),\n        this.operand1.hashCode()), this.operand2.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    return output.debug(this.operand1).write(46/*'.'*/).write(\"le\").write(40/*'('*/)\n                 .debug(this.operand2).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): LeOperator {\n    return new LeOperator(this.operand1.clone(), this.operand2.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class EqOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  override get operator(): string {\n    return \"==\";\n  }\n\n  override get precedence(): number {\n    return 0;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this.operand1.evaluate(interpreter);\n    const argument2 = this.operand2.evaluate(interpreter);\n    const result = argument1.eq(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument1 = this.operand1.substitute(interpreter);\n    const argument2 = this.operand2.substitute(interpreter);\n    return argument1.eq(argument2);\n  }\n\n  override get typeOrder(): number {\n    return 28;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof EqOperator) {\n      let order = this.operand1.compareTo(that.operand1);\n      if (order === 0) {\n        order = this.operand2.compareTo(that.operand2);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof EqOperator) {\n      return this.operand1.equivalentTo(that.operand1, epsilon)\n          && this.operand2.equivalentTo(that.operand2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof EqOperator) {\n      return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(EqOperator),\n        this.operand1.hashCode()), this.operand2.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand1).write(46/*'.'*/).write(\"eq\").write(40/*'('*/)\n                   .debug(this.operand2).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): EqOperator {\n    return new EqOperator(this.operand1.clone(), this.operand2.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class NeOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  override get operator(): string {\n    return \"!=\";\n  }\n\n  override get precedence(): number {\n    return 0;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this.operand1.evaluate(interpreter);\n    const argument2 = this.operand2.evaluate(interpreter);\n    const result = argument1.ne(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument1 = this.operand1.substitute(interpreter);\n    const argument2 = this.operand2.substitute(interpreter);\n    return argument1.ne(argument2);\n  }\n\n  override get typeOrder(): number {\n    return 29;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof NeOperator) {\n      let order = this.operand1.compareTo(that.operand1);\n      if (order === 0) {\n        order = this.operand2.compareTo(that.operand2);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof NeOperator) {\n      return this.operand1.equivalentTo(that.operand1, epsilon)\n          && this.operand2.equivalentTo(that.operand2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof NeOperator) {\n      return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(NeOperator),\n        this.operand1.hashCode()), this.operand2.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand1).write(46/*'.'*/).write(\"ne\").write(40/*'('*/)\n                   .debug(this.operand2).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): NeOperator {\n    return new NeOperator(this.operand1.clone(), this.operand2.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class GeOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  override get operator(): string {\n    return \">=\";\n  }\n\n  override get precedence(): number {\n    return 0;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this.operand1.evaluate(interpreter);\n    const argument2 = this.operand2.evaluate(interpreter);\n    const result = argument1.ge(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument1 = this.operand1.substitute(interpreter);\n    const argument2 = this.operand2.substitute(interpreter);\n    return argument1.ge(argument2);\n  }\n\n  override get typeOrder(): number {\n    return 30;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof GeOperator) {\n      let order = this.operand1.compareTo(that.operand1);\n      if (order === 0) {\n        order = this.operand2.compareTo(that.operand2);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeOperator) {\n      return this.operand1.equivalentTo(that.operand1, epsilon)\n          && this.operand2.equivalentTo(that.operand2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeOperator) {\n      return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(GeOperator),\n        this.operand1.hashCode()), this.operand2.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand1).write(46/*'.'*/).write(\"ge\").write(40/*'('*/)\n                   .debug(this.operand2).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): GeOperator {\n    return new GeOperator(this.operand1.clone(), this.operand2.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class GtOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  override get operator(): string {\n    return \">\";\n  }\n\n  override get precedence(): number {\n    return 0;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this.operand1.evaluate(interpreter);\n    const argument2 = this.operand2.evaluate(interpreter);\n    const result = argument1.gt(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument1 = this.operand1.substitute(interpreter);\n    const argument2 = this.operand2.substitute(interpreter);\n    return argument1.gt(argument2);\n  }\n\n  override get typeOrder(): number {\n    return 31;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof GtOperator) {\n      let order = this.operand1.compareTo(that.operand1);\n      if (order === 0) {\n        order = this.operand2.compareTo(that.operand2);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GtOperator) {\n      return this.operand1.equivalentTo(that.operand1, epsilon)\n          && this.operand2.equivalentTo(that.operand2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GtOperator) {\n      return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(GtOperator),\n        this.operand1.hashCode()), this.operand2.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand1).write(46/*'.'*/).write(\"gt\").write(40/*'('*/)\n                   .debug(this.operand2).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): GtOperator {\n    return new GtOperator(this.operand1.clone(), this.operand2.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class PlusOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  override get operator(): string {\n    return \"+\";\n  }\n\n  override get precedence(): number {\n    return 8;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this.operand1.evaluate(interpreter);\n    const argument2 = this.operand2.evaluate(interpreter);\n    const result = argument1.plus(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument1 = this.operand1.substitute(interpreter);\n    const argument2 = this.operand2.substitute(interpreter);\n    return argument1.plus(argument2);\n  }\n\n  override get typeOrder(): number {\n    return 32;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof PlusOperator) {\n      let order = this.operand1.compareTo(that.operand1);\n      if (order === 0) {\n        order = this.operand2.compareTo(that.operand2);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof PlusOperator) {\n      return this.operand1.equivalentTo(that.operand1, epsilon)\n          && this.operand2.equivalentTo(that.operand2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof PlusOperator) {\n      return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(PlusOperator),\n        this.operand1.hashCode()), this.operand2.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand1).write(46/*'.'*/).write(\"plus\").write(40/*'('*/)\n                   .debug(this.operand2).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): PlusOperator {\n    return new PlusOperator(this.operand1.clone(), this.operand2.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class MinusOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  override get operator(): string {\n    return \"-\";\n  }\n\n  override get precedence(): number {\n    return 8;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this.operand1.evaluate(interpreter);\n    const argument2 = this.operand2.evaluate(interpreter);\n    const result = argument1.minus(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument1 = this.operand1.substitute(interpreter);\n    const argument2 = this.operand2.substitute(interpreter);\n    return argument1.minus(argument2);\n  }\n\n  override get typeOrder(): number {\n    return 33;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof MinusOperator) {\n      let order = this.operand1.compareTo(that.operand1);\n      if (order === 0) {\n        order = this.operand2.compareTo(that.operand2);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof MinusOperator) {\n      return this.operand1.equivalentTo(that.operand1, epsilon)\n          && this.operand2.equivalentTo(that.operand2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof MinusOperator) {\n      return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(MinusOperator),\n        this.operand1.hashCode()), this.operand2.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand1).write(46/*'.'*/).write(\"minus\").write(40/*'('*/)\n                   .debug(this.operand2).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): MinusOperator {\n    return new MinusOperator(this.operand1.clone(), this.operand2.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class TimesOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  override get operator(): string {\n    return \"*\";\n  }\n\n  override get precedence(): number {\n    return 9;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this.operand1.evaluate(interpreter);\n    const argument2 = this.operand2.evaluate(interpreter);\n    const result = argument1.times(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument1 = this.operand1.substitute(interpreter);\n    const argument2 = this.operand2.substitute(interpreter);\n    return argument1.times(argument2);\n  }\n\n  override get typeOrder(): number {\n    return 34;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof TimesOperator) {\n      let order = this.operand1.compareTo(that.operand1);\n      if (order === 0) {\n        order = this.operand2.compareTo(that.operand2);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof TimesOperator) {\n      return this.operand1.equivalentTo(that.operand1, epsilon)\n          && this.operand2.equivalentTo(that.operand2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof TimesOperator) {\n      return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(TimesOperator),\n        this.operand1.hashCode()), this.operand2.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand1).write(46/*'.'*/).write(\"times\").write(40/*'('*/)\n                   .debug(this.operand2).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): TimesOperator {\n    return new TimesOperator(this.operand1.clone(), this.operand2.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class DivideOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  override get operator(): string {\n    return \"/\";\n  }\n\n  override get precedence(): number {\n    return 9;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this.operand1.evaluate(interpreter);\n    const argument2 = this.operand2.evaluate(interpreter);\n    const result = argument1.divide(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument1 = this.operand1.substitute(interpreter);\n    const argument2 = this.operand2.substitute(interpreter);\n    return argument1.divide(argument2);\n  }\n\n  override get typeOrder(): number {\n    return 35;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof DivideOperator) {\n      let order = this.operand1.compareTo(that.operand1);\n      if (order === 0) {\n        order = this.operand2.compareTo(that.operand2);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof DivideOperator) {\n      return this.operand1.equivalentTo(that.operand1, epsilon)\n          && this.operand2.equivalentTo(that.operand2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof DivideOperator) {\n      return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(DivideOperator),\n        this.operand1.hashCode()), this.operand2.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand1).write(46/*'.'*/).write(\"divide\").write(40/*'('*/)\n                   .debug(this.operand2).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): DivideOperator {\n    return new DivideOperator(this.operand1.clone(), this.operand2.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class ModuloOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  override get operator(): string {\n    return \"%\";\n  }\n\n  override get precedence(): number {\n    return 9;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this.operand1.evaluate(interpreter);\n    const argument2 = this.operand2.evaluate(interpreter);\n    const result = argument1.modulo(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument1 = this.operand1.substitute(interpreter);\n    const argument2 = this.operand2.substitute(interpreter);\n    return argument1.modulo(argument2);\n  }\n\n  override get typeOrder(): number {\n    return 36;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof ModuloOperator) {\n      let order = this.operand1.compareTo(that.operand1);\n      if (order === 0) {\n        order = this.operand2.compareTo(that.operand2);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof ModuloOperator) {\n      return this.operand1.equivalentTo(that.operand1, epsilon)\n          && this.operand2.equivalentTo(that.operand2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof ModuloOperator) {\n      return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(ModuloOperator),\n        this.operand1.hashCode()), this.operand2.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand1).write(46/*'.'*/).write(\"modulo\").write(40/*'('*/)\n                   .debug(this.operand2).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): ModuloOperator {\n    return new ModuloOperator(this.operand1.clone(), this.operand2.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Item} from \"../Item\";\nimport {UnaryOperator} from \"./UnaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class NotOperator extends UnaryOperator {\n  constructor(operand: Item) {\n    super(operand);\n  }\n\n  override get operator(): string {\n    return \"!\";\n  }\n\n  override get precedence(): number {\n    return 10;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument = this.operand.evaluate(interpreter);\n    return argument.not();\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument = this.operand.substitute(interpreter);\n    return argument.not();\n  }\n\n  override get typeOrder(): number {\n    return 37;\n  }\n\n  override compareTo(that: Item): number {\n    return Numbers.compare(this.typeOrder, that.typeOrder);\n  }\n\n  override equivalentTo(that: Item, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof NotOperator) {\n      return this.operand.equivalentTo(that.operand, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof NotOperator) {\n      return this.operand.equals(that.operand);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(NotOperator), this.operand.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand).write(46/*'.'*/).write(\"not\").write(40/*'('*/).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): NotOperator {\n    return new NotOperator(this.operand.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {UnaryOperator} from \"./UnaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class BitwiseNotOperator extends UnaryOperator {\n  constructor(operand: Item) {\n    super(operand);\n  }\n\n  override get operator(): string {\n    return \"~\";\n  }\n\n  override get precedence(): number {\n    return 10;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument = this.operand.evaluate(interpreter);\n    return argument.bitwiseNot();\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument = this.operand.substitute(interpreter);\n    return argument.bitwiseNot();\n  }\n\n  override get typeOrder(): number {\n    return 38;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof BitwiseNotOperator) {\n      return this.operand.compareTo(that.operand);\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof BitwiseNotOperator) {\n      return this.operand.equivalentTo(that.operand, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof BitwiseNotOperator) {\n      return this.operand.equals(that.operand);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(BitwiseNotOperator), this.operand.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand).write(46/*'.'*/).write(\"bitwiseNot\").write(40/*'('*/).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): BitwiseNotOperator {\n    return new BitwiseNotOperator(this.operand.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {UnaryOperator} from \"./UnaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class NegativeOperator extends UnaryOperator {\n  constructor(operand: Item) {\n    super(operand);\n  }\n\n  override get operator(): string {\n    return \"-\";\n  }\n\n  override get precedence(): number {\n    return 10;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument = this.operand.evaluate(interpreter);\n    return argument.negative();\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument = this.operand.substitute(interpreter);\n    return argument.negative();\n  }\n\n  override get typeOrder(): number {\n    return 39;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof NegativeOperator) {\n      return this.operand.compareTo(that.operand);\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof NegativeOperator) {\n      return this.operand.equivalentTo(that.operand, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof NegativeOperator) {\n      return this.operand.equals(that.operand);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(NegativeOperator), this.operand.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand).write(46/*'.'*/).write(\"negative\").write(40/*'('*/).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): NegativeOperator {\n    return new NegativeOperator(this.operand.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {UnaryOperator} from \"./UnaryOperator\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport class PositiveOperator extends UnaryOperator {\n  constructor(operand: Item) {\n    super(operand);\n  }\n\n  override get operator(): string {\n    return \"+\";\n  }\n\n  override get precedence(): number {\n    return 10;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument = this.operand.evaluate(interpreter);\n    return argument.positive();\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const argument = this.operand.substitute(interpreter);\n    return argument.positive();\n  }\n\n  override get typeOrder(): number {\n    return 40;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof PositiveOperator) {\n      return this.operand.compareTo(that.operand);\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof PositiveOperator) {\n      return this.operand.equivalentTo(that.operand, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof PositiveOperator) {\n      return this.operand.equals(that.operand);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(PositiveOperator), this.operand.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.operand).write(46/*'.'*/).write(\"positive\").write(40/*'('*/).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): PositiveOperator {\n    return new PositiveOperator(this.operand.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Interpolator} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport type {Value} from \"../Value\";\nimport {Operator} from \"./Operator\";\nimport {InvokeOperatorInterpolator} from \"../\"; // forward import\nimport {Func} from \"../\"; // forward import\nimport type {InterpreterLike} from \"../interpreter/Interpreter\"; // forward import\nimport {Interpreter} from \"../\"; // forward import\n\n/** @public */\nexport class InvokeOperator extends Operator {\n  constructor(func: Value, args: Value) {\n    super();\n    this.func = func;\n    this.args = args.commit();\n    this.state = void 0;\n  }\n\n  readonly func: Value;\n\n  readonly args: Value;\n\n  readonly state: unknown;\n\n  setState(state: unknown): void {\n    (this as Mutable<this>).state = state;\n  }\n\n  override isConstant(): boolean {\n    return this.func.isConstant() && this.args.isConstant();\n  }\n\n  override get precedence(): number {\n    return 11;\n  }\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const func = this.func.evaluate(interpreter);\n    if (func instanceof Func) {\n      return func.invoke(this.args, interpreter, this);\n    }\n    return Item.absent();\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const func = this.func.evaluate(interpreter);\n    if (func instanceof Func) {\n      const result = func.expand(this.args, interpreter, this);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    const args = this.args.substitute(interpreter).toValue();\n    return new InvokeOperator(this.func, args);\n  }\n\n  override interpolateTo(that: InvokeOperator): Interpolator<InvokeOperator>;\n  override interpolateTo(that: Item): Interpolator<Item>;\n  override interpolateTo(that: unknown): Interpolator<Item> | null;\n  override interpolateTo(that: unknown): Interpolator<Item> | null {\n    if (that instanceof InvokeOperator) {\n      return InvokeOperatorInterpolator(this, that);\n    } else {\n      return super.interpolateTo(that);\n    }\n  }\n\n  override get typeOrder(): number {\n    return 41;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof InvokeOperator) {\n      let order = this.func.compareTo(that.func);\n      if (order === 0) {\n        order = this.args.compareTo(that.args);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof InvokeOperator) {\n      return this.func.equals(that.func)\n          && this.args.equivalentTo(that.args, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof InvokeOperator) {\n      return this.func.equals(that.func) && this.args.equals(that.args);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(InvokeOperator),\n        this.func.hashCode()), this.args.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.func).write(46/*'.'*/).write(\"invoke\").write(40/*'('*/)\n                   .debug(this.args).write(41/*')'*/);\n    return output;\n  }\n\n  override clone(): InvokeOperator {\n    return new InvokeOperator(this.func.clone(), this.args.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Item} from \"../Item\";\nimport {InvokeOperator} from \"./InvokeOperator\";\n\n/** @internal */\nexport interface InvokeOperatorInterpolator extends Interpolator<InvokeOperator> {\n  /** @internal */\n  readonly funcInterpolator: Interpolator<Item>;\n  /** @internal */\n  readonly argsInterpolator: Interpolator<Item>;\n\n  readonly 0: InvokeOperator;\n\n  readonly 1: InvokeOperator;\n\n  equals(that: unknown): boolean;\n}\n\n/** @internal */\nexport const InvokeOperatorInterpolator = (function (_super: typeof Interpolator) {\n  const InvokeOperatorInterpolator = function (y0: InvokeOperator, y1: InvokeOperator): InvokeOperatorInterpolator {\n    const interpolator = function (u: number): InvokeOperator {\n      const func = interpolator.funcInterpolator(u);\n      const args = interpolator.argsInterpolator(u);\n      return new InvokeOperator(func, args);\n    } as InvokeOperatorInterpolator;\n    Object.setPrototypeOf(interpolator, InvokeOperatorInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>).funcInterpolator = y0.func.interpolateTo(y1.func);\n    (interpolator as Mutable<typeof interpolator>).argsInterpolator = y0.args.interpolateTo(y1.args);\n    return interpolator;\n  } as {\n    (y0: InvokeOperator, y1: InvokeOperator): InvokeOperatorInterpolator;\n\n    /** @internal */\n    prototype: InvokeOperatorInterpolator;\n  };\n\n  InvokeOperatorInterpolator.prototype = Object.create(_super.prototype);\n  InvokeOperatorInterpolator.prototype.constructor = InvokeOperatorInterpolator;\n\n  Object.defineProperty(InvokeOperatorInterpolator.prototype, 0, {\n    get(this: InvokeOperatorInterpolator): InvokeOperator {\n      const func = this.funcInterpolator[0];\n      const args = this.argsInterpolator[0];\n      return new InvokeOperator(func, args);\n    },\n    configurable: true,\n  });\n\n  Object.defineProperty(InvokeOperatorInterpolator.prototype, 1, {\n    get(this: InvokeOperatorInterpolator): InvokeOperator {\n      const func = this.funcInterpolator[1];\n      const args = this.argsInterpolator[1];\n      return new InvokeOperator(func, args);\n    },\n    configurable: true,\n  });\n\n  InvokeOperatorInterpolator.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof InvokeOperatorInterpolator) {\n      return this.funcInterpolator.equals(that.funcInterpolator)\n          && this.argsInterpolator.equals(that.argsInterpolator);\n    }\n    return false;\n  };\n\n  return InvokeOperatorInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {ItemLike} from \"../Item\";\nimport {Item} from \"../Item\";\nimport type {ValueLike} from \"../Value\";\nimport {Value} from \"../Value\";\nimport {Record} from \"../Record\";\nimport type {TextLike} from \"../Text\";\nimport {Text} from \"../Text\";\nimport type {NumLike} from \"../Num\";\nimport {Num} from \"../Num\";\nimport {Expression} from \"../Expression\";\nimport type {Operator} from \"../operator/Operator\";\nimport {InvokeOperator} from \"../operator/InvokeOperator\";\nimport {IdentitySelector} from \"../\"; // forward import\nimport {GetSelector} from \"../\"; // forward import\nimport {GetAttrSelector} from \"../\"; // forward import\nimport {GetItemSelector} from \"../\"; // forward import\nimport {KeysSelector} from \"../\"; // forward import\nimport {ValuesSelector} from \"../\"; // forward import\nimport {ChildrenSelector} from \"../\"; // forward import\nimport {DescendantsSelector} from \"../\"; // forward import\nimport {FilterSelector} from \"../\"; // forward import\nimport {LiteralSelector} from \"../\"; // forward import\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../\"; // forward import\n\n/** @public */\nexport abstract class Selector extends Expression {\n  /** @internal */\n  constructor() {\n    super();\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  /**\n   * The `Selector` that this `Selector` uses to match sub-selections.\n   */\n  abstract readonly then: Selector;\n\n  abstract forSelected<T>(interpreter: Interpreter,\n                          callback: (interpreter: Interpreter) => T | undefined): T | undefined;\n  abstract forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S, interpreter: Interpreter) => T | undefined,\n                             thisArg: S): T | undefined;\n\n  abstract mapSelected(interpreter: Interpreter,\n                       transform: (interpreter: Interpreter) => Item): Item;\n  abstract mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S, interpreter: Interpreter) => Item,\n                          thisArg: S): Item;\n\n  override evaluate(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    let selected = Item.absent();\n    let count = 0;\n    this.forSelected(interpreter, function (interpreter: Interpreter): void {\n      const scope = interpreter.peekScope();\n      if (scope !== void 0) {\n        if (count === 0) {\n          selected = scope;\n        } else {\n          if (count === 1) {\n            const record = Record.create();\n            record.push(selected);\n            selected = record;\n          }\n          (selected as Record).push(scope);\n        }\n        count += 1;\n      }\n    }, this);\n    return selected;\n  }\n\n  abstract override substitute(interpreter: InterpreterLike): Item;\n\n  abstract andThen(then: Selector): Selector;\n\n  override get(key: ValueLike): Selector {\n    key = Value.fromLike(key);\n    return this.andThen(new GetSelector(key, Selector.identity()));\n  }\n\n  override getAttr(key: TextLike): Selector {\n    key = Text.fromLike(key);\n    return this.andThen(new GetAttrSelector(key, Selector.identity()));\n  }\n\n  override getItem(index: NumLike): Selector {\n    index = Num.fromLike(index);\n    return this.andThen(new GetItemSelector(index, Selector.identity()));\n  }\n\n  keys(): Selector {\n    return this.andThen(Selector.keys());\n  }\n\n  values(): Selector {\n    return this.andThen(Selector.values());\n  }\n\n  children(): Selector {\n    return this.andThen(Selector.children());\n  }\n\n  descendants(): Selector {\n    return this.andThen(Selector.descendants());\n  }\n\n  override filter(predicate?: ItemLike): Selector {\n    if (arguments.length === 0) {\n      return new FilterSelector(this, Selector.identity());\n    } else {\n      predicate = Item.fromLike(predicate);\n      return this.andThen(predicate.filter());\n    }\n  }\n\n  override invoke(args: Value): Operator {\n    return new InvokeOperator(this, args);\n  }\n\n  override get precedence(): number {\n    return 11;\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Selector\").write(46/*'.'*/).write(\"identity\").write(40/*'('*/).write(41/*')'*/);\n    output = this.debugThen(output);\n    return output;\n  }\n\n  abstract debugThen<T>(output: Output<T>): Output<T>;\n\n  abstract override clone(): Selector;\n\n  @Lazy\n  static identity(): Selector {\n    return new IdentitySelector();\n  }\n\n  static get(key: ValueLike): Selector {\n    key = Value.fromLike(key);\n    return new GetSelector(key, Selector.identity());\n  }\n\n  static getAttr(key: TextLike): Selector {\n    key = Text.fromLike(key);\n    return new GetAttrSelector(key, Selector.identity());\n  }\n\n  static getItem(index: NumLike): Selector {\n    index = Num.fromLike(index);\n    return new GetItemSelector(index, Selector.identity());\n  }\n\n  @Lazy\n  static keys(): Selector {\n    return new KeysSelector(Selector.identity());\n  }\n\n  @Lazy\n  static values(): Selector {\n    return new ValuesSelector(Selector.identity());\n  }\n\n  @Lazy\n  static children(): Selector {\n    return new ChildrenSelector(Selector.identity());\n  }\n\n  @Lazy\n  static descendants(): Selector {\n    return new DescendantsSelector(Selector.identity());\n  }\n\n  static literal(item: ItemLike): Selector {\n    item = Item.fromLike(item);\n    if (!(item instanceof Selector)) {\n      item = new LiteralSelector(item, Selector.identity());\n    }\n    return item as Selector;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {ItemLike} from \"../Item\";\nimport {Item} from \"../Item\";\nimport type {ValueLike} from \"../Value\";\nimport {Value} from \"../Value\";\nimport type {TextLike} from \"../Text\";\nimport {Text} from \"../Text\";\nimport type {NumLike} from \"../Num\";\nimport {Num} from \"../Num\";\nimport {Selector} from \"./Selector\";\nimport {GetSelector} from \"../\"; // forward import\nimport {GetAttrSelector} from \"../\"; // forward import\nimport {GetItemSelector} from \"../\"; // forward import\nimport {FilterSelector} from \"../\"; // forward import\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../\"; // forward import\n\n/** @public */\nexport class IdentitySelector extends Selector {\n  override get then(): Selector {\n    return this;\n  }\n\n  override forSelected<T>(interpreter: Interpreter,\n                          callback: (interpreter: Interpreter) => T | undefined): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S, interpreter: Interpreter) => T | undefined,\n                             thisArg: S): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S | undefined, interpreter: Interpreter) => T | undefined,\n                             thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    interpreter.willSelect(this);\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const oldScope = interpreter.popScope();\n      // Evaluate the current selection.\n      const newScope = oldScope.evaluate(interpreter);\n      // Push the evaluated selection onto the scope stack.\n      interpreter.pushScope(newScope);\n      // Visit the evaluated selection.\n      selected = callback.call(thisArg, interpreter);\n      // Restore the original selection to the top of the scope stack.\n      interpreter.swapScope(oldScope);\n    }\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  override mapSelected(interpreter: Interpreter,\n                       transform: (interpreter: Interpreter) => Item): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S, interpreter: Interpreter) => Item,\n                          thisArg: S): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S | undefined, interpreter: Interpreter) => Item,\n                          thisArg?: S): Item {\n    return transform.call(thisArg, interpreter);\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    return interpreter.peekScope().substitute(interpreter);\n  }\n\n  override get(key: ValueLike): Selector {\n    key = Value.fromLike(key);\n    return new GetSelector(key, this);\n  }\n\n  override getAttr(key: TextLike): Selector {\n    key = Text.fromLike(key);\n    return new GetAttrSelector(key, this);\n  }\n\n  override getItem(index: NumLike): Selector {\n    index = Num.fromLike(index);\n    return new GetItemSelector(index, this);\n  }\n\n  override andThen(then: Selector): Selector {\n    return then;\n  }\n\n  override keys(): Selector {\n    return Selector.keys();\n  }\n\n  override values(): Selector {\n    return Selector.values();\n  }\n\n  override children(): Selector {\n    return Selector.children();\n  }\n\n  override descendants(): Selector {\n    return Selector.descendants();\n  }\n\n  override filter(predicate?: ItemLike): Selector {\n    if (arguments.length === 0) {\n      return new FilterSelector(this, this);\n    } else {\n      predicate = Item.fromLike(predicate);\n      return predicate.filter();\n    }\n  }\n\n  override get typeOrder(): number {\n    return 10;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown): boolean {\n    return this === that;\n  }\n\n  override equals(that: unknown): boolean {\n    return this === that;\n  }\n\n  override hashCode(): number {\n    return Constructors.hash(IdentitySelector);\n  }\n\n  override debugThen<T>(output: Output<T>): Output<T> {\n    return output; // blank\n  }\n\n  override clone(): Selector {\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Field} from \"../Field\";\nimport type {Value} from \"../Value\";\nimport {Record} from \"../Record\";\nimport {Selector} from \"./Selector\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../\"; // forward import\n\n/** @public */\nexport class GetSelector extends Selector {\n  constructor(key: Value, then: Selector) {\n    super();\n    this.item = key.commit();\n    this.then = then;\n  }\n\n  readonly item: Value;\n\n  override readonly then: Selector;\n\n  override forSelected<T>(interpreter: Interpreter,\n                          callback: (interpreter: Interpreter) => T | undefined): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S, interpreter: Interpreter) => T | undefined,\n                             thisArg: S): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S | undefined, interpreter: Interpreter) => T | undefined,\n                             thisArg?: S): T | undefined {\n    interpreter.willSelect(this);\n    // Evaluate the key, in case it's dynamic.\n    const key = this.item.evaluate(interpreter).toValue();\n    const selected = GetSelector.forSelected(key, this.then, interpreter, callback, thisArg);\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  /** @internal */\n  static forSelected<T, S>(key: Value, then: Selector, interpreter: Interpreter,\n                           callback: (this: S | undefined, interpreter: Interpreter) => T,\n                           thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the next selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      let field: Field | undefined;\n      // Only records can have members.\n      if (scope instanceof Record) {\n        field = scope.getField(key);\n        if (field !== void 0) {\n          // Push the field value onto the scope stack.\n          interpreter.pushScope(field.toValue());\n          // Subselect the field value.\n          selected = then.forSelected(interpreter, callback, thisArg);\n          // Pop the field value off of the scope stack.\n          interpreter.popScope();\n        }\n      }\n      if (field === void 0 && selected === void 0) {\n        selected = GetSelector.forSelected(key, then, interpreter, callback, thisArg);\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    return selected;\n  }\n\n  override mapSelected(interpreter: Interpreter,\n                       transform: (interpreter: Interpreter) => Item): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S, interpreter: Interpreter) => Item,\n                          thisArg: S): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S | undefined, interpreter: Interpreter) => Item,\n                          thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    // Evaluate the key, if it's dynamic.\n    const key = this.item.evaluate(interpreter).toValue();\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      // Only records can have members.\n      if (scope instanceof Record) {\n        const oldField = scope.getField(key);\n        if (oldField !== void 0) {\n          // Push the field value onto the scope stack.\n          interpreter.pushScope(oldField.toValue());\n          // Transform the field value.\n          const newItem = this.then.mapSelected(interpreter, transform, thisArg);\n          // Pop the field value off the scope stack.\n          interpreter.popScope();\n          if (newItem instanceof Field) {\n            // Replace the original field with the transformed field.\n            if (key.equals(newItem.key)) {\n              scope.set(key, newItem.toValue());\n            } else {\n              scope.delete(key);\n              scope.push(newItem);\n            }\n          } else if (newItem.isDefined()) {\n            // Update the field with the transformed value.\n            scope.set(key, newItem.toValue());\n          } else {\n            // Remove the field.\n            scope.delete(key);\n          }\n        }\n      }\n      // Push the transformed selection back onto the stack.\n      interpreter.pushScope(scope);\n      result = scope;\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    // Evaluate the key, in case it's dynamic.\n    const key = this.item.evaluate(interpreter).toValue();\n    const value = GetSelector.substitute(key, this.then, interpreter);\n    if (value !== void 0) {\n      return value;\n    }\n    let then = this.then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this.then;\n    }\n    return new GetSelector(this.item, then as Selector);\n  }\n\n  /** @internal */\n  static substitute(key: Value, then: Selector, interpreter: Interpreter): Item | undefined {\n    let selected: Item | undefined;\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the next selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      let field: Field | undefined;\n      // Only records can have members.\n      if (scope instanceof Record) {\n        field = scope.getField(key);\n        if (field !== void 0) {\n          // Substitute the field value.\n          selected = field.toValue().substitute(interpreter);\n        }\n      }\n      if (field === void 0 && selected === void 0) {\n        selected = GetSelector.substitute(key, then, interpreter);\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    return selected;\n  }\n\n  override andThen(then: Selector): Selector {\n    return new GetSelector(this.item, this.then.andThen(then));\n  }\n\n  override get typeOrder(): number {\n    return 12;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof GetSelector) {\n      let order = this.item.compareTo(that.item);\n      if (order === 0) {\n        order = this.then.compareTo(that.then);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GetSelector) {\n      return this.item.equals(that.item) && this.then.equivalentTo(that.then, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GetSelector) {\n      return this.item.equals(that.item) && this.then.equals(that.then);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(GetSelector),\n        this.item.hashCode()), this.then.hashCode()));\n  }\n\n  override debugThen<T>(output: Output<T>): Output<T> {\n    output = output.write(46/*'.'*/).write(\"get\").write(40/*'('*/).debug(this.item).write(41/*')'*/);\n    output = this.then.debugThen(output);\n    return output;\n  }\n\n  override clone(): Selector {\n    return new GetSelector(this.item.clone(), this.then.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Field} from \"../Field\";\nimport {Attr} from \"../Attr\";\nimport {Record} from \"../Record\";\nimport type {Text} from \"../Text\";\nimport {Selector} from \"./Selector\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../\"; // forward import\n\n/** @public */\nexport class GetAttrSelector extends Selector {\n  constructor(key: Text, then: Selector) {\n    super();\n    this.item = key;\n    this.then = then;\n  }\n\n  readonly item: Text;\n\n  override readonly then: Selector;\n\n  override forSelected<T>(interpreter: Interpreter,\n                          callback: (interpreter: Interpreter) => T | undefined): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S, interpreter: Interpreter) => T | undefined,\n                             thisArg: S): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S | undefined, interpreter: Interpreter) => T | undefined,\n                             thisArg?: S): T | undefined {\n    interpreter.willSelect(this);\n    const key = this.item;\n    const selected = GetAttrSelector.forSelected(key, this.then, interpreter, callback);\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  /** @internal */\n  static forSelected<T, S>(key: Text, then: Selector, interpreter: Interpreter,\n                           callback: (this: S | undefined, interpreter: Interpreter) => T | undefined,\n                           thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the next selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      let field: Field | undefined;\n      // Only records can have members.\n      if (scope instanceof Record) {\n        field = scope.getField(key);\n        if (field instanceof Attr) {\n          // Push the field value onto the scope stack.\n          interpreter.pushScope(field.toValue());\n          // Subselect the field value.\n          selected = then.forSelected(interpreter, callback, thisArg);\n          // Pop the field value off of the scope stack.\n          interpreter.popScope();\n        }\n      }\n      if (field === void 0 && selected === void 0) {\n        selected = GetAttrSelector.forSelected(key, then, interpreter, callback, thisArg);\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    return selected;\n  }\n\n  override mapSelected(interpreter: Interpreter,\n                       transform: (interpreter: Interpreter) => Item): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S, interpreter: Interpreter) => Item,\n                          thisArg: S): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S | undefined, interpreter: Interpreter) => Item,\n                          thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    const key = this.item;\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      // Only records can have members.\n      if (scope instanceof Record) {\n        const oldField = scope.getField(key);\n        if (oldField instanceof Attr) {\n          // Push the field value onto the scope stack.\n          interpreter.pushScope(oldField.toValue());\n          // Transform the field value.\n          const newItem = this.then.mapSelected(interpreter, transform, thisArg);\n          // Pop the field value off the scope stack.\n          interpreter.popScope();\n          if (newItem instanceof Field) {\n            // Replace the original field with the transformed field.\n            if (key.equals(newItem.key)) {\n              scope.setAttr(key, newItem.toValue());\n            } else {\n              scope.delete(key);\n              scope.push(newItem);\n            }\n          } else if (newItem.isDefined()) {\n            // Update the field with the transformed value.\n            scope.setAttr(key, newItem.toValue());\n          } else {\n            // Remove the field.\n            scope.delete(key);\n          }\n        }\n      }\n      // Push the transformed selection back onto the stack.\n      interpreter.pushScope(scope);\n      result = scope;\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const key = this.item;\n    const value = GetAttrSelector.substitute(key, this.then, interpreter);\n    if (value !== void 0) {\n      return value;\n    }\n    let then = this.then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this.then;\n    }\n    return new GetAttrSelector(this.item, then as Selector);\n  }\n\n  /** @internal */\n  static substitute(key: Text, then: Selector, interpreter: Interpreter): Item | undefined {\n    let selected: Item | undefined;\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the next selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      let field: Field | undefined;\n      // Only records can have members.\n      if (scope instanceof Record) {\n        field = scope.getField(key);\n        if (field instanceof Attr) {\n          // Substitute the field value.\n          selected = field.toValue().substitute(interpreter);\n        }\n      }\n      if (field === void 0 && selected === void 0) {\n        selected = GetAttrSelector.substitute(key, then, interpreter);\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    return selected;\n  }\n\n  override andThen(then: Selector): Selector {\n    return new GetAttrSelector(this.item, this.then.andThen(then));\n  }\n\n  override get typeOrder(): number {\n    return 13;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof GetAttrSelector) {\n      let order = this.item.compareTo(that.item);\n      if (order === 0) {\n        order = this.then.compareTo(that.then);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GetAttrSelector) {\n      return this.item.equals(that.item) && this.then.equivalentTo(that.then, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GetAttrSelector) {\n      return this.item.equals(that.item) && this.then.equals(that.then);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(GetAttrSelector),\n        this.item.hashCode()), this.then.hashCode()));\n  }\n\n  override debugThen<T>(output: Output<T>): Output<T> {\n    output = output.write(46/*'.'*/).write(\"getAttr\").write(40/*'('*/)\n                   .debug(this.item).write(41/*')'*/);\n    output = this.then.debugThen(output);\n    return output;\n  }\n\n  override clone(): Selector {\n    return new GetAttrSelector(this.item.clone(), this.then.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Record} from \"../Record\";\nimport type {Num} from \"../Num\";\nimport {Selector} from \"./Selector\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../\"; // forward import\n\n/** @public */\nexport class GetItemSelector extends Selector {\n  constructor(index: Num, then: Selector) {\n    super();\n    this.item = index;\n    this.then = then;\n  }\n\n  readonly item: Num;\n\n  override readonly then: Selector;\n\n  override forSelected<T>(interpreter: Interpreter,\n                          callback: (interpreter: Interpreter) => T | undefined): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S, interpreter: Interpreter) => T | undefined,\n                             thisArg: S): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S | undefined, interpreter: Interpreter) => T | undefined,\n                             thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    interpreter.willSelect(this);\n    const index = this.item.numberValue();\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      if (scope instanceof Record && index < scope.length) {\n        const item = scope.getItem(index);\n        // Push the item onto the scope stack.\n        interpreter.pushScope(item);\n        // Subselect the item.\n        selected = this.then.forSelected(interpreter, callback, thisArg);\n        // Pop the item off of the scope stack.\n        interpreter.popScope();\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  override mapSelected(interpreter: Interpreter,\n                       transform: (interpreter: Interpreter) => Item): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S, interpreter: Interpreter) => Item,\n                          thisArg: S): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S | undefined, interpreter: Interpreter) => Item,\n                          thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      const index = this.item.numberValue();\n      if (scope instanceof Record && index < scope.length) {\n        const oldItem = scope.getItem(index);\n        // Push the item onto the scope stack.\n        interpreter.pushScope(oldItem);\n        // Transform the item.\n        const newItem = this.then.mapSelected(interpreter, transform, thisArg);\n        // Pop the item off the scope stack.\n        interpreter.popScope();\n        if (newItem.isDefined()) {\n          scope.setItem(index, newItem);\n        } else {\n          scope.splice(index, 1);\n        }\n      }\n      // Push the transformed selection back onto the stack.\n      interpreter.pushScope(scope);\n      result = scope;\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const index = this.item.numberValue();\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      let selected: Item | undefined;\n      if (scope instanceof Record && index < scope.length) {\n        const item = scope.getItem(index);\n        // Substitute the item.\n        selected = item.substitute(interpreter);\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n      if (selected !== void 0) {\n        return selected;\n      }\n    }\n    let then = this.then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this.then;\n    }\n    return new GetItemSelector(this.item, then as Selector);\n  }\n\n  override andThen(then: Selector): Selector {\n    return new GetItemSelector(this.item, this.then.andThen(then));\n  }\n\n  override get typeOrder(): number {\n    return 14;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof GetItemSelector) {\n      let order = this.item.compareTo(that.item);\n      if (order === 0) {\n        order = this.then.compareTo(that.then);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GetItemSelector) {\n      return this.item.equals(that.item) && this.then.equivalentTo(that.then, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GetItemSelector) {\n      return this.item.equals(that.item) && this.then.equals(that.then);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(GetItemSelector),\n        this.item.hashCode()), this.then.hashCode()));\n  }\n\n  override debugThen<T>(output: Output<T>): Output<T> {\n    output = output.write(46/*'.'*/).write(\"getItem\").write(40/*'('*/)\n                   .debug(this.item).write(41/*')'*/);\n    output = this.then.debugThen(output);\n    return output;\n  }\n\n  override clone(): Selector {\n    return new GetItemSelector(this.item, this.then.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Field} from \"../Field\";\nimport {Attr} from \"../Attr\";\nimport {Slot} from \"../Slot\";\nimport {Record} from \"../Record\";\nimport {Text} from \"../Text\";\nimport {Selector} from \"./Selector\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../\"; // forward import\n\n/** @public */\nexport class KeysSelector extends Selector {\n  constructor(then: Selector) {\n    super();\n    this.then = then;\n  }\n\n  override readonly then: Selector;\n\n  override forSelected<T>(interpreter: Interpreter,\n                          callback: (interpreter: Interpreter) => T | undefined): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S, interpreter: Interpreter) => T | undefined,\n                             thisArg: S): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S | undefined, interpreter: Interpreter) => T | undefined,\n                             thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    interpreter.willSelect(this);\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope();\n      if (scope instanceof Record) {\n        const children = scope.iterator();\n        // For each child, while none have been selected:\n        while (selected === void 0 && children.hasNext()) {\n          const child = children.next().value!;\n          // Only fields can have keys.\n          if (child instanceof Field) {\n            // Push the child key onto the scope stack.\n            interpreter.pushScope(child.key);\n            // Subselect the child key.\n            selected = this.then.forSelected(interpreter, callback, thisArg);\n            // Pop the child key off of the scope stack.\n            interpreter.popScope();\n          }\n        }\n      } else if (scope instanceof Field) {\n        // Push the key onto the scope stack.\n        interpreter.pushScope(scope.key);\n        // Subselect the key.\n        selected = this.then.forSelected(interpreter, callback, thisArg);\n        // Pop the key off of the scope stack.\n        interpreter.popScope();\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  override mapSelected(interpreter: Interpreter,\n                       transform: (interpreter: Interpreter) => Item): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S, interpreter: Interpreter) => Item,\n                          thisArg: S): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S | undefined, interpreter: Interpreter) => Item,\n                          thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      let scope = interpreter.popScope();\n      if (scope instanceof Record) {\n        const children = scope.iterator();\n        while (children.hasNext()) {\n          const child = children.next().value!;\n          if (child instanceof Field) {\n            const oldKey = child.key;\n            // Push the key onto the scope stack.\n            interpreter.pushScope(oldKey);\n            // Subselect the key.\n            const newKey = this.then.mapSelected(interpreter, transform, thisArg).toValue();\n            // Pop the key off of the scope stack.\n            interpreter.popScope();\n            if (newKey.isDefined()) {\n              if (oldKey !== newKey) {\n                if (scope instanceof Attr && newKey instanceof Text) {\n                  children.set(Attr.of(newKey, scope.toValue()));\n                } else {\n                  children.set(Slot.of(newKey, scope.toValue()));\n                }\n              }\n            } else {\n              children.delete();\n            }\n          }\n        }\n      } else if (scope instanceof Field) {\n        const oldKey = scope.key;\n        // Push the key onto the scope stack.\n        interpreter.pushScope(oldKey);\n        // Subselect the key.\n        const newKey = this.then.mapSelected(interpreter, transform, thisArg).toValue();\n        // Pop the key off of the scope stack.\n        interpreter.popScope();\n        if (newKey.isDefined()) {\n          if (oldKey !== newKey) {\n            if (scope instanceof Attr && newKey instanceof Text) {\n              scope = Attr.of(newKey, scope.toValue());\n            } else {\n              scope = Slot.of(newKey, scope.toValue());\n            }\n          }\n        } else {\n          scope = Item.absent();\n        }\n      }\n      // Push the transformed selection back onto the stack.\n      interpreter.pushScope(scope);\n      result = scope;\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    let then = this.then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this.then;\n    }\n    return new KeysSelector(then as Selector);\n  }\n\n  override andThen(then: Selector): Selector {\n    return new KeysSelector(this.then.andThen(then));\n  }\n\n  override get typeOrder(): number {\n    return 15;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof KeysSelector) {\n      return this.then.compareTo(that.then);\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof KeysSelector) {\n      return this.then.equivalentTo(that.then, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof KeysSelector) {\n      return this.then.equals(that.then);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(KeysSelector), this.then.hashCode()));\n  }\n\n  override debugThen<T>(output: Output<T>): Output<T> {\n    output = output.write(46/*'.'*/).write(\"keys\").write(40/*'('*/).write(41/*')'*/);\n    output = this.then.debugThen(output);\n    return output;\n  }\n\n  override clone(): Selector {\n    return new KeysSelector(this.then.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Field} from \"../Field\";\nimport {Record} from \"../Record\";\nimport {Selector} from \"./Selector\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../\"; // forward import\n\n/** @public */\nexport class ValuesSelector extends Selector {\n  constructor(then: Selector) {\n    super();\n    this.then = then;\n  }\n\n  override readonly then: Selector;\n\n  override forSelected<T>(interpreter: Interpreter,\n                          callback: (interpreter: Interpreter) => T | undefined): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S, interpreter: Interpreter) => T | undefined,\n                             thisArg: S): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S | undefined, interpreter: Interpreter) => T | undefined,\n                             thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    interpreter.willSelect(this);\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope();\n      if (scope instanceof Record) {\n        const children = scope.iterator();\n        // For each child, while none have been selected:\n        while (selected === void 0 && children.hasNext()) {\n          const child = children.next().value!;\n          // Push the child value onto the scope stack.\n          interpreter.pushScope(child.toValue());\n          // Subselect the child value.\n          selected = this.then.forSelected(interpreter, callback, thisArg);\n          // Pop the child value off of the scope stack.\n          interpreter.popScope();\n        }\n      } else {\n        // Push the value onto the scope stack.\n        interpreter.pushScope(scope.toValue());\n        // Subselect the value.\n        selected = this.then.forSelected(interpreter, callback, thisArg);\n        // Pop the value off of the scope stack.\n        interpreter.popScope();\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  override mapSelected(interpreter: Interpreter,\n                       transform: (interpreter: Interpreter) => Item): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S, interpreter: Interpreter) => Item,\n                          thisArg: S): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S | undefined, interpreter: Interpreter) => Item,\n                          thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      let scope = interpreter.popScope();\n      if (scope instanceof Record) {\n        const children = scope.iterator();\n        while (children.hasNext()) {\n          const child = children.next().value!;\n          if (child instanceof Field) {\n            const oldValue = child.toValue();\n            // Push the child value onto the scope stack.\n            interpreter.pushScope(oldValue);\n            // Transform the child value.\n            const newItem = this.then.mapSelected(interpreter, transform, thisArg);\n            // Pop the child value off of the scope stack.\n            interpreter.popScope();\n            if (newItem.isDefined()) {\n              if (newItem instanceof Field) {\n                children.set(newItem);\n              } else if (newItem !== oldValue) {\n                children.set(child.updatedValue(newItem.toValue()));\n              }\n            } else {\n              children.delete();\n            }\n          } else {\n            // Push the child onto the scope stack.\n            interpreter.pushScope(child.toValue());\n            // Transform the child.\n            const newItem = this.then.mapSelected(interpreter, transform, thisArg);\n            // Pop the child off of the scope stack.\n            interpreter.popScope();\n            if (newItem.isDefined()) {\n              if (child !== newItem) {\n                children.set(newItem);\n              }\n            } else {\n              children.delete();\n            }\n          }\n        }\n      } else if (scope instanceof Field) {\n        const oldValue = scope.toValue();\n        // Push the field value onto the scope stack.\n        interpreter.pushScope(oldValue);\n        // Transform the field value.\n        const newItem = this.then.mapSelected(interpreter, transform, thisArg);\n        // Pop the field value off of the scope stack.\n        interpreter.popScope();\n        if (newItem.isDefined()) {\n          if (newItem instanceof Field) {\n            scope = newItem;\n          } else if (newItem !== oldValue) {\n            scope = scope.updatedValue(newItem.toValue());\n          }\n        } else {\n          scope = Item.absent();\n        }\n      } else {\n        // Push the value onto the scope stack.\n        interpreter.pushScope(scope);\n        // Transform the value.\n        scope = this.then.mapSelected(interpreter, transform, thisArg);\n        // Pop the value off of the scope stack.\n        interpreter.popScope();\n      }\n      // Push the transformed selection back onto the stack.\n      interpreter.pushScope(scope);\n      result = scope;\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    let then = this.then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this.then;\n    }\n    return new ValuesSelector(then as Selector);\n  }\n\n  override andThen(then: Selector): Selector {\n    return new ValuesSelector(this.then.andThen(then));\n  }\n\n  override get typeOrder(): number {\n    return 16;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof ValuesSelector) {\n      return this.then.compareTo(that.then);\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof ValuesSelector) {\n      return this.then.equivalentTo(that.then, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof ValuesSelector) {\n      return this.then.equals(that.then);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(ValuesSelector), this.then.hashCode()));\n  }\n\n  override debugThen<T>(output: Output<T>): Output<T> {\n    output = output.write(46/*'.'*/).write(\"values\").write(40/*'('*/).write(41/*')'*/);\n    output = this.then.debugThen(output);\n    return output;\n  }\n\n  override clone(): Selector {\n    return new ValuesSelector(this.then.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Record} from \"../Record\";\nimport {Selector} from \"./Selector\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../\"; // forward import\n\n/** @public */\nexport class ChildrenSelector extends Selector {\n  constructor(then: Selector) {\n    super();\n    this.then = then;\n  }\n\n  override readonly then: Selector;\n\n  override forSelected<T>(interpreter: Interpreter,\n                          callback: (interpreter: Interpreter) => T | undefined): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S, interpreter: Interpreter) => T | undefined,\n                             thisArg: S): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S | undefined, interpreter: Interpreter) => T | undefined,\n                             thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    interpreter.willSelect(this);\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      // Only records can have children.\n      if (scope instanceof Record) {\n        const children = scope.iterator();\n        // For each child, while none have been selected:\n        while (selected === void 0 && children.hasNext()) {\n          const child = children.next().value!;\n          // Push the child onto the scope stack.\n          interpreter.pushScope(child);\n          // Subselect the child.\n          selected = this.then.forSelected(interpreter, callback, thisArg);\n          // Pop the child off of the scope stack.\n          interpreter.popScope();\n        }\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  override mapSelected(interpreter: Interpreter,\n                       transform: (interpreter: Interpreter) => Item): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S, interpreter: Interpreter) => Item,\n                          thisArg: S): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S | undefined, interpreter: Interpreter) => Item,\n                          thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      // Only records can have children.\n      if (scope instanceof Record) {\n        const children = scope.iterator();\n        // For each child:\n        while (children.hasNext()) {\n          const oldChild = children.next().value!;\n          // Push the child onto the scope stack.\n          interpreter.pushScope(oldChild);\n          // Transform the child.\n          const newChild = this.then.mapSelected(interpreter, transform);\n          // Pop the child off the scope stack.\n          interpreter.popScope();\n          if (newChild.isDefined()) {\n            // Update the child, if its identity changed.\n            if (newChild !== oldChild) {\n              children.set(newChild);\n            }\n          } else {\n            // Remove the child, if it transformed to Absent.\n            children.delete();\n          }\n        }\n      }\n      // Push the transformed selection back onto the stack.\n      interpreter.pushScope(scope);\n      result = scope;\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    let then = this.then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this.then;\n    }\n    return new ChildrenSelector(then as Selector);\n  }\n\n  override andThen(then: Selector): Selector {\n    return new ChildrenSelector(this.then.andThen(then));\n  }\n\n  override get typeOrder(): number {\n    return 17;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof ChildrenSelector) {\n      return this.then.compareTo(that.then);\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof ChildrenSelector) {\n      return this.then.equivalentTo(that.then, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof ChildrenSelector) {\n      return this.then.equals(that.then);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(ChildrenSelector), this.then.hashCode()));\n  }\n\n  override debugThen<T>(output: Output<T>): Output<T> {\n    output = output.write(46/*'.'*/).write(\"children\").write(40/*'('*/).write(41/*')'*/);\n    output = this.then.debugThen(output);\n    return output;\n  }\n\n  override clone(): Selector {\n    return new ChildrenSelector(this.then.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Record} from \"../Record\";\nimport {Selector} from \"./Selector\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../\"; // forward import\n\n/** @public */\nexport class DescendantsSelector extends Selector {\n  constructor(then: Selector) {\n    super();\n    this.then = then;\n  }\n\n  override readonly then: Selector;\n\n  override forSelected<T>(interpreter: Interpreter,\n                          callback: (interpreter: Interpreter) => T | undefined): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S, interpreter: Interpreter) => T | undefined,\n                             thisArg: S): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S | undefined, interpreter: Interpreter) => T | undefined,\n                             thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    interpreter.willSelect(this);\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      // Only records can have descendants.\n      if (scope instanceof Record) {\n        const children = scope.iterator();\n        // For each child, while none have selected a result:\n        while (selected === void 0 && children.hasNext()) {\n          const child = children.next().value!;\n          // Push the child onto the scope stack.\n          interpreter.pushScope(child);\n          // Subselect the child.\n          selected = this.then.forSelected(interpreter, callback, thisArg);\n          // If the child was not selected:\n          if (selected === void 0) {\n            // Recursively select the child's children.\n            this.forSelected(interpreter, callback, thisArg);\n          }\n          // Pop the child off of the scope stack.\n          interpreter.popScope();\n        }\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  override mapSelected(interpreter: Interpreter,\n                       transform: (interpreter: Interpreter) => Item): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S, interpreter: Interpreter) => Item,\n                          thisArg: S): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S | undefined, interpreter: Interpreter) => Item,\n                          thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    if (interpreter.scopeDepth !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      // Only records can have descendants.\n      if (scope instanceof Record) {\n        const children = scope.iterator();\n        // For each child:\n        while (children.hasNext()) {\n          const oldChild = children.next().value!;\n          // Push the child onto the scope stack.\n          interpreter.pushScope(oldChild);\n          // Transform the child.\n          let newChild = this.then.mapSelected(interpreter, transform, thisArg);\n          // If the child was not removed:\n          if (newChild.isDefined()) {\n            // Recursively transform the child's children.\n            newChild = this.mapSelected(interpreter, transform, thisArg);\n          }\n          // Pop the child off the scope stack.\n          interpreter.popScope();\n          if (newChild.isDefined()) {\n            // Update the child, if its identity changed.\n            if (newChild !== oldChild) {\n              children.set(newChild);\n            }\n          } else {\n            // Remove the child, if it transformed to Absent.\n            children.delete();\n          }\n        }\n      }\n      // Push the transformed selection back onto the stack.\n      interpreter.pushScope(scope);\n      result = scope;\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    let then = this.then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this.then;\n    }\n    return new DescendantsSelector(then as Selector);\n  }\n\n  override andThen(then: Selector): Selector {\n    return new DescendantsSelector(this.then.andThen(then));\n  }\n\n  override get typeOrder(): number {\n    return 18;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof DescendantsSelector) {\n      return this.then.compareTo(that.then);\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof DescendantsSelector) {\n      return this.then.equivalentTo(that.then, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof DescendantsSelector) {\n      return this.then.equals(that.then);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(DescendantsSelector), this.then.hashCode()));\n  }\n\n  override debugThen<T>(output: Output<T>): Output<T> {\n    output = output.write(46/*'.'*/).write(\"descendants\").write(40/*'('*/).write(41/*')'*/);\n    output = this.then.debugThen(output);\n    return output;\n  }\n\n  override clone(): Selector {\n    return new DescendantsSelector(this.then.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {ItemLike} from \"../Item\";\nimport {Item} from \"../Item\";\nimport {Selector} from \"./Selector\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../\"; // forward import\n\n/** @public */\nexport class FilterSelector extends Selector {\n  constructor(predicate: Selector, then: Selector) {\n    super();\n    this.predicate = predicate;\n    this.then = then;\n  }\n\n  readonly predicate: Selector;\n\n  override readonly then: Selector;\n\n  override forSelected<T>(interpreter: Interpreter,\n                          callback: (interpreter: Interpreter) => T | undefined): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S, interpreter: Interpreter) => T | undefined,\n                             thisArg: S): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S | undefined, interpreter: Interpreter) => T | undefined,\n                             thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    interpreter.willSelect(this);\n    if (interpreter.scopeDepth !== 0) {\n      // If the filter matches the selection scope:\n      if (this.filterSelected(interpreter)) {\n        // Then subselect the selection scope.\n        selected = this.then.forSelected(interpreter, callback, thisArg);\n      }\n    }\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  override mapSelected(interpreter: Interpreter,\n                       transform: (interpreter: Interpreter) => Item): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S, interpreter: Interpreter) => Item,\n                          thisArg: S): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S | undefined, interpreter: Interpreter) => Item,\n                          thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    if (interpreter.scopeDepth !== 0) {\n      // If the filter matches the selection scope:\n      if (this.filterSelected(interpreter)) {\n        // Then transform the selection scope.\n        result = this.then.mapSelected(interpreter, transform, thisArg);\n      } else {\n        result = interpreter.peekScope().toValue();\n      }\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    let predicate = this.predicate.substitute(interpreter);\n    if (!(predicate instanceof Selector)) {\n      predicate = this.predicate;\n    }\n    let then = this.then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this.then;\n    }\n    return new FilterSelector(predicate as Selector, then as Selector);\n  }\n\n  protected filterSelected(interpreter: Interpreter): boolean {\n    return this.predicate.forSelected(interpreter, this.selected, this) !== void 0;\n  }\n\n  protected selected(interpreter: Interpreter): null {\n    return null;\n  }\n\n  override andThen(then: Selector): Selector {\n    return new FilterSelector(this.predicate, this.then.andThen(then));\n  }\n\n  override filter(predicate?: ItemLike): Selector {\n    if (arguments.length === 0) {\n      return this;\n    } else {\n      predicate = Item.fromLike(predicate);\n      return this.andThen(predicate.filter());\n    }\n  }\n\n  override get typeOrder(): number {\n    return 19;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof FilterSelector) {\n      let order = this.predicate.compareTo(that.predicate);\n      if (order === 0) {\n        order = this.then.compareTo(that.then);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof FilterSelector) {\n      return this.predicate.equivalentTo(that.predicate, epsilon)\n          && this.then.equivalentTo(that.then, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof FilterSelector) {\n      return this.predicate.equals(that.predicate) && this.then.equals(that.then);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(FilterSelector),\n        this.predicate.hashCode()), this.then.hashCode()));\n  }\n\n  override debugThen<T>(output: Output<T>): Output<T> {\n    output = output.write(46/*'.'*/).write(\"filter\").write(40/*'('*/)\n                   .debug(this.predicate).write(41/*')'*/);\n    output = this.then.debugThen(output);\n    return output;\n  }\n\n  override clone(): Selector {\n    return new FilterSelector(this.predicate.clone(), this.then.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Selector} from \"./Selector\";\nimport type {InterpreterLike} from \"../interpreter/Interpreter\";\nimport {Interpreter} from \"../\"; // forward import\n\n/** @public */\nexport class LiteralSelector extends Selector {\n  constructor(item: Item, then: Selector) {\n    super();\n    this.item = item.commit();\n    this.then = then;\n  }\n\n  readonly item: Item;\n\n  override readonly then: Selector;\n\n  override forSelected<T>(interpreter: Interpreter,\n                          callback: (interpreter: Interpreter) => T | undefined): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S, interpreter: Interpreter) => T | undefined,\n                             thisArg: S): T | undefined;\n  override forSelected<T, S>(interpreter: Interpreter,\n                             callback: (this: S | undefined, interpreter: Interpreter) => T | undefined,\n                             thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    interpreter.willSelect(this);\n    if (interpreter.scopeDepth !== 0) {\n      const literal = this.item.evaluate(interpreter);\n      if (literal.isDefined()) {\n        // Push the literal onto the scope stack.\n        interpreter.pushScope(literal);\n        // Subselect the literal.\n        selected = this.then.forSelected(interpreter, callback, thisArg);\n        // Pop the literal off of the scope stack.\n        interpreter.popScope();\n      }\n    }\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  override mapSelected(interpreter: Interpreter,\n                       transform: (interpreter: Interpreter) => Item): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S, interpreter: Interpreter) => Item,\n                          thisArg: S): Item;\n  override mapSelected<S>(interpreter: Interpreter,\n                          transform: (this: S | undefined, interpreter: Interpreter) => Item,\n                          thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    if (interpreter.scopeDepth !== 0) {\n      let literal = this.item.evaluate(interpreter);\n      if (literal.isDefined()) {\n        // Push the literal onto the scope stack.\n        interpreter.pushScope(literal);\n        // Transform the literal.\n        literal = this.then.mapSelected(interpreter, transform, thisArg);\n        // Pop the literal off of the scope stack.\n        interpreter.popScope();\n      }\n      result = literal;\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  override substitute(interpreter: InterpreterLike): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const item = this.item.substitute(interpreter);\n    let then = this.then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this.then;\n    }\n    return new LiteralSelector(item, then as Selector);\n  }\n\n  override andThen(then: Selector): Selector {\n    return new LiteralSelector(this.item, this.then.andThen(then));\n  }\n\n  override get precedence(): number {\n    return this.item.precedence;\n  }\n\n  override get typeOrder(): number {\n    return 11;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof LiteralSelector) {\n      let order = this.item.compareTo(that.item);\n      if (order === 0) {\n        order = this.then.compareTo(that.then);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof LiteralSelector) {\n      return this.item.equivalentTo(that.item, epsilon)\n          && this.then.equivalentTo(that.then, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof LiteralSelector) {\n      return this.item.equals(that.item) && this.then.equals(that.then);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(LiteralSelector),\n        this.item.hashCode()), this.then.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Selector\").write(46/*'.'*/).write(\"literal\").write(40/*'('*/)\n                   .debug(this.item).write(41/*')'*/);\n    output = this.then.debugThen(output);\n    return output;\n  }\n\n  override debugThen<T>(output: Output<T>): Output<T> {\n    return output; // blank\n  }\n\n  override clone(): Selector {\n    return new LiteralSelector(this.item.clone(), this.then.clone());\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Item} from \"../Item\";\nimport type {Value} from \"../Value\";\nimport {Expression} from \"../Expression\";\nimport type {InvokeOperator} from \"../operator/InvokeOperator\";\nimport type {Interpreter} from \"../interpreter/Interpreter\";\n\n/** @public */\nexport abstract class Func extends Expression {\n  /** @internal */\n  constructor() {\n    super();\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  abstract override invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item;\n\n  expand(args: Value, interpreter: Interpreter, operator: InvokeOperator): Item | undefined {\n    return void 0;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Slot} from \"../Slot\";\nimport {Value} from \"../Value\";\nimport {Record} from \"../Record\";\nimport {Text} from \"../Text\";\nimport type {InvokeOperator} from \"../operator/InvokeOperator\";\nimport {Func} from \"./Func\";\nimport {Interpreter} from \"../\"; // forward import\n\n/** @public */\nexport class LambdaFunc extends Func {\n  constructor(bindings: Value, template: Value) {\n    super();\n    this.bindings = bindings;\n    this.template = template;\n  }\n\n  readonly bindings: Value;\n\n  readonly template: Value;\n\n  override get precedence(): number {\n    return 1;\n  }\n\n  override invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n    interpreter = Interpreter.fromLike(interpreter);\n    const bindings = this.bindings;\n    const arity = Math.max(1, bindings.length);\n    const params = Record.create(arity);\n    let i = 0;\n    let j = 0;\n    while (i < arity) {\n      const binding = bindings instanceof Record ? bindings.getItem(i) : i === 0 ? bindings : Item.absent();\n      const arg = args instanceof Record ? args.getItem(j).toValue() : j === 0 ? args : Value.absent();\n      if (binding instanceof Text && arg.isDistinct()) {\n        params.push(Slot.of(binding, arg));\n        j += 1;\n      } else if (binding instanceof Slot) {\n        if (arg.isDistinct()) {\n          params.push(binding.updatedValue(arg));\n        } else {\n          params.push(binding);\n        }\n        j += 1;\n      }\n      i += 1;\n    }\n    interpreter.pushScope(params);\n    const result = this.template.evaluate(interpreter);\n    interpreter.popScope();\n    return result;\n  }\n\n  override get typeOrder(): number {\n    return 50;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof LambdaFunc) {\n      let order = this.bindings.compareTo(that.bindings);\n      if (order === 0) {\n        order = this.template.compareTo(that.template);\n      }\n      return order;\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof LambdaFunc) {\n      return this.bindings.equivalentTo(that.bindings, epsilon)\n          && this.template.equivalentTo(that.template, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof LambdaFunc) {\n      return this.bindings.equals(that.bindings) && this.template.equals(that.template);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(LambdaFunc),\n        this.bindings.hashCode()), this.template.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.debug(this.bindings).write(46/*'.'*/).write(\"lambda\").write(40/*'('*/)\n                   .debug(this.template).write(41/*')'*/);\n    return output;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Func} from \"./Func\";\n\n/** @public */\nexport abstract class BridgeFunc extends Func {\n  override get typeOrder(): number {\n    return 51;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof BridgeFunc) {\n      return Constructors.compare(this.constructor, that.constructor);\n    } else if (that instanceof Item) {\n      return Numbers.compare(this.typeOrder, that.typeOrder);\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown): boolean {\n    return this === that;\n  }\n\n  override equals(that: unknown): boolean {\n    return this === that;\n  }\n\n  override hashCode(): number {\n    return Constructors.hash(this.constructor);\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(this.constructor.name);\n    return output;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item} from \"../Item\";\nimport type {Value} from \"../Value\";\nimport {Record} from \"../Record\";\nimport {Num} from \"../Num\";\nimport type {InvokeOperator} from \"../operator/InvokeOperator\";\nimport type {Func} from \"./Func\";\nimport {BridgeFunc} from \"./BridgeFunc\";\nimport {Interpreter} from \"../\"; // forward import\n\n/** @public */\nexport const MathModule = (function () {\n  const MathModule = {} as {\n    readonly max: Func;\n\n    readonly min: Func;\n\n    readonly abs: Func;\n\n    readonly ceil: Func;\n\n    readonly floor: Func;\n\n    readonly round: Func;\n\n    readonly sqrt: Func;\n\n    readonly pow: Func;\n\n    readonly rate: Func;\n\n    readonly random: Func;\n\n    readonly scope: Record;\n  };\n\n  Object.defineProperty(MathModule, \"max\", {\n    get(): Func {\n      const func = new MaxFunc();\n      Object.defineProperty(MathModule, \"max\", {\n        value: func,\n        enumerable: true,\n        configurable: true,\n      });\n      return func;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Object.defineProperty(MathModule, \"min\", {\n    get(): Func {\n      const func = new MinFunc();\n      Object.defineProperty(MathModule, \"min\", {\n        value: func,\n        enumerable: true,\n        configurable: true,\n      });\n      return func;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Object.defineProperty(MathModule, \"abs\", {\n    get(): Func {\n      const func = new AbsFunc();\n      Object.defineProperty(MathModule, \"abs\", {\n        value: func,\n        enumerable: true,\n        configurable: true,\n      });\n      return func;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Object.defineProperty(MathModule, \"ceil\", {\n    get(): Func {\n      const func = new CeilFunc();\n      Object.defineProperty(MathModule, \"ceil\", {\n        value: func,\n        enumerable: true,\n        configurable: true,\n      });\n      return func;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Object.defineProperty(MathModule, \"floor\", {\n    get(): Func {\n      const func = new FloorFunc();\n      Object.defineProperty(MathModule, \"floor\", {\n        value: func,\n        enumerable: true,\n        configurable: true,\n      });\n      return func;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Object.defineProperty(MathModule, \"round\", {\n    get(): Func {\n      const func = new RoundFunc();\n      Object.defineProperty(MathModule, \"round\", {\n        value: func,\n        enumerable: true,\n        configurable: true,\n      });\n      return func;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Object.defineProperty(MathModule, \"sqrt\", {\n    get(): Func {\n      const func = new SqrtFunc();\n      Object.defineProperty(MathModule, \"sqrt\", {\n        value: func,\n        enumerable: true,\n        configurable: true,\n      });\n      return func;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Object.defineProperty(MathModule, \"pow\", {\n    get(): Func {\n      const func = new PowFunc();\n      Object.defineProperty(MathModule, \"pow\", {\n        value: func,\n        enumerable: true,\n        configurable: true,\n      });\n      return func;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Object.defineProperty(MathModule, \"rate\", {\n    get(): Func {\n      const func = new RateFunc();\n      Object.defineProperty(MathModule, \"rate\", {\n        value: func,\n        enumerable: true,\n        configurable: true,\n      });\n      return func;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Object.defineProperty(MathModule, \"random\", {\n    get(): Func {\n      const func = new RandomFunc();\n      Object.defineProperty(MathModule, \"random\", {\n        value: func,\n        enumerable: true,\n        configurable: true,\n      });\n      return func;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Object.defineProperty(MathModule, \"scope\", {\n    get(): Record {\n      const scope = Record.create(10)\n          .slot(\"max\", MathModule.max)\n          .slot(\"min\", MathModule.min)\n          .slot(\"abs\", MathModule.abs)\n          .slot(\"ceil\", MathModule.ceil)\n          .slot(\"floor\", MathModule.floor)\n          .slot(\"round\", MathModule.round)\n          .slot(\"pow\", MathModule.pow)\n          .slot(\"sqrt\", MathModule.sqrt)\n          .slot(\"rate\", MathModule.rate)\n          .slot(\"random\", MathModule.random)\n          .commit();\n      Object.defineProperty(MathModule, \"scope\", {\n        value: scope,\n        configurable: true,\n        enumerable: true,\n      });\n      return scope;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  class MaxFunc extends BridgeFunc {\n    override invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n      interpreter = Interpreter.fromLike(interpreter);\n      let x: Item;\n      let y: Item | undefined;\n      if (args.length >= 2) {\n        x = args.getItem(0).evaluate(interpreter);\n        y = args.getItem(1).evaluate(interpreter);\n      } else {\n        x = args.evaluate(interpreter);\n      }\n      if (y !== void 0) {\n        return x.max(y);\n      } else if (operator !== void 0) {\n        y = operator.state as Item;\n        const max = y !== void 0 ? x.max(y) : x;\n        operator.setState(max);\n        return max;\n      }\n      return Item.absent();\n    }\n\n    override expand(args: Value, interpreter: Interpreter, operator: InvokeOperator): Item | undefined {\n      if (args.length === 1) {\n        args = args.evaluate(interpreter).toValue();\n        return this.invoke(args, interpreter, operator);\n      }\n      return void 0;\n    }\n  }\n\n  class MinFunc extends BridgeFunc {\n    override invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n      interpreter = Interpreter.fromLike(interpreter);\n      let x: Item;\n      let y: Item | undefined;\n      if (args.length >= 2) {\n        x = args.getItem(0).evaluate(interpreter);\n        y = args.getItem(1).evaluate(interpreter);\n      } else {\n        x = args.evaluate(interpreter);\n      }\n      if (y !== void 0) {\n        return x.min(y);\n      } else if (operator !== void 0) {\n        y = operator.state as Item;\n        const min = y !== void 0 ? x.min(y) : x;\n        operator.setState(min);\n        return min;\n      }\n      return Item.absent();\n    }\n\n    override expand(args: Value, interpreter: Interpreter, operator: InvokeOperator): Item | undefined {\n      if (args.length === 1) {\n        args = args.evaluate(interpreter).toValue();\n        return this.invoke(args, interpreter, operator);\n      }\n      return void 0;\n    }\n  }\n\n  class AbsFunc extends BridgeFunc {\n    override invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n      args = args.evaluate(interpreter).toValue();\n      if (args instanceof Num) {\n        return args.abs();\n      }\n      return Item.absent();\n    }\n  }\n\n  class CeilFunc extends BridgeFunc {\n    override invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n      args = args.evaluate(interpreter).toValue();\n      if (args instanceof Num) {\n        return args.ceil();\n      }\n      return Item.absent();\n    }\n  }\n\n  class FloorFunc extends BridgeFunc {\n    override invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n      args = args.evaluate(interpreter).toValue();\n      if (args instanceof Num) {\n        return args.floor();\n      }\n      return Item.absent();\n    }\n  }\n\n  class RoundFunc extends BridgeFunc {\n    override invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n      args = args.evaluate(interpreter).toValue();\n      if (args instanceof Num) {\n        return args.round();\n      }\n      return Item.absent();\n    }\n  }\n\n  class SqrtFunc extends BridgeFunc {\n    override invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n      args = args.evaluate(interpreter).toValue();\n      if (args instanceof Num) {\n        return args.sqrt();\n      }\n      return Item.absent();\n    }\n  }\n\n  class PowFunc extends BridgeFunc {\n    override invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n      interpreter = Interpreter.fromLike(interpreter);\n      const x = args.getItem(0).evaluate(interpreter);\n      const y = args.getItem(1).evaluate(interpreter);\n      if (x instanceof Num && y instanceof Num) {\n        return x.pow(y);\n      }\n      return Item.absent();\n    }\n  }\n\n  class RateFunc extends BridgeFunc {\n    override invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n      interpreter = Interpreter.fromLike(interpreter);\n      let value: number;\n      let period: number;\n      if (args.length >= 2) {\n        value = args.getItem(0).evaluate(interpreter).numberValue(NaN);\n        period = args.getItem(1).evaluate(interpreter).numberValue(1000);\n      } else {\n        value = args.evaluate(interpreter).numberValue(NaN);\n        period = 1000;\n      }\n      if (isFinite(value) && operator !== void 0) {\n        let state = operator.state as {v0: number, t0: number, dv: number, dt: number} | undefined;\n        if (state === void 0) {\n          state = {v0: value, t0: Date.now(), dv: 0, dt: 0};\n          operator.setState(state);\n        } else {\n          const t1 = Date.now();\n          const dt = t1 - state.t0;\n          if (dt > period && t1 > state.t0 || dt > 2 * period) {\n            const dv = value - state.v0;\n            state.v0 = value;\n            state.t0 = t1;\n            state.dv = dv;\n            state.dt = dt;\n          }\n          operator.setState(state);\n          if (state.dt !== 0) {\n            const rate = period * state.dv / state.dt;\n            return Num.from(rate);\n          }\n        }\n      }\n      return Item.absent();\n    }\n\n    override expand(args: Value, interpreter: Interpreter, operator: InvokeOperator): Item | undefined {\n      args = args.evaluate(interpreter).toValue();\n      return this.invoke(args, interpreter, operator);\n    }\n  }\n\n  class RandomFunc extends BridgeFunc {\n    override invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n      args = args.evaluate(interpreter).toValue();\n      const lower = args.length >= 1 ? args.getItem(0).numberValue(0.0) : 0.0;\n      const upper = args.length >= 2 ? args.getItem(1).numberValue(lower + 1.0) : lower + 1.0;\n      const value = lower + Math.random() * (upper - lower);\n      return Num.from(value);\n    }\n  }\n\n  return MathModule;\n})();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/** @public */\nexport class FormException extends Error {\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, FormException.prototype);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\nimport type {ItemLike} from \"../Item\";\nimport {Item} from \"../Item\";\nimport type {ValueLike} from \"../Value\";\nimport {Value} from \"../Value\";\nimport {TagForm} from \"../\"; // forward import\nimport {UnitForm} from \"../\"; // forward import\nimport {StringForm} from \"../\"; // forward import\nimport {NumberForm} from \"../\"; // forward import\nimport {BooleanForm} from \"../\"; // forward import\nimport {AnyForm} from \"../\"; // forward import\nimport {ItemForm} from \"../\"; // forward import\nimport {ValueForm} from \"../\"; // forward import\n\n/**\n * Transformation between a structurally typed [Item] and a nominally typed\n * JavaScript object.\n * @public\n */\nexport abstract class Form<T, U = T> {\n  /**\n   * Returns the key of the tag attribute that distinguishes structures of this\n   * `Form`; returns `undefined` if this `Form` has no distinguishing tag\n   * attribute. Used to accelerate discrimination of polymorphic structural\n   * types with nominal type hints.\n   */\n  declare readonly tag: string | undefined; // getter defined below to work around useDefineForClassFields lunacy\n\n  /**\n   * Returns a version of this `Form` that requires a head [Attr] with the\n   * given `tag` name.\n   */\n  withTag(tag: string | undefined): Form<T, U> {\n    if (tag === void 0 || tag === this.tag) {\n      return this;\n    }\n    return new TagForm(this, tag);\n  }\n\n  /**\n   * Returns a default–possibly `undefined`–value of type `T`. Used as the\n   * fallback return value when [Item.coerce coercing] an invalid structural\n   * value.\n   */\n  declare readonly unit: T | undefined; // getter defined below to work around useDefineForClassFields lunacy\n\n  /**\n   * Returns a version of this `Form` with the given `unit` value.\n   */\n  withUnit(unit: T | undefined): Form<T, U> {\n    if (unit === this.unit) {\n      return this;\n    }\n    return new UnitForm(this, unit);\n  }\n\n  /**\n   * Converts a nominally typed JavaScript `object` into its structurally typed\n   * equivalent, optionally based on the provided prototype `item`.\n   */\n  abstract mold(object: T | U, item?: Item): Item;\n\n  /**\n   * Converts a structurally typed `item` into a nominally typed JavaScript\n   * object, optionally based on the provided prototype `object`.\n   */\n  abstract cast(item: Item, object?: T): T | undefined;\n\n  @Lazy\n  static forString(): Form<string> {\n    return new StringForm(\"\");\n  }\n\n  @Lazy\n  static forNumber(): Form<number> {\n    return new NumberForm(0);\n  }\n\n  @Lazy\n  static forBoolean(): Form<boolean> {\n    return new BooleanForm(false);\n  }\n\n  @Lazy\n  static forAny(): Form<ItemLike> {\n    return new AnyForm(void 0);\n  }\n\n  @Lazy\n  static forItem(): Form<Item, ItemLike> {\n    return new ItemForm(Item.absent());\n  }\n\n  @Lazy\n  static forValue(): Form<Value, ValueLike> {\n    return new ValueForm(Value.absent());\n  }\n}\nObject.defineProperty(Form.prototype, \"tag\", {\n  get<T, U>(this: Form<T, U>): string | undefined {\n    return void 0;\n  },\n  configurable: true,\n});\nObject.defineProperty(Form.prototype, \"unit\", {\n  get<T, U>(this: Form<T, U>): T | undefined {\n    return void 0;\n  },\n  configurable: true,\n});\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Item} from \"../Item\";\nimport {Attr} from \"../Attr\";\nimport {Form} from \"./Form\";\n\n/** @internal */\nexport class TagForm<T, U = T> extends Form<T, U> {\n  constructor(form: Form<T, U>, tag: string) {\n    super();\n    this.form = form;\n    this.tag = tag;\n  }\n\n  /** @internal */\n  readonly form: Form<T, U>;\n\n  override readonly tag: string;\n\n  override withTag(tag: string | undefined): Form<T, U> {\n     if (tag !== void 0 && tag !== this.tag) {\n      return new TagForm(this.form, tag);\n    } else if (tag === void 0) {\n      return this.form;\n    } else {\n      return this;\n    }\n  }\n\n  override readonly unit!: T | undefined; // // getter defined below to work around useDefineForClassFields lunacy\n\n  override withUnit(unit: T | undefined): Form<T, U> {\n    if (unit === this.unit) {\n      return this;\n    }\n    return new TagForm(this.form.withUnit(unit), this.tag);\n  }\n\n  override mold(object: T | U, item?: Item): Item {\n    item = this.form.mold(object, item);\n    if (!item.header(this.tag).isDefined()) {\n      item = item.prepended(Attr.of(this.tag));\n    }\n    return item;\n  }\n\n  override cast(item: Item, object?: T): T | undefined {\n    if (item.header(this.tag).isDefined()) {\n      return this.form.cast(item, object);\n    } else if (item.keyEquals(this.tag)) {\n      return this.form.cast(item.toValue(), object);\n    }\n    return void 0;\n  }\n}\nObject.defineProperty(TagForm.prototype, \"unit\", {\n  get<T, U>(this: TagForm<T, U>): T | undefined {\n    return this.form.unit;\n  },\n  configurable: true,\n});\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Item} from \"../Item\";\nimport {Form} from \"./Form\";\n\n/** @internal */\nexport class UnitForm<T, U = T> extends Form<T, U> {\n  constructor(form: Form<T, U>, unit: T | undefined) {\n    super();\n    this.form = form;\n    Object.defineProperty(this, \"unit\", {\n      value: unit,\n      enumerable: true,\n      configurable: true,\n    });\n  }\n\n  /** @internal */\n  readonly form: Form<T, U>;\n\n  override readonly tag: string | undefined; // // getter defined below to work around useDefineForClassFields lunacy\n\n  override withTag(tag: string | undefined): Form<T, U> {\n    if (tag === this.tag) {\n      return this;\n    }\n    return new UnitForm(this.form.withTag(tag), this.unit);\n  }\n\n  override readonly unit: T | undefined;\n\n  override withUnit(unit: T | undefined): Form<T, U> {\n    if (unit !== this.unit) {\n      return new UnitForm(this.form, unit);\n    } else if (unit === this.form.unit) {\n      return this.form;\n    }\n    return this;\n  }\n\n  override mold(object: T | U, item?: Item): Item {\n    if (arguments.length === 1) {\n      return this.form.mold(object);\n    }\n    return this.form.mold(object, item);\n  }\n\n  override cast(item: Item, object?: T): T | undefined {\n    if (arguments.length === 1) {\n      return this.form.cast(item);\n    }\n    return this.form.cast(item, object);\n  }\n}\nObject.defineProperty(UnitForm.prototype, \"tag\", {\n  get<T, U>(this: UnitForm<T, U>): string | undefined {\n    return this.form.tag;\n  },\n  configurable: true,\n});\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Item} from \"../Item\";\nimport {Text} from \"../Text\";\nimport {Form} from \"./Form\";\n\n/** @internal */\nexport class StringForm extends Form<string> {\n  constructor(unit?: string) {\n    super();\n    Object.defineProperty(this, \"unit\", {\n      value: unit,\n      enumerable: true,\n      configurable: true,\n    });\n  }\n\n  override readonly unit: string | undefined;\n\n  override withUnit(unit: string | undefined): Form<string> {\n    if (unit === this.unit) {\n      return this;\n    }\n    return new StringForm(unit);\n  }\n\n  override mold(object: string, item?: Item): Item {\n    if (item === void 0) {\n      return Text.from(object);\n    } else {\n      return item.concat(Text.from(object));\n    }\n  }\n\n  override cast(item: Item, object?: string): string | undefined {\n    const value = item.target;\n    try {\n      return value.stringValue();\n    } catch (error) {\n      return void 0;\n    }\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Item} from \"../Item\";\nimport {Num} from \"../Num\";\nimport {Form} from \"./Form\";\n\n/** @internal */\nexport class NumberForm extends Form<number> {\n  constructor(unit?: number) {\n    super();\n    Object.defineProperty(this, \"unit\", {\n      value: unit,\n      enumerable: true,\n      configurable: true,\n    });\n  }\n\n  override readonly unit: number | undefined;\n\n  override withUnit(unit: number | undefined): Form<number> {\n    if (unit === this.unit) {\n      return this;\n    }\n    return new NumberForm(unit);\n  }\n\n  override mold(object: number, item?: Item): Item {\n    if (item === void 0) {\n      return Num.from(object);\n    } else {\n      return item.concat(Num.from(object));\n    }\n  }\n\n  override cast(item: Item, object?: number): number | undefined {\n    const value = item.target;\n    try {\n      return value.numberValue();\n    } catch (error) {\n      return void 0;\n    }\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Item} from \"../Item\";\nimport {Bool} from \"../Bool\";\nimport {Form} from \"./Form\";\n\n/** @internal */\nexport class BooleanForm extends Form<boolean> {\n  constructor(unit?: boolean) {\n    super();\n    Object.defineProperty(this, \"unit\", {\n      value: unit,\n      enumerable: true,\n      configurable: true,\n    });\n  }\n\n  override readonly unit: boolean | undefined;\n\n  override withUnit(unit: boolean | undefined): Form<boolean> {\n    if (unit === this.unit) {\n      return this;\n    }\n    return new BooleanForm(unit);\n  }\n\n  override mold(object: boolean, item?: Item): Item {\n    if (item === void 0) {\n      return Bool.from(object);\n    } else {\n      return item.concat(Bool.from(object));\n    }\n  }\n\n  override cast(item: Item, object?: boolean): boolean | undefined {\n    const value = item.target;\n    try {\n      return value.booleanValue();\n    } catch (error) {\n      return void 0;\n    }\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {ItemLike} from \"../Item\";\nimport {Item} from \"../Item\";\nimport {Form} from \"./Form\";\n\n/** @internal */\nexport class AnyForm extends Form<ItemLike> {\n  constructor(unit?: ItemLike) {\n    super();\n    Object.defineProperty(this, \"unit\", {\n      value: unit,\n      enumerable: true,\n      configurable: true,\n    });\n  }\n\n  override readonly unit: ItemLike | undefined;\n\n  override withUnit(unit: ItemLike | undefined): Form<ItemLike> {\n    if (unit === this.unit) {\n      return this;\n    }\n    return new AnyForm(unit);\n  }\n\n  override mold(object: ItemLike, item?: Item): Item {\n    object = Item.fromLike(object);\n    if (item !== void 0) {\n      object = item.concat(object);\n    }\n    return object;\n  }\n\n  override cast(item: Item, object?: ItemLike): ItemLike | undefined {\n    return item.toLike();\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {ItemLike} from \"../Item\";\nimport {Item} from \"../Item\";\nimport {Form} from \"./Form\";\n\n/** @internal */\nexport class ItemForm extends Form<Item, ItemLike> {\n  constructor(unit?: Item) {\n    super();\n    Object.defineProperty(this, \"unit\", {\n      value: unit,\n      enumerable: true,\n      configurable: true,\n    });\n  }\n\n  override readonly unit: Item | undefined;\n\n  override withUnit(unit: Item | undefined): Form<Item> {\n    if (unit === this.unit) {\n      return this;\n    }\n    return new ItemForm(unit);\n  }\n\n  override mold(object: ItemLike, item?: Item): Item {\n    object = Item.fromLike(object);\n    if (item !== void 0) {\n      object = item.concat(object);\n    }\n    return object;\n  }\n\n  override cast(item: Item, object?: Item): Item | undefined {\n    return item;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Item} from \"../Item\";\nimport type {ValueLike} from \"../Value\";\nimport {Value} from \"../Value\";\nimport {Form} from \"./Form\";\n\n/** @internal */\nexport class ValueForm extends Form<Value, ValueLike> {\n  constructor(unit?: Value) {\n    super();\n    Object.defineProperty(this, \"unit\", {\n      value: unit,\n      enumerable: true,\n      configurable: true,\n    });\n  }\n\n  override readonly unit: Value | undefined;\n\n  override withUnit(unit: Value | undefined): Form<Value> {\n    if (unit === this.unit) {\n      return this;\n    }\n    return new ValueForm(unit);\n  }\n\n  override mold(object: ValueLike, item?: Item): Item {\n    object = Value.fromLike(object);\n    if (item !== void 0) {\n      object = item.concat(object);\n    }\n    return object;\n  }\n\n  override cast(item: Item, object?: Value): Value | undefined {\n    return item.toValue();\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output} from \"@swim/codec\";\nimport type {Parser} from \"@swim/codec\";\nimport type {Writer} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Utf8} from \"@swim/codec\";\nimport {Item} from \"@swim/structure\";\nimport {Value} from \"@swim/structure\";\nimport {Data} from \"@swim/structure\";\nimport type {ReconParser} from \"./parser/ReconParser\";\nimport {ReconStructureParser} from \"./\"; // forward import\nimport type {ReconWriter} from \"./writer/ReconWriter\";\nimport {ReconStructureWriter} from \"./\"; // forward import\n\n/**\n * Factory for constructing Recon parsers and writers.\n * @public\n */\nexport const Recon = (function () {\n  const Recon = {} as {\n    structureParser(): ReconParser<Item, Value>;\n\n    structureWriter(): ReconWriter<Item, Value>;\n\n    parse(recon: string): Value;\n\n    parser(): Parser<Value>;\n\n    sizeOf(item: Item): number;\n\n    sizeOfBlock(item: Item): number;\n\n    write(output: Output, item: Item): Writer;\n\n    writeBlock(output: Output, item: Item): Writer;\n\n    toString(item: Item): string;\n\n    toBlockString(item: Item): string;\n\n    toData(item: Item): Data;\n\n    toBlockData(item: Item): Data;\n\n    /** @internal */\n    isSpace(c: number): boolean;\n\n    /** @internal */\n    isNewline(c: number): boolean;\n\n    /** @internal */\n    isWhitespace(c: number): boolean;\n\n    /** @internal */\n    isIdentStartChar(c: number): boolean;\n\n    /** @internal */\n    isIdentChar(c: number): boolean;\n  };\n\n  Object.defineProperty(Recon, \"structureParser\", {\n    value: function (): ReconStructureParser {\n      const structureParser = new ReconStructureParser();\n      Object.defineProperty(Recon, \"structureParser\", {\n        value: function (): ReconStructureParser {\n          return structureParser;\n        },\n        enumerable: true,\n        configurable: true,\n      });\n      return structureParser;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Object.defineProperty(Recon, \"structureWriter\", {\n    value: function (): ReconStructureWriter {\n      const structureWriter = new ReconStructureWriter();\n      Object.defineProperty(Recon, \"structureWriter\", {\n        value: function (): ReconStructureWriter {\n          return structureWriter;\n        },\n        enumerable: true,\n        configurable: true,\n      });\n      return structureWriter;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n\n  Recon.parse = function (recon: string): Value {\n    return Recon.structureParser().parseBlockString(recon);\n  };\n\n  Recon.parser = function (): Parser<Value> {\n    return Recon.structureParser().blockParser();\n  };\n\n  Recon.sizeOf = function (item: Item): number {\n    return Recon.structureWriter().sizeOfItem(item);\n  };\n\n  Recon.sizeOfBlock = function (item: Item): number {\n    return Recon.structureWriter().sizeOfBlockItem(item);\n  };\n\n  Recon.write = function (output: Output, item: Item): Writer {\n    return Recon.structureWriter().writeItem(output, item);\n  };\n\n  Recon.writeBlock = function (output: Output, item: Item): Writer {\n    return Recon.structureWriter().writeBlockItem(output, item);\n  };\n\n  Recon.toString = function (item: Item): string {\n    let output = Unicode.stringOutput();\n    const writer = Recon.write(output, item);\n    if (!writer.isDone()) {\n      output = Output.error(writer.trap());\n    }\n    return output.bind();\n  };\n\n  Recon.toBlockString = function (item: Item): string {\n    let output = Unicode.stringOutput();\n    const writer = Recon.writeBlock(output, item);\n    if (!writer.isDone()) {\n      output = Output.error(writer.trap());\n    }\n    return output.bind();\n  };\n\n  Recon.toData = function (item: Item): Data {\n    let output = Utf8.encodedOutput(Data.output());\n    const writer = Recon.write(output, item);\n    if (!writer.isDone()) {\n      output = Output.error(writer.trap());\n    }\n    return output.bind();\n  };\n\n  Recon.toBlockData = function (item: Item): Data {\n    let output = Utf8.encodedOutput(Data.output());\n    const writer = Recon.writeBlock(output, item);\n    if (!writer.isDone()) {\n      output = Output.error(writer.trap());\n    }\n    return output.bind();\n  };\n\n  Recon.isSpace = function (c: number): boolean {\n    return c === 0x20 || c === 0x9;\n  };\n\n  Recon.isNewline = function (c: number): boolean {\n    return c === 0xa || c === 0xd;\n  };\n\n  Recon.isWhitespace = function (c: number): boolean {\n    return Recon.isSpace(c) || Recon.isNewline(c);\n  };\n\n  Recon.isIdentStartChar = function (c: number): boolean {\n    return c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c === 95/*'_'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/\n        || c >= 0xc0 && c <= 0xd6\n        || c >= 0xd8 && c <= 0xf6\n        || c >= 0xf8 && c <= 0x2ff\n        || c >= 0x370 && c <= 0x37d\n        || c >= 0x37f && c <= 0x1fff\n        || c >= 0x200c && c <= 0x200d\n        || c >= 0x2070 && c <= 0x218f\n        || c >= 0x2c00 && c <= 0x2fef\n        || c >= 0x3001 && c <= 0xd7ff\n        || c >= 0xf900 && c <= 0xfdcf\n        || c >= 0xfdf0 && c <= 0xfffd\n        || c >= 0x10000 && c <= 0xeffff;\n  };\n\n  Recon.isIdentChar = function (c: number): boolean {\n    return c === 45/*'-'*/\n        || c >= 48/*'0'*/ && c <= 57/*'9'*/\n        || c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c === 95/*'_'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/\n        || c === 0xb7\n        || c >= 0xc0 && c <= 0xd6\n        || c >= 0xd8 && c <= 0xf6\n        || c >= 0xf8 && c <= 0x37d\n        || c >= 0x37f && c <= 0x1fff\n        || c >= 0x200c && c <= 0x200d\n        || c >= 0x203f && c <= 0x2040\n        || c >= 0x2070 && c <= 0x218f\n        || c >= 0x2c00 && c <= 0x2fef\n        || c >= 0x3001 && c <= 0xd7ff\n        || c >= 0xf900 && c <= 0xfdcf\n        || c >= 0xfdf0 && c <= 0xfffd\n        || c >= 0x10000 && c <= 0xeffff;\n  };\n\n  Item.prototype.toRecon = function (this: Item): string {\n    return Recon.toString(this);\n  };\n\n  Item.prototype.toReconBlock = function (this: Item): string {\n    return Recon.toBlockString(this);\n  };\n\n  return Recon;\n})();\n\nValue.parseRecon = function (recon: string): Value {\n  return Recon.parse(recon);\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class BlockParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly keyParser: Parser<V> | undefined;\n  private readonly valueParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, keyParser?: Parser<V>,\n              valueParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.keyParser = keyParser;\n    this.valueParser = valueParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return BlockParser.parse(input, this.recon, this.builder, this.keyParser,\n                             this.valueParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     keyParser?: Parser<V>, valueParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    block: do {\n      if (step === 1) {\n        while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 33/*'!'*/ || c === 34/*'\"'*/ || c === 36/*'$'*/ || c === 37/*'%'*/\n              || c === 39/*'\\''*/ || c === 40/*'('*/ || c === 43/*'+'*/ || c === 45/*'-'*/\n              || c >= 48/*'0'*/ && c <= 57/*'9'*/ || c === 64/*'@'*/\n              || c === 91/*'['*/ || c === 96/*'`'*/ || c === 123/*'{'*/ || c === 126/*'~'*/\n              || Recon.isIdentStartChar(c)) {\n            builder = builder || recon.valueBuilder();\n            step = 2;\n          } else if (c === 35/*'#'*/) {\n            input = input.step();\n            step = 7;\n          } else {\n            if (builder !== void 0) {\n              return Parser.done(builder.build());\n            } else {\n              return Parser.done(recon.absent());\n            }\n          }\n        } else if (input.isDone()) {\n          if (builder !== void 0) {\n            return Parser.done(builder.build());\n          } else {\n            return Parser.done(recon.absent());\n          }\n        }\n      }\n      if (step === 2) {\n        if (keyParser === void 0) {\n          keyParser = recon.parseBlockExpression(input);\n        }\n        while (keyParser.isCont() && !input.isEmpty()) {\n          keyParser = keyParser.feed(input);\n        }\n        if (keyParser.isDone()) {\n          step = 3;\n        } else if (keyParser.isError()) {\n          return keyParser;\n        }\n      }\n      if (step === 3) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 58/*':'*/) {\n            input = input.step();\n            step = 4;\n          } else {\n            builder!.push(recon.item(keyParser!.bind()));\n            keyParser = void 0;\n            step = 6;\n          }\n        } else if (input.isDone()) {\n          builder!.push(recon.item(keyParser!.bind()));\n          return Parser.done(builder!.build());\n        }\n      }\n      if (step === 4) {\n        while (input.isCont() && Recon.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          step = 5;\n        } else if (input.isDone()) {\n          builder!.push(recon.slot(keyParser!.bind()));\n          return Parser.done(builder!.build());\n        }\n      }\n      if (step === 5) {\n        if (valueParser === void 0) {\n          valueParser = recon.parseBlockExpression(input);\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          builder!.push(recon.slot(keyParser!.bind(), valueParser.bind()));\n          keyParser = void 0;\n          valueParser = void 0;\n          step = 6;\n        } else if (valueParser.isError()) {\n          return valueParser;\n        }\n      }\n      if (step === 6) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 44/*','*/ || c === 59/*';'*/ || Recon.isNewline(c)) {\n            input = input.step();\n            step = 1;\n            continue;\n          } else if (c === 35/*'#'*/) {\n            input = input.step();\n            step = 7;\n          } else {\n            return Parser.done(builder!.build());\n          }\n        } else if (input.isDone()) {\n          return Parser.done(builder!.build());\n        }\n      }\n      if (step === 7) {\n        while (input.isCont()) {\n          c = input.head();\n          if (!Recon.isNewline(c)) {\n            input = input.step();\n          } else {\n            step = 1;\n            continue block;\n          }\n        }\n        if (input.isDone()) {\n          step = 1;\n          continue;\n        }\n      }\n      break;\n    } while (true);\n    return new BlockParser<I, V>(recon, builder, keyParser, valueParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class AttrParser<I, V> extends Parser<I> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly keyParser: Parser<V> | undefined;\n  private readonly valueParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, keyParser?: Parser<V>,\n              valueParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.keyParser = keyParser;\n    this.valueParser = valueParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<I> {\n    return AttrParser.parse(input, this.recon, this.keyParser,\n                            this.valueParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, keyParser?: Parser<V>,\n                     valueParser?: Parser<V>, step: number = 1): Parser<I> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 64/*'@'*/) {\n          input = input.step();\n          step = 2;\n        } else {\n          return Parser.error(Diagnostic.expected(64/*'@'*/, input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(64/*'@'*/, input));\n      }\n    }\n    if (step === 2) {\n      if (keyParser === void 0) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 34/*'\"'*/ || c === 39/*'\\''*/) {\n            keyParser = recon.parseString(input);\n          } else if (Recon.isIdentStartChar(c)) {\n            keyParser = recon.parseIdent(input);\n          } else {\n            return Parser.error(Diagnostic.expected(\"attribute name\", input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(\"attribute name\", input));\n        }\n      } else {\n        keyParser = keyParser.feed(input);\n      }\n      if (keyParser !== void 0) {\n        if (keyParser.isDone()) {\n          step = 3;\n        } else if (keyParser.isError()) {\n          return keyParser.asError();\n        }\n      }\n    }\n    if (step === 3) {\n      if (input.isCont() && input.head() === 40/*'('*/) {\n        input = input.step();\n        step = 4;\n      } else if (!input.isEmpty()) {\n        return Parser.done(recon.attr(keyParser!.bind()));\n      }\n    }\n    if (step === 4) {\n      while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 41/*')'*/) {\n          input = input.step();\n          return Parser.done(recon.attr(keyParser!.bind()));\n        } else {\n          step = 5;\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\")\", input));\n      }\n    }\n    if (step === 5) {\n      if (valueParser === void 0) {\n        valueParser = recon.parseBlock(input);\n      }\n      while (valueParser.isCont() && !input.isEmpty()) {\n        valueParser = valueParser.feed(input);\n      }\n      if (valueParser.isDone()) {\n        step = 6;\n      } else if (valueParser.isError()) {\n        return valueParser.asError();\n      }\n    }\n    if (step === 6) {\n      while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 41/*')'*/) {\n          input = input.step();\n          return Parser.done(recon.attr(keyParser!.bind(), valueParser!.bind()));\n        } else {\n          return Parser.error(Diagnostic.expected(\")\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\")\", input));\n      }\n    }\n    return new AttrParser<I, V>(recon, keyParser, valueParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class BlockItemParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly fieldParser: Parser<I> | undefined;\n  private readonly valueParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, fieldParser?: Parser<I>,\n              valueParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.fieldParser = fieldParser;\n    this.valueParser = valueParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return BlockItemParser.parse(input, this.recon, this.builder, this.fieldParser,\n                                 this.valueParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     fieldParser?: Parser<I>, valueParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 64/*'@'*/) {\n            fieldParser = recon.parseAttr(input);\n            step = 2;\n          } else if (c === 123/*'{'*/) {\n            builder = builder || recon.recordBuilder();\n            valueParser = recon.parseRecord(input, builder);\n            step = 5;\n          } else if (c === 91/*'['*/) {\n            builder = builder || recon.recordBuilder();\n            valueParser = recon.parseMarkup(input, builder);\n            step = 5;\n          } else if (Recon.isIdentStartChar(c)) {\n            valueParser = recon.parseIdent(input);\n            step = 4;\n          } else if (c === 34/*'\"'*/ || c === 39/*'\\''*/) {\n            valueParser = recon.parseString(input);\n            step = 4;\n          } else if (c === 96/*'`'*/) {\n            valueParser = recon.parseRawString(input);\n            step = 4;\n          } else if (c === 45/*'-'*/ || c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n            valueParser = recon.parseNumber(input);\n            step = 4;\n          } else if (c === 37/*'%'*/) {\n            valueParser = recon.parseData(input);\n            step = 4;\n          } else if (c === 36/*'$'*/) {\n            valueParser = recon.parseSelector(input);\n            step = 4;\n          } else if (builder === void 0) {\n            return Parser.done(recon.extant());\n          } else {\n            return Parser.done(builder.build());\n          }\n        } else if (input.isDone()) {\n          if (builder === void 0) {\n            return Parser.done(recon.extant());\n          } else {\n            return Parser.done(builder.build());\n          }\n        }\n      }\n      if (step === 2) {\n        while (fieldParser!.isCont() && !input.isEmpty()) {\n          fieldParser = fieldParser!.feed(input);\n        }\n        if (fieldParser!.isDone()) {\n          builder = builder || recon.valueBuilder();\n          builder.push(fieldParser!.bind());\n          fieldParser = void 0;\n          step = 3;\n        } else if (fieldParser!.isError()) {\n          return fieldParser!.asError();\n        }\n      }\n      if (step === 3) {\n        while (input.isCont() && Recon.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          step = 1;\n          continue;\n        } else if (input.isDone()) {\n          return Parser.done(builder!.build());\n        }\n      }\n      if (step === 4) {\n        while (valueParser!.isCont() && !input.isEmpty()) {\n          valueParser = valueParser!.feed(input);\n        }\n        if (valueParser!.isDone()) {\n          builder = builder || recon.valueBuilder();\n          builder.push(recon.item(valueParser!.bind()));\n          valueParser = void 0;\n          step = 6;\n        } else if (valueParser!.isError()) {\n          return valueParser!;\n        }\n      }\n      if (step === 5) {\n        while (valueParser!.isCont() && !input.isEmpty()) {\n          valueParser = valueParser!.feed(input);\n        }\n        if (valueParser!.isDone()) {\n          valueParser = void 0;\n          step = 6;\n        } else if (valueParser!.isError()) {\n          return valueParser!;\n        }\n      }\n      if (step === 6) {\n        while (input.isCont() && Recon.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (input.head() === 64/*'@'*/) {\n            step = 1;\n          } else {\n            return Parser.done(builder!.build());\n          }\n        } else if (input.isDone()) {\n          return Parser.done(builder!.build());\n        }\n      }\n      break;\n    } while (true);\n    return new BlockItemParser<I, V>(recon, builder, fieldParser, valueParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class InlineItemParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly fieldParser: Parser<I> | undefined;\n  private readonly valueParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, fieldParser?: Parser<I>,\n              valueParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.fieldParser = fieldParser;\n    this.valueParser = valueParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return InlineItemParser.parse(input, this.recon, this.builder, this.fieldParser,\n                                  this.valueParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     fieldParser?: Parser<I>,  valueParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 64/*'@'*/) {\n          fieldParser = recon.parseAttr(input);\n          step = 2;\n        } else if (c === 123/*'{'*/) {\n          if (builder !== void 0) {\n            valueParser = recon.parseRecord(input, builder);\n            step = 5;\n          } else {\n            valueParser = recon.parseRecord(input);\n            step = 4;\n          }\n        } else if (c === 91/*'['*/) {\n          if (builder !== void 0) {\n            valueParser = recon.parseMarkup(input, builder);\n            step = 5;\n          } else {\n            valueParser = recon.parseMarkup(input);\n            step = 4;\n          }\n        } else if (builder === void 0) {\n          return Parser.done(recon.extant());\n        } else {\n          return Parser.done(builder.build());\n        }\n      } else if (input.isDone()) {\n        if (builder === void 0) {\n          return Parser.done(recon.extant());\n        } else {\n          return Parser.done(builder.build());\n        }\n      }\n    }\n    if (step === 2) {\n      while (fieldParser!.isCont() && !input.isEmpty()) {\n        fieldParser = fieldParser!.feed(input);\n      }\n      if (fieldParser!.isDone()) {\n        builder = builder || recon.valueBuilder();\n        builder.push(fieldParser!.bind());\n        fieldParser = void 0;\n        step = 3;\n      } else if (fieldParser!.isError()) {\n        return fieldParser!.asError();\n      }\n    }\n    if (step === 3) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 123/*'{'*/) {\n          valueParser = recon.parseRecord(input, builder);\n          step = 5;\n        } else if (c === 91/*'['*/) {\n          valueParser = recon.parseMarkup(input, builder);\n          step = 5;\n        } else {\n          return Parser.done(builder!.build());\n        }\n      } else if (input.isDone()) {\n        return Parser.done(builder!.build());\n      }\n    }\n    if (step === 4) {\n      while (valueParser!.isCont() && !input.isEmpty()) {\n        valueParser = valueParser!.feed(input);\n      }\n      if (valueParser!.isDone()) {\n        builder = builder || recon.valueBuilder();\n        builder.push(recon.item(valueParser!.bind()));\n        return Parser.done(builder.build());\n      } else if (valueParser!.isError()) {\n        return valueParser!;\n      }\n    }\n    if (step === 5) {\n      while (valueParser!.isCont() && !input.isEmpty()) {\n        valueParser = valueParser!.feed(input);\n      }\n      if (valueParser!.isDone()) {\n        return Parser.done(builder!.build());\n      } else if (valueParser!.isError()) {\n        return valueParser!;\n      }\n    }\n    return new InlineItemParser<I, V>(recon, builder, fieldParser, valueParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class RecordParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly keyParser: Parser<V> | undefined;\n  private readonly valueParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, keyParser?: Parser<V>,\n              valueParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.keyParser = keyParser;\n    this.valueParser = valueParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return RecordParser.parse(input, this.recon, this.builder, this.keyParser,\n                              this.valueParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     keyParser?: Parser<V>, valueParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 123/*'{'*/) {\n          input = input.step();\n          step = 2;\n        } else {\n          return Parser.error(Diagnostic.expected(123/*'{'*/, input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(123/*'{'*/, input));\n      }\n    }\n    block: do {\n      if (step === 2) {\n        while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          builder = builder || recon.recordBuilder();\n          if (c === 125/*'}'*/) {\n            input = input.step();\n            return Parser.done(builder.build());\n          } else if (c === 35/*'#'*/) {\n            input = input.step();\n            step = 8;\n          } else {\n            step = 3;\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(125/*'}'*/, input));\n        }\n      }\n      if (step === 3) {\n        if (keyParser === void 0) {\n          keyParser = recon.parseBlockExpression(input);\n        }\n        while (keyParser.isCont() && !input.isEmpty()) {\n          keyParser = keyParser.feed(input);\n        }\n        if (keyParser.isDone()) {\n          step = 4;\n        } else if (keyParser.isError()) {\n          return keyParser;\n        }\n      }\n      if (step === 4) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 58/*':'*/) {\n            input = input.step();\n            step = 5;\n          } else {\n            builder!.push(recon.item(keyParser!.bind()));\n            keyParser = void 0;\n            step = 7;\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(125/*'}'*/, input));\n        }\n      }\n      if (step === 5) {\n        while (input.isCont() && Recon.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          step = 6;\n        } else if (input.isDone()) {\n          builder!.push(recon.slot(keyParser!.bind()));\n          return Parser.done(builder!.build());\n        }\n      }\n      if (step === 6) {\n        if (valueParser === void 0) {\n          valueParser = recon.parseBlockExpression(input);\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          builder!.push(recon.slot(keyParser!.bind(), valueParser.bind()));\n          keyParser = void 0;\n          valueParser = void 0;\n          step = 7;\n        } else if (valueParser.isError()) {\n          return valueParser;\n        }\n      }\n      if (step === 7) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 44/*','*/ || c === 59/*';'*/ || Recon.isNewline(c)) {\n            input = input.step();\n            step = 2;\n            continue;\n          } else if (c === 35/*'#'*/) {\n            input = input.step();\n            step = 8;\n          } else if (c === 125/*'}'*/) {\n            input = input.step();\n            return Parser.done(builder!.build());\n          } else {\n            return Parser.error(Diagnostic.expected(\"'}', ';', ',', or newline\", input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(125/*'}'*/, input));\n        }\n      }\n      if (step === 8) {\n        while (input.isCont()) {\n          c = input.head();\n          if (!Recon.isNewline(c)) {\n            input = input.step();\n          } else {\n            step = 2;\n            continue block;\n          }\n        }\n        if (input.isDone()) {\n          step = 2;\n          continue;\n        }\n      }\n      break;\n    } while (true);\n    return new RecordParser<I, V>(recon, builder, keyParser, valueParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class MarkupParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly textOutput: Output<V> | undefined;\n  private readonly valueParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, textOutput?: Output<V>,\n              valueParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.textOutput = textOutput;\n    this.valueParser = valueParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return MarkupParser.parse(input, this.recon, this.builder, this.textOutput,\n                              this.valueParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     textOutput?: Output<V>, valueParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 91/*'['*/) {\n          input = input.step();\n          step = 2;\n        } else {\n          return Parser.error(Diagnostic.expected(91/*'['*/, input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(91/*'['*/, input));\n      }\n    }\n    do {\n      if (step === 2) {\n        while (input.isCont()) {\n          c = input.head();\n          if (c !== 64/*'@'*/ && c !== 91/*'['*/ && c !== 92/*'\\\\'*/ && c !== 93/*']'*/\n              && c !== 123/*'{'*/ && c !== 125/*'}'*/) {\n            input = input.step();\n            textOutput = textOutput || recon.textOutput();\n            textOutput.write(c);\n          } else {\n            break;\n          }\n        }\n        if (input.isCont()) {\n          if (c === 93/*']'*/) {\n            input = input.step();\n            builder = builder || recon.recordBuilder();\n            if (textOutput !== void 0) {\n              builder.push(recon.item(textOutput.bind()));\n            }\n            return Parser.done(builder.build());\n          } else if (c === 64/*'@'*/) {\n            builder = builder || recon.recordBuilder();\n            if (textOutput !== void 0) {\n              builder.push(recon.item(textOutput.bind()));\n              textOutput = void 0;\n            }\n            valueParser = recon.parseInlineItem(input);\n            step = 3;\n          } else if (c === 123/*'{'*/) {\n            builder = builder || recon.recordBuilder();\n            if (textOutput !== void 0) {\n              builder.push(recon.item(textOutput.bind()));\n              textOutput = void 0;\n            }\n            valueParser = recon.parseRecord(input, builder);\n            step = 4;\n          } else if (c === 91/*'['*/) {\n            builder = builder || recon.recordBuilder();\n            if (textOutput !== void 0) {\n              builder.push(recon.item(textOutput.bind()));\n              textOutput = void 0;\n            }\n            valueParser = recon.parseMarkup(input, builder);\n            step = 4;\n          } else if (c === 92/*'\\\\'*/) {\n            input = input.step();\n            step = 5;\n          } else {\n            return Parser.error(Diagnostic.unexpected(input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.unexpected(input));\n        }\n      }\n      if (step === 3) {\n        while (valueParser!.isCont() && !input.isEmpty()) {\n          valueParser = valueParser!.feed(input);\n        }\n        if (valueParser!.isDone()) {\n          builder!.push(recon.item(valueParser!.bind()));\n          valueParser = void 0;\n          step = 2;\n          continue;\n        } else if (valueParser!.isError()) {\n          return valueParser!;\n        }\n      }\n      if (step === 4) {\n        while (valueParser!.isCont() && !input.isEmpty()) {\n          valueParser = valueParser!.feed(input);\n        }\n        if (valueParser!.isDone()) {\n          valueParser = void 0;\n          step = 2;\n          continue;\n        } else if (valueParser!.isError()) {\n          return valueParser!;\n        }\n      }\n      if (step === 5) {\n        if (input.isCont()) {\n          c = input.head();\n          textOutput = textOutput || recon.textOutput();\n          if (c === 34/*'\"'*/ || c === 36/*'$'*/ || c === 39/*'\\''*/ || c === 47/*'/'*/\n              || c === 64/*'@'*/ || c === 91/*'['*/ || c === 92/*'\\\\'*/ || c === 93/*']'*/\n              || c === 123/*'{'*/ || c === 125/*'}'*/) {\n            input = input.step();\n            textOutput.write(c);\n            step = 2;\n          } else if (c === 98/*'b'*/) {\n            input = input.step();\n            textOutput.write(8/*'\\b'*/);\n            step = 2;\n          } else if (c === 102/*'f'*/) {\n            input = input.step();\n            textOutput.write(12/*'\\f'*/);\n            step = 2;\n          } else if (c === 110/*'n'*/) {\n            input = input.step();\n            textOutput.write(10/*'\\n'*/);\n            step = 2;\n          } else if (c === 114/*'r'*/) {\n            input = input.step();\n            textOutput.write(13/*'\\r'*/);\n            step = 2;\n          } else if (c === 116/*'t'*/) {\n            input = input.step();\n            textOutput.write(9/*'\\t'*/);\n            step = 2;\n          } else {\n            return Parser.error(Diagnostic.expected(\"escape character\", input));\n          }\n          continue;\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(\"escape character\", input));\n        }\n      }\n      break;\n    } while (true);\n    return new MarkupParser<I, V>(recon, builder, textOutput, valueParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Base64} from \"@swim/codec\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class DataParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly base64Parser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, base64Parser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.base64Parser = base64Parser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return DataParser.parse(input, this.recon, this.base64Parser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>,\n                     base64Parser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 37/*'%'*/) {\n          input = input.step();\n          step = 2;\n        } else {\n          return Parser.error(Diagnostic.expected(37/*'%'*/, input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(37/*'%'*/, input));\n      }\n    }\n    if (step === 2) {\n      if (base64Parser === void 0) {\n        base64Parser = Base64.standard().parse(input, recon.dataOutput());\n      }\n      while (base64Parser.isCont() && !input.isEmpty()) {\n        base64Parser = base64Parser.feed(input);\n      }\n      if (base64Parser.isDone()) {\n        return base64Parser;\n      } else if (base64Parser.isError()) {\n        return base64Parser;\n      }\n    }\n    return new DataParser<I, V>(recon, base64Parser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class IdentParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly output: Output<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, output?: Output<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.output = output;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return IdentParser.parse(input, this.recon, this.output, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, output?: Output<V>,\n                     step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (Recon.isIdentStartChar(c)) {\n          input = input.step();\n          output = output || recon.textOutput();\n          output = output.write(c);\n          step = 2;\n        } else {\n          return Parser.error(Diagnostic.expected(\"identifier\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"identifier\", input));\n      }\n    }\n    if (step === 2) {\n      while (input.isCont() && (c = input.head(), Recon.isIdentChar(c))) {\n        input = input.step();\n        output!.write(c);\n      }\n      if (!input.isEmpty()) {\n        return Parser.done(recon.ident(output!.bind()));\n      }\n    }\n    return new IdentParser<I, V>(recon, output, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Base16} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class StringParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly output: Output<V> | undefined;\n  private readonly quote: number | undefined;\n  private readonly code: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, output?: Output<V>, quote?: number,\n              code?: number, step?: number) {\n    super();\n    this.recon = recon;\n    this.output = output;\n    this.quote = quote;\n    this.code = code;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return StringParser.parse(input, this.recon, this.output, this.quote,\n                              this.code, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, output?: Output<V>,\n                     quote: number = 0, code: number = 0, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if ((c === 34/*'\"'*/ || c === 39/*'\\''*/) && (quote === c || quote === 0)) {\n          input = input.step();\n          output = output || recon.textOutput();\n          quote = c;\n          step = 2;\n        } else {\n          return Parser.error(Diagnostic.expected(\"string\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"string\", input));\n      }\n    }\n    string: do {\n      if (step === 2) {\n        while (input.isCont()) {\n          c = input.head();\n          if (c >= 0x20 && c !== quote && c !== 92/*'\\\\'*/) {\n            input = input.step();\n            output = output!.write(c);\n          } else {\n            break;\n          }\n        }\n        if (input.isCont()) {\n          if (c === quote) {\n            input = input.step();\n            return Parser.done(output!.bind());\n          } else if (c === 92/*'\\\\'*/) {\n            input = input.step();\n            step = 3;\n          } else {\n            return Parser.error(Diagnostic.expected(quote, input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(quote, input));\n        }\n      }\n      if (step === 3) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 34/*'\"'*/ || c === 36/*'$'*/ || c === 39/*'\\''*/ || c === 47/*'/'*/\n              || c === 64/*'@'*/ || c === 91/*'['*/ || c === 92/*'\\\\'*/ || c === 93/*']'*/\n              || c === 123/*'{'*/ || c === 125/*'}'*/) {\n            input = input.step();\n            output = output!.write(c);\n            step = 2;\n            continue;\n          } else if (c === 98/*'b'*/) {\n            input = input.step();\n            output = output!.write(8/*'\\b'*/);\n            step = 2;\n            continue;\n          } else if (c === 102/*'f'*/) {\n            input = input.step();\n            output = output!.write(12/*'\\f'*/);\n            step = 2;\n            continue;\n          } else if (c === 110/*'n'*/) {\n            input = input.step();\n            output = output!.write(10/*'\\n'*/);\n            step = 2;\n            continue;\n          } else if (c === 114/*'r'*/) {\n            input = input.step();\n            output = output!.write(13/*'\\r'*/);\n            step = 2;\n            continue;\n          } else if (c === 116/*'t'*/) {\n            input = input.step();\n            output = output!.write(9/*'\\t'*/);\n            step = 2;\n            continue;\n          } else if (c === 117/*'u'*/) {\n            input = input.step();\n            step = 4;\n          } else {\n            return Parser.error(Diagnostic.expected(\"escape character\", input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(\"escape character\", input));\n        }\n      }\n      if (step >= 4) {\n        do {\n          if (input.isCont()) {\n            c = input.head();\n            if (Base16.isDigit(c)) {\n              input = input.step();\n              code = 16 * code + Base16.decodeDigit(c);\n              if (step <= 6) {\n                step += 1;\n                continue;\n              } else {\n                output = output!.write(code);\n                code = 0;\n                step = 2;\n                continue string;\n              }\n            } else {\n              return Parser.error(Diagnostic.expected(\"hex digit\", input));\n            }\n          } else if (input.isDone()) {\n            return Parser.error(Diagnostic.expected(\"hex digit\", input));\n          }\n          break;\n        } while (true);\n      }\n      break;\n    } while (true);\n    return new StringParser<I, V>(recon, output, quote, code, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class RawStringParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly output: Output<V> | undefined;\n  private readonly count: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, output?: Output<V>, count?: number, step?: number) {\n    super();\n    this.recon = recon;\n    this.output = output;\n    this.count = count;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return RawStringParser.parse(input, this.recon, this.output, this.count, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, output?: Output<V>,\n                     count: number = 0, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n        input = input.step();\n      }\n      if (input.isCont() && c === 96/*'`'*/) {\n        input = input.step();\n        count = 1;\n        step = 2;\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"raw string\", input));\n      }\n    }\n    if (step === 2) {\n      if (input.isCont()) {\n        if (input.head() === 96/*'`'*/) {\n          input = input.step();\n          count = 2;\n          step = 3;\n        } else {\n          output = output || recon.textOutput();\n          step = 4;\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"raw string\", input));\n      }\n    }\n    if (step === 3) {\n      if (input.isCont()) {\n        if (input.head() === 96/*'`'*/) {\n          input = input.step();\n          output = output || recon.textOutput();\n          count = 3;\n          step = 4;\n        } else {\n          output = output || recon.textOutput();\n          return Parser.done(output!.bind());\n        }\n      } else if (input.isDone()) {\n        output = output || recon.textOutput();\n        return Parser.done(output!.bind());\n      }\n    }\n    do {\n      if (step === 4) {\n        while (input.isCont()) {\n          c = input.head();\n          if ((count !== 1 || c >= 0x20) && c !== 96/*'`'*/ && c !== 92/*'\\\\'*/) {\n            input = input.step();\n            output = output!.write(c);\n          } else {\n            break;\n          }\n        }\n        if (input.isCont()) {\n          if (c === 92/*'\\\\'*/) {\n            input = input.step();\n            step = 5;\n          } else if (c === 96/*'`'*/) {\n            input = input.step();\n            if (count === 1) {\n              return Parser.done(output!.bind());\n            } else {\n              step = 6;\n            }\n          } else {\n            return Parser.error(Diagnostic.expected(96/*'`'*/, input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(96/*'`'*/, input));\n        }\n      }\n      if (step === 5) {\n        if (input.isCont()) {\n          c = input.head();\n          input = input.step();\n          if (c !== 92/*'\\\\'*/ && c !== 96/*'`'*/) {\n            output = output!.write(92/*'\\\\'*/);\n          }\n          output = output!.write(c);\n          step = 4;\n          continue;\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(\"escape character\", input));\n        }\n      }\n      if (step === 6) {\n        if (input.isCont()) {\n          if (input.head() === 96/*'`'*/) {\n            input = input.step();\n            step = 7;\n          } else {\n            output = output!.write(96/*'`'*/);\n            step = 4;\n            continue;\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.message(\"unclosed raw string\", input));\n        }\n      }\n      if (step === 7) {\n        if (input.isCont()) {\n          if (input.head() === 96/*'`'*/) {\n            input = input.step();\n            return Parser.done(output!.bind());\n          } else {\n            output = output!.write(96/*'`'*/);\n            output = output!.write(96/*'`'*/);\n            step = 4;\n            continue;\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.message(\"unclosed raw string\", input));\n        }\n      }\n      break;\n    } while (true);\n    return new RawStringParser<I, V>(recon, output, count, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Base16} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class NumberParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly sign: number | undefined;\n  private readonly value: number | undefined;\n  private readonly mode: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, sign?: number, value?: number, mode?: number, step?: number) {\n    super();\n    this.recon = recon;\n    this.sign = sign;\n    this.value = value;\n    this.mode = mode;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return NumberParser.parse(input, this.recon, this.sign, this.value, this.mode, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, sign: number = 1, value: number = 0,\n                     mode: number = 2, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 45/*'-'*/) {\n          input = input.step();\n          sign = -1;\n        }\n        step = 2;\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"number\", input));\n      }\n    }\n    if (step === 2) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 48/*'0'*/) {\n          input = input.step();\n          step = 4;\n        } else if (c >= 49/*'1'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          value = sign * (c - 48/*'0'*/);\n          step = 3;\n        } else {\n          return Parser.error(Diagnostic.expected(\"digit\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"digit\", input));\n      }\n    }\n    if (step === 3) {\n      while (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          const newValue = 10 * value + sign * (c - 48/*'0'*/);\n          if (-9007199254740991 <= newValue && newValue <= 9007199254740992) {\n            value = newValue;\n            input = input.step();\n          } else {\n            return Parser.error(Diagnostic.message(\"integer overflow\", input));\n          }\n        } else {\n          break;\n        }\n      }\n      if (input.isCont()) {\n        step = 4;\n      } else if (input.isDone()) {\n        return Parser.done(recon.num(value));\n      }\n    }\n    if (step === 4) {\n      if (input.isCont()) {\n        c = input.head();\n        if (mode > 0 && c === 46/*'.'*/ || mode > 1 && (c === 69/*'E'*/ || c === 101/*'e'*/)) {\n          let output = Unicode.stringOutput();\n          if (sign < 0 && value === 0) {\n            output = output.write(45/*'-'*/).write(48/*'0'*/);\n          } else {\n            output = output.write(\"\" + value);\n          }\n          return DecimalParser.parse(input, recon, output, mode);\n        } else if (c === 120/*'x'*/ && sign > 0 && value === 0) {\n          input = input.step();\n          return HexadecimalParser.parse(input, recon);\n        } else {\n          return Parser.done(recon.num(value));\n        }\n      } else if (input.isDone()) {\n        return Parser.done(recon.num(value));\n      }\n    }\n    return new NumberParser<I, V>(recon, sign, value, mode, step);\n  }\n\n  static parseInteger<I, V>(input: Input, recon: ReconParser<I, V>): Parser<V> {\n    return NumberParser.parse(input, recon, void 0, void 0, 0);\n  }\n\n  static parseDecimal<I, V>(input: Input, recon: ReconParser<I, V>): Parser<V> {\n    return NumberParser.parse(input, recon, void 0, void 0, 1);\n  }\n}\n\n/** @internal */\nexport class DecimalParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly output: Output<string>;\n  private readonly mode: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, output: Output<string>, mode?: number, step?: number) {\n    super();\n    this.recon = recon;\n    this.output = output;\n    this.mode = mode;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return DecimalParser.parse(input, this.recon, this.output, this.mode, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, output: Output<string>,\n                     mode: number = 2, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 46/*'.'*/) {\n          input = input.step();\n          output = output.write(c);\n          step = 2;\n        } else if (mode > 1 && (c === 69/*'E'*/ || c === 101/*'e'*/)) {\n          input = input.step();\n          output = output.write(c);\n          step = 5;\n        } else {\n          return Parser.error(Diagnostic.expected(\"decimal or exponent\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"decimal or exponent\", input));\n      }\n    }\n    if (step === 2) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          output = output.write(c);\n          step = 3;\n        } else {\n          return Parser.error(Diagnostic.expected(\"digit\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"digit\", input));\n      }\n    }\n    if (step === 3) {\n      while (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          output = output.write(c);\n        } else {\n          break;\n        }\n      }\n      if (input.isCont()) {\n        if (mode > 1) {\n          step = 4;\n        } else {\n          return Parser.done(recon.num(output.bind()));\n        }\n      } else if (input.isDone()) {\n        return Parser.done(recon.num(output.bind()));\n      }\n    }\n    if (step === 4) {\n      c = input.head();\n      if (c === 69/*'E'*/ || c === 101/*'e'*/) {\n        input = input.step();\n        output = output.write(c);\n        step = 5;\n      } else {\n        return Parser.done(recon.num(output.bind()));\n      }\n    }\n    if (step === 5) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 43/*'+'*/ || c === 45/*'-'*/) {\n          input = input.step();\n          output = output.write(c);\n        }\n        step = 6;\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 6) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          output = output.write(c);\n          step = 7;\n        } else {\n          return Parser.error(Diagnostic.expected(\"digit\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"digit\", input));\n      }\n    }\n    if (step === 7) {\n      while (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          output = output.write(c);\n        } else {\n          break;\n        }\n      }\n      if (!input.isEmpty()) {\n        return Parser.done(recon.num(output.bind()));\n      }\n    }\n    return new DecimalParser<I, V>(recon, output, mode, step);\n  }\n}\n\n/** @internal */\nclass HexadecimalParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly value: number | undefined;\n  private readonly size: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, value?: number, size?: number) {\n    super();\n    this.recon = recon;\n    this.value = value;\n    this.size = size;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return HexadecimalParser.parse(input, this.recon, this.value, this.size);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>,\n                     value: number = 0, size: number = 0): Parser<V> {\n    let c = 0;\n    while (input.isCont()) {\n      c = input.head();\n      if (Base16.isDigit(c)) {\n        input = input.step();\n        value = 16 * value + Base16.decodeDigit(c);\n        size += 1;\n      } else {\n        break;\n      }\n    }\n    if (!input.isEmpty()) {\n      if (size > 0) {\n        if (size <= 8) {\n          return Parser.done(recon.uint32(value));\n        } else {\n          return Parser.done(recon.uint64(value));\n        }\n      } else {\n        return Parser.error(Diagnostic.expected(\"hex digit\", input));\n      }\n    }\n    return new HexadecimalParser<I, V>(recon, value, size);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class LambdaFuncParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly bindingsParser: Parser<V> | undefined;\n  private readonly templateParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, bindingsParser?: Parser<V>,\n              templateParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.bindingsParser = bindingsParser;\n    this.templateParser = templateParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return LambdaFuncParser.parse(input, this.recon, this.builder, this.bindingsParser,\n                                  this.templateParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     bindingsParser?: Parser<V>, templateParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (bindingsParser === void 0) {\n        bindingsParser = recon.parseConditionalOperator(input, builder);\n      }\n      while (bindingsParser.isCont() && !input.isEmpty()) {\n        bindingsParser = bindingsParser.feed(input);\n      }\n      if (bindingsParser.isDone()) {\n        step = 2;\n      } else if (bindingsParser.isError()) {\n        return bindingsParser.asError();\n      }\n    }\n    if (step === 2) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 62/*'>'*/) {\n          // leading '=' consumed by ComparisonOperatorParser\n          input = input.step();\n          step = 3;\n        } else {\n          return bindingsParser!;\n        }\n      } else if (input.isDone()) {\n        return bindingsParser!;\n      }\n    }\n    if (step === 3) {\n      if (templateParser === void 0) {\n        templateParser = recon.parseConditionalOperator(input);\n      }\n      while (templateParser.isCont() && !input.isEmpty()) {\n        templateParser = templateParser.feed(input);\n      }\n      if (templateParser.isDone()) {\n        const bindings = bindingsParser!.bind();\n        const template = templateParser.bind();\n        return Parser.done(recon.lambda(bindings, template));\n      } else if (templateParser.isError()) {\n        return templateParser.asError();\n      }\n    }\n    return new LambdaFuncParser<I, V>(recon, builder, bindingsParser, templateParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class ConditionalOperatorParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly ifParser: Parser<V> | undefined;\n  private readonly thenParser: Parser<V> | undefined;\n  private readonly elseParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, ifParser?: Parser<V>,\n              thenParser?: Parser<V>, elseParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.ifParser = ifParser;\n    this.thenParser = thenParser;\n    this.elseParser = elseParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return ConditionalOperatorParser.parse(input, this.recon, this.builder, this.ifParser,\n                                           this.thenParser, this.elseParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     ifParser?: Parser<V>, thenParser?: Parser<V>,\n                     elseParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (ifParser === void 0) {\n        ifParser = recon.parseOrOperator(input, builder);\n      }\n      while (ifParser.isCont() && !input.isEmpty()) {\n        ifParser = ifParser.feed(input);\n      }\n      if (ifParser.isDone()) {\n        step = 2;\n      } else if (ifParser.isError()) {\n        return ifParser.asError();\n      }\n    }\n    if (step === 2) {\n      while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 63/*'?'*/) {\n          input = input.step();\n          step = 3;\n        } else {\n          return ifParser!;\n        }\n      } else if (input.isDone()) {\n        return ifParser!;\n      }\n    }\n    if (step === 3) {\n      if (thenParser === void 0) {\n        thenParser = recon.parseConditionalOperator(input, builder);\n      }\n      while (thenParser.isCont() && !input.isEmpty()) {\n        thenParser = thenParser.feed(input);\n      }\n      if (thenParser.isDone()) {\n        step = 4;\n      } else if (thenParser.isError()) {\n        return thenParser.asError();\n      }\n    }\n    if (step === 4) {\n      while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 58/*':'*/) {\n          input = input.step();\n          step = 5;\n        } else {\n          return Parser.error(Diagnostic.expected(58/*':'*/, input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(58/*':'*/, input));\n      }\n    }\n    if (step === 5) {\n      if (elseParser === void 0) {\n        elseParser = recon.parseConditionalOperator(input, builder);\n      }\n      while (elseParser.isCont() && !input.isEmpty()) {\n        elseParser = elseParser.feed(input);\n      }\n      if (elseParser.isDone()) {\n        const ifTerm = ifParser!.bind();\n        const thenTerm = thenParser!.bind();\n        const elseTerm = elseParser.bind();\n        return Parser.done(recon.conditional(ifTerm, thenTerm, elseTerm));\n      } else if (elseParser.isError()) {\n        return elseParser.asError();\n      }\n    }\n    return new ConditionalOperatorParser<I, V>(recon, builder, ifParser, thenParser, elseParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class OrOperatorParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly lhsParser: Parser<V> | undefined;\n  private readonly rhsParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              lhsParser?: Parser<V>, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.lhsParser = lhsParser;\n    this.rhsParser = rhsParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return OrOperatorParser.parse(input, this.recon, this.builder, this.lhsParser,\n                                  this.rhsParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     lhsParser?: Parser<V>, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (lhsParser === void 0) {\n          lhsParser = recon.parseAndOperator(input, builder);\n        }\n        while (lhsParser.isCont() && !input.isEmpty()) {\n          lhsParser = lhsParser.feed(input);\n        }\n        if (lhsParser.isDone()) {\n          step = 2;\n        } else if (lhsParser.isError()) {\n          return lhsParser.asError();\n        }\n      }\n      if (step === 2) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 124/*'|'*/) {\n            // first '|' consumed by BitwiseOrOperatorParser\n            input = input.step();\n            step = 3;\n          } else {\n            return lhsParser!;\n          }\n        } else if (input.isDone()) {\n          return lhsParser!;\n        }\n      }\n      if (step === 3) {\n        if (rhsParser === void 0) {\n          rhsParser = recon.parseAndOperator(input, builder);\n        }\n        while (rhsParser.isCont() && !input.isEmpty()) {\n          rhsParser = rhsParser.feed(input);\n        }\n        if (rhsParser.isDone()) {\n          const lhs = lhsParser!.bind();\n          const rhs = rhsParser.bind();\n          lhsParser = Parser.done(recon.or(lhs, rhs));\n          rhsParser = void 0;\n          step = 2;\n          continue;\n        } else if (rhsParser.isError()) {\n          return rhsParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new OrOperatorParser<I, V>(recon, builder, lhsParser, rhsParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class AndOperatorParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly lhsParser: Parser<V> | undefined;\n  private readonly rhsParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              lhsParser?: Parser<V>, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.lhsParser = lhsParser;\n    this.rhsParser = rhsParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return AndOperatorParser.parse(input, this.recon, this.builder, this.lhsParser,\n                                   this.rhsParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     lhsParser?: Parser<V>, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (lhsParser === void 0) {\n          lhsParser = recon.parseBitwiseOrOperator(input, builder);\n        }\n        while (lhsParser.isCont() && !input.isEmpty()) {\n          lhsParser = lhsParser.feed(input);\n        }\n        if (lhsParser.isDone()) {\n          step = 2;\n        } else if (lhsParser.isError()) {\n          return lhsParser.asError();\n        }\n      }\n      if (step === 2) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 38/*'&'*/) {\n            // first '&' consumed by BitwiseAndOperatorParser\n            input = input.step();\n            step = 3;\n          } else {\n            return lhsParser!;\n          }\n        } else if (input.isDone()) {\n          return lhsParser!;\n        }\n      }\n      if (step === 3) {\n        if (rhsParser === void 0) {\n          rhsParser = recon.parseBitwiseOrOperator(input, builder);\n        }\n        while (rhsParser.isCont() && !input.isEmpty()) {\n          rhsParser = rhsParser.feed(input);\n        }\n        if (rhsParser.isDone()) {\n          const lhs = lhsParser!.bind();\n          const rhs = rhsParser.bind();\n          lhsParser = Parser.done(recon.and(lhs, rhs));\n          rhsParser = void 0;\n          step = 2;\n          continue;\n        } else if (rhsParser.isError()) {\n          return rhsParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new AndOperatorParser<I, V>(recon, builder, lhsParser, rhsParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class BitwiseOrOperatorParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly lhsParser: Parser<V> | undefined;\n  private readonly rhsParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              lhsParser?: Parser<V>, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.lhsParser = lhsParser;\n    this.rhsParser = rhsParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return BitwiseOrOperatorParser.parse(input, this.recon, this.builder,\n                                         this.lhsParser, this.rhsParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     lhsParser?: Parser<V>, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (lhsParser === void 0) {\n          lhsParser = recon.parseBitwiseXorOperator(input, builder);\n        }\n        while (lhsParser.isCont() && !input.isEmpty()) {\n          lhsParser = lhsParser.feed(input);\n        }\n        if (lhsParser.isDone()) {\n          step = 2;\n        } else if (lhsParser.isError()) {\n          return lhsParser.asError();\n        }\n      }\n      if (step === 2) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 124/*'|'*/) {\n            input = input.step();\n            step = 3;\n          } else {\n            return lhsParser!;\n          }\n        } else if (input.isDone()) {\n          return lhsParser!;\n        }\n      }\n      if (step === 3) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 124/*'|'*/) {\n            return lhsParser!;\n          } else {\n            step = 4;\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.unexpected(input));\n        }\n      }\n      if (step === 4) {\n        if (rhsParser === void 0) {\n          rhsParser = recon.parseBitwiseXorOperator(input, builder);\n        }\n        while (rhsParser.isCont() && !input.isEmpty()) {\n          rhsParser = rhsParser.feed(input);\n        }\n        if (rhsParser.isDone()) {\n          const lhs = lhsParser!.bind();\n          const rhs = rhsParser.bind();\n          lhsParser = Parser.done(recon.bitwiseOr(lhs, rhs));\n          rhsParser = void 0;\n          step = 2;\n          continue;\n        } else if (rhsParser.isError()) {\n          return rhsParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new BitwiseOrOperatorParser<I, V>(recon, builder, lhsParser, rhsParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class BitwiseXorOperatorParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly lhsParser: Parser<V> | undefined;\n  private readonly rhsParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              lhsParser?: Parser<V>, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.lhsParser = lhsParser;\n    this.rhsParser = rhsParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return BitwiseXorOperatorParser.parse(input, this.recon, this.builder,\n                                          this.lhsParser, this.rhsParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     lhsParser?: Parser<V>, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (lhsParser === void 0) {\n          lhsParser = recon.parseBitwiseAndOperator(input, builder);\n        }\n        while (lhsParser.isCont() && !input.isEmpty()) {\n          lhsParser = lhsParser.feed(input);\n        }\n        if (lhsParser.isDone()) {\n          step = 2;\n        } else if (lhsParser.isError()) {\n          return lhsParser.asError();\n        }\n      }\n      if (step === 2) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 94/*'^'*/) {\n            input = input.step();\n            step = 3;\n          } else {\n            return lhsParser!;\n          }\n        } else if (input.isDone()) {\n          return lhsParser!;\n        }\n      }\n      if (step === 3) {\n        if (rhsParser === void 0) {\n          rhsParser = recon.parseBitwiseAndOperator(input, builder);\n        }\n        while (rhsParser.isCont() && !input.isEmpty()) {\n          rhsParser = rhsParser.feed(input);\n        }\n        if (rhsParser.isDone()) {\n          const lhs = lhsParser!.bind();\n          const rhs = rhsParser.bind();\n          lhsParser = Parser.done(recon.bitwiseXor(lhs, rhs));\n          rhsParser = void 0;\n          step = 2;\n          continue;\n        } else if (rhsParser.isError()) {\n          return rhsParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new BitwiseXorOperatorParser<I, V>(recon, builder, lhsParser, rhsParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class BitwiseAndOperatorParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly lhsParser: Parser<V> | undefined;\n  private readonly rhsParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              lhsParser?: Parser<V>, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.lhsParser = lhsParser;\n    this.rhsParser = rhsParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return BitwiseAndOperatorParser.parse(input, this.recon, this.builder,\n                                          this.lhsParser, this.rhsParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     lhsParser?: Parser<V>, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (lhsParser === void 0) {\n          lhsParser = recon.parseComparisonOperator(input, builder);\n        }\n        while (lhsParser.isCont() && !input.isEmpty()) {\n          lhsParser = lhsParser.feed(input);\n        }\n        if (lhsParser.isDone()) {\n          step = 2;\n        } else if (lhsParser.isError()) {\n          return lhsParser.asError();\n        }\n      }\n      if (step === 2) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 38/*'&'*/) {\n            input = input.step();\n            step = 3;\n          } else {\n            return lhsParser!;\n          }\n        } else if (input.isDone()) {\n          return lhsParser!;\n        }\n      }\n      if (step === 3) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 38/*'&'*/) {\n            return lhsParser!;\n          } else {\n            step = 4;\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.unexpected(input));\n        }\n      }\n      if (step === 4) {\n        if (rhsParser === void 0) {\n          rhsParser = recon.parseComparisonOperator(input, builder);\n        }\n        while (rhsParser.isCont() && !input.isEmpty()) {\n          rhsParser = rhsParser.feed(input);\n        }\n        if (rhsParser.isDone()) {\n          const lhs = lhsParser!.bind();\n          const rhs = rhsParser.bind();\n          lhsParser = Parser.done(recon.bitwiseAnd(lhs, rhs));\n          rhsParser = void 0;\n          step = 2;\n          continue;\n        } else if (rhsParser.isError()) {\n          return rhsParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new BitwiseAndOperatorParser<I, V>(recon, builder, lhsParser, rhsParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class ComparisonOperatorParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly lhsParser: Parser<V> | undefined;\n  private readonly operator: string | undefined;\n  private readonly rhsParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, lhsParser?: Parser<V>,\n              operator?: string, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.lhsParser = lhsParser;\n    this.operator = operator;\n    this.rhsParser = rhsParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return ComparisonOperatorParser.parse(input, this.recon, this.builder, this.lhsParser,\n                                          this.operator, this.rhsParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>, lhsParser?: Parser<V>,\n                     operator?: string, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (lhsParser === void 0) {\n        lhsParser = recon.parseAttrExpression(input, builder);\n      }\n      while (lhsParser.isCont() && !input.isEmpty()) {\n        lhsParser = lhsParser.feed(input);\n      }\n      if (lhsParser.isDone()) {\n        step = 2;\n      } else if (lhsParser.isError()) {\n        return lhsParser.asError();\n      }\n    }\n    if (step === 2) {\n      while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 33/*'!'*/) {\n          input = input.step();\n          step = 3;\n        } else if (c === 60/*'<'*/) {\n          input = input.step();\n          step = 4;\n        } else if (c === 62/*'>'*/) {\n          input = input.step();\n          step = 5;\n        } else if (c === 61/*'='*/) {\n          input = input.step();\n          step = 6;\n        } else {\n          return lhsParser!;\n        }\n      } else if (input.isDone()) {\n        return lhsParser!;\n      }\n    }\n    if (step === 3) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 61/*'='*/) {\n          input = input.step();\n          operator = \"!=\";\n          step = 7;\n        } else {\n          operator = \"!\";\n          step = 7;\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 4) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 61/*'='*/) {\n          input = input.step();\n          operator = \"<=\";\n          step = 7;\n        } else {\n          operator = \"<\";\n          step = 7;\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 5) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 61/*'='*/) {\n          input = input.step();\n          operator = \">=\";\n          step = 7;\n        } else {\n          operator = \">\";\n          step = 7;\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 6) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 61/*'='*/) {\n          input = input.step();\n          operator = \"==\";\n          step = 7;\n        } else if (c === 62/*'>'*/) {\n          return lhsParser!;\n        } else {\n          operator = \"=\";\n          step = 7;\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 7) {\n      if (rhsParser === void 0) {\n        rhsParser = recon.parseAttrExpression(input, builder);\n      }\n      while (rhsParser.isCont() && !input.isEmpty()) {\n        rhsParser = rhsParser.feed(input);\n      }\n      if (rhsParser.isDone()) {\n        const lhs = lhsParser!.bind();\n        const rhs = rhsParser.bind();\n        if (operator === \"<\") {\n          return Parser.done(recon.lt(lhs, rhs));\n        } else if (operator === \"<=\") {\n          return Parser.done(recon.le(lhs, rhs));\n        } else if (operator === \"==\") {\n          return Parser.done(recon.eq(lhs, rhs));\n        } else if (operator === \"!=\") {\n          return Parser.done(recon.ne(lhs, rhs));\n        } else if (operator === \">=\") {\n          return Parser.done(recon.ge(lhs, rhs));\n        } else if (operator === \">\") {\n          return Parser.done(recon.gt(lhs, rhs));\n        } else {\n          return Parser.error(Diagnostic.message(operator!, input));\n        }\n      } else if (rhsParser.isError()) {\n        return rhsParser.asError();\n      }\n    }\n    return new ComparisonOperatorParser<I, V>(recon, builder, lhsParser, operator, rhsParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class AttrExpressionParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly fieldParser: Parser<I> | undefined;\n  private readonly valueParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              fieldParser?: Parser<I>, valueParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.fieldParser = fieldParser;\n    this.valueParser = valueParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return AttrExpressionParser.parse(input, this.recon, this.builder,\n                                      this.fieldParser, this.valueParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     fieldParser?: Parser<I>, valueParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 64/*'@'*/) {\n            step = 2;\n          } else if (c === 123/*'{'*/ || c === 91/*'['*/) {\n            builder = builder || recon.recordBuilder();\n            step = 5;\n          } else if (c === 40/*'('*/) {\n            step = 4;\n          } else if (c === 33/*'!'*/ || c === 34/*'\"'*/ || c === 36/*'$'*/ || c === 37/*'%'*/\n                  || c === 39/*'\\''*/ || c === 43/*'+'*/ || c === 45/*'-'*/\n                  || c >= 48/*'0'*/ && c <= 57/*'9'*/ || c === 96/*'`'*/ || c === 126/*'~'*/\n                  || Recon.isIdentStartChar(c)) {\n            step = 3;\n          } else if (builder === void 0) {\n            return Parser.done(recon.extant());\n          } else {\n            return Parser.done(builder.build());\n          }\n        } else if (input.isDone()) {\n          if (builder === void 0) {\n            return Parser.done(recon.extant());\n          } else {\n            return Parser.done(builder.build());\n          }\n        }\n      }\n      if (step === 2) {\n        if (fieldParser === void 0) {\n          fieldParser = recon.parseAttr(input);\n        }\n        while (fieldParser.isCont() && !input.isEmpty()) {\n          fieldParser = fieldParser.feed(input);\n        }\n        if (fieldParser.isDone()) {\n          builder = builder || recon.recordBuilder();\n          builder.push(fieldParser.bind());\n          fieldParser = void 0;\n          step = 1;\n          continue;\n        } else if (fieldParser.isError()) {\n          return fieldParser.asError();\n        }\n      }\n      if (step === 3) {\n        if (valueParser === void 0) {\n          valueParser = recon.parseAdditiveOperator(input);\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          builder = builder || recon.valueBuilder();\n          builder.push(recon.item(valueParser.bind()));\n          valueParser = void 0;\n          step = 6;\n        } else if (valueParser.isError()) {\n          return valueParser.asError();\n        }\n      }\n      if (step === 4) {\n        if (valueParser === void 0) {\n          valueParser = recon.parseAdditiveOperator(input, builder);\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          if (builder === void 0) {\n            builder = recon.valueBuilder();\n            builder.push(recon.item(valueParser.bind()));\n          }\n          valueParser = void 0;\n          step = 6;\n        } else if (valueParser.isError()) {\n          return valueParser.asError();\n        }\n      }\n      if (step === 5) {\n        if (valueParser === void 0) {\n          valueParser = recon.parseAdditiveOperator(input, builder);\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          valueParser = void 0;\n          step = 6;\n        } else if (valueParser.isError()) {\n          return valueParser.asError();\n        }\n      }\n      if (step === 6) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 64/*'@'*/) {\n            step = 1;\n            continue;\n          } else {\n            return Parser.done(builder!.build());\n          }\n        } else if (input.isDone()) {\n          return Parser.done(builder!.build());\n        }\n      }\n      break;\n    } while (true);\n    return new AttrExpressionParser<I, V>(recon, builder, fieldParser, valueParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class AdditiveOperatorParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly lhsParser: Parser<V> | undefined;\n  private readonly operator: string | undefined;\n  private readonly rhsParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, lhsParser?: Parser<V>,\n              operator?: string, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.lhsParser = lhsParser;\n    this.operator = operator;\n    this.rhsParser = rhsParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return AdditiveOperatorParser.parse(input, this.recon, this.builder, this.lhsParser,\n                                        this.operator, this.rhsParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>, lhsParser?: Parser<V>,\n                     operator?: string, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (lhsParser === void 0) {\n          lhsParser = recon.parseMultiplicativeOperator(input, builder);\n        }\n        while (lhsParser.isCont() && !input.isEmpty()) {\n          lhsParser = lhsParser.feed(input);\n        }\n        if (lhsParser.isDone()) {\n          step = 2;\n        } else if (lhsParser.isError()) {\n          return lhsParser.asError();\n        }\n      }\n      if (step === 2) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 43/*'+'*/) {\n            input = input.step();\n            operator = \"+\";\n            step = 3;\n          } else if (c === 45/*'-'*/) {\n            input = input.step();\n            operator = \"-\";\n            step = 3;\n          } else {\n            return lhsParser!;\n          }\n        } else if (input.isDone()) {\n          return lhsParser!;\n        }\n      }\n      if (step === 3) {\n        if (rhsParser === void 0) {\n          rhsParser = recon.parseMultiplicativeOperator(input, builder);\n        }\n        while (rhsParser.isCont() && !input.isEmpty()) {\n          rhsParser = rhsParser.feed(input);\n        }\n        if (rhsParser.isDone()) {\n          const lhs = lhsParser!.bind();\n          const rhs = rhsParser.bind();\n          if (operator === \"+\") {\n            lhsParser = Parser.done(recon.plus(lhs, rhs));\n          } else if (operator === \"-\") {\n            lhsParser = Parser.done(recon.minus(lhs, rhs));\n          } else {\n            return Parser.error(Diagnostic.message(operator!, input));\n          }\n          rhsParser = void 0;\n          operator = void 0;\n          step = 2;\n          continue;\n        } else if (rhsParser.isError()) {\n          return rhsParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new AdditiveOperatorParser<I, V>(recon, builder, lhsParser, operator, rhsParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class MultiplicativeOperatorParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly lhsParser: Parser<V> | undefined;\n  private readonly operator: string | undefined;\n  private readonly rhsParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, lhsParser?: Parser<V>,\n              operator?: string, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.lhsParser = lhsParser;\n    this.operator = operator;\n    this.rhsParser = rhsParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return MultiplicativeOperatorParser.parse(input, this.recon, this.builder, this.lhsParser,\n                                              this.operator, this.rhsParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>, lhsParser?: Parser<V>,\n                     operator?: string, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (lhsParser === void 0) {\n          lhsParser = recon.parsePrefixOperator(input, builder);\n        }\n        while (lhsParser.isCont() && !input.isEmpty()) {\n          lhsParser = lhsParser.feed(input);\n        }\n        if (lhsParser.isDone()) {\n          step = 2;\n        } else if (lhsParser.isError()) {\n          return lhsParser.asError();\n        }\n      }\n      if (step === 2) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 42/*'*'*/) {\n            input = input.step();\n            operator = \"*\";\n            step = 3;\n          } else if (c === 47/*'/'*/) {\n            input = input.step();\n            operator = \"/\";\n            step = 3;\n          } else if (c === 37/*'%'*/) {\n            input = input.step();\n            operator = \"%\";\n            step = 3;\n          } else {\n            return lhsParser!;\n          }\n        } else if (input.isDone()) {\n          return lhsParser!;\n        }\n      }\n      if (step === 3) {\n        if (rhsParser === void 0) {\n          rhsParser = recon.parsePrefixOperator(input, builder);\n        }\n        while (rhsParser.isCont() && !input.isEmpty()) {\n          rhsParser = rhsParser.feed(input);\n        }\n        if (rhsParser.isDone()) {\n          const lhs = lhsParser!.bind();\n          const rhs = rhsParser.bind();\n          if (operator === \"*\") {\n            lhsParser = Parser.done(recon.times(lhs, rhs));\n          } else if (operator === \"/\") {\n            lhsParser = Parser.done(recon.divide(lhs, rhs));\n          } else if (operator === \"%\") {\n            lhsParser = Parser.done(recon.modulo(lhs, rhs));\n          } else {\n            return Parser.error(Diagnostic.message(operator!, input));\n          }\n          rhsParser = void 0;\n          operator = void 0;\n          step = 2;\n          continue;\n        } else if (rhsParser.isError()) {\n          return rhsParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new MultiplicativeOperatorParser<I, V>(recon, builder, lhsParser, operator, rhsParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class PrefixOperatorParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly operator: string | undefined;\n  private readonly operandParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              operator?: string, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.operator = operator;\n    this.operandParser = rhsParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return PrefixOperatorParser.parse(input, this.recon, this.builder,\n                                      this.operator, this.operandParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     operator?: string, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 33/*'!'*/) {\n          input = input.step();\n          operator = \"!\";\n        } else if (c === 126/*'~'*/) {\n          input = input.step();\n          operator = \"~\";\n        } else if (c === 45/*'-'*/) {\n          input = input.step();\n          operator = \"-\";\n        } else if (c === 43/*'+'*/) {\n          input = input.step();\n          operator = \"+\";\n        } else {\n          return recon.parseInvokeOperator(input, builder);\n        }\n        step = 2;\n      } else if (input.isDone()) {\n        return recon.parseInvokeOperator(input, builder);\n      }\n    }\n    if (step === 2) {\n      if (rhsParser === void 0) {\n        rhsParser = recon.parsePrefixOperator(input, builder);\n      }\n      while (rhsParser.isCont() && !input.isEmpty()) {\n        rhsParser = rhsParser.feed(input);\n      }\n      if (rhsParser.isDone()) {\n        const operand = rhsParser.bind();\n        if (!recon.isDistinct(operand)) {\n          return Parser.error(Diagnostic.expected(\"value\", input));\n        } else if (operator === \"!\") {\n          return Parser.done(recon.not(operand));\n        } else if (operator === \"~\") {\n          return Parser.done(recon.bitwiseNot(operand));\n        } else if (operator === \"-\") {\n          return Parser.done(recon.negative(operand));\n        } else if (operator === \"+\") {\n          return Parser.done(recon.positive(operand));\n        } else {\n          return Parser.error(Diagnostic.message(operator!, input));\n        }\n      } else if (rhsParser.isError()) {\n        return rhsParser.asError();\n      }\n    }\n    return new PrefixOperatorParser<I, V>(recon, builder, operator, rhsParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Builder} from \"@swim/util\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class InvokeOperatorParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly exprParser: Parser<V> | undefined;\n  private readonly argsParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              exprParser?: Parser<V>, argsParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.exprParser = exprParser;\n    this.argsParser = argsParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return InvokeOperatorParser.parse(input, this.recon, this.builder,\n                                      this.exprParser, this.argsParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     exprParser?: Parser<V>, argsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (exprParser === void 0) {\n        exprParser = recon.parsePrimary(input, builder);\n      }\n      while (exprParser.isCont() && !input.isEmpty()) {\n        exprParser = exprParser.feed(input);\n      }\n      if (exprParser.isDone()) {\n        step = 2;\n      } else if (exprParser.isError()) {\n        return exprParser.asError();\n      }\n    }\n    do {\n      if (step === 2) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 40/*'('*/) {\n            input = input.step();\n            step = 3;\n          } else {\n            return exprParser!;\n          }\n        } else if (input.isDone()) {\n          return exprParser!;\n        }\n      }\n      if (step === 3) {\n        while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 41/*')'*/) {\n            input = input.step();\n            const expr = exprParser!.bind();\n            exprParser = Parser.done(recon.invoke(expr, recon.extant()));\n            step = 2;\n            continue;\n          } else {\n            step = 4;\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(41/*')'*/, input));\n        }\n      }\n      if (step === 4) {\n        if (argsParser === void 0) {\n          argsParser = recon.parseBlock(input);\n        }\n        while (argsParser.isCont() && !input.isEmpty()) {\n          argsParser = argsParser.feed(input);\n        }\n        if (argsParser.isDone()) {\n          step = 5;\n        } else if (argsParser.isError()) {\n          return argsParser.asError();\n        }\n      }\n      if (step === 5) {\n        while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n        if (c === 41/*')'*/) {\n            input = input.step();\n            const expr = exprParser!.bind();\n            const args = argsParser!.bind();\n            exprParser = Parser.done(recon.invoke(expr, args));\n            argsParser = void 0;\n            step = 2;\n            continue;\n          } else {\n            return Parser.error(Diagnostic.expected(41/*')'*/, input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(41/*')'*/, input));\n        }\n      }\n      break;\n    } while (true);\n    return new InvokeOperatorParser<I, V>(recon, builder, exprParser, argsParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class PrimaryParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly exprParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              exprParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.exprParser = exprParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return PrimaryParser.parse(input, this.recon, this.builder,\n                               this.exprParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     exprParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 40/*'('*/) {\n          input = input.step();\n          step = 3;\n        } else {\n          step = 2;\n        }\n      } else if (input.isDone()) {\n        step = 2;\n      }\n    }\n    if (step === 2) {\n      if (exprParser === void 0) {\n        exprParser = recon.parseLiteral(input, builder);\n      }\n      while (exprParser.isCont() && !input.isEmpty()) {\n        exprParser = exprParser.feed(input);\n      }\n      if (exprParser.isDone()) {\n        return exprParser;\n      } else if (exprParser.isError()) {\n        return exprParser.asError();\n      }\n    }\n    if (step === 3) {\n      if (exprParser === void 0) {\n        exprParser = recon.parseBlockExpression(input, builder);\n      }\n      while (exprParser.isCont() && !input.isEmpty()) {\n        exprParser = exprParser.feed(input);\n      }\n      if (exprParser.isDone()) {\n        step = 4;\n      } else if (exprParser.isError()) {\n        return exprParser.asError();\n      }\n    }\n    do {\n      if (step === 4) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 44/*','*/) {\n            input = input.step();\n            if (exprParser !== void 0) {\n              if (builder === void 0) {\n                builder = recon.recordBuilder();\n                builder.push(recon.item(exprParser.bind()));\n              }\n              exprParser = void 0;\n            }\n            step = 5;\n          } else if (c === 41/*')'*/) {\n            input = input.step();\n            if (exprParser !== void 0) {\n              return exprParser;\n            } else {\n              return Parser.done(builder!.build());\n            }\n          } else {\n            return Parser.error(Diagnostic.expected(41/*')'*/, input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(41/*')'*/, input));\n        }\n      }\n      if (step === 5) {\n        if (exprParser === void 0) {\n          exprParser = recon.parseBlockExpression(input, builder);\n        }\n        while (exprParser.isCont() && !input.isEmpty()) {\n          exprParser = exprParser.feed(input);\n        }\n        if (exprParser.isDone()) {\n          exprParser = void 0;\n          step = 4;\n          continue;\n        } else if (exprParser.isError()) {\n          return exprParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new PrimaryParser<I, V>(recon, builder, exprParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Builder} from \"@swim/util\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class LiteralParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly valueParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              valueParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.valueParser = valueParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return LiteralParser.parse(input, this.recon, this.builder, this.valueParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     valueParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 40/*'('*/) {\n          input = input.step();\n          step = 4;\n        } else if (c === 123/*'{'*/) {\n          builder = builder || recon.recordBuilder();\n          valueParser = recon.parseRecord(input, builder);\n          step = 3;\n        } else if (c === 91/*'['*/) {\n          builder = builder || recon.recordBuilder();\n          valueParser = recon.parseMarkup(input, builder);\n          step = 3;\n        } else if (Recon.isIdentStartChar(c)) {\n          valueParser = recon.parseIdent(input);\n          step = 2;\n        } else if (c === 34/*'\"'*/ || c === 39/*'\\''*/) {\n          valueParser = recon.parseString(input);\n          step = 2;\n        } else if (c === 96/*'`'*/) {\n          valueParser = recon.parseRawString(input);\n          step = 2;\n        } else if (c === 45/*'-'*/ || c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          valueParser = recon.parseNumber(input);\n          step = 2;\n        } else if (c === 37/*'%'*/) {\n          valueParser = recon.parseData(input);\n          step = 2;\n        } else if (c === 36/*'$'*/) {\n          valueParser = recon.parseSelector(input);\n          step = 2;\n        } else if (builder === void 0) {\n          return Parser.done(recon.extant());\n        } else {\n          return Parser.done(builder.build());\n        }\n      } else if (input.isDone()) {\n        if (builder === void 0) {\n          return Parser.done(recon.extant());\n        } else {\n          return Parser.done(builder.build());\n        }\n      }\n    }\n    if (step === 2) {\n      while (valueParser!.isCont() && !input.isEmpty()) {\n        valueParser = valueParser!.feed(input);\n      }\n      if (valueParser!.isDone()) {\n        builder = builder || recon.valueBuilder();\n        builder.push(recon.item(valueParser!.bind()));\n        return Parser.done(builder.build());\n      } else if (valueParser!.isError()) {\n        return valueParser!.asError();\n      }\n    }\n    if (step === 3) {\n      while (valueParser!.isCont() && !input.isEmpty()) {\n        valueParser = valueParser!.feed(input);\n      }\n      if (valueParser!.isDone()) {\n        return Parser.done(builder!.build());\n      } else if (valueParser!.isError()) {\n        return valueParser!.asError();\n      }\n    }\n    if (step === 4) {\n      if (valueParser === void 0) {\n        valueParser = recon.parseBlockExpression(input);\n      }\n      while (valueParser.isCont() && !input.isEmpty()) {\n        valueParser = valueParser.feed(input);\n      }\n      if (valueParser.isDone()) {\n        step = 5;\n      } else if (valueParser.isError()) {\n        return valueParser.asError();\n      }\n    }\n    if (step === 5) {\n      while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 41/*')'*/) {\n          input = input.step();\n          builder = builder || recon.valueBuilder();\n          builder.push(recon.item(valueParser!.bind()));\n          return Parser.done(builder.build());\n        } else {\n          return Parser.error(Diagnostic.expected(41/*')'*/, input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(41/*')'*/, input));\n      }\n    }\n    return new LiteralParser<I, V>(recon, builder, valueParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport type {ReconParser} from \"./ReconParser\";\n\n/** @internal */\nexport class SelectorParser<I, V> extends Parser<V> {\n  private readonly recon: ReconParser<I, V>;\n  private readonly builder: Builder<I, V> | undefined;\n  private readonly selector: V | undefined;\n  private readonly valueParser: Parser<V> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              selector?: V, valueParser?: Parser<V>, step?: number) {\n    super();\n    this.recon = recon;\n    this.builder = builder;\n    this.selector = selector;\n    this.valueParser = valueParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<V> {\n    return SelectorParser.parse(input, this.recon, this.builder,\n                                this.selector, this.valueParser, this.step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     selector?: V, valueParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont() && c === 36/*'$'*/) {\n        input = input.step();\n        selector = selector || recon.selector();\n        step = 2;\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(36/*'$'*/, input));\n      }\n    }\n    if (step === 2) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 91/*'['*/) {\n          input = input.step();\n          step = 8;\n        } else if (c === 64/*'@'*/) {\n          input = input.step();\n          step = 7;\n        } else if (c === 58/*':'*/) {\n          input = input.step();\n          step = 6;\n        } else if (c === 42/*'*'*/) {\n          input = input.step();\n          step = 5;\n        } else if (c === 35/*'#'*/) {\n          input = input.step();\n          step = 4;\n        } else {\n          step = 3;\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    do {\n      if (step === 3) {\n        if (valueParser === void 0) {\n          valueParser = recon.parseLiteral(input, recon.valueBuilder());\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          selector = recon.get(selector!, valueParser.bind());\n          valueParser = void 0;\n          step = 10;\n        } else if (valueParser.isError()) {\n          return valueParser.asError();\n        }\n      }\n      if (step === 4) {\n        if (valueParser === void 0) {\n          valueParser = recon.parseInteger(input);\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          selector = recon.value(recon.getItem(selector!, valueParser.bind()));\n          valueParser = void 0;\n          step = 10;\n        } else if (valueParser.isError()) {\n          return valueParser.asError();\n        }\n      }\n      if (step === 5) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 58/*':'*/) {\n            input = input.step();\n            selector = recon.keys(selector!);\n            step = 10;\n          } else if (c === 42/*'*'*/) {\n            input = input.step();\n            selector = recon.descendants(selector!);\n            step = 10;\n          } else {\n            selector = recon.children(selector!);\n            step = 10;\n          }\n        } else if (input.isDone()) {\n          selector = recon.children(selector!);\n          step = 10;\n        }\n      }\n      if (step === 6) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 42/*'*'*/) {\n            input = input.step();\n            selector = recon.values(selector!);\n            step = 10;\n          } else {\n            return Parser.error(Diagnostic.expected(42/*'*'*/, input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(42/*'*'*/, input));\n        }\n      }\n      if (step === 7) {\n        if (valueParser === void 0) {\n          valueParser = recon.parseIdent(input);\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          selector = recon.getAttr(selector!, valueParser.bind());\n          valueParser = void 0;\n          step = 10;\n        } else if (valueParser.isError()) {\n          return valueParser.asError();\n        }\n      }\n      if (step === 8) {\n        if (valueParser === void 0) {\n          valueParser = recon.parseBlockExpression(input);\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          step = 9;\n        } else if (valueParser.isError()) {\n          return valueParser.asError();\n        }\n      }\n      if (step === 9) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 93/*']'*/) {\n            input = input.step();\n            selector = recon.filter(selector!, valueParser!.bind());\n            valueParser = void 0;\n            step = 10;\n          } else {\n            return Parser.error(Diagnostic.expected(93/*']'*/, input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(93/*']'*/, input));\n        }\n      }\n      if (step === 10) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 91/*'['*/) {\n            input = input.step();\n            step = 8;\n            continue;\n          } else if (c === 35/*'#'*/) {\n            input = input.step();\n            step = 4;\n            continue;\n          } else if (c === 46/*'.'*/) {\n            input = input.step();\n            step = 11;\n          } else if (builder !== void 0) {\n            builder.push(recon.item(selector!));\n            return Parser.done(builder.build());\n          } else {\n            return Parser.done(selector!);\n          }\n        } else if (input.isDone()) {\n          if (builder !== void 0) {\n            builder.push(recon.item(selector!));\n            return Parser.done(builder.build());\n          } else {\n            return Parser.done(selector!);\n          }\n        }\n      }\n      if (step === 11) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 64/*'@'*/) {\n            input = input.step();\n            step = 7;\n            continue;\n          } else if (c === 58/*':'*/) {\n            input = input.step();\n            step = 6;\n            continue;\n          } else if (c === 42/*'*'*/) {\n            input = input.step();\n            step = 5;\n            continue;\n          } else {\n            step = 3;\n            continue;\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.unexpected(input));\n        }\n      }\n      break;\n    } while (true);\n    return new SelectorParser<I, V>(recon, builder, selector, valueParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport {BlockParser} from \"./BlockParser\";\nimport {AttrParser} from \"./AttrParser\";\nimport {BlockItemParser} from \"./BlockItemParser\";\nimport {InlineItemParser} from \"./InlineItemParser\";\nimport {RecordParser} from \"./RecordParser\";\nimport {MarkupParser} from \"./MarkupParser\";\nimport {DataParser} from \"./DataParser\";\nimport {IdentParser} from \"./IdentParser\";\nimport {StringParser} from \"./StringParser\";\nimport {RawStringParser} from \"./RawStringParser\";\nimport {NumberParser} from \"./NumberParser\";\nimport {LambdaFuncParser} from \"./LambdaFuncParser\";\nimport {ConditionalOperatorParser} from \"./ConditionalOperatorParser\";\nimport {OrOperatorParser} from \"./OrOperatorParser\";\nimport {AndOperatorParser} from \"./AndOperatorParser\";\nimport {BitwiseOrOperatorParser} from \"./BitwiseOrOperatorParser\";\nimport {BitwiseXorOperatorParser} from \"./BitwiseXorOperatorParser\";\nimport {BitwiseAndOperatorParser} from \"./BitwiseAndOperatorParser\";\nimport {ComparisonOperatorParser} from \"./ComparisonOperatorParser\";\nimport {AttrExpressionParser} from \"./AttrExpressionParser\";\nimport {AdditiveOperatorParser} from \"./AdditiveOperatorParser\";\nimport {MultiplicativeOperatorParser} from \"./MultiplicativeOperatorParser\";\nimport {PrefixOperatorParser} from \"./PrefixOperatorParser\";\nimport {InvokeOperatorParser} from \"./InvokeOperatorParser\";\nimport {PrimaryParser} from \"./PrimaryParser\";\nimport {LiteralParser} from \"./LiteralParser\";\nimport {SelectorParser} from \"./SelectorParser\";\n\n/**\n * Factory for constructing Recon parsers and parse trees.\n * @public\n */\nexport abstract class ReconParser<I, V> {\n  abstract isDistinct(value: V): boolean;\n\n  abstract item(value: V): I;\n\n  abstract value(item: I): V;\n\n  abstract attr(key: V, value: V): I;\n\n  abstract attr(key: V): I;\n\n  abstract slot(key: V, value: V): I;\n\n  abstract slot(key: V): I;\n\n  abstract valueBuilder(): Builder<I, V>;\n\n  abstract recordBuilder(): Builder<I, V>;\n\n  abstract dataOutput(): Output<V>;\n\n  abstract textOutput(): Output<V>;\n\n  abstract ident(value: V): V;\n\n  abstract num(value: number | string): V;\n\n  abstract uint32(value: number): V;\n\n  abstract uint64(value: number): V;\n\n  abstract bool(value: boolean): V;\n\n  abstract selector(): V;\n\n  abstract extant(): V;\n\n  abstract absent(): V;\n\n  abstract conditional(ifTerm: V, thenTerm: V, elseTerm: V): V;\n\n  abstract or(lhs: V, rhs: V): V;\n\n  abstract and(lhs: V, rhs: V): V;\n\n  abstract bitwiseOr(lhs: V, rhs: V): V;\n\n  abstract bitwiseXor(lhs: V, rhs: V): V;\n\n  abstract bitwiseAnd(lhs: V, rhs: V): V;\n\n  abstract lt(lhs: V, rhs: V): V;\n\n  abstract le(lhs: V, rhs: V): V;\n\n  abstract eq(lhs: V, rhs: V): V;\n\n  abstract ne(lhs: V, rhs: V): V;\n\n  abstract ge(lhs: V, rhs: V): V;\n\n  abstract gt(lhs: V, rhs: V): V;\n\n  abstract plus(lhs: V, rhs: V): V;\n\n  abstract minus(lhs: V, rhs: V): V;\n\n  abstract times(lhs: V, rhs: V): V;\n\n  abstract divide(lhs: V, rhs: V): V;\n\n  abstract modulo(lhs: V, rhs: V): V;\n\n  abstract not(rhs: V): V;\n\n  abstract bitwiseNot(rhs: V): V;\n\n  abstract negative(rhs: V): V;\n\n  abstract positive(rhs: V): V;\n\n  abstract invoke(func: V, args: V): V;\n\n  abstract lambda(bindings: V, template: V): V;\n\n  abstract get(selector: V, key: V): V;\n\n  abstract getAttr(selector: V, key: V): V;\n\n  abstract getItem(selector: V, index: V): I;\n\n  abstract children(selector: V): V;\n\n  abstract descendants(selector: V): V;\n\n  abstract keys(selector: V): V;\n\n  abstract values(selector: V): V;\n\n  abstract filter(selector: V, predicate: V): V;\n\n  parseBlock(input: Input): Parser<V> {\n    return BlockParser.parse(input, this);\n  }\n\n  parseAttr(input: Input): Parser<I> {\n    return AttrParser.parse(input, this);\n  }\n\n  parseBlockItem(input: Input): Parser<V> {\n    return BlockItemParser.parse(input, this);\n  }\n\n  parseInlineItem(input: Input): Parser<V> {\n    return InlineItemParser.parse(input, this);\n  }\n\n  parseRecord(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return RecordParser.parse(input, this, builder);\n  }\n\n  parseMarkup(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return MarkupParser.parse(input, this, builder);\n  }\n\n  parseData(input: Input): Parser<V> {\n    return DataParser.parse(input, this);\n  }\n\n  parseIdent(input: Input): Parser<V> {\n    return IdentParser.parse(input, this);\n  }\n\n  parseString(input: Input): Parser<V> {\n    return StringParser.parse(input, this);\n  }\n\n  parseRawString(input: Input): Parser<V> {\n    return RawStringParser.parse(input, this);\n  }\n\n  parseNumber(input: Input): Parser<V> {\n    return NumberParser.parse(input, this);\n  }\n\n  parseInteger(input: Input): Parser<V> {\n    return NumberParser.parseInteger(input, this);\n  }\n\n  parseBlockExpression(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return this.parseLambdaFunc(input, builder);\n  }\n\n  parseLambdaFunc(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return LambdaFuncParser.parse(input, this, builder);\n  }\n\n  parseConditionalOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return ConditionalOperatorParser.parse(input, this, builder);\n  }\n\n  parseOrOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return OrOperatorParser.parse(input, this, builder);\n  }\n\n  parseAndOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return AndOperatorParser.parse(input, this, builder);\n  }\n\n  parseBitwiseOrOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return BitwiseOrOperatorParser.parse(input, this, builder);\n  }\n\n  parseBitwiseXorOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return BitwiseXorOperatorParser.parse(input, this, builder);\n  }\n\n  parseBitwiseAndOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return BitwiseAndOperatorParser.parse(input, this, builder);\n  }\n\n  parseComparisonOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return ComparisonOperatorParser.parse(input, this, builder);\n  }\n\n  parseAttrExpression(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return AttrExpressionParser.parse(input, this, builder);\n  }\n\n  parseAdditiveOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return AdditiveOperatorParser.parse(input, this, builder);\n  }\n\n  parseMultiplicativeOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return MultiplicativeOperatorParser.parse(input, this, builder);\n  }\n\n  parsePrefixOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return PrefixOperatorParser.parse(input, this, builder);\n  }\n\n  parseInvokeOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return InvokeOperatorParser.parse(input, this, builder);\n  }\n\n  parsePrimary(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return PrimaryParser.parse(input, this, builder);\n  }\n\n  parseLiteral(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return LiteralParser.parse(input, this, builder);\n  }\n\n  parseSelector(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return SelectorParser.parse(input, this, builder);\n  }\n\n  blockParser(): Parser<V> {\n    return new BlockParser<I, V>(this);\n  }\n\n  parseBlockString(string: string): V {\n    let input = Unicode.stringInput(string);\n    while (input.isCont() && Recon.isWhitespace(input.head())) {\n      input = input.step();\n    }\n    let parser = this.parseBlock(input);\n    if (parser.isDone()) {\n      while (input.isCont() && Recon.isWhitespace(input.head())) {\n        input = input.step();\n      }\n    }\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Builder} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Item} from \"@swim/structure\";\nimport {Attr} from \"@swim/structure\";\nimport {Slot} from \"@swim/structure\";\nimport {Value} from \"@swim/structure\";\nimport {Record} from \"@swim/structure\";\nimport {Data} from \"@swim/structure\";\nimport {Text} from \"@swim/structure\";\nimport {Num} from \"@swim/structure\";\nimport {Bool} from \"@swim/structure\";\nimport {Selector} from \"@swim/structure\";\nimport {AndOperator} from \"@swim/structure\";\nimport {BitwiseAndOperator} from \"@swim/structure\";\nimport {BitwiseNotOperator} from \"@swim/structure\";\nimport {BitwiseOrOperator} from \"@swim/structure\";\nimport {BitwiseXorOperator} from \"@swim/structure\";\nimport {DivideOperator} from \"@swim/structure\";\nimport {EqOperator} from \"@swim/structure\";\nimport {GeOperator} from \"@swim/structure\";\nimport {GtOperator} from \"@swim/structure\";\nimport {InvokeOperator} from \"@swim/structure\";\nimport {LeOperator} from \"@swim/structure\";\nimport {LtOperator} from \"@swim/structure\";\nimport {MinusOperator} from \"@swim/structure\";\nimport {ModuloOperator} from \"@swim/structure\";\nimport {NeOperator} from \"@swim/structure\";\nimport {NegativeOperator} from \"@swim/structure\";\nimport {NotOperator} from \"@swim/structure\";\nimport {OrOperator} from \"@swim/structure\";\nimport {PlusOperator} from \"@swim/structure\";\nimport {PositiveOperator} from \"@swim/structure\";\nimport {TimesOperator} from \"@swim/structure\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @public */\nexport class ReconStructureParser extends ReconParser<Item, Value> {\n  override isDistinct(value: Value): boolean {\n    return value.isDistinct();\n  }\n\n  override item(value: Value): Item {\n    return value;\n  }\n\n  override value(item: Item): Value {\n    return item.toValue();\n  }\n\n  override attr(key: Value, value?: Value): Item {\n    if (arguments.length === 1) {\n      return Attr.of(key as Text);\n    } else {\n      return Attr.of(key as Text, value);\n    }\n  }\n\n  override slot(key: Value, value?: Value): Item {\n    if (arguments.length === 1) {\n      return Slot.of(key);\n    } else {\n      return Slot.of(key, value);\n    }\n  }\n\n  override valueBuilder(): Builder<Item, Value> {\n    return Value.builder();\n  }\n\n  override recordBuilder(): Builder<Item, Value> {\n    return Record.create();\n  }\n\n  override dataOutput(): Output<Value> {\n    return Data.output();\n  }\n\n  override textOutput(): Output<Value> {\n    return Text.output();\n  }\n\n  override ident(value: Value): Value {\n    if (value instanceof Text) {\n      const string = value.stringValue();\n      if (string === \"true\") {\n        return Bool.from(true);\n      } else if (string === \"false\") {\n        return Bool.from(false);\n      }\n    }\n    return value;\n  }\n\n  override num(value: number | string): Value {\n    if (typeof value === \"number\") {\n      return Num.from(value);\n    } else if (typeof value === \"string\") {\n      return Num.from(+value);\n    } else {\n      throw new TypeError(\"\" + value);\n    }\n  }\n\n  override uint32(value: number): Value {\n    return Num.uint32(value);\n  }\n\n  override uint64(value: number): Value {\n    return Num.uint64(value);\n  }\n\n  override bool(value: boolean): Value {\n    return Bool.from(value);\n  }\n\n  override selector(): Value {\n    return Selector.identity();\n  }\n\n  override extant(): Value {\n    return Value.extant();\n  }\n\n  override absent(): Value {\n    return Value.absent();\n  }\n\n  override conditional(ifTerm: Value, thenTerm: Value, elseTerm: Value): Value {\n    return ifTerm.conditional(thenTerm, elseTerm);\n  }\n\n  override or(lhs: Value, rhs: Value): Value {\n    return new OrOperator(lhs, rhs);\n  }\n\n  override and(lhs: Value, rhs: Value): Value {\n    return new AndOperator(lhs, rhs);\n  }\n\n  override bitwiseOr(lhs: Value, rhs: Value): Value {\n    return new BitwiseOrOperator(lhs, rhs);\n  }\n\n  override bitwiseXor(lhs: Value, rhs: Value): Value {\n    return new BitwiseXorOperator(lhs, rhs);\n  }\n\n  override bitwiseAnd(lhs: Value, rhs: Value): Value {\n    return new BitwiseAndOperator(lhs, rhs);\n  }\n\n  override lt(lhs: Value, rhs: Value): Value {\n    return new LtOperator(lhs, rhs);\n  }\n\n  override le(lhs: Value, rhs: Value): Value {\n    return new LeOperator(lhs, rhs);\n  }\n\n  override eq(lhs: Value, rhs: Value): Value {\n    return new EqOperator(lhs, rhs);\n  }\n\n  override ne(lhs: Value, rhs: Value): Value {\n    return new NeOperator(lhs, rhs);\n  }\n\n  override ge(lhs: Value, rhs: Value): Value {\n    return new GeOperator(lhs, rhs);\n  }\n\n  override gt(lhs: Value, rhs: Value): Value {\n    return new GtOperator(lhs, rhs);\n  }\n\n  override plus(lhs: Value, rhs: Value): Value {\n    return new PlusOperator(lhs, rhs);\n  }\n\n  override minus(lhs: Value, rhs: Value): Value {\n    return new MinusOperator(lhs, rhs);\n  }\n\n  override times(lhs: Value, rhs: Value): Value {\n    return new TimesOperator(lhs, rhs);\n  }\n\n  override divide(lhs: Value, rhs: Value): Value {\n    return new DivideOperator(lhs, rhs);\n  }\n\n  override modulo(lhs: Value, rhs: Value): Value {\n    return new ModuloOperator(lhs, rhs);\n  }\n\n  override not(rhs: Value): Value {\n    return new NotOperator(rhs);\n  }\n\n  override bitwiseNot(rhs: Value): Value {\n    return new BitwiseNotOperator(rhs);\n  }\n\n  override negative(rhs: Value): Value {\n    if (rhs instanceof Num) {\n      return rhs.negative();\n    } else {\n      return new NegativeOperator(rhs);\n    }\n  }\n\n  override positive(rhs: Value): Value {\n    return new PositiveOperator(rhs);\n  }\n\n  override invoke(func: Value, args: Value): Value {\n    return new InvokeOperator(func, args);\n  }\n\n  override lambda(bindings: Value, template: Value): Value {\n    return bindings.lambda(template);\n  }\n\n  override get(selector: Value, key: Value): Value {\n    return selector.get(key);\n  }\n\n  override getAttr(selector: Value, key: Value): Value {\n    return selector.getAttr(key as Text);\n  }\n\n  override getItem(selector: Value, index: Value): Item {\n    return selector.getItem(index as Num);\n  }\n\n  override children(selector: Value): Value {\n    return Selector.literal(selector).children();\n  }\n\n  override descendants(selector: Value): Value {\n    return Selector.literal(selector).descendants();\n  }\n\n  override keys(selector: Value): Value {\n    return Selector.literal(selector).keys();\n  }\n\n  override values(selector: Value): Value {\n    return Selector.literal(selector).values();\n  }\n\n  override filter(selector: Value, predicate: Value): Value {\n    return selector.filter(predicate);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class AttrWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly key: V;\n  private readonly value: V;\n  private readonly part: Writer | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, key: V, value: V, part?: Writer, step?: number) {\n    super();\n    this.recon = recon;\n    this.key = key;\n    this.value = value;\n    this.part = part;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return AttrWriter.write(output, this.recon, this.key, this.value, this.part, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, key: V, value: V): number {\n    let size = 0;\n    size += 1; // '@'\n    size += recon.sizeOfValue(key);\n    if (!recon.isExtant(recon.item(value))) {\n      size += 1; // '(';\n      size += recon.sizeOfBlockValue(value);\n      size += 1; // ')';\n    }\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, key: V, value: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(64/*'@'*/);\n      step = 2;\n    }\n    if (step === 2) {\n      if (part === void 0) {\n        part = recon.writeValue(output, key);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        if (recon.isExtant(recon.item(value))) {\n          return Writer.end();\n        } else {\n          step = 3;\n        }\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 3 && output.isCont()) {\n      output = output.write(40/*'('*/);\n      step = 4;\n    }\n    if (step === 4) {\n      if (part === void 0) {\n        part = recon.writeBlockValue(output, value);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 5;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 5 && output.isCont()) {\n      output = output.write(41/*')'*/);\n      return Writer.end();\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new AttrWriter<I, V>(recon, key, value, part, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class SlotWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly key: V;\n  private readonly value: V;\n  private readonly part: Writer | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, key: V, value: V, part?: Writer, step?: number) {\n    super();\n    this.recon = recon;\n    this.key = key;\n    this.value = value;\n    this.part = part;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return SlotWriter.write(output, this.recon, this.key, this.value, this.part, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, key: V, value: V): number {\n    let size = 0;\n    size += recon.sizeOfValue(key);\n    size += 1; // ':'\n    if (!recon.isExtant(recon.item(value))) {\n      size += recon.sizeOfValue(value);\n    }\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, key: V, value: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1) {\n      if (part === void 0) {\n        part = recon.writeValue(output, key);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 2;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 2 && output.isCont()) {\n      output = output.write(58/*':'*/);\n      if (recon.isExtant(recon.item(value))) {\n        return Writer.end();\n      } else {\n        step = 3;\n      }\n    }\n    if (step === 3) {\n      if (part === void 0) {\n        part = recon.writeValue(output, value);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        return Writer.end();\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new SlotWriter<I, V>(recon, key, value, part, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Cursor} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class BlockWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly items: Cursor<I>;\n  private readonly inBlock: boolean;\n  private readonly inMarkup: boolean;\n  private readonly inBraces: boolean | undefined;\n  private readonly inBrackets: boolean | undefined;\n  private readonly first: boolean | undefined;\n  private readonly markupSafe: boolean | undefined;\n  private readonly item: I | undefined;\n  private readonly next: I | undefined;\n  private readonly part: Writer | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, items: Cursor<I>, inBlock: boolean, inMarkup: boolean,\n              inBraces?: boolean, inBrackets?: boolean, first?: boolean, markupSafe?: boolean,\n              item?: I, next?: I, part?: Writer, step?: number) {\n    super();\n    this.recon = recon;\n    this.items = items;\n    this.inBlock = inBlock;\n    this.inMarkup = inMarkup;\n    this.inBraces = inBraces;\n    this.inBrackets = inBrackets;\n    this.first = first;\n    this.markupSafe = markupSafe;\n    this.item = item;\n    this.next = next;\n    this.part = part;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return BlockWriter.write(output, this.recon, this.items, this.inBlock, this.inMarkup,\n                             this.inBraces, this.inBrackets, this.first, this.markupSafe,\n                             this.item, this.next, this.part, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, items: Cursor<I>,\n                      inBlock: boolean, inMarkup: boolean): number {\n    let size = 0;\n    let inBraces = false;\n    let inBrackets = false;\n    let first = true;\n    let markupSafe = true;\n    let next: I | undefined;\n    while (next !== void 0 || items.hasNext()) {\n      let item: I | undefined;\n      if (next === void 0) {\n        item = items.next().value as I;\n      } else {\n        item = next;\n        next = void 0;\n      }\n      if (items.hasNext()) {\n        next = items.next().value as I;\n      }\n      if (recon.isExpression(item)) {\n        markupSafe = false;\n      }\n      if (inBrackets && recon.isAttr(item)) {\n        if (inBraces) {\n          size += 1; // '}'\n          inBraces = false;\n        }\n        size += 1; // ']'\n        inBrackets = false;\n      }\n      if (recon.isAttr(item)) {\n        if (inBraces) {\n          size += 1; // '}'\n          inBraces = false;\n        } else if (inBrackets) { // Case already covered?\n          size += 1; // ']'\n          inBrackets = false;\n        }\n        size += recon.sizeOfItem(item);\n        first = false;\n      } else if (inBrackets && recon.isText(item)) {\n        if (inBraces) {\n          size += 1; // '}'\n          inBraces = false;\n        }\n        size += recon.sizeOfMarkupText(item);\n      } else if (inBraces) {\n        if (!first) {\n          size += 1; // ','\n        } else {\n          first = false;\n        }\n        size += BlockWriter.sizeOfBlockItem(recon, item);\n      } else if (inBrackets) {\n        if (recon.isRecord(item) && recon.isMarkupSafe(recon.items(item))) {\n          size += recon.sizeOfBlock(recon.items(item), false, true);\n          if (next !== void 0 && recon.isText(next)) {\n            size += recon.sizeOfMarkupText(next);\n            next = void 0;\n          } else if (next !== void 0 && !recon.isAttr(next)) {\n            size += 1; // '{'\n            inBraces = true;\n            first = true;\n          } else {\n            size += 1; // ']'\n            inBrackets = false;\n          }\n        } else {\n          size += 1; // '{'\n          size += recon.sizeOfItem(item);\n          inBraces = true;\n          first = false;\n        }\n      } else if (markupSafe && recon.isText(item) && next !== void 0 && !recon.isField(next)\n              && !recon.isText(next) && !recon.isBool(next)) {\n        size += 1; // '['\n        size += recon.sizeOfMarkupText(item);\n        inBrackets = true;\n      } else if (inBlock && !inBraces) {\n        if (!first) {\n          size += 1; // ','\n        } else {\n          first = false;\n        }\n        size += BlockWriter.sizeOfBlockItem(recon, item);\n      } else if (inMarkup && recon.isText(item) && next === void 0) {\n        size += 1; // '['\n        size += recon.sizeOfMarkupText(item);\n        size += 1; // ']'\n      } else if (!inMarkup && recon.isValue(item) && !recon.isRecord(item)\n             && (!first && next === void 0 || next !== void 0 && recon.isAttr(next))) {\n        if (!first && (recon.isText(item) && recon.isIdent(item)\n                    || recon.isNum(item) || recon.isBool(item))) {\n          size += 1; // ' '\n        }\n        size += recon.sizeOfItem(item);\n      } else {\n        size += 1; // '{'\n        size += recon.sizeOfItem(item);\n        inBraces = true;\n        first = false;\n      }\n    }\n    if (inBraces) {\n      size += 1; // '}'\n    }\n    if (inBrackets) {\n      size += 1; // ']'\n    }\n    return size;\n  }\n\n  static sizeOfBlockItem<I, V>(recon: ReconWriter<I, V>, item: I): number {\n    let size = 0;\n    if (recon.isField(item)) {\n      size += recon.sizeOfSlot(recon.key(item), recon.value(item));\n    } else {\n      size += recon.sizeOfItem(item);\n    }\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, items: Cursor<I>,\n                     inBlock: boolean, inMarkup: boolean, inBraces: boolean = false,\n                     inBrackets: boolean = false, first: boolean = true, markupSafe: boolean = true,\n                     item?: I, next?: I, part?: Writer, step: number = 1): Writer {\n    do {\n      if (step === 1) {\n        if (next === void 0 && !items.hasNext()) {\n          step = 10;\n          break;\n        } else {\n          if (next === void 0) {\n            item = items.next().value as I;\n          } else {\n            item = next;\n            next = void 0;\n          }\n          if (items.hasNext()) {\n            next = items.next().value as I;\n          }\n          if (recon.isExpression(item)) {\n            markupSafe = false;\n          }\n          step = 2;\n        }\n      }\n      if (step === 2 && output.isCont()) {\n        if (inBrackets && recon.isAttr(item!)) {\n          if (inBraces) {\n            output = output.write(125/*'}'*/);\n            inBraces = false;\n          }\n          step = 3;\n        } else {\n          step = 4;\n        }\n      }\n      if (step === 3 && output.isCont()) {\n        output = output.write(93/*']'*/);\n        inBrackets = false;\n        step = 4;\n      }\n      if (step === 4 && output.isCont()) {\n        if (recon.isAttr(item!)) {\n          if (inBraces) {\n            output = output.write(125/*'}'*/);\n            inBraces = false;\n          } else if (inBrackets) {\n            output = output.write(93/*']'*/);\n            inBrackets = false;\n          }\n          part = recon.writeItem(output, item!);\n          first = false;\n          step = 7;\n        } else if (inBrackets && recon.isText(item!)) {\n          if (inBraces) {\n            output = output.write(125/*'}'*/);\n            inBraces = false;\n          }\n          part = recon.writeMarkupText(output, item!);\n          step = 7;\n        } else if (inBraces) {\n          if (!first) {\n            output = output.write(44/*','*/);\n          } else {\n            first = false;\n          }\n          part = BlockWriter.writeBlockItem(output, recon, item!);\n          step = 7;\n        } else if (inBrackets) {\n          if (recon.isRecord(item!) && recon.isMarkupSafe(recon.items(item!))) {\n            part = recon.writeBlock(output, recon.items(item!), false, true);\n            step = 5;\n          } else {\n            output = output.write(123/*'{'*/);\n            part = recon.writeItem(output, item!);\n            inBraces = true;\n            first = false;\n            step = 7;\n          }\n        } else if (markupSafe && recon.isText(item!) && next !== void 0 && !recon.isField(next)\n                && !recon.isText(next) && !recon.isBool(next)) {\n          output = output.write(91/*'['*/);\n          part = recon.writeMarkupText(output, item!);\n          inBrackets = true;\n          step = 7;\n        } else if (inBlock && !inBraces) {\n          if (!first) {\n            output = output.write(44/*','*/);\n          } else {\n            first = false;\n          }\n          part = BlockWriter.writeBlockItem(output, recon, item!);\n          step = 7;\n        } else if (inMarkup && recon.isText(item!) && next === void 0) {\n          output = output.write(91/*'['*/);\n          part = recon.writeMarkupText(output, item!);\n          step = 8;\n        } else if (!inMarkup && recon.isValue(item!) && !recon.isRecord(item!)\n               && (!first && next === void 0 || next !== void 0 && recon.isAttr(next))) {\n          if (!first && (recon.isText(item!) && recon.isIdent(item!)\n                      || recon.isNum(item!) || recon.isBool(item!))) {\n            output = output.write(32/*' '*/);\n          }\n          part = recon.writeItem(output, item!);\n          step = 7;\n        } else {\n          output = output.write(123/*'{'*/);\n          part = recon.writeItem(output, item!);\n          inBraces = true;\n          first = false;\n          step = 7;\n        }\n      }\n      if (step === 5) {\n        part = part!.pull(output);\n        if (part.isDone()) {\n          part = void 0;\n          step = 6;\n        } else if (part.isError()) {\n          return part.asError();\n        }\n      }\n      if (step === 6 && output.isCont()) {\n        if (next !== void 0 && recon.isText(next)) {\n          part = recon.writeMarkupText(output, next);\n          next = void 0;\n          step = 7;\n        } else if (next !== void 0 && !recon.isAttr(next)) {\n          output = output.write(123/*'{'*/);\n          inBraces = true;\n          first = true;\n          step = 1;\n          continue;\n        } else {\n          output = output.write(93/*']'*/);\n          inBrackets = false;\n          step = 1;\n          continue;\n        }\n      }\n      if (step === 7) {\n        part = part!.pull(output);\n        if (part.isDone()) {\n          part = void 0;\n          step = 1;\n          continue;\n        } else if (part.isError()) {\n          return part.asError();\n        }\n      }\n      if (step === 8) {\n        part = part!.pull(output);\n        if (part.isDone()) {\n          part = void 0;\n          step = 9;\n        } else if (part.isError()) {\n          return part.asError();\n        }\n      }\n      if (step === 9 && output.isCont()) {\n        output = output.write(93/*']'*/);\n        step = 1;\n        continue;\n      }\n      break;\n    } while (true);\n    if (step === 10) {\n      if (inBraces) {\n        if (output.isCont()) {\n          output = output.write(125/*'}'*/);\n          step = 11;\n        }\n      } else {\n        step = 11;\n      }\n    }\n    if (step === 11) {\n      if (inBrackets) {\n        if (output.isCont()) {\n          output = output.write(93/*']'*/);\n          return Writer.end();\n        }\n      } else {\n        return Writer.end();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new BlockWriter<I, V>(recon, items, inBlock, inMarkup, inBraces, inBrackets,\n                                 first, markupSafe, item, next, part, step);\n  }\n\n  static writeBlockItem<I, V>(output: Output, recon: ReconWriter<I, V>, item: I): Writer {\n    if (recon.isField(item)) {\n      return recon.writeSlot(output, recon.key(item), recon.value(item));\n    } else {\n      return recon.writeItem(output, item);\n    }\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Cursor} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class PrimaryWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly items: Cursor<I>;\n  private readonly inParens: boolean | undefined;\n  private readonly first: boolean | undefined;\n  private readonly item: I | undefined;\n  private readonly next: I | undefined;\n  private readonly part: Writer | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, items: Cursor<I>, inParens?: boolean,\n              first?: boolean, item?: I, next?: I, part?: Writer, step?: number) {\n    super();\n    this.recon = recon;\n    this.items = items;\n    this.inParens = inParens;\n    this.first = first;\n    this.item = item;\n    this.next = next;\n    this.part = part;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return PrimaryWriter.write(output, this.recon, this.items, this.inParens, this.first,\n                               this.item, this.next, this.part, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, items: Cursor<I>): number {\n    let size = 0;\n    let inParens = false;\n    let first = true;\n    let next: I | undefined;\n    while (next !== void 0 || items.hasNext()) {\n      let item: I | undefined;\n      if (next === void 0) {\n        item = items.next().value as I;\n      } else {\n        item = next;\n        next = void 0;\n      }\n      if (items.hasNext()) {\n        next = items.next().value as I;\n      }\n      if (!inParens && !first) {\n        size += 1; // ' '\n      }\n      if (recon.isAttr(item)) {\n        if (inParens) {\n          size += 1; // ')'\n          inParens = false;\n        }\n        size += recon.sizeOfItem(item);\n        first = false;\n      } else if (inParens) {\n        if (!first) {\n          size += 1; // ','\n        } else {\n          first = false;\n        }\n        size += recon.sizeOfBlockItem(item);\n      } else if (recon.isValue(item) && !recon.isRecord(item)\n             && (!first && next === void 0 || next !== void 0 && recon.isAttr(next))) {\n        size += recon.sizeOfItem(item);\n      } else {\n        size += 1; // '('\n        size += recon.sizeOfItem(item);\n        inParens = true;\n        first = false;\n      }\n    }\n    if (inParens) {\n      size += 1; // ')'\n    }\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, items: Cursor<I>,\n                     inParens: boolean = false, first: boolean = true, item?: I,\n                     next?: I, part?: Writer, step: number = 1): Writer {\n    do {\n      if (step === 1) {\n        if (next === void 0 && !items.hasNext()) {\n          step = 5;\n          break;\n        } else {\n          if (next === void 0) {\n            item = items.next().value!;\n          } else {\n            item = next;\n            next = void 0;\n          }\n          if (items.hasNext()) {\n            next = items.next().value!;\n          }\n          step = 2;\n        }\n      }\n      if (step === 2 && output.isCont()) {\n        if (!inParens && !first) {\n          output = output.write(32/*' '*/);\n        }\n        step = 3;\n      }\n      if (step === 3 && output.isCont()) {\n        if (recon.isAttr(item!)) {\n          if (inParens) {\n            output = output.write(41/*')'*/);\n            inParens = false;\n          }\n          part = recon.writeItem(output, item!);\n          first = false;\n          step = 4;\n        } else if (inParens) {\n          if (!first) {\n            output = output.write(44/*','*/);\n          } else {\n            first = false;\n          }\n          part = recon.writeBlockItem(output, item!);\n          step = 4;\n        } else if (recon.isValue(item!) && !recon.isRecord(item!)\n               && (!first && next === void 0 || next !== void 0 && recon.isAttr(next))) {\n          part = recon.writeItem(output, item!);\n          step = 4;\n        } else {\n          output = output.write(40/*'('*/);\n          part = recon.writeItem(output, item!);\n          inParens = true;\n          first = false;\n          step = 4;\n        }\n      }\n      if (step === 4) {\n        part = part!.pull(output);\n        if (part.isDone()) {\n          part = void 0;\n          step = 1;\n          continue;\n        } else if (part.isError()) {\n          return part.asError();\n        }\n      }\n      break;\n    } while (true);\n    if (step === 5) {\n      if (inParens) {\n        if (output.isCont()) {\n          output = output.write(41/*')'*/);\n          return Writer.end();\n        }\n      } else {\n        return Writer.end();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new PrimaryWriter<I, V>(recon, items, inParens, first, item, next, part, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Strings} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport {Utf8} from \"@swim/codec\";\nimport {Base16} from \"@swim/codec\";\n\n/** @internal */\nexport class MarkupTextWriter extends Writer {\n  private readonly text: string;\n  private readonly index: number | undefined;\n  private readonly escape: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(text: string, index?: number, escape?: number, step?: number) {\n    super();\n    this.text = text;\n    this.index = index;\n    this.escape = escape;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return MarkupTextWriter.write(output, this.text, this.index, this.escape, this.step);\n  }\n\n  static sizeOf(text: string): number {\n    let size = 0;\n    for (let i = 0; i < text.length; i = Strings.offsetByCodePoints(text, i, 1)) {\n      let c = text.codePointAt(i);\n      if (c === void 0) {\n        c = text.charCodeAt(i);\n      }\n      if (c === 36/*'$'*/ || c === 64/*'@'*/ || c === 91/*'['*/ || c === 92/*'\\\\'*/\n          || c === 93/*']'*/ || c === 123/*'{'*/ || c === 125/*'}'*/ || c === 8/*'\\b'*/\n          || c === 12/*'\\f'*/ || c === 10/*'\\n'*/ || c === 13/*'\\r'*/ || c === 9/*'\\t'*/) {\n        size += 2;\n      } else if (c < 0x20) {\n        size += 6;\n      } else {\n        size += Utf8.sizeOf(c);\n      }\n    }\n    return size;\n  }\n\n  static write(output: Output, text: string, index: number = 0,\n               escape: number = 0, step: number = 1): Writer {\n    const length = text.length;\n    while (output.isCont()) {\n      if (step === 1) {\n        if (index < length) {\n          let c = text.codePointAt(index);\n          if (c === void 0) {\n            c = text.charCodeAt(index);\n          }\n          index = Strings.offsetByCodePoints(text, index, 1);\n          if (c === 36/*'$'*/ || c === 64/*'@'*/ || c === 91/*'['*/ || c === 92/*'\\\\'*/\n              || c === 93/*']'*/ || c === 123/*'{'*/ || c === 125/*'}'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = c;\n            step = 2;\n          } else if (c === 8/*'\\b'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 98/*'b'*/;\n            step = 2;\n          } else if (c === 12/*'\\f'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 102/*'f'*/;\n            step = 2;\n          } else if (c === 10/*'\\n'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 110/*'n'*/;\n            step = 2;\n          } else if (c === 13/*'\\r'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 114/*'r'*/;\n            step = 2;\n          } else if (c === 9/*'\\t'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 116/*'t'*/;\n            step = 2;\n          } else if (c < 0x20) {\n            output = output.write(92/*'\\\\'*/);\n            escape = c;\n            step = 3;\n          } else {\n            output = output.write(c);\n          }\n        } else {\n          return Writer.end();\n        }\n      } else if (step === 2) {\n        output = output.write(escape);\n        escape = 0;\n        step = 1;\n      } else if (step === 3) {\n        output = output.write(117/*'u'*/);\n        step = 4;\n      } else if (step === 4) {\n        output = output.write(Base16.uppercase.encodeDigit((escape >>> 12) & 0xf));\n        step = 5;\n      } else if (step === 5) {\n        output = output.write(Base16.uppercase.encodeDigit((escape >>> 8) & 0xf));\n        step = 6;\n      } else if (step === 6) {\n        output = output.write(Base16.uppercase.encodeDigit((escape >>> 4) & 0xf));\n        step = 7;\n      } else if (step === 7) {\n        output = output.write(Base16.uppercase.encodeDigit(escape & 0xf));\n        escape = 0;\n        step = 1;\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new MarkupTextWriter(text, index, escape, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport {Base64} from \"@swim/codec\";\n\n/** @internal */\nexport class DataWriter extends Writer {\n  private readonly array: Uint8Array;\n  private readonly part: Writer | undefined;\n  private readonly step: number | undefined;\n\n  constructor(array: Uint8Array, part?: Writer, step?: number) {\n    super();\n    this.array = array;\n    this.part = part;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return DataWriter.write(output, this.array, this.part, this.step);\n  }\n\n  static sizeOf(length: number): number {\n    return 1 + ((Math.floor(length * 4 / 3) + 3) & ~3);\n  }\n\n  static write(output: Output, array: Uint8Array, part?: Writer,\n               step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(37/*'%'*/);\n      step = 2;\n    }\n    if (step === 2) {\n      if (part === void 0) {\n        part = Base64.standard().writeUint8Array(output, array);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        return Writer.end();\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new DataWriter(array, part, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Strings} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport {Utf8} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\n\n/** @internal */\nexport class IdentWriter extends Writer {\n  private readonly ident: string;\n  private readonly index: number | undefined;\n\n  constructor(ident: string, index?: number) {\n    super();\n    this.ident = ident;\n    this.index = index;\n  }\n\n  override pull(output: Output): Writer {\n    return IdentWriter.write(output, this.ident, this.index);\n  }\n\n  static sizeOf(ident: string): number {\n    return Utf8.sizeOf(ident);\n  }\n\n  static write(output: Output, ident: string, index: number = 0): Writer {\n    let c: number | undefined;\n    const length = ident.length;\n    if (length === 0) {\n      return Writer.error(new WriterException(\"empty identifier\"));\n    }\n    if (index === 0 && output.isCont()) {\n      c = ident.codePointAt(0);\n      if (c === void 0) {\n        c = ident.charCodeAt(0);\n      }\n      if (Recon.isIdentStartChar(c)) {\n        output = output.write(c);\n        index = Strings.offsetByCodePoints(ident, 0, 1);\n      }\n    }\n    while (index < length && output.isCont()) {\n      c = ident.codePointAt(index);\n      if (c === void 0) {\n        c = ident.charCodeAt(index);\n      }\n      if (Recon.isIdentChar(c)) {\n        output = output.write(c);\n        index = Strings.offsetByCodePoints(ident, index, 1);\n      } else {\n        return Writer.error(new WriterException(\"invalid identifier\"));\n      }\n    }\n    if (index >= length) {\n      return Writer.end();\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new IdentWriter(ident, index);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Strings} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport {Utf8} from \"@swim/codec\";\nimport {Base16} from \"@swim/codec\";\n\n/** @internal */\nexport class StringWriter extends Writer {\n  private readonly string: string;\n  private readonly index: number | undefined;\n  private readonly escape: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(string: string, index?: number, escape?: number, step?: number) {\n    super();\n    this.string = string;\n    this.index = index;\n    this.escape = escape;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return StringWriter.write(output, this.string, this.index, this.escape, this.step);\n  }\n\n  static sizeOf(string: string): number {\n    let size = 0;\n    size += 1; // '\"';\n    for (let i = 0; i < string.length; i = Strings.offsetByCodePoints(string, i, 1)) {\n      let c = string.codePointAt(i);\n      if (c === void 0) {\n        c = string.charCodeAt(i);\n      }\n      if (c === 34/*'\"'*/ || c === 92/*'\\\\'*/ || c === 8/*'\\b'*/ || c === 12/*'\\f'*/\n          || c === 10/*'\\n'*/ || c === 13/*'\\r'*/ || c === 9/*'\\t'*/) {\n        size += 2;\n      } else if (c < 0x20) {\n        size += 6;\n      } else {\n        size += Utf8.sizeOf(c);\n      }\n    }\n    size += 1; // '\"';\n    return size;\n  }\n\n  static write(output: Output, string: string, index: number = 0, escape: number = 0,\n               step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(34/*'\"'*/);\n      step = 2;\n    }\n    const length = string.length;\n    while (step >= 2 && step <= 8 && output.isCont()) {\n      if (step === 2) {\n        if (index < length) {\n          let c = string.codePointAt(index);\n          if (c === void 0) {\n            c = string.charCodeAt(index);\n          }\n          index = Strings.offsetByCodePoints(string, index, 1);\n          if (c === 34/*'\"'*/ || c === 92/*'\\\\'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = c;\n            step = 3;\n          } else if (c === 8/*'\\b'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 98/*'b'*/;\n            step = 3;\n          } else if (c === 12/*'\\f'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 102/*'f'*/;\n            step = 3;\n          } else if (c === 10/*'\\n'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 110/*'n'*/;\n            step = 3;\n          } else if (c === 13/*'\\r'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 114/*'r'*/;\n            step = 3;\n          } else if (c === 9/*'\\t'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 116/*'t'*/;\n            step = 3;\n          } else if (c < 0x20) {\n            output = output.write('\\\\');\n            escape = c;\n            step = 4;\n          } else {\n            output = output.write(c);\n          }\n        } else {\n          step = 9;\n          break;\n        }\n      } else if (step === 3) {\n        output = output.write(escape);\n        escape = 0;\n        step = 2;\n      } else if (step === 4) {\n        output = output.write(117/*'u'*/);\n        step = 5;\n      } else if (step === 5) {\n        output = output.write(Base16.uppercase.encodeDigit((escape >>> 12) & 0xf));\n        step = 6;\n      } else if (step === 6) {\n        output = output.write(Base16.uppercase.encodeDigit((escape >>> 8) & 0xf));\n        step = 7;\n      } else if (step === 7) {\n        output = output.write(Base16.uppercase.encodeDigit((escape >>> 4) & 0xf));\n        step = 8;\n      } else if (step === 8) {\n        output = output.write(Base16.uppercase.encodeDigit(escape & 0xf));\n        escape = 0;\n        step = 2;\n      }\n    }\n    if (step === 9 && output.isCont()) {\n      output = output.write(34/*'\"'*/);\n      return Writer.end();\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new StringWriter(string, index, escape, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class LambdaFuncWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly bindings: V;\n  private readonly template: V;\n  private readonly part: Writer | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, bindings: V, template: V,\n              part?: Writer, step?: number) {\n    super();\n    this.recon = recon;\n    this.bindings = bindings;\n    this.template = template;\n    this.part = part;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return LambdaFuncWriter.write(output, this.recon, this.bindings, this.template,\n                                  this.part, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, bindings: V, template: V): number {\n    let size = 0;\n    size += recon.sizeOfPrimary(bindings);\n    size += 4; // \" => \"\n    size += recon.sizeOfValue(template);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, bindings: V, template: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1) {\n      if (part === void 0) {\n        part = recon.writePrimary(output, bindings);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 2;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 2 && output.isCont()) {\n      output = output.write(32/*' '*/);\n      step = 3;\n    }\n    if (step === 3 && output.isCont()) {\n      output = output.write(61/*'='*/);\n      step = 4;\n    }\n    if (step === 4 && output.isCont()) {\n      output = output.write(62/*'>'*/);\n      step = 5;\n    }\n    if (step === 5 && output.isCont()) {\n      output = output.write(32/*' '*/);\n      step = 6;\n    }\n    if (step === 6) {\n      if (part === void 0) {\n        part = recon.writeValue(output, template);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        return Writer.end();\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new LambdaFuncWriter<I, V>(recon, bindings, template, part, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class ConditionalOperatorWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly ifTerm: I;\n  private readonly thenTerm: I;\n  private readonly elseTerm: I;\n  private readonly precedence: number;\n  private readonly part: Writer | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, ifTerm: I, thenTerm: I, elseTerm: I,\n              precedence: number, part?: Writer, step?: number) {\n    super();\n    this.recon = recon;\n    this.ifTerm = ifTerm;\n    this.thenTerm = thenTerm;\n    this.elseTerm = elseTerm;\n    this.precedence = precedence;\n    this.part = part;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return ConditionalOperatorWriter.write(output, this.recon, this.ifTerm, this.thenTerm,\n                                           this.elseTerm, this.precedence, this.part, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, ifTerm: I, thenTerm: I,\n                      elseTerm: I, precedence: number): number {\n    let size = 0;\n    if (recon.precedence(ifTerm) > 0 && recon.precedence(ifTerm) <= precedence) {\n      size += 1; // '('\n      size += recon.sizeOfItem(ifTerm);\n      size += 1; // ')'\n    } else {\n      size += recon.sizeOfItem(ifTerm);\n    }\n    size += 3; // \" ? \"\n    size += recon.sizeOfItem(thenTerm);\n    size += 3; // \" : \"\n    size += recon.sizeOfItem(elseTerm);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, ifTerm: I, thenTerm: I, elseTerm: I,\n                     precedence: number, part?: Writer, step: number = 1): Writer {\n    if (step === 1) {\n      if (recon.precedence(ifTerm) > 0 && recon.precedence(ifTerm) <= precedence) {\n        if (output.isCont()) {\n          output = output.write(40/*'('*/);\n          step = 2;\n        }\n      } else {\n        step = 2;\n      }\n    }\n    if (step === 2) {\n      if (part === void 0) {\n        part = recon.writeItem(output, ifTerm);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 3;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 3) {\n      if (recon.precedence(ifTerm) > 0 && recon.precedence(ifTerm) <= precedence) {\n        if (output.isCont()) {\n          output = output.write(41/*')'*/);\n          step = 4;\n        }\n      } else {\n        step = 4;\n      }\n    }\n    if (step === 4 && output.isCont()) {\n      output = output.write(32/*' '*/);\n      step = 5;\n    }\n    if (step === 5 && output.isCont()) {\n      output = output.write(63/*'?'*/);\n      step = 6;\n    }\n    if (step === 6 && output.isCont()) {\n      output = output.write(32/*' '*/);\n      step = 7;\n    }\n    if (step === 7) {\n      if (part === void 0) {\n        part = recon.writeItem(output, thenTerm);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 8;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 8 && output.isCont()) {\n      output = output.write(32/*' '*/);\n      step = 9;\n    }\n    if (step === 9 && output.isCont()) {\n      output = output.write(58/*':'*/);\n      step = 10;\n    }\n    if (step === 10 && output.isCont()) {\n      output = output.write(32/*' '*/);\n      step = 11;\n    }\n    if (step === 11) {\n      if (part === void 0) {\n        part = recon.writeItem(output, elseTerm);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        return Writer.end();\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new ConditionalOperatorWriter<I, V>(recon, ifTerm, thenTerm, elseTerm,\n                                               precedence, part, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Utf8} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class InfixOperatorWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly lhs: I;\n  private readonly operator: string;\n  private readonly rhs: I;\n  private readonly precedence: number;\n  private readonly part: Writer | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, lhs: I, operator: string, rhs: I,\n              precedence: number, part?: Writer, step?: number) {\n    super();\n    this.recon = recon;\n    this.lhs = lhs;\n    this.operator = operator;\n    this.rhs = rhs;\n    this.precedence = precedence;\n    this.part = part;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return InfixOperatorWriter.write(output, this.recon, this.lhs, this.operator, this.rhs,\n                                     this.precedence, this.part, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, lhs: I, operator: string, rhs: I, precedence: number): number {\n    let size = 0;\n    if (recon.precedence(lhs) < precedence) {\n      size += 1; // '('\n      size += recon.sizeOfItem(lhs);\n      size += 1; // ')'\n    } else {\n      size += recon.sizeOfItem(lhs);\n    }\n    size += 1; // ' '\n    size += Utf8.sizeOf(operator);\n    size += 1; // ' '\n    if (recon.precedence(rhs) < precedence) {\n      size += 1; // '('\n      size += recon.sizeOfItem(rhs);\n      size += 1; // ')'\n    } else {\n      size += recon.sizeOfItem(rhs);\n    }\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, lhs: I, operator: string, rhs: I,\n                     precedence: number, part?: Writer, step: number = 1): Writer {\n    if (step === 1) {\n      if (recon.precedence(lhs) < precedence) {\n        if (output.isCont()) {\n          output = output.write(40/*'('*/);\n          step = 2;\n        }\n      } else {\n        step = 2;\n      }\n    }\n    if (step === 2) {\n      if (part === void 0) {\n        part = recon.writeItem(output, lhs);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 3;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 3) {\n      if (recon.precedence(lhs) < precedence) {\n        if (output.isCont()) {\n          output = output.write(41/*')'*/);\n          step = 4;\n        }\n      } else {\n        step = 4;\n      }\n    }\n    if (step === 4 && output.isCont()) {\n      output = output.write(32/*' '*/);\n      step = 5;\n    }\n    if (step === 5) {\n      if (part === void 0) {\n        part = Unicode.writeString(output, operator);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 6;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 6 && output.isCont()) {\n      output = output.write(32/*' '*/);\n      step = 7;\n    }\n    if (step === 7) {\n      if (recon.precedence(rhs) < precedence) {\n        if (output.isCont()) {\n          output = output.write(40/*'('*/);\n          step = 8;\n        }\n      } else {\n        step = 8;\n      }\n    }\n    if (step === 8) {\n      if (part === void 0) {\n        part = recon.writeItem(output, rhs);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 9;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 9) {\n      if (recon.precedence(rhs) < precedence) {\n        if (output.isCont()) {\n          output = output.write(41/*')'*/);\n          return Writer.end();\n        }\n      } else {\n        return Writer.end();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new InfixOperatorWriter<I, V>(recon, lhs, operator, rhs, precedence, part, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Utf8} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class PrefixOperatorWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly operator: string;\n  private readonly rhs: I;\n  private readonly precedence: number;\n  private readonly part: Writer | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, operator: string, rhs: I,\n              precedence: number, part?: Writer, step?: number) {\n    super();\n    this.recon = recon;\n    this.operator = operator;\n    this.rhs = rhs;\n    this.precedence = precedence;\n    this.part = part;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return PrefixOperatorWriter.write(output, this.recon, this.operator, this.rhs,\n                                      this.precedence, this.part, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, operator: string, rhs: I, precedence: number): number {\n    let size = 0;\n    size += Utf8.sizeOf(operator);\n    if (recon.precedence(rhs) < precedence) {\n      size += 1; // '('\n      size += recon.sizeOfItem(rhs);\n      size += 1; // ')'\n    } else {\n      size += recon.sizeOfItem(rhs);\n    }\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, operator: string, rhs: I,\n                     precedence: number, part?: Writer, step: number = 1): Writer {\n    if (step === 1) {\n      if (part === void 0) {\n        part = Unicode.writeString(output, operator);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 2;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 2) {\n      if (recon.precedence(rhs) < precedence) {\n        if (output.isCont()) {\n          output = output.write(40/*'('*/);\n          step = 3;\n        }\n      } else {\n        step = 3;\n      }\n    }\n    if (step === 3) {\n      if (part === void 0) {\n        part = recon.writeItem(output, rhs);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 4;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 4) {\n      if (recon.precedence(rhs) < precedence) {\n        if (output.isCont()) {\n          output = output.write(41/*')'*/);\n          return Writer.end();\n        }\n      } else {\n        return Writer.end();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new PrefixOperatorWriter<I, V>(recon, operator, rhs, precedence, part, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class InvokeOperatorWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly func: V;\n  private readonly args: V;\n  private readonly part: Writer | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, func: V, args: V, part?: Writer, step?: number) {\n    super();\n    this.recon = recon;\n    this.func = func;\n    this.args = args;\n    this.part = part;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return InvokeOperatorWriter.write(output, this.recon, this.func, this.args,\n                                      this.part, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, func: V, args: V): number {\n    let size = 0;\n    size += recon.sizeOfValue(func);\n    size += 1; // '('\n    size += recon.sizeOfBlockValue(args);\n    size += 1; // ')'\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, func: V, args: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1) {\n      if (part === void 0) {\n        part = recon.writeValue(output, func);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 2;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 2 && output.isCont()) {\n      output = output.write(40/*'('*/);\n      step = 3;\n    }\n    if (step === 3) {\n      if (part === void 0) {\n        part = recon.writeBlockValue(output, args);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 4;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 4 && output.isCont()) {\n      output = output.write(41/*')'*/);\n      return Writer.end();\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new InvokeOperatorWriter<I, V>(recon, func, args, part, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class LiteralSelectorWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly item: I;\n  private readonly then: V;\n  private readonly part: Writer | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, item: I, then: V, part?: Writer, step?: number) {\n    super();\n    this.recon = recon;\n    this.item = item;\n    this.then = then;\n    this.part = part;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return LiteralSelectorWriter.write(output, this.recon, this.item, this.then,\n                                       this.part, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, item: I, then: V): number {\n    let size = 0;\n    if (recon.precedence(item) < recon.precedence(recon.item(then))) {\n      size += 1; // '('\n      size += recon.sizeOfItem(item);\n      size += 1; // ')'\n    } else {\n      size += recon.sizeOfItem(item);\n    }\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, item: I, then: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1) {\n      if (recon.precedence(item) < recon.precedence(recon.item(then))) {\n        if (output.isCont()) {\n          output = output.write(40/*'('*/);\n          step = 2;\n        }\n      } else {\n        step = 2;\n      }\n    }\n    if (step === 2) {\n      if (part === void 0) {\n        part = recon.writeItem(output, item);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 3;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 3) {\n      if (recon.precedence(item) < recon.precedence(recon.item(then))) {\n        if (output.isCont()) {\n          output = output.write(41/*')'*/);\n          step = 4;\n        }\n      } else {\n        step = 4;\n      }\n    }\n    if (step === 4) {\n      return recon.writeThen(output, then);\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new LiteralSelectorWriter<I, V>(recon, item, then, part, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class GetSelectorWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly key: V;\n  private readonly then: V;\n  private readonly part: Writer | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, key: V, then: V, part?: Writer, step?: number) {\n    super();\n    this.recon = recon;\n    this.key = key;\n    this.then = then;\n    this.part = part;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return GetSelectorWriter.write(output, this.recon, this.key, this.then, this.part, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, key: V, then: V): number {\n    let size = 1; // '$' | '.'\n    if (recon.isRecord(recon.item(key))) {\n      size += 1; // '{'\n      size += recon.sizeOfBlockValue(key);\n      size += 1; // '}'\n    } else {\n      size += recon.sizeOfValue(key);\n    }\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, key: V, then: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(36/*'$'*/);\n      step = 3;\n    } else if (step === 2 && output.isCont()) {\n      output = output.write(46/*'.'*/);\n      step = 3;\n    }\n    if (step === 3) {\n      if (recon.isRecord(recon.item(key))) {\n        if (output.isCont()) {\n          output = output.write(123/*'{'*/);\n          step = 4;\n        }\n      } else {\n        step = 4;\n      }\n    }\n    if (step === 4) {\n      if (part === void 0) {\n        if (recon.isRecord(recon.item(key))) {\n          part = recon.writeBlockValue(output, key);\n        } else {\n          part = recon.writeValue(output, key);\n        }\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 5;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 5) {\n      if (recon.isRecord(recon.item(key))) {\n        if (output.isCont()) {\n          output = output.write(125/*'}'*/);\n          step = 6;\n        }\n      } else {\n        step = 6;\n      }\n    }\n    if (step === 6) {\n      return recon.writeThen(output, then);\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new GetSelectorWriter<I, V>(recon, key, then, part, step);\n  }\n\n  static writeThen<I, V>(output: Output, recon: ReconWriter<I, V>, key: V, then: V): Writer {\n    return GetSelectorWriter.write(output, recon, key, then, void 0, 2);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class GetAttrSelectorWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly key: V;\n  private readonly then: V;\n  private readonly part: Writer | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, key: V, then: V, part?: Writer, step?: number) {\n    super();\n    this.recon  = recon;\n    this.key = key;\n    this.then = then;\n    this.part = part;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return GetAttrSelectorWriter.write(output, this.recon, this.key, this.then,\n                                       this.part, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, key: V, then: V): number {\n    let size = 2; // ('$' | '.') '@'\n    size += recon.sizeOfValue(key);\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, key: V, then: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(36/*'$'*/);\n      step = 3;\n    } else if (step === 2 && output.isCont()) {\n      output = output.write(46/*'.'*/);\n      step = 3;\n    }\n    if (step === 3 && output.isCont()) {\n      output = output.write(64/*'@'*/);\n      step = 4;\n    }\n    if (step === 4) {\n      if (part === void 0) {\n        part = recon.writeValue(output, key);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        return recon.writeThen(output, then);\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new GetAttrSelectorWriter<I, V>(recon, key, then, part, step);\n  }\n\n  static writeThen<I, V>(output: Output, recon: ReconWriter<I, V>, key: V, then: V): Writer {\n    return GetAttrSelectorWriter.write(output, recon, key, then, void 0, 2);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class GetItemSelectorWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly index: V;\n  private readonly then: V;\n  private readonly part: Writer | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, index: V, then: V, part?: Writer, step?: number) {\n    super();\n    this.recon = recon;\n    this.index = index;\n    this.then = then;\n    this.part = part;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return GetItemSelectorWriter.write(output, this.recon, this.index, this.then,\n                                       this.part, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, index: V, then: V): number {\n    let size = 2; // \"$#\"\n    size += recon.sizeOfValue(index);\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static sizeOfThen<I, V>(recon: ReconWriter<I, V>, index: V, then: V): number {\n    let size = 1; // '#'\n    size += recon.sizeOfValue(index);\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, index: V, then: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(36/*'$'*/);\n      step = 2;\n    }\n    if (step === 2 && output.isCont()) {\n      output = output.write(35/*'#'*/);\n      step = 3;\n    }\n    if (step === 3) {\n      if (part === void 0) {\n        part = recon.writeValue(output, index);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        return recon.writeThen(output, then);\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new GetItemSelectorWriter<I, V>(recon, index, then, part, step);\n  }\n\n  static writeThen<I, V>(output: Output, recon: ReconWriter<I, V>, index: V, then: V): Writer {\n    return GetItemSelectorWriter.write(output, recon, index, then, void 0, 2);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class KeysSelectorWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly then: V;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, then: V, step?: number) {\n    super();\n    this.recon = recon;\n    this.then = then;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return KeysSelectorWriter.write(output, this.recon, this.then, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, then: V): number {\n    let size = 3; // ('$' | '.') '*' ':'\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, then: V,\n                     step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(36/*'$'*/);\n      step = 3;\n    } else if (step === 2 && output.isCont()) {\n      output = output.write(46/*'.'*/);\n      step = 3;\n    }\n    if (step === 3 && output.isCont()) {\n      output = output.write(42/*'*'*/);\n      step = 4;\n    }\n    if (step === 4 && output.isCont()) {\n      output = output.write(58/*':'*/);\n      return recon.writeThen(output, then);\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new KeysSelectorWriter<I, V>(recon, then, step);\n  }\n\n  static writeThen<I, V>(output: Output, recon: ReconWriter<I, V>, then: V): Writer {\n    return KeysSelectorWriter.write(output, recon, then, 2);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class ValuesSelectorWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly then: V;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, then: V, step?: number) {\n    super();\n    this.recon = recon;\n    this.then = then;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return ValuesSelectorWriter.write(output, this.recon, this.then, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, then: V): number {\n    let size = 3; // ('$' | '.') ':' '*'\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, then: V,\n                     step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(36/*'$'*/);\n      step = 3;\n    } else if (step === 2 && output.isCont()) {\n      output = output.write(46/*'.'*/);\n      step = 3;\n    }\n    if (step === 3 && output.isCont()) {\n      output = output.write(58/*':'*/);\n      step = 4;\n    }\n    if (step === 4 && output.isCont()) {\n      output = output.write(42/*'*'*/);\n      return recon.writeThen(output, then);\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new ValuesSelectorWriter<I, V>(recon, then, step);\n  }\n\n  static writeThen<I, V>(output: Output, recon: ReconWriter<I, V>, then: V): Writer {\n    return ValuesSelectorWriter.write(output, recon, then, 2);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class ChildrenSelectorWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly then: V;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, then: V, step?: number) {\n    super();\n    this.recon = recon;\n    this.then = then;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return ChildrenSelectorWriter.write(output, this.recon, this.then, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, then: V): number {\n    let size = 2; // ('$' | '.') '*'\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, then: V,\n                     step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(36/*'$'*/);\n      step = 3;\n    } else if (step === 2 && output.isCont()) {\n      output = output.write(46/*'.'*/);\n      step = 3;\n    }\n    if (step === 3 && output.isCont()) {\n      output = output.write(42/*'*'*/);\n      return recon.writeThen(output, then);\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new ChildrenSelectorWriter<I, V>(recon, then, step);\n  }\n\n  static writeThen<I, V>(output: Output, recon: ReconWriter<I, V>, then: V): Writer {\n    return ChildrenSelectorWriter.write(output, recon, then, 2);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class DescendantsSelectorWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly then: V;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, then: V, step?: number) {\n    super();\n    this.recon = recon;\n    this.then = then;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return DescendantsSelectorWriter.write(output, this.recon, this.then, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, then: V): number {\n    let size = 3; // ('$' | '.') '*' '*'\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, then: V,\n                     step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(36/*'$'*/);\n      step = 3;\n    } else if (step === 2 && output.isCont()) {\n      output = output.write(46/*'.'*/);\n      step = 3;\n    }\n    if (step === 3 && output.isCont()) {\n      output = output.write(42/*'*'*/);\n      step = 4;\n    }\n    if (step === 4 && output.isCont()) {\n      output = output.write(42/*'*'*/);\n      return recon.writeThen(output, then);\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new DescendantsSelectorWriter<I, V>(recon, then, step);\n  }\n\n  static writeThen<I, V>(output: Output, recon: ReconWriter<I, V>, then: V): Writer {\n    return DescendantsSelectorWriter.write(output, recon, then, 2);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {ReconWriter} from \"./ReconWriter\";\n\n/** @internal */\nexport class FilterSelectorWriter<I, V> extends Writer {\n  private readonly recon: ReconWriter<I, V>;\n  private readonly predicate: V;\n  private readonly then: V;\n  private readonly part: Writer | undefined;\n  private readonly step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, predicate: V, then: V,\n              part?: Writer, step?: number) {\n    super();\n    this.recon = recon;\n    this.predicate = predicate;\n    this.then = then;\n    this.part = part;\n    this.step = step;\n  }\n\n  override pull(output: Output): Writer {\n    return FilterSelectorWriter.write(output, this.recon, this.predicate,\n                                      this.then, this.part, this.step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, predicate: V, then: V): number {\n    let size = 2; // '$' '['\n    size += recon.sizeOfValue(predicate);\n    size += 1; // ']'\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static sizeOfThen<I, V>(recon: ReconWriter<I, V>, predicate: V, then: V): number {\n    let size = 1; // '['\n    size += recon.sizeOfValue(predicate);\n    size += 1; // ']'\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, predicate: V, then: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(36/*'$'*/);\n      step = 2;\n    }\n    if (step === 2 && output.isCont()) {\n      output = output.write(91/*'['*/);\n      step = 3;\n    }\n    if (step === 3) {\n      if (part === void 0) {\n        part = recon.writeValue(output, predicate);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 4;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 4 && output.isCont()) {\n      output = output.write(93/*']'*/);\n      return recon.writeThen(output, then);\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new FilterSelectorWriter<I, V>(recon, predicate, then, part, step);\n  }\n\n  static writeThen<I, V>(output: Output, recon: ReconWriter<I, V>,\n                         predicate: V, then: V): Writer {\n    return FilterSelectorWriter.write(output, recon, predicate, then, void 0, 2);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Strings} from \"@swim/util\";\nimport type {Cursor} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Base10} from \"@swim/codec\";\nimport {Base16} from \"@swim/codec\";\nimport {Recon} from \"../Recon\";\nimport {AttrWriter} from \"./AttrWriter\";\nimport {SlotWriter} from \"./SlotWriter\";\nimport {BlockWriter} from \"./BlockWriter\";\nimport {PrimaryWriter} from \"./PrimaryWriter\";\nimport {MarkupTextWriter} from \"./MarkupTextWriter\";\nimport {DataWriter} from \"./DataWriter\";\nimport {IdentWriter} from \"./IdentWriter\";\nimport {StringWriter} from \"./StringWriter\";\nimport {LambdaFuncWriter} from \"./LambdaFuncWriter\";\nimport {ConditionalOperatorWriter} from \"./ConditionalOperatorWriter\";\nimport {InfixOperatorWriter} from \"./InfixOperatorWriter\";\nimport {PrefixOperatorWriter} from \"./PrefixOperatorWriter\";\nimport {InvokeOperatorWriter} from \"./InvokeOperatorWriter\";\nimport {LiteralSelectorWriter} from \"./LiteralSelectorWriter\";\nimport {GetSelectorWriter} from \"./GetSelectorWriter\";\nimport {GetAttrSelectorWriter} from \"./GetAttrSelectorWriter\";\nimport {GetItemSelectorWriter} from \"./GetItemSelectorWriter\";\nimport {KeysSelectorWriter} from \"./KeysSelectorWriter\";\nimport {ValuesSelectorWriter} from \"./ValuesSelectorWriter\";\nimport {ChildrenSelectorWriter} from \"./ChildrenSelectorWriter\";\nimport {DescendantsSelectorWriter} from \"./DescendantsSelectorWriter\";\nimport {FilterSelectorWriter} from \"./FilterSelectorWriter\";\n\n/**\n * Factory for constructing Recon writers.\n * @public\n */\nexport abstract class ReconWriter<I, V> {\n  abstract isField(item: I): boolean;\n\n  abstract isAttr(item: I): boolean;\n\n  abstract isSlot(item: I): boolean;\n\n  abstract isValue(item: I): boolean;\n\n  abstract isRecord(item: I): boolean;\n\n  abstract isText(item: I): boolean;\n\n  abstract isNum(item: I): boolean;\n\n  abstract isBool(item: I): boolean;\n\n  abstract isExpression(item: I): boolean;\n\n  abstract isExtant(item: I): boolean;\n\n  abstract items(item: I): Cursor<I>;\n\n  abstract item(value: V): I;\n\n  abstract key(item: I): V;\n\n  abstract value(item: I): V;\n\n  abstract string(item: I): string;\n\n  abstract precedence(item: I): number;\n\n  abstract sizeOfItem(item: I): number;\n\n  abstract writeItem(output: Output, item: I): Writer;\n\n  abstract sizeOfValue(value: V): number;\n\n  abstract writeValue(output: Output, value: V): Writer;\n\n  abstract sizeOfBlockValue(value: V): number;\n\n  abstract writeBlockValue(output: Output, value: V): Writer;\n\n  sizeOfAttr(key: V, value: V): number {\n    return AttrWriter.sizeOf(this, key, value);\n  }\n\n  writeAttr(output: Output, key: V, value: V): Writer {\n    return AttrWriter.write(output, this, key, value);\n  }\n\n  sizeOfSlot(key: V, value: V): number {\n    return SlotWriter.sizeOf(this, key, value);\n  }\n\n  writeSlot(output: Output, key: V, value: V): Writer {\n    return SlotWriter.write(output, this, key, value);\n  }\n\n  abstract sizeOfBlockItem(item: I): number;\n\n  abstract writeBlockItem(output: Output, item: I): Writer;\n\n  sizeOfBlock(item: I): number;\n  sizeOfBlock(items: Cursor<I>, inBlock: boolean, inMarkup: boolean): number;\n  sizeOfBlock(item: I | Cursor<I>, inBlock?: boolean, inMarkup?: boolean): number {\n    if (arguments.length === 3) {\n      return BlockWriter.sizeOf(this, item as Cursor<I>, inBlock!, inMarkup!);\n    } else {\n      const items = this.items(item as I);\n      if (items.hasNext()) {\n        return BlockWriter.sizeOf(this, items, this.isBlockSafe(this.items(item as I)), false);\n      } else {\n        return 2; // \"{}\"\n      }\n    }\n  }\n\n  writeBlock(output: Output, item: I): Writer;\n  writeBlock(output: Output, items: Cursor<I>, inBlock: boolean, inMarkup: boolean): Writer;\n  writeBlock(output: Output, item: I | Cursor<I>, inBlock?: boolean, inMarkup?: boolean): Writer {\n    if (arguments.length === 4) {\n      return BlockWriter.write(output, this, item as Cursor<I>, inBlock!, inMarkup!);\n    } else {\n      const items = this.items(item as I);\n      if (items.hasNext()) {\n        return BlockWriter.write(output, this, items, this.isBlockSafe(this.items(item as I)), false);\n      } else {\n        return Unicode.writeString(output, \"{}\");\n      }\n    }\n  }\n\n  sizeOfRecord(item: I): number {\n    const items = this.items(item);\n    if (items.hasNext()) {\n      return BlockWriter.sizeOf(this, items, false, false);\n    } else {\n      return 2; // \"{}\"\n    }\n  }\n\n  writeRecord(output: Output, item: I): Writer {\n    const items = this.items(item);\n    if (items.hasNext()) {\n      return BlockWriter.write(output, this, items, false, false);\n    } else {\n      return Unicode.writeString(output, \"{}\");\n    }\n  }\n\n  sizeOfPrimary(value: V): number {\n    if (this.isRecord(this.item(value))) {\n      const items = this.items(this.item(value));\n      if (items.hasNext()) {\n        return PrimaryWriter.sizeOf(this, items);\n      }\n    } else if (!this.isExtant(this.item(value))) {\n      return this.sizeOfValue(value);\n    }\n    return 2; // \"()\"\n  }\n\n  writePrimary(output: Output, value: V): Writer {\n    if (this.isRecord(this.item(value))) {\n      const items = this.items(this.item(value));\n      if (items.hasNext()) {\n        return PrimaryWriter.write(output, this, items);\n      }\n    } else if (!this.isExtant(this.item(value))) {\n      return this.writeValue(output, value);\n    }\n    return Unicode.writeString(output, \"()\");\n  }\n\n  isBlockSafe(items: Cursor<I>): boolean {\n    while (items.hasNext()) {\n      if (this.isAttr(items.next().value!)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  isMarkupSafe(items: Cursor<I>): boolean {\n    if (!items.hasNext() || !this.isAttr(items.next().value!)) {\n      return false;\n    }\n    while (items.hasNext()) {\n      if (this.isAttr(items.next().value!)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  sizeOfMarkupText(item: I | string): number {\n    if (typeof item !== \"string\") {\n      item = this.string(item);\n    }\n    return MarkupTextWriter.sizeOf(item);\n  }\n\n  writeMarkupText(output: Output, item: I | string): Writer {\n    if (typeof item !== \"string\") {\n      item = this.string(item);\n    }\n    return MarkupTextWriter.write(output, item);\n  }\n\n  sizeOfData(length: number): number {\n    return DataWriter.sizeOf(length);\n  }\n\n  writeData(output: Output, value: Uint8Array | undefined): Writer {\n    if (value !== void 0) {\n      return DataWriter.write(output, value);\n    } else {\n      return Unicode.writeString(output, \"%\");\n    }\n  }\n\n  isIdent(value: I | string): boolean {\n    if (typeof value !== \"string\") {\n      value = this.string(value);\n    }\n    const n = value.length;\n    let c: number | undefined;\n    if (n === 0 || (c = value.codePointAt(0), c !== void 0 && !Recon.isIdentStartChar(c))) {\n      return false;\n    }\n    for (let i = Strings.offsetByCodePoints(value, 0, 1); i < n; i = Strings.offsetByCodePoints(value, i, 1)) {\n      c = value.codePointAt(i);\n      if (c === void 0 || !Recon.isIdentChar(c)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  sizeOfText(value: string): number {\n    if (this.isIdent(value)) {\n      return IdentWriter.sizeOf(value);\n    } else {\n      return StringWriter.sizeOf(value);\n    }\n  }\n\n  writeText(output: Output, value: string): Writer {\n    if (this.isIdent(value)) {\n      return IdentWriter.write(output, value);\n    } else {\n      return StringWriter.write(output, value);\n    }\n  }\n\n  sizeOfNum(value: number): number {\n    if (isFinite(value) && Math.floor(value) === value && Math.abs(value) < 2147483648) {\n      let size = Base10.countDigits(value);\n      if (value < 0) {\n        size += 1;\n      }\n      return size;\n    } else {\n      return (\"\" + value).length;\n    }\n  }\n\n  writeNum(output: Output, value: number): Writer {\n    if (isFinite(value) && Math.floor(value) === value && Math.abs(value) < 2147483648) {\n      return Base10.writeInteger(output, value);\n    } else {\n      return Unicode.writeString(output, \"\" + value);\n    }\n  }\n\n  sizeOfUint32(value: number): number {\n    return 10;\n  }\n\n  writeUint32(output: Output, value: number): Writer {\n    return Base16.lowercase.writeIntegerLiteral(output, value, 8);\n  }\n\n  sizeOfUint64(value: number): number {\n    return 18;\n  }\n\n  writeUint64(output: Output, value: number): Writer {\n    return Base16.lowercase.writeIntegerLiteral(output, value, 16);\n  }\n\n  sizeOfBool(value: boolean): number {\n    return value ? 4 : 5;\n  }\n\n  writeBool(output: Output, value: boolean): Writer {\n    return Unicode.writeString(output, value ? \"true\" : \"false\");\n  }\n\n  sizeOfLambdaFunc(bindings: V, template: V): number {\n    return LambdaFuncWriter.sizeOf(this, bindings, template);\n  }\n\n  writeLambdaFunc(output: Output, bindings: V, template: V): Writer {\n    return LambdaFuncWriter.write(output, this, bindings, template);\n  }\n\n  sizeOfConditionalOperator(ifTerm: I, thenTerm: I, elseTerm: I, precedence: number): number {\n    return ConditionalOperatorWriter.sizeOf(this, ifTerm, thenTerm, elseTerm, precedence);\n  }\n\n  writeConditionalOperator(output: Output, ifTerm: I, thenTerm: I, elseTerm: I, precedence: number): Writer {\n    return ConditionalOperatorWriter.write(output, this, ifTerm, thenTerm, elseTerm, precedence);\n  }\n\n  sizeOfInfixOperator(lhs: I, operator: string, rhs: I, precedence: number): number {\n    return InfixOperatorWriter.sizeOf(this, lhs, operator, rhs, precedence);\n  }\n\n  writeInfixOperator(output: Output, lhs: I, operator: string, rhs: I, precedence: number): Writer {\n    return InfixOperatorWriter.write(output, this, lhs, operator, rhs, precedence);\n  }\n\n  sizeOfPrefixOperator(operator: string, rhs: I, precedence: number): number {\n    return PrefixOperatorWriter.sizeOf(this, operator, rhs, precedence);\n  }\n\n  writePrefixOperator(output: Output, operator: string, rhs: I, precedence: number): Writer {\n    return PrefixOperatorWriter.write(output, this, operator, rhs, precedence);\n  }\n\n  sizeOfInvokeOperator(func: V, args: V): number {\n    return InvokeOperatorWriter.sizeOf(this, func, args);\n  }\n\n  writeInvokeOperator(output: Output, func: V, args: V): Writer {\n    return InvokeOperatorWriter.write(output, this, func, args);\n  }\n\n  abstract sizeOfThen(then: V): number;\n\n  abstract writeThen(output: Output, then: V): Writer;\n\n  sizeOfIdentitySelector(): number {\n    return 0;\n  }\n\n  writeIdentitySelector(output: Output): Writer {\n    return Writer.end();\n  }\n\n  sizeOfThenIdentitySelector(): number {\n    return 0;\n  }\n\n  writeThenIdentitySelector(output: Output): Writer {\n    return Writer.end();\n  }\n\n  sizeOfLiteralSelector(item: I, then: V): number {\n    return LiteralSelectorWriter.sizeOf(this, item, then);\n  }\n\n  writeLiteralSelector(output: Output, item: I, then: V): Writer {\n    return LiteralSelectorWriter.write(output, this, item, then);\n  }\n\n  sizeOfThenLiteralSelector(item: I, then: V): number {\n    return 0;\n  }\n\n  writeThenLiteralSelector(output: Output, item: I, then: V): Writer {\n    return Writer.end();\n  }\n\n  sizeOfGetSelector(key: V, then: V): number {\n    return GetSelectorWriter.sizeOf(this, key, then);\n  }\n\n  writeGetSelector(output: Output, key: V, then: V): Writer {\n    return GetSelectorWriter.write(output, this, key, then);\n  }\n\n  sizeOfThenGetSelector(key: V, then: V): number {\n    return GetSelectorWriter.sizeOf(this, key, then);\n  }\n\n  writeThenGetSelector(output: Output, key: V, then: V): Writer {\n    return GetSelectorWriter.writeThen(output, this, key, then);\n  }\n\n  sizeOfGetAttrSelector(key: V, then: V): number {\n    return GetAttrSelectorWriter.sizeOf(this, key, then);\n  }\n\n  writeGetAttrSelector(output: Output, key: V, then: V): Writer {\n    return GetAttrSelectorWriter.write(output, this, key, then);\n  }\n\n  sizeOfThenGetAttrSelector(key: V, then: V): number {\n    return GetAttrSelectorWriter.sizeOf(this, key, then);\n  }\n\n  writeThenGetAttrSelector(output: Output, key: V, then: V): Writer {\n    return GetAttrSelectorWriter.writeThen(output, this, key, then);\n  }\n\n  sizeOfGetItemSelector(index: V, then: V): number {\n    return GetItemSelectorWriter.sizeOf(this, index, then);\n  }\n\n  writeGetItemSelector(output: Output, index: V, then: V): Writer {\n    return GetItemSelectorWriter.write(output, this, index, then);\n  }\n\n  sizeOfThenGetItemSelector(index: V, then: V): number {\n    return GetItemSelectorWriter.sizeOfThen(this, index, then);\n  }\n\n  writeThenGetItemSelector(output: Output, index: V, then: V): Writer {\n    return GetItemSelectorWriter.writeThen(output, this, index, then);\n  }\n\n  sizeOfKeysSelector(then: V): number {\n    return KeysSelectorWriter.sizeOf(this, then);\n  }\n\n  writeKeysSelector(output: Output, then: V): Writer {\n    return KeysSelectorWriter.write(output, this, then);\n  }\n\n  sizeOfThenKeysSelector(then: V): number {\n    return KeysSelectorWriter.sizeOf(this, then);\n  }\n\n  writeThenKeysSelector(output: Output, then: V): Writer {\n    return KeysSelectorWriter.writeThen(output, this, then);\n  }\n\n  sizeOfValuesSelector(then: V): number {\n    return ValuesSelectorWriter.sizeOf(this, then);\n  }\n\n  writeValuesSelector(output: Output, then: V): Writer {\n    return ValuesSelectorWriter.write(output, this, then);\n  }\n\n  sizeOfThenValuesSelector(then: V): number {\n    return ValuesSelectorWriter.sizeOf(this, then);\n  }\n\n  writeThenValuesSelector(output: Output, then: V): Writer {\n    return ValuesSelectorWriter.writeThen(output, this, then);\n  }\n\n  sizeOfChildrenSelector(then: V): number {\n    return ChildrenSelectorWriter.sizeOf(this, then);\n  }\n\n  writeChildrenSelector(output: Output, then: V): Writer {\n    return ChildrenSelectorWriter.write(output, this, then);\n  }\n\n  sizeOfThenChildrenSelector(then: V): number {\n    return ChildrenSelectorWriter.sizeOf(this, then);\n  }\n\n  writeThenChildrenSelector(output: Output, then: V): Writer {\n    return ChildrenSelectorWriter.writeThen(output, this, then);\n  }\n\n  sizeOfDescendantsSelector(then: V): number {\n    return DescendantsSelectorWriter.sizeOf(this, then);\n  }\n\n  writeDescendantsSelector(output: Output, then: V): Writer {\n    return DescendantsSelectorWriter.write(output, this, then);\n  }\n\n  sizeOfThenDescendantsSelector(then: V): number {\n    return DescendantsSelectorWriter.sizeOf(this, then);\n  }\n\n  writeThenDescendantsSelector(output: Output, then: V): Writer {\n    return DescendantsSelectorWriter.writeThen(output, this, then);\n  }\n\n  sizeOfFilterSelector(predicate: V, then: V): number {\n    return FilterSelectorWriter.sizeOf(this, predicate, then);\n  }\n\n  writeFilterSelector(output: Output, predicate: V, then: V): Writer {\n    return FilterSelectorWriter.write(output, this, predicate, then);\n  }\n\n  sizeOfThenFilterSelector(predicate: V, then: V): number {\n    return FilterSelectorWriter.sizeOfThen(this, predicate, then);\n  }\n\n  writeThenFilterSelector(output: Output, predicate: V, then: V): Writer {\n    return FilterSelectorWriter.writeThen(output, this, predicate, then);\n  }\n\n  sizeOfExtant(): number {\n    return 0;\n  }\n\n  writeExtant(output: Output): Writer {\n    return Writer.end();\n  }\n\n  sizeOfAbsent(): number {\n    return 0;\n  }\n\n  writeAbsent(output: Output): Writer {\n    return Writer.end();\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Cursor} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport {WriterException} from \"@swim/codec\";\nimport {Writer} from \"@swim/codec\";\nimport type {Item} from \"@swim/structure\";\nimport {Field} from \"@swim/structure\";\nimport {Attr} from \"@swim/structure\";\nimport {Slot} from \"@swim/structure\";\nimport {Value} from \"@swim/structure\";\nimport {Record} from \"@swim/structure\";\nimport {Data} from \"@swim/structure\";\nimport {Text} from \"@swim/structure\";\nimport {Num} from \"@swim/structure\";\nimport {Bool} from \"@swim/structure\";\nimport {Expression} from \"@swim/structure\";\nimport {Operator} from \"@swim/structure\";\nimport {Selector} from \"@swim/structure\";\nimport {Func} from \"@swim/structure\";\nimport {Extant} from \"@swim/structure\";\nimport {Absent} from \"@swim/structure\";\nimport {ChildrenSelector} from \"@swim/structure\";\nimport {DescendantsSelector} from \"@swim/structure\";\nimport {FilterSelector} from \"@swim/structure\";\nimport {GetAttrSelector} from \"@swim/structure\";\nimport {GetItemSelector} from \"@swim/structure\";\nimport {GetSelector} from \"@swim/structure\";\nimport {IdentitySelector} from \"@swim/structure\";\nimport {KeysSelector} from \"@swim/structure\";\nimport {LiteralSelector} from \"@swim/structure\";\nimport {ValuesSelector} from \"@swim/structure\";\nimport {BinaryOperator} from \"@swim/structure\";\nimport {ConditionalOperator} from \"@swim/structure\";\nimport {InvokeOperator} from \"@swim/structure\";\nimport {UnaryOperator} from \"@swim/structure\";\nimport {BridgeFunc} from \"@swim/structure\";\nimport {LambdaFunc} from \"@swim/structure\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @public */\nexport class ReconStructureWriter extends ReconWriter<Item, Value> {\n  override isField(item: Item): boolean {\n    return item instanceof Field;\n  }\n\n  override isAttr(item: Item): boolean {\n    return item instanceof Attr;\n  }\n\n  override isSlot(item: Item): boolean {\n    return item instanceof Slot;\n  }\n\n  override isValue(item: Item): boolean {\n    return item instanceof Value;\n  }\n\n  override isRecord(item: Item): boolean {\n    return item instanceof Record;\n  }\n\n  override isText(item: Item): boolean {\n    return item instanceof Text;\n  }\n\n  override isNum(item: Item): boolean {\n    return item instanceof Num;\n  }\n\n  override isBool(item: Item): boolean {\n    return item instanceof Bool;\n  }\n\n  override isExpression(item: Item): boolean {\n    return item instanceof Expression;\n  }\n\n  override isExtant(item: Item): boolean {\n    return item instanceof Extant;\n  }\n\n  override items(item: Item): Cursor<Item> {\n    return item.iterator();\n  }\n\n  override item(value: Value): Item {\n    return value;\n  }\n\n  override key(item: Item): Value {\n    return item.key;\n  }\n\n  override value(item: Item): Value {\n    return item.toValue();\n  }\n\n  override string(item: Item): string {\n    return item.stringValue(\"\");\n  }\n\n  override precedence(item: Item): number {\n    return item.precedence;\n  }\n\n  override sizeOfItem(item: Item): number {\n    if (item instanceof Field) {\n      if (item instanceof Attr) {\n        return this.sizeOfAttr(item.key, item.value);\n      } else if (item instanceof Slot) {\n        return this.sizeOfSlot(item.key, item.value);\n      }\n    } else if (item instanceof Value) {\n      return this.sizeOfValue(item);\n    }\n    throw new WriterException(\"No Recon serialization for \" + item);\n  }\n\n  override writeItem(output: Output, item: Item): Writer {\n    if (item instanceof Field) {\n      if (item instanceof Attr) {\n        return this.writeAttr(output, item.key, item.value);\n      } else if (item instanceof Slot) {\n        return this.writeSlot(output, item.key, item.value);\n      }\n    } else if (item instanceof Value) {\n      return this.writeValue(output, item);\n    }\n    return Writer.error(new WriterException(\"No Recon serialization for \" + item));\n  }\n\n  override sizeOfValue(value: Value): number {\n    if (value instanceof Record) {\n      return this.sizeOfRecord(value);\n    } else if (value instanceof Data) {\n      return this.sizeOfData(value.size);\n    } else if (value instanceof Text) {\n      return this.sizeOfText(value.value);\n    } else if (value instanceof Num) {\n      if (value.isUint32()) {\n        return this.sizeOfUint32(value.value);\n      } else if (value.isUint64()) {\n        return this.sizeOfUint64(value.value);\n      } else {\n        return this.sizeOfNum(value.value);\n      }\n    } else if (value instanceof Bool) {\n      return this.sizeOfBool(value.value);\n    } else if (value instanceof Selector) {\n      return this.sizeOfSelector(value);\n    } else if (value instanceof Operator) {\n      return this.sizeOfOperator(value);\n    } else if (value instanceof Func) {\n      return this.sizeOfFunc(value);\n    } else if (value instanceof Extant) {\n      return this.sizeOfExtant();\n    } else if (value instanceof Absent) {\n      return this.sizeOfAbsent();\n    }\n    throw new WriterException(\"No Recon serialization for \" + value);\n  }\n\n  override writeValue(output: Output, value: Value): Writer {\n    if (value instanceof Record) {\n      return this.writeRecord(output, value);\n    } else if (value instanceof Data) {\n      return this.writeData(output, value.asUint8Array());\n    } else if (value instanceof Text) {\n      return this.writeText(output, value.value);\n    } else if (value instanceof Num) {\n      if (value.isUint32()) {\n        return this.writeUint32(output, value.value);\n      } else if (value.isUint64()) {\n        return this.writeUint64(output, value.value);\n      } else {\n        return this.writeNum(output, value.value);\n      }\n    } else if (value instanceof Bool) {\n      return this.writeBool(output, value.value);\n    } else if (value instanceof Selector) {\n      return this.writeSelector(output, value);\n    } else if (value instanceof Operator) {\n      return this.writeOperator(output, value);\n    } else if (value instanceof Func) {\n      return this.writeFunc(output, value);\n    } else if (value instanceof Extant) {\n      return this.writeExtant(output);\n    } else if (value instanceof Absent) {\n      return this.writeAbsent(output);\n    }\n    return Writer.error(new WriterException(\"No Recon serialization for \" + value));\n  }\n\n  sizeOfSelector(selector: Selector): number {\n    if (selector instanceof IdentitySelector) {\n      return this.sizeOfIdentitySelector();\n    } else if (selector instanceof LiteralSelector) {\n      return this.sizeOfLiteralSelector(selector.item, selector.then);\n    } else if (selector instanceof GetSelector) {\n      return this.sizeOfGetSelector(selector.item, selector.then);\n    } else if (selector instanceof GetAttrSelector) {\n      return this.sizeOfGetAttrSelector(selector.item, selector.then);\n    } else if (selector instanceof GetItemSelector) {\n      return this.sizeOfGetItemSelector(selector.item, selector.then);\n    } else if (selector instanceof KeysSelector) {\n      return this.sizeOfKeysSelector(selector.then);\n    } else if (selector instanceof ValuesSelector) {\n      return this.sizeOfValuesSelector(selector.then);\n    } else if (selector instanceof ChildrenSelector) {\n      return this.sizeOfChildrenSelector(selector.then);\n    } else if (selector instanceof DescendantsSelector) {\n      return this.sizeOfDescendantsSelector(selector.then);\n    } else if (selector instanceof FilterSelector) {\n      return this.sizeOfFilterSelector(selector.predicate, selector.then);\n    }\n    throw new WriterException(\"No Recon serialization for \" + selector);\n  }\n\n  writeSelector(output: Output, selector: Selector): Writer {\n    if (selector instanceof IdentitySelector) {\n      return this.writeIdentitySelector(output);\n    } else if (selector instanceof LiteralSelector) {\n      return this.writeLiteralSelector(output, selector.item, selector.then);\n    } else if (selector instanceof GetSelector) {\n      return this.writeGetSelector(output, selector.item, selector.then);\n    } else if (selector instanceof GetAttrSelector) {\n      return this.writeGetAttrSelector(output, selector.item, selector.then);\n    } else if (selector instanceof GetItemSelector) {\n      return this.writeGetItemSelector(output, selector.item, selector.then);\n    } else if (selector instanceof KeysSelector) {\n      return this.writeKeysSelector(output, selector.then);\n    } else if (selector instanceof ValuesSelector) {\n      return this.writeValuesSelector(output, selector.then);\n    } else if (selector instanceof ChildrenSelector) {\n      return this.writeChildrenSelector(output, selector.then);\n    } else if (selector instanceof DescendantsSelector) {\n      return this.writeDescendantsSelector(output, selector.then);\n    } else if (selector instanceof FilterSelector) {\n      return this.writeFilterSelector(output, selector.predicate, selector.then);\n    }\n    return Writer.error(new WriterException(\"No Recon serialization for \" + selector));\n  }\n\n  sizeOfOperator(operator: Operator): number {\n    if (operator instanceof BinaryOperator) {\n      return this.sizeOfInfixOperator(operator.operand1, operator.operator, operator.operand2, operator.precedence);\n    } else if (operator instanceof UnaryOperator) {\n      return this.sizeOfPrefixOperator(operator.operator, operator.operand, operator.precedence);\n    } else if (operator instanceof InvokeOperator) {\n      return this.sizeOfInvokeOperator(operator.func, operator.args);\n    } else if (operator instanceof ConditionalOperator) {\n      return this.sizeOfConditionalOperator(operator.ifTerm, operator.thenTerm, operator.elseTerm, operator.precedence);\n    }\n    throw new WriterException(\"No Recon serialization for \" + operator);\n  }\n\n  writeOperator(output: Output, operator: Operator): Writer {\n    if (operator instanceof BinaryOperator) {\n      return this.writeInfixOperator(output, operator.operand1, operator.operator, operator.operand2, operator.precedence);\n    } else if (operator instanceof UnaryOperator) {\n      return this.writePrefixOperator(output, operator.operator, operator.operand, operator.precedence);\n    } else if (operator instanceof InvokeOperator) {\n      return this.writeInvokeOperator(output, operator.func, operator.args);\n    } else if (operator instanceof ConditionalOperator) {\n      return this.writeConditionalOperator(output, operator.ifTerm, operator.thenTerm, operator.elseTerm, operator.precedence);\n    }\n    return Writer.error(new WriterException(\"No Recon serialization for \" + operator));\n  }\n\n  sizeOfFunc(func: Func): number {\n    if (func instanceof LambdaFunc) {\n      return this.sizeOfLambdaFunc(func.bindings, func.template);\n    } else if (func instanceof BridgeFunc) {\n      return 0;\n    }\n    throw new WriterException(\"No Recon serialization for \" + func);\n  }\n\n  writeFunc(output: Output, func: Func): Writer {\n    if (func instanceof LambdaFunc) {\n      return this.writeLambdaFunc(output, func.bindings, func.template);\n    } else if (func instanceof BridgeFunc) {\n      return Writer.end();\n    }\n    return Writer.error(new WriterException(\"No Recon serialization for \" + func));\n  }\n\n  override sizeOfBlockItem(item: Item): number {\n    if (item instanceof Field) {\n      return this.sizeOfItem(item);\n    } else if (item instanceof Value) {\n      return this.sizeOfBlockValue(item);\n    }\n    throw new WriterException(\"No Recon serialization for \" + item);\n  }\n\n  override writeBlockItem(output: Output, item: Item): Writer {\n    if (item instanceof Field) {\n      return this.writeItem(output, item);\n    } else if (item instanceof Value) {\n      return this.writeBlockValue(output, item);\n    }\n    return Writer.error(new WriterException(\"No Recon serialization for \" + item));\n  }\n\n  override sizeOfBlockValue(value: Value): number {\n    if (value instanceof Record) {\n      return this.sizeOfBlock(value);\n    }\n    return this.sizeOfValue(value);\n  }\n\n  override writeBlockValue(output: Output, value: Value): Writer {\n    if (value instanceof Record) {\n      return this.writeBlock(output, value);\n    }\n    return this.writeValue(output, value);\n  }\n\n  override sizeOfThen(then: Value): number {\n    if (then instanceof Selector) {\n      if (then instanceof IdentitySelector) {\n        return this.sizeOfThenIdentitySelector();\n      } else if (then instanceof LiteralSelector) {\n        return this.sizeOfThenLiteralSelector(then.item, then.then);\n      } else if (then instanceof GetSelector) {\n        return this.sizeOfThenGetSelector(then.item, then.then);\n      } else if (then instanceof GetAttrSelector) {\n        return this.sizeOfThenGetAttrSelector(then.item, then.then);\n      } else if (then instanceof GetItemSelector) {\n        return this.sizeOfThenGetItemSelector(then.item, then.then);\n      } else if (then instanceof KeysSelector) {\n        return this.sizeOfThenKeysSelector(then.then);\n      } else if (then instanceof ValuesSelector) {\n        return this.sizeOfThenValuesSelector(then.then);\n      } else if (then instanceof ChildrenSelector) {\n        return this.sizeOfThenChildrenSelector(then.then);\n      } else if (then instanceof DescendantsSelector) {\n        return this.sizeOfThenDescendantsSelector(then.then);\n      } else if (then instanceof FilterSelector) {\n        return this.sizeOfThenFilterSelector(then.predicate, then.then);\n      }\n    }\n    throw new WriterException(\"No Recon serialization for \" + then);\n  }\n\n  override writeThen(output: Output, then: Value): Writer {\n    if (then instanceof Selector) {\n      if (then instanceof IdentitySelector) {\n        return this.writeThenIdentitySelector(output);\n      } else if (then instanceof LiteralSelector) {\n        return this.writeThenLiteralSelector(output, then.item, then.then);\n      } else if (then instanceof GetSelector) {\n        return this.writeThenGetSelector(output, then.item, then.then);\n      } else if (then instanceof GetAttrSelector) {\n        return this.writeThenGetAttrSelector(output, then.item, then.then);\n      } else if (then instanceof GetItemSelector) {\n        return this.writeThenGetItemSelector(output, then.item, then.then);\n      } else if (then instanceof KeysSelector) {\n        return this.writeThenKeysSelector(output, then.then);\n      } else if (then instanceof ValuesSelector) {\n        return this.writeThenValuesSelector(output, then.then);\n      } else if (then instanceof ChildrenSelector) {\n        return this.writeThenChildrenSelector(output, then.then);\n      } else if (then instanceof DescendantsSelector) {\n        return this.writeThenDescendantsSelector(output, then.then);\n      } else if (then instanceof FilterSelector) {\n        return this.writeThenFilterSelector(output, then.predicate, then.then);\n      }\n    }\n    return Writer.error(new WriterException(\"No Recon serialization for \" + then));\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Compare} from \"@swim/util\";\nimport {Strings} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport type {Display} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport {Base16} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport type {Item} from \"@swim/structure\";\nimport {Text} from \"@swim/structure\";\nimport {Form} from \"@swim/structure\";\nimport type {UriSchemeLike} from \"./UriScheme\";\nimport {UriScheme} from \"./\"; // forward import\nimport type {UriAuthorityLike} from \"./UriAuthority\";\nimport type {UriAuthorityInit} from \"./UriAuthority\";\nimport {UriAuthority} from \"./\"; // forward import\nimport type {UriUserLike} from \"./UriUser\";\nimport type {UriUser} from \"./UriUser\";\nimport type {UriHostLike} from \"./UriHost\";\nimport type {UriHost} from \"./UriHost\";\nimport type {UriPortLike} from \"./UriPort\";\nimport type {UriPort} from \"./UriPort\";\nimport type {UriPathLike} from \"./UriPath\";\nimport {UriPath} from \"./\"; // forward import\nimport {UriPathBuilder} from \"./\"; // forward import\nimport type {UriQueryLike} from \"./UriQuery\";\nimport {UriQuery} from \"./\"; // forward import\nimport {UriQueryBuilder} from \"./\"; // forward import\nimport type {UriFragmentLike} from \"./UriFragment\";\nimport {UriFragment} from \"./\"; // forward import\nimport {UriSchemeParser} from \"./\"; // forward import\nimport {UriAuthorityParser} from \"./\"; // forward import\nimport {UriPathParser} from \"./\"; // forward import\nimport {UriQueryParser} from \"./\"; // forward import\nimport {UriFragmentParser} from \"./\"; // forward import\n\n/** @public */\nexport type UriLike = Uri | UriInit | string;\n\n/** @public */\nexport const UriLike = {\n  [Symbol.hasInstance](instance: unknown): instance is UriLike {\n    return instance instanceof Uri\n        || UriInit[Symbol.hasInstance](instance)\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport interface UriInit extends UriAuthorityInit {\n  /** @internal */\n  readonly typeid?: \"UriInit\";\n  scheme?: UriSchemeLike;\n  authority?: UriAuthorityLike;\n  path?: UriPathLike;\n  query?: UriQueryLike;\n  fragment?: UriFragmentLike;\n}\n\n/** @public */\nexport const UriInit = {\n  [Symbol.hasInstance](instance: unknown): instance is UriInit {\n    return Objects.hasAnyKey<UriInit>(instance, \"scheme\", \"authority\", \"path\", \"query\", \"fragment\");\n  },\n};\n\n/** @public */\nexport class Uri implements HashCode, Compare, Debug, Display {\n  /** @internal */\n  constructor(scheme: UriScheme, authority: UriAuthority, path: UriPath,\n              query: UriQuery, fragment: UriFragment) {\n    this.scheme = scheme;\n    this.authority = authority;\n    this.path = path;\n    this.query = query;\n    this.fragment = fragment;\n    this.hashValue = void 0;\n    this.stringValue = void 0;\n  }\n\n  /** @internal */\n  declare readonly typeid?: \"Uri\";\n\n  likeType?(like: UriInit | string): void;\n\n  isDefined(): boolean {\n    return this.scheme.isDefined() || this.authority.isDefined() || this.path.isDefined()\n        || this.query.isDefined() || this.fragment.isDefined();\n  }\n\n  isEmpty(): boolean {\n    return !this.scheme.isDefined() && !this.authority.isDefined() && this.path.isEmpty()\n        && !this.query.isDefined() && !this.fragment.isDefined();\n  }\n\n  readonly scheme: UriScheme;\n\n  withScheme(scheme: UriSchemeLike): Uri {\n    scheme = UriScheme.fromLike(scheme);\n    if (scheme === this.scheme) {\n      return this;\n    }\n    return this.copy(scheme, this.authority, this.path, this.query, this.fragment);\n  }\n\n  get schemePart(): string {\n    return this.scheme.toString();\n  }\n\n  withSchemePart(schemePart: string): Uri {\n    return this.withScheme(UriScheme.parse(schemePart));\n  }\n\n  get schemeName(): string {\n    return this.scheme.name;\n  }\n\n  withSchemeName(schemeName: string): Uri {\n    return this.withScheme(UriScheme.create(schemeName));\n  }\n\n  readonly authority: UriAuthority;\n\n  withAuthority(authority: UriAuthorityLike): Uri {\n    authority = UriAuthority.fromLike(authority);\n    if (authority === this.authority) {\n      return this;\n    }\n    return this.copy(this.scheme, authority, this.path, this.query, this.fragment);\n  }\n\n  get authorityPart(): string {\n    return this.authority.toString();\n  }\n\n  withAuthorityPart(authorityPart: string): Uri {\n    return this.withAuthority(UriAuthority.parse(authorityPart));\n  }\n\n  get user(): UriUser {\n    return this.authority.user;\n  }\n\n  withUser(user: UriUserLike): Uri {\n    return this.withAuthority(this.authority.withUser(user));\n  }\n\n  get userPart(): string {\n    return this.authority.userPart;\n  }\n\n  withUserPart(userPart: string): Uri {\n    return this.withAuthority(this.authority.withUserPart(userPart));\n  }\n\n  get username(): string | undefined {\n    return this.authority.username;\n  }\n\n  withUsername(username: string | undefined, password?: string): Uri {\n    if (arguments.length === 1) {\n      return this.withAuthority(this.authority.withUsername(username));\n    } else if (arguments.length === 2) {\n      return this.withAuthority(this.authority.withUsername(username, password));\n    }\n    throw new Error(arguments.toString());\n  }\n\n  get password(): string | undefined {\n    return this.authority.password;\n  }\n\n  withPassword(password: string | undefined): Uri {\n    return this.withAuthority(this.authority.withPassword(password));\n  }\n\n  get host(): UriHost {\n    return this.authority.host;\n  }\n\n  withHost(host: UriHostLike): Uri {\n    return this.withAuthority(this.authority.withHost(host));\n  }\n\n  get hostPart(): string {\n    return this.authority.hostPart;\n  }\n\n  withHostPart(hostPart: string): Uri {\n    return this.withAuthority(this.authority.withHostPart(hostPart));\n  }\n\n  get hostAddress(): string {\n    return this.authority.hostAddress;\n  }\n\n  get hostName(): string | undefined {\n    return this.authority.hostName;\n  }\n\n  withHostName(hostName: string): Uri {\n    return this.withAuthority(this.authority.withHostName(hostName));\n  }\n\n  get hostIPv4(): string | undefined {\n    return this.authority.hostIPv4;\n  }\n\n  withHostIPv4(hostIPv4: string): Uri {\n    return this.withAuthority(this.authority.withHostIPv4(hostIPv4));\n  }\n\n  get hostIPv6(): string | undefined {\n    return this.authority.hostIPv6;\n  }\n\n  withHostIPv6(hostIPv6: string): Uri {\n    return this.withAuthority(this.authority.withHostIPv6(hostIPv6));\n  }\n\n  get port(): UriPort {\n    return this.authority.port;\n  }\n\n  withPort(port: UriPortLike): Uri {\n    return this.withAuthority(this.authority.withPort(port));\n  }\n\n  get portPart(): string {\n    return this.authority.portPart;\n  }\n\n  withPortPart(portPart: string): Uri {\n    return this.withAuthority(this.authority.withPortPart(portPart));\n  }\n\n  get portNumber(): number {\n    return this.authority.portNumber;\n  }\n\n  withPortNumber(portNumber: number): Uri {\n    return this.withAuthority(this.authority.withPortNumber(portNumber));\n  }\n\n  readonly path: UriPath;\n\n  withPath(...components: UriPathLike[]): Uri {\n    const path = UriPath.of(...components);\n    if (path === this.path) {\n      return this;\n    }\n    return this.copy(this.scheme, this.authority, path, this.query, this.fragment);\n  }\n\n  get pathPart(): string {\n    return this.path.toString();\n  }\n\n  withPathPart(pathPart: string): Uri {\n    return this.withPath(UriPath.parse(pathPart));\n  }\n\n  get pathName(): string {\n    return this.path.name;\n  }\n\n  withPathName(pathName: string): Uri {\n    return this.withPath(this.path.withName(pathName));\n  }\n\n  parentPath(): UriPath {\n    return this.path.parent();\n  }\n\n  basePath(): UriPath {\n    return this.path.base();\n  }\n\n  parent(): Uri {\n    return Uri.create(this.scheme, this.authority, this.path.parent());\n  }\n\n  base(): Uri {\n    return Uri.create(this.scheme, this.authority, this.path.base());\n  }\n\n  appendedPath(...components: UriPathLike[]): Uri {\n    return this.withPath(this.path.appended(...components));\n  }\n\n  appendedSlash(): Uri {\n    return this.withPath(this.path.appendedSlash());\n  }\n\n  appendedSegment(segment: string): Uri {\n    return this.withPath(this.path.appendedSegment(segment));\n  }\n\n  prependedPath(...components: UriPathLike[]): Uri {\n    return this.withPath(this.path.prepended(...components));\n  }\n\n  prependedSlash(): Uri {\n    return this.withPath(this.path.prependedSlash());\n  }\n\n  prependedSegment(segment: string): Uri {\n    return this.withPath(this.path.prependedSegment(segment));\n  }\n\n  readonly query: UriQuery;\n\n  withQuery(query: UriQueryLike): Uri {\n    query = UriQuery.fromLike(query);\n    if (query === this.query) {\n      return this;\n    }\n    return this.copy(this.scheme, this.authority, this.path, query, this.fragment);\n  }\n\n  get queryPart(): string {\n    return this.query.toString();\n  }\n\n  withQueryPart(query: string): Uri {\n    return this.withQuery(UriQuery.parse(query));\n  }\n\n  updatedQuery(key: string, value: string): Uri {\n    return this.withQuery(this.query.updated(key, value));\n  }\n\n  removedQuery(key: string): Uri {\n    return this.withQuery(this.query.removed(key));\n  }\n\n  appendedQuery(key: string | undefined, value: string): Uri;\n  appendedQuery(params: UriQueryLike): Uri;\n  appendedQuery(key: UriQueryLike | undefined, value?: string): Uri {\n    return this.withQuery(this.query.appended(key as any, value as any));\n  }\n\n  prependedQuery(key: string | undefined, value: string): Uri;\n  prependedQuery(params: UriQueryLike): Uri;\n  prependedQuery(key: UriQueryLike | undefined, value?: string): Uri {\n    return this.withQuery(this.query.prepended(key as any, value as any));\n  }\n\n  readonly fragment: UriFragment;\n\n  withFragment(fragment: UriFragmentLike): Uri {\n    fragment = UriFragment.fromLike(fragment);\n    if (fragment === this.fragment) {\n      return this;\n    }\n    return Uri.create(this.scheme, this.authority, this.path, this.query, fragment);\n  }\n\n  get fragmentPart(): string {\n    return this.fragment.toString();\n  }\n\n  withFragmentPart(fragmentPart: string): Uri {\n    return this.withFragment(UriFragment.parse(fragmentPart));\n  }\n\n  get fragmentIdentifier(): string | undefined {\n    return this.fragment.identifier;\n  }\n\n  withFragmentIdentifier(fragmentIdentifier: string | undefined): Uri {\n    return this.withFragment(UriFragment.create(fragmentIdentifier));\n  }\n\n  endpoint(): Uri {\n    if (!this.path.isDefined() && !this.query.isDefined() && !this.fragment.isDefined()) {\n      return this;\n    }\n    return Uri.create(this.scheme, this.authority);\n  }\n\n  resolve(relative: UriLike): Uri {\n    const that = Uri.fromLike(relative);\n    if (that.scheme.isDefined()) {\n      return this.copy(that.scheme,\n                       that.authority,\n                       that.path.removeDotSegments(),\n                       that.query,\n                       that.fragment);\n    } else if (that.authority.isDefined()) {\n      return this.copy(this.scheme,\n                       that.authority,\n                       that.path.removeDotSegments(),\n                       that.query,\n                       that.fragment);\n    } else if (that.path.isEmpty()) {\n      return this.copy(this.scheme,\n                       this.authority,\n                       this.path,\n                       that.query.isDefined() ? that.query : this.query,\n                       that.fragment);\n    } else if (that.path.isAbsolute()) {\n      return this.copy(this.scheme,\n                       this.authority,\n                       that.path.removeDotSegments(),\n                       that.query,\n                       that.fragment);\n    }\n    return this.copy(this.scheme,\n                     this.authority,\n                     this.merge(that.path).removeDotSegments(),\n                     that.query,\n                     that.fragment);\n  }\n\n  /** @internal */\n  merge(relative: UriPath): UriPath {\n    if (this.authority.isDefined() && this.path.isEmpty()) {\n      return relative.prependedSlash();\n    } else if (this.path.isEmpty()) {\n      return relative;\n    }\n    return this.path.merge(relative);\n  }\n\n  unresolve(absolute: UriLike): Uri {\n    const that = Uri.fromLike(absolute);\n    if (!this.scheme.equals(that.scheme) || !this.authority.equals(that.authority)) {\n      return that;\n    }\n    return Uri.create(UriScheme.undefined(),\n                      UriAuthority.undefined(),\n                      this.path.unmerge(that.path),\n                      that.query,\n                      that.fragment);\n  }\n\n  protected copy(scheme: UriScheme, authority: UriAuthority, path: UriPath,\n                 query: UriQuery, fragment: UriFragment): Uri {\n    return Uri.create(scheme, authority, path, query, fragment);\n  }\n\n  toLike(): {scheme?: string, username?: string, password?: string, host?: string,\n             port?: number, path: string[], query?: {[key: string]: string},\n             fragment?: string} {\n    const uri = {} as {scheme?: string, username?: string, password?: string, host?: string,\n                       port?: number, path: string[], query?: {[key: string]: string},\n                       fragment?: string};\n    uri.scheme = this.scheme.toLike();\n    this.authority.toLike(uri);\n    uri.path = this.path.toLike();\n    uri.query = this.query.toLike();\n    uri.fragment = this.fragment.toLike();\n    return uri;\n  }\n\n  /** @override */\n  compareTo(that: Uri): number {\n    if (that instanceof Uri) {\n      return this.toString().localeCompare(that.toString());\n    }\n    return NaN;\n  }\n\n  /** @override */\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Uri) {\n      return this.toString() === that.toString();\n    }\n    return false;\n  }\n\n  /** @internal */\n  readonly hashValue: number | undefined;\n\n  /** @override */\n  hashCode(): number {\n    let hashValue = this.hashValue;\n    if (hashValue === void 0) {\n      hashValue = Strings.hash(this.toString());\n      (this as Mutable<this>).hashValue = hashValue;\n    }\n    return hashValue;\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Uri\").write(46/*'.'*/);\n    if (this.isDefined()) {\n      output = output.write(\"parse\").write(40/*'('*/).write(34/*'\"'*/).display(this).write(34/*'\"'*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"empty\").write(40/*'('*/).write(41/*')'*/);\n    }\n    return output;\n  }\n\n  /** @internal */\n  readonly stringValue: string | undefined;\n\n  /** @override */\n  display<T>(output: Output<T>): Output<T> {\n    const stringValue = this.stringValue;\n    if (stringValue !== void 0) {\n      output = output.write(stringValue);\n    } else {\n      if (this.scheme.isDefined()) {\n        output = output.display(this.scheme).write(58/*':'*/);\n      }\n      if (this.authority.isDefined()) {\n        output = output.write(47/*'/'*/).write(47/*'/'*/).display(this.authority);\n      }\n      output = output.display(this.path);\n      if (this.query.isDefined()) {\n        output = output.write(63/*'?'*/).display(this.query);\n      }\n      if (this.fragment.isDefined()) {\n        output = output.write(35/*'#'*/).display(this.fragment);\n      }\n    }\n    return output;\n  }\n\n  /** @override */\n  toString(): string {\n    let stringValue = this.stringValue;\n    if (stringValue === void 0) {\n      stringValue = Format.display(this);\n      (this as Mutable<this>).stringValue = stringValue;\n    }\n    return stringValue;\n  }\n\n  @Lazy\n  static empty(): Uri {\n    return new Uri(UriScheme.undefined(), UriAuthority.undefined(), UriPath.empty(),\n                         UriQuery.undefined(), UriFragment.undefined());\n  }\n\n  static create(scheme: UriScheme = UriScheme.undefined(),\n                authority: UriAuthority = UriAuthority.undefined(),\n                path: UriPath = UriPath.empty(),\n                query: UriQuery = UriQuery.undefined(),\n                fragment: UriFragment = UriFragment.undefined()): Uri {\n    if (!scheme.isDefined() && !authority.isDefined() && !path.isDefined()\n        && !query.isDefined() && !fragment.isDefined()) {\n      return Uri.empty();\n    }\n    return new Uri(scheme, authority, path, query, fragment);\n  }\n\n  static fromLike<T extends UriLike | null | undefined>(value: T): Uri | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof Uri) {\n      return value as Uri | Uninitable<T>;\n    } else if (typeof value === \"object\") {\n      return Uri.fromInit(value);\n    } else if (typeof value === \"string\") {\n      return Uri.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromInit(init: UriInit): Uri {\n    const scheme = UriScheme.fromLike(init.scheme);\n    const authority = UriAuthority.fromLike(init.authority);\n    const path = UriPath.fromLike(init.path);\n    const query = UriQuery.fromLike(init.query);\n    const fragment = UriFragment.fromLike(init.fragment);\n    return this.create(scheme, authority, path, query, fragment);\n  }\n\n  static scheme(scheme: UriSchemeLike): Uri {\n    scheme = UriScheme.fromLike(scheme);\n    return Uri.create(scheme, void 0, void 0, void 0, void 0);\n  }\n\n  static schemePart(schemePart: string): Uri {\n    const scheme = UriScheme.parse(schemePart);\n    return Uri.create(scheme, void 0, void 0, void 0, void 0);\n  }\n\n  static schemeName(name: string): Uri {\n    const scheme = UriScheme.create(name);\n    return Uri.create(scheme, void 0, void 0, void 0, void 0);\n  }\n\n  static authority(authority: UriAuthorityLike): Uri {\n    authority = UriAuthority.fromLike(authority);\n    return Uri.create(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static authorityPart(authorityPart: string): Uri {\n    const authority = UriAuthority.parse(authorityPart);\n    return Uri.create(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static user(user: UriUserLike): Uri {\n    const authority = UriAuthority.user(user);\n    return Uri.create(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static userPart(userPart: string): Uri {\n    const authority = UriAuthority.userPart(userPart);\n    return Uri.create(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static username(username: string, password?: string): Uri {\n    const authority = UriAuthority.username(username, password);\n    return Uri.create(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static password(password: string): Uri {\n    const authority = UriAuthority.password(password);\n    return Uri.create(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static host(host: UriHostLike): Uri {\n    const authority = UriAuthority.host(host);\n    return Uri.create(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static hostPart(hostPart: string): Uri {\n    const authority = UriAuthority.hostPart(hostPart);\n    return Uri.create(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static hostName(hostName: string): Uri {\n    const authority = UriAuthority.hostName(hostName);\n    return Uri.create(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static hostIPv4(hostIPv4: string): Uri {\n    const authority = UriAuthority.hostIPv4(hostIPv4);\n    return Uri.create(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static hostIPv6(hostIPv6: string): Uri {\n    const authority = UriAuthority.hostIPv6(hostIPv6);\n    return Uri.create(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static port(port: UriPortLike): Uri {\n    const authority = UriAuthority.port(port);\n    return Uri.create(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static portPart(portPart: string): Uri {\n    const authority = UriAuthority.portPart(portPart);\n    return Uri.create(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static portNumber(portNumber: number): Uri {\n    const authority = UriAuthority.portNumber(portNumber);\n    return Uri.create(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static path(...components: UriPathLike[]): Uri {\n    const path = UriPath.of(...components);\n    return Uri.create(void 0, void 0, path, void 0, void 0);\n  }\n\n  static pathPart(pathPart: string): Uri {\n    const path = UriPath.parse(pathPart);\n    return Uri.create(void 0, void 0, path, void 0, void 0);\n  }\n\n  static query(query: UriQueryLike): Uri {\n    query = UriQuery.fromLike(query);\n    return Uri.create(void 0, void 0, void 0, query, void 0);\n  }\n\n  static queryPart(queryPart: string): Uri {\n    const query = UriQuery.parse(queryPart);\n    return Uri.create(void 0, void 0, void 0, query, void 0);\n  }\n\n  static fragment(fragment: UriFragmentLike): Uri {\n    fragment = UriFragment.fromLike(fragment);\n    return Uri.create(void 0, void 0, void 0, void 0, fragment);\n  }\n\n  static fragmentPart(fragmentPart: string): Uri {\n    const fragment = UriFragment.parse(fragmentPart);\n    return Uri.create(void 0, void 0, void 0, void 0, fragment);\n  }\n\n  static fragmentIdentifier(fragmentIdentifier: string | undefined): Uri {\n    const fragment = UriFragment.create(fragmentIdentifier);\n    return Uri.create(void 0, void 0, void 0, void 0, fragment);\n  }\n\n  /** @internal */\n  static ParseCacheCapacity: number = 256;\n\n  /** @internal */\n  @Lazy\n  static parseCache(): Map<string, Uri> {\n    return new Map<string, Uri>();\n  }\n\n  static parse(input: Input): Parser<Uri>;\n  static parse(string: string): Uri;\n  static parse(string: Input | string): Parser<Uri> | Uri {\n    const parseCache = this.parseCache();\n    let uri: Uri | undefined;\n    if (typeof string === \"string\") {\n      uri = parseCache.get(string);\n      if (uri !== void 0) {\n        parseCache.delete(string);\n      }\n    }\n\n    let parser: Parser<Uri>;\n    if (uri === void 0) {\n      const input = typeof string === \"string\" ? Unicode.stringInput(string) : string;\n      parser = UriParser.parse(input);\n      if (typeof string === \"string\" && input.isCont() && !parser.isError()) {\n        parser = Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n\n    if (typeof string === \"string\") {\n      if (uri === void 0) {\n        uri = parser!.bind();\n      }\n      parseCache.set(string, uri);\n      const capacity = Uri.ParseCacheCapacity;\n      let size = parseCache.size;\n      if (size > capacity) {\n        const keys = parseCache.keys();\n        let next: IteratorResult<string>;\n        while (size > capacity && (next = keys.next()).done !== true) {\n          parseCache.delete(next.value);\n          size -= 1;\n        }\n      }\n      return uri;\n    }\n    return parser!;\n  }\n\n  static pathBuilder(): UriPathBuilder {\n    return new UriPathBuilder();\n  }\n\n  static queryBuilder(): UriQueryBuilder {\n    return new UriQueryBuilder();\n  }\n\n  @Lazy\n  static form(): Form<Uri, UriLike> {\n    return new UriForm(Uri.empty());\n  }\n\n  /** @internal */\n  static isUnreservedChar(c: number): boolean {\n    return c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/\n        || c >= 48/*'0'*/ && c <= 57/*'9'*/\n        || c === 45/*'-'*/ || c === 46/*'.'*/\n        || c === 95/*'_'*/ || c === 126/*'~'*/;\n  }\n\n  /** @internal */\n  static isSubDelimChar(c: number): boolean {\n    return c === 33/*'!'*/ || c === 36/*'$'*/\n        || c === 38/*'&'*/ || c === 40/*'('*/\n        || c === 41/*')'*/ || c === 42/*'*'*/\n        || c === 43/*'+'*/ || c === 44/*','*/\n        || c === 59/*';'*/ || c === 61/*'='*/\n        || c === 39/*'\\''*/;\n  }\n\n  /** @internal */\n  static isSchemeChar(c: number): boolean {\n    return c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/\n        || c >= 48/*'0'*/ && c <= 57/*'9'*/\n        || c === 43/*'+'*/ || c === 45/*'-'*/\n        || c === 46/*'.'*/;\n  }\n\n  /** @internal */\n  static isUserInfoChar(c: number): boolean {\n    return Uri.isUnreservedChar(c)\n        || Uri.isSubDelimChar(c)\n        || c === 58/*':'*/;\n  }\n\n  /** @internal */\n  static isUserChar(c: number): boolean {\n    return Uri.isUnreservedChar(c)\n        || Uri.isSubDelimChar(c);\n  }\n\n  /** @internal */\n  static isHostChar(c: number): boolean {\n    return Uri.isUnreservedChar(c)\n        || Uri.isSubDelimChar(c);\n  }\n\n  /** @internal */\n  static isPathChar(c: number): boolean {\n    return Uri.isUnreservedChar(c)\n        || Uri.isSubDelimChar(c)\n        || c === 58/*':'*/ || c === 64/*'@'*/;\n  }\n\n  /** @internal */\n  static isQueryChar(c: number): boolean {\n    return Uri.isUnreservedChar(c)\n        || Uri.isSubDelimChar(c)\n        || c === 47/*'/'*/ || c === 58/*':'*/\n        || c === 63/*'?'*/ || c === 64/*'@'*/;\n  }\n\n  /** @internal */\n  static isParamChar(c: number): boolean {\n    return Uri.isUnreservedChar(c)\n        || c === 33/*'!'*/ || c === 36/*'$'*/\n        || c === 40/*'('*/ || c === 41/*')'*/\n        || c === 42/*'*'*/ || c === 43/*'+'*/\n        || c === 44/*','*/ || c === 47/*'/'*/\n        || c === 58/*':'*/ || c === 59/*';'*/\n        || c === 63/*'?'*/ || c === 64/*'@'*/\n        || c === 39/*'\\''*/;\n  }\n\n  /** @internal */\n  static isFragmentChar(c: number): boolean {\n    return Uri.isUnreservedChar(c)\n        || Uri.isSubDelimChar(c)\n        || c === 47/*'/'*/ || c === 58/*':'*/\n        || c === 63/*'?'*/ || c === 64/*'@'*/;\n  }\n\n  /** @internal */\n  static isAlpha(c: number): boolean {\n    return c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/;\n  }\n\n  /** @internal */\n  static toLowerCase(c: number): number {\n    if (c >= 65/*'A'*/ && c <= 90/*'Z'*/) {\n      return c + (97/*'a'*/ - 65/*'A'*/);\n    }\n    return c;\n  }\n\n  /** @internal */\n  static writeScheme<T>(output: Output<T>, scheme: string): Output<T> {\n    if (scheme.length === 0 || !Uri.isAlpha(scheme.charCodeAt(0))) {\n      return Output.error(new Error(\"Invalid scheme: \" + scheme));\n    }\n    for (let i = 0; i < scheme.length; i += 1) {\n      const c = scheme.charCodeAt(i);\n      if (!Uri.isSchemeChar(c)) {\n        return Output.error(new Error(\"Invalid scheme: \" + scheme));\n      }\n      output = output.write(c);\n    }\n    return output;\n  }\n\n  /** @internal */\n  static writeUserInfo<T>(output: Output<T>, userInfo: string): Output<T> {\n    for (let i = 0; i < userInfo.length; i += 1) {\n      const c = userInfo.charCodeAt(i);\n      if (Uri.isUserInfoChar(c)) {\n        output = output.write(c);\n      } else {\n        output = Uri.writeEncoded(output, c);\n      }\n    }\n    return output;\n  }\n\n  /** @internal */\n  static writeUser<T>(output: Output<T>, user: string): Output<T> {\n    for (let i = 0; i < user.length; i += 1) {\n      const c = user.charCodeAt(i);\n      if (Uri.isUserChar(c)) {\n        output = output.write(c);\n      } else {\n        output = Uri.writeEncoded(output, c);\n      }\n    }\n    return output;\n  }\n\n  /** @internal */\n  static writeHost<T>(output: Output<T>, address: string): Output<T> {\n    for (let i = 0; i < address.length; i += 1) {\n      const c = address.charCodeAt(i);\n      if (Uri.isHostChar(c)) {\n        output = output.write(c);\n      } else {\n        output = Uri.writeEncoded(output, c);\n      }\n    }\n    return output;\n  }\n\n  /** @internal */\n  static writeHostLiteral<T>(output: Output<T>, address: string): Output<T> {\n    for (let i = 0; i < address.length; i += 1) {\n      const c = address.charCodeAt(i);\n      if (Uri.isHostChar(c) || c === 58/*':'*/) {\n        output = output.write(c);\n      } else {\n        output = Uri.writeEncoded(output, c);\n      }\n    }\n    return output;\n  }\n\n  /** @internal */\n  static writePathSegment<T>(output: Output<T>, segment: string): Output<T> {\n    for (let i = 0; i < segment.length; i += 1) {\n      const c = segment.charCodeAt(i);\n      if (Uri.isPathChar(c)) {\n        output = output.write(c);\n      } else {\n        output = Uri.writeEncoded(output, c);\n      }\n    }\n    return output;\n  }\n\n  /** @internal */\n  static writeQuery<T>(output: Output<T>, query: string): Output<T> {\n    for (let i = 0; i < query.length; i += 1) {\n      const c = query.charCodeAt(i);\n      if (Uri.isQueryChar(c)) {\n        output = output.write(c);\n      } else {\n        output = Uri.writeEncoded(output, c);\n      }\n    }\n    return output;\n  }\n\n  /** @internal */\n  static writeParam<T>(output: Output<T>, param: string): Output<T> {\n    for (let i = 0; i < param.length; i += 1) {\n      const c = param.charCodeAt(i);\n      if (Uri.isParamChar(c)) {\n        output = output.write(c);\n      } else {\n        output = Uri.writeEncoded(output, c);\n      }\n    }\n    return output;\n  }\n\n  /** @internal */\n  static writeFragment<T>(output: Output<T>, fragment: string): Output<T> {\n    for (let i = 0; i < fragment.length; i += 1) {\n      const c = fragment.charCodeAt(i);\n      if (Uri.isFragmentChar(c)) {\n        output = output.write(c);\n      } else {\n        output = Uri.writeEncoded(output, c);\n      }\n    }\n    return output;\n  }\n\n  /** @internal */\n  static writeEncoded<T>(output: Output<T>, c: number): Output<T> {\n    if (c === 0x00) { // modified UTF-8\n      output = Uri.writePctEncoded(output, 0xC0);\n      output = Uri.writePctEncoded(output, 0x80);\n    } else if (c >= 0x00 && c <= 0x7F) { // U+0000..U+007F\n      output = Uri.writePctEncoded(output, c);\n    } else if (c >= 0x80 && c <= 0x07FF) { // U+0080..U+07FF\n      output = Uri.writePctEncoded(output, 0xC0 | (c >>> 6));\n      output = Uri.writePctEncoded(output, 0x80 | (c & 0x3F));\n    } else if (c >= 0x0800 && c <= 0xFFFF) { // U+0800..U+D7FF, U+E000..U+FFFF, and surrogates\n      output = Uri.writePctEncoded(output, 0xE0 | (c >>> 12));\n      output = Uri.writePctEncoded(output, 0x80 | (c >>> 6 & 0x3F));\n      output = Uri.writePctEncoded(output, 0x80 | (c & 0x3F));\n    } else if (c >= 0x10000 && c <= 0x10FFFF) { // U+10000..U+10FFFF\n      output = Uri.writePctEncoded(output, 0xF0 | (c >>> 18));\n      output = Uri.writePctEncoded(output, 0x80 | (c >>> 12 & 0x3F));\n      output = Uri.writePctEncoded(output, 0x80 | (c >>> 6 & 0x3F));\n      output = Uri.writePctEncoded(output, 0x80 | (c & 0x3F));\n    } else { // surrogate or invalid code point\n      output = Uri.writePctEncoded(output, 0xEF);\n      output = Uri.writePctEncoded(output, 0xBF);\n      output = Uri.writePctEncoded(output, 0xBD);\n    }\n    return output;\n  }\n\n  /** @internal */\n  static writePctEncoded<T>(output: Output<T>, c: number): Output<T> {\n    const base16 = Base16.lowercase;\n    output = output.write(37/*'%'*/)\n                   .write(base16.encodeDigit(c >>> 4 & 0xF))\n                   .write(base16.encodeDigit(c       & 0xF));\n    return output;\n  }\n}\n\n/** @internal */\nexport class UriForm extends Form<Uri, UriLike> {\n  constructor(unit: Uri | undefined) {\n    super();\n    Object.defineProperty(this, \"unit\", {\n      value: unit,\n      enumerable: true,\n      configurable: true,\n    });\n  }\n\n  override readonly unit: Uri | undefined;\n\n  override withUnit(unit: Uri | undefined): Form<Uri, UriLike> {\n    if (unit === this.unit) {\n      return this;\n    }\n    return new UriForm(unit);\n  }\n\n  override mold(object: UriLike, item?: Item): Item {\n    object = Uri.fromLike(object);\n    if (item === void 0) {\n      return Text.from(object.toString());\n    } else {\n      return item.concat(Text.from(object.toString()));\n    }\n  }\n\n  override cast(item: Item, object?: Uri): Uri | undefined {\n    const value = item.target;\n    try {\n      const string = value.stringValue();\n      if (typeof string === \"string\") {\n        return Uri.parse(string);\n      }\n    } catch (error) {\n      // swallow\n    }\n    return void 0;\n  }\n}\n\n/** @internal */\nexport class UriParser extends Parser<Uri> {\n  private readonly schemeParser: Parser<UriScheme> | undefined;\n  private readonly authorityParser: Parser<UriAuthority> | undefined;\n  private readonly pathParser: Parser<UriPath> | undefined;\n  private readonly queryParser: Parser<UriQuery> | undefined;\n  private readonly fragmentParser: Parser<UriFragment> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(schemeParser?: Parser<UriScheme>, authorityParser?: Parser<UriAuthority>,\n              pathParser?: Parser<UriPath>, queryParser?: Parser<UriQuery>,\n              fragmentParser?: Parser<UriFragment>, step?: number) {\n    super();\n    this.schemeParser = schemeParser;\n    this.authorityParser = authorityParser;\n    this.pathParser = pathParser;\n    this.queryParser = queryParser;\n    this.fragmentParser = fragmentParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<Uri> {\n    return UriParser.parse(input, this.schemeParser, this.authorityParser, this.pathParser,\n                           this.queryParser, this.fragmentParser, this.step);\n  }\n\n  static parse(input: Input, schemeParser?: Parser<UriScheme>, authorityParser?: Parser<UriAuthority>,\n               pathParser?: Parser<UriPath>, queryParser?: Parser<UriQuery>,\n               fragmentParser?: Parser<UriFragment>, step: number = 1): Parser<Uri> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        const look = input.clone();\n        while (look.isCont() && (c = look.head(), Uri.isSchemeChar(c))) {\n          look.step();\n        }\n        if (look.isCont() && c === 58/*':'*/) {\n          step = 2;\n        } else {\n          step = 3;\n        }\n      } else if (input.isDone()) {\n        step = 3;\n      }\n    }\n    if (step === 2) {\n      if (schemeParser === void 0) {\n        schemeParser = UriSchemeParser.parse(input);\n      } else {\n        schemeParser = schemeParser.feed(input);\n      }\n      if (schemeParser.isDone()) {\n        if (input.isCont() && input.head() === 58/*':'*/) {\n          input = input.step();\n          step = 3;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(58/*':'*/, input));\n        }\n      } else if (schemeParser.isError()) {\n        return schemeParser.asError();\n      }\n    }\n    if (step === 3) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 47/*'/'*/) {\n          input = input.step();\n          step = 4;\n        } else if (c === 63/*'?'*/) {\n          input = input.step();\n          step = 7;\n        } else if (c === 35/*'#'*/) {\n          input = input.step();\n          step = 8;\n        } else {\n          step = 6;\n        }\n      } else if (input.isDone()) {\n        return Parser.done(Uri.create(schemeParser !== void 0 ? schemeParser.bind() : void 0,\n                                      void 0, void 0, void 0, void 0));\n      }\n    }\n    if (step === 4) {\n      if (input.isCont() && input.head() === 47/*'/'*/) {\n        input = input.step();\n        step = 5;\n      } else if (input.isCont()) {\n        const pathBuilder = new UriPathBuilder();\n        pathBuilder.addSlash();\n        pathParser = UriPathParser.parse(input, pathBuilder);\n        step = 6;\n      } else if (input.isDone()) {\n        return Parser.done(Uri.create(schemeParser !== void 0 ? schemeParser.bind() : void 0,\n                                      void 0, UriPath.slash(), void 0, void 0));\n      }\n    }\n    if (step === 5) {\n      if (authorityParser === void 0) {\n        authorityParser = UriAuthorityParser.parse(input);\n      } else {\n        authorityParser = authorityParser.feed(input);\n      }\n      if (authorityParser.isDone()) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 63/*'?'*/) {\n            input = input.step();\n            step = 7;\n          } else if (c === 35/*'#'*/) {\n            input = input.step();\n            step = 8;\n          } else {\n            step = 6;\n          }\n        } else if (input.isDone()) {\n          return Parser.done(Uri.create(schemeParser !== void 0 ? schemeParser.bind() : void 0,\n                                        authorityParser !== void 0 ? authorityParser.bind() : void 0,\n                                        void 0, void 0, void 0));\n        }\n      } else if (authorityParser.isError()) {\n        return authorityParser.asError();\n      }\n    }\n    if (step === 6) {\n      if (pathParser === void 0) {\n        pathParser = UriPathParser.parse(input);\n      } else {\n        pathParser = pathParser.feed(input);\n      }\n      if (pathParser.isDone()) {\n        if (input.isCont() && input.head() === 63/*'?'*/) {\n          input = input.step();\n          step = 7;\n        } else if (input.isCont() && input.head() === 35/*'#'*/) {\n          input = input.step();\n          step = 8;\n        } else if (!input.isEmpty()) {\n          return Parser.done(Uri.create(schemeParser !== void 0 ? schemeParser.bind() : void 0,\n                                        authorityParser !== void 0 ? authorityParser.bind() : void 0,\n                                        pathParser.bind(), void 0, void 0));\n        }\n      } else if (pathParser.isError()) {\n        return pathParser.asError();\n      }\n    }\n    if (step === 7) {\n      if (queryParser === void 0) {\n        queryParser = UriQueryParser.parse(input);\n      } else {\n        queryParser = queryParser.feed(input);\n      }\n      if (queryParser.isDone()) {\n        if (input.isCont() && input.head() === 35/*'#'*/) {\n          input = input.step();\n          step = 8;\n        } else if (!input.isEmpty()) {\n          return Parser.done(Uri.create(schemeParser !== void 0 ? schemeParser.bind() : void 0,\n                                        authorityParser !== void 0 ? authorityParser.bind() : void 0,\n                                        pathParser !== void 0 ? pathParser.bind() : void 0,\n                                        queryParser.bind(), void 0));\n        }\n      } else if (queryParser.isError()) {\n        return queryParser.asError();\n      }\n    }\n    if (step === 8) {\n      if (fragmentParser === void 0) {\n        fragmentParser = UriFragmentParser.parse(input);\n      } else {\n        fragmentParser = fragmentParser.feed(input);\n      }\n      if (fragmentParser.isDone()) {\n        return Parser.done(Uri.create(schemeParser !== void 0 ? schemeParser.bind() : void 0,\n                                      authorityParser !== void 0 ? authorityParser.bind() : void 0,\n                                      pathParser !== void 0 ? pathParser.bind() : void 0,\n                                      queryParser !== void 0 ? queryParser.bind() : void 0,\n                                      fragmentParser.bind()));\n      } else if (fragmentParser.isError()) {\n        return fragmentParser.asError();\n      }\n    }\n    return new UriParser(schemeParser, authorityParser, pathParser,\n                         queryParser, fragmentParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Compare} from \"@swim/util\";\nimport {Strings} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport type {Display} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Utf8} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\n\n/** @public */\nexport type UriSchemeLike = UriScheme | string;\n\n/** @public */\nexport const UriSchemeLike = {\n  [Symbol.hasInstance](instance: unknown): instance is UriSchemeLike {\n    return instance instanceof UriScheme\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport class UriScheme implements HashCode, Compare, Debug, Display {\n  /** @internal */\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  likeType?(like: string): void;\n\n  isDefined(): boolean {\n    return this.name.length !== 0;\n  }\n\n  readonly name: string;\n\n  toLike(): string | undefined {\n    return this.name.length !== 0 ? this.name : void 0;\n  }\n\n  /** @override */\n  compareTo(that: unknown): number {\n    if (that instanceof UriScheme) {\n      return this.name.localeCompare(that.name);\n    }\n    return NaN;\n  }\n\n  /** @override */\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UriScheme) {\n      return this.name === that.name;\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Strings.hash(this.name);\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"UriScheme\").write(46/*'.'*/);\n    if (this.isDefined()) {\n      output = output.write(\"parse\").write(40/*'('*/).write(34/*'\"'*/)\n                     .display(this).write(34/*'\"'*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"undefined\").write(40/*'('*/).write(41/*')'*/);\n    }\n    return output;\n  }\n\n  /** @override */\n  display<T>(output: Output<T>): Output<T> {\n    output = Uri.writeScheme(output, this.name);\n    return output;\n  }\n\n  /** @override */\n  toString(): string {\n    return this.name;\n  }\n\n  @Lazy\n  static undefined(): UriScheme {\n    return new UriScheme(\"\");\n  }\n\n  static create(schemeName: string): UriScheme {\n    return new UriScheme(schemeName);\n  }\n\n  static fromLike<T extends UriSchemeLike | null | undefined>(value: T): UriScheme | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof UriScheme) {\n      return value as UriScheme | Uninitable<T>;\n    } else if (typeof value === \"string\") {\n      return UriScheme.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static parse(input: Input): Parser<UriScheme>;\n  static parse(string: string): UriScheme;\n  static parse(string: Input | string): Parser<UriScheme> | UriScheme {\n    const input = typeof string === \"string\" ? Unicode.stringInput(string) : string;\n    let parser = UriSchemeParser.parse(input);\n    if (typeof string === \"string\" && input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return typeof string === \"string\" ? parser.bind() : parser;\n  }\n}\n\n/** @internal */\nexport class UriSchemeParser extends Parser<UriScheme> {\n  private readonly output: Output<string> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(output?: Output<string>, step?: number) {\n    super();\n    this.output = output;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<UriScheme> {\n    return UriSchemeParser.parse(input, this.output, this.step);\n  }\n\n  static parse(input: Input, output?: Output<string>, step: number = 1): Parser<UriScheme> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont() && (c = input.head(), Uri.isAlpha(c))) {\n        input = input.step();\n        output = output || Utf8.decodedString();\n        output = output.write(Uri.toLowerCase(c));\n        step = 2;\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.expected(\"scheme\", input));\n      }\n    }\n    if (step === 2) {\n      while (input.isCont() && (c = input.head(), Uri.isSchemeChar(c))) {\n        input = input.step();\n        output!.write(Uri.toLowerCase(c));\n      }\n      if (!input.isEmpty()) {\n        return Parser.done(UriScheme.create(output!.bind()));\n      }\n    }\n    return new UriSchemeParser(output, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Compare} from \"@swim/util\";\nimport {Strings} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport type {Display} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport type {UriUserLike} from \"./UriUser\";\nimport type {UriUserInit} from \"./UriUser\";\nimport {UriUser} from \"./\"; // forward import\nimport type {UriHostLike} from \"./UriHost\";\nimport {UriHost} from \"./\"; // forward import\nimport type {UriPortLike} from \"./UriPort\";\nimport {UriPort} from \"./\"; // forward import\nimport {UriUserParser} from \"./\"; // forward import\nimport {UriHostParser} from \"./\"; // forward import\nimport {UriPortParser} from \"./\"; // forward import\n\n/** @public */\nexport type UriAuthorityLike = UriAuthority | UriAuthorityInit | string;\n\n/** @public */\nexport const UriAuthorityLike = {\n  [Symbol.hasInstance](instance: unknown): instance is UriAuthorityLike {\n    return instance instanceof UriAuthority\n        || UriAuthorityInit[Symbol.hasInstance](instance)\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport interface UriAuthorityInit extends UriUserInit {\n  /** @internal */\n  readonly typeid?: \"UriAuthorityInit\" | \"UriInit\";\n  user?: UriUserLike;\n  host?: UriHostLike;\n  port?: UriPortLike;\n}\n\n/** @public */\nexport const UriAuthorityInit = {\n  [Symbol.hasInstance](instance: unknown): instance is UriAuthorityInit {\n    return Objects.hasAnyKey<UriAuthorityInit>(instance, \"user\", \"host\", \"port\");\n  },\n};\n\n/** @public */\nexport class UriAuthority implements HashCode, Compare, Debug, Display {\n  /** @internal */\n  constructor(user: UriUser, host: UriHost, port: UriPort) {\n    this.user = user;\n    this.host = host;\n    this.port = port;\n    this.hashValue = void 0;\n    this.stringValue = void 0;\n  }\n\n  /** @internal */\n  declare readonly typeid?: \"UriAuthority\";\n\n  likeType?(like: UriAuthorityInit | string): void;\n\n  isDefined(): boolean {\n    return this.user.isDefined() || this.host.isDefined() || this.port.isDefined();\n  }\n\n  readonly user: UriUser;\n\n  withUser(user: UriUserLike): UriAuthority {\n    user = UriUser.fromLike(user);\n    if (user === this.user) {\n      return this;\n    }\n    return this.copy(user, this.host, this.port);\n  }\n\n  get userPart(): string {\n    return this.user.toString();\n  }\n\n  withUserPart(userPart: string): UriAuthority {\n    return this.withUser(UriUser.parse(userPart));\n  }\n\n  get username(): string | undefined {\n    return this.user.username;\n  }\n\n  withUsername(username: string | undefined, password?: string): UriAuthority {\n    if (arguments.length === 1) {\n      return this.withUser(this.user.withUsername(username));\n    } else if (arguments.length === 2) {\n      return this.withUser(UriUser.create(username, password));\n    }\n    throw new Error(arguments.toString());\n  }\n\n  get password(): string | undefined {\n    return this.user.password;\n  }\n\n  withPassword(password: string | undefined): UriAuthority {\n    return this.withUser(this.user.withPassword(password));\n  }\n\n  readonly host: UriHost;\n\n  withHost(host: UriHostLike): UriAuthority {\n    host = UriHost.fromLike(host);\n    if (host === this.host) {\n      return this;\n    }\n    return this.copy(this.user, host, this.port);\n  }\n\n  get hostPart(): string {\n    return this.host.toString();\n  }\n\n  withHostPart(hostPart: string): UriAuthority {\n    return this.withHost(UriHost.parse(hostPart));\n  }\n\n  get hostAddress(): string {\n    return this.host.address;\n  }\n\n  get hostName(): string | undefined {\n    return this.host.name;\n  }\n\n  withHostName(hostName: string): UriAuthority {\n    return this.withHost(UriHost.hostname(hostName));\n  }\n\n  get hostIPv4(): string | undefined {\n    return this.host.ipv4;\n  }\n\n  withHostIPv4(hostIPv4: string): UriAuthority {\n    return this.withHost(UriHost.ipv4(hostIPv4));\n  }\n\n  get hostIPv6(): string | undefined {\n    return this.host.ipv6;\n  }\n\n  withHostIPv6(hostIPv5: string): UriAuthority {\n    return this.withHost(UriHost.ipv6(hostIPv5));\n  }\n\n  readonly port: UriPort;\n\n  withPort(port: UriPortLike): UriAuthority {\n    port = UriPort.fromLike(port);\n    if (port === this.port) {\n      return this;\n    }\n    return this.copy(this.user, this.host, port);\n  }\n\n  get portPart(): string {\n    return this.port.toString();\n  }\n\n  withPortPart(portPart: string): UriAuthority {\n    return this.withPort(UriPort.parse(portPart));\n  }\n\n  get portNumber(): number {\n    return this.port.number;\n  }\n\n  withPortNumber(portNumber: number): UriAuthority {\n    return this.withPort(UriPort.create(portNumber));\n  }\n\n  protected copy(user: UriUser, host: UriHost, port: UriPort): UriAuthority {\n    return UriAuthority.create(user, host, port);\n  }\n\n  toLike(authority?: {username?: string, password?: string, host?: string, port?: number}):\n      {username?: string, password?: string, host?: string, port?: number} | undefined {\n    if (this.isDefined()) {\n      if (authority === void 0) {\n        authority = {};\n      }\n      this.user.toLike(authority);\n      if (this.host.isDefined()) {\n        authority.host = this.host.toLike();\n      }\n      if (this.port.isDefined()) {\n        authority.port = this.port.toLike();\n      }\n    }\n    return authority;\n  }\n\n  /** @override */\n  compareTo(that: unknown): number {\n    if (that instanceof UriAuthority) {\n      return this.toString().localeCompare(that.toString());\n    }\n    return NaN;\n  }\n\n  /** @override */\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UriAuthority) {\n      return this.toString() === that.toString();\n    }\n    return false;\n  }\n\n  /** @internal */\n  readonly hashValue: number | undefined;\n\n  /** @override */\n  hashCode(): number {\n    let hashValue = this.hashValue;\n    if (hashValue === void 0) {\n      hashValue = Strings.hash(this.toString());\n      (this as Mutable<this>).hashValue = hashValue;\n    }\n    return hashValue;\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"UriAuthority\").write(46/*'.'*/);\n    if (this.isDefined()) {\n      output = output.write(\"parse\").write(40/*'('*/).write(34/*'\"'*/)\n                     .display(this).write(34/*'\"'*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"undefined\").write(40/*'('*/).write(41/*')'*/);\n    }\n    return output;\n  }\n\n  /** @override */\n  display<T>(output: Output<T>): Output<T> {\n    const stringValue = this.stringValue;\n    if (stringValue !== void 0) {\n      output = output.write(stringValue);\n    } else {\n      const user = this.user;\n      if (user.isDefined()) {\n        output = output.display(user).write(64/*'@'*/);\n      }\n      output = output.display(this.host);\n      const port = this.port;\n      if (port.isDefined()) {\n        output = output.write(58/*':'*/).display(port);\n      }\n    }\n    return output;\n  }\n\n  /** @internal */\n  readonly stringValue: string | undefined;\n\n  /** @override */\n  toString(): string {\n    let stringValue = this.stringValue;\n    if (stringValue === void 0) {\n      stringValue = Format.display(this);\n      (this as Mutable<this>).stringValue = stringValue;\n    }\n    return stringValue;\n  }\n\n  @Lazy\n  static undefined(): UriAuthority {\n    return new UriAuthority(UriUser.undefined(), UriHost.undefined(), UriPort.undefined());\n  }\n\n  static create(user: UriUser = UriUser.undefined(),\n                host: UriHost = UriHost.undefined(),\n                port: UriPort = UriPort.undefined()): UriAuthority {\n    if (!user.isDefined() && !host.isDefined() && !port.isDefined()) {\n      return UriAuthority.undefined();\n    }\n    return new UriAuthority(user, host, port);\n  }\n\n  static fromLike<T extends UriAuthorityLike | null | undefined>(value: T): UriAuthority | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof UriAuthority) {\n      return value as UriAuthority | Uninitable<T>;\n    } else if (typeof value === \"object\") {\n      return UriAuthority.fromInit(value);\n    } else if (typeof value === \"string\") {\n      return UriAuthority.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromInit(init: UriAuthorityInit): UriAuthority {\n    const user = UriUser.fromLike(init.user);\n    const host = UriHost.fromLike(init.host);\n    const port = UriPort.fromLike(init.port);\n    return this.create(user, host, port);\n  }\n\n  static user(user: UriUserLike): UriAuthority {\n    user = UriUser.fromLike(user);\n    return this.create(user, void 0, void 0);\n  }\n\n  static userPart(userPart: string): UriAuthority {\n    const user = UriUser.parse(userPart);\n    return this.create(user, void 0, void 0);\n  }\n\n  static username(username: string, password?: string | undefined): UriAuthority {\n    const user = UriUser.create(username, password);\n    return this.create(user, void 0, void 0);\n  }\n\n  static password(password: string): UriAuthority {\n    const user = UriUser.create(\"\", password);\n    return this.create(user, void 0, void 0);\n  }\n\n  static host(host: UriHostLike): UriAuthority {\n    host = UriHost.fromLike(host);\n    return this.create(void 0, host, void 0);\n  }\n\n  static hostPart(hostPart: string): UriAuthority {\n    const host = UriHost.parse(hostPart);\n    return this.create(void 0, host, void 0);\n  }\n\n  static hostName(hostName: string): UriAuthority {\n    const host = UriHost.hostname(hostName);\n    return this.create(void 0, host, void 0);\n  }\n\n  static hostIPv4(hostIPv4: string): UriAuthority {\n    const host = UriHost.ipv4(hostIPv4);\n    return this.create(void 0, host, void 0);\n  }\n\n  static hostIPv6(hostIPv6: string): UriAuthority {\n    const host = UriHost.ipv6(hostIPv6);\n    return this.create(void 0, host, void 0);\n  }\n\n  static port(port: UriPortLike): UriAuthority {\n    port = UriPort.fromLike(port);\n    return this.create(void 0, void 0, port);\n  }\n\n  static portPart(portPart: string): UriAuthority {\n    const port = UriPort.parse(portPart);\n    return this.create(void 0, void 0, port);\n  }\n\n  static portNumber(portNumber: number): UriAuthority {\n    const port = UriPort.create(portNumber);\n    return this.create(void 0, void 0, port);\n  }\n\n  static parse(input: Input): Parser<UriAuthority>;\n  static parse(string: string): UriAuthority;\n  static parse(string: Input | string): Parser<UriAuthority> | UriAuthority {\n    const input = typeof string === \"string\" ? Unicode.stringInput(string) : string;\n    let parser = UriAuthorityParser.parse(input);\n    if (typeof string === \"string\" && input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return typeof string === \"string\" ? parser.bind() : parser;\n  }\n}\n\n/** @internal */\nexport class UriAuthorityParser extends Parser<UriAuthority> {\n  private readonly userParser: Parser<UriUser> | undefined;\n  private readonly hostParser: Parser<UriHost> | undefined;\n  private readonly portParser: Parser<UriPort> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(userParser?: Parser<UriUser>, hostParser?: Parser<UriHost>,\n              portParser?: Parser<UriPort>, step?: number) {\n    super();\n    this.userParser = userParser;\n    this.hostParser = hostParser;\n    this.portParser = portParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<UriAuthority> {\n    return UriAuthorityParser.parse(input, this.userParser, this.hostParser,\n                                    this.portParser, this.step);\n  }\n\n  static parse(input: Input, userParser?: Parser<UriUser>, hostParser?: Parser<UriHost>,\n               portParser?: Parser<UriPort>, step: number = 1): Parser<UriAuthority> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        const look = input.clone();\n        while (look.isCont() && (c = look.head(), c !== 64/*'@'*/ && c !== 47/*'/'*/)) {\n          look.step();\n        }\n        if (look.isCont() && c === 64/*'@'*/) {\n          step = 2;\n        } else {\n          step = 3;\n        }\n      } else if (input.isDone()) {\n        step = 3;\n      }\n    }\n    if (step === 2) {\n      if (userParser === void 0) {\n        userParser = UriUserParser.parse(input);\n      } else {\n        userParser = userParser.feed(input);\n      }\n      if (userParser.isDone()) {\n        if (input.isCont() && input.head() === 64/*'@'*/) {\n          input = input.step();\n          step = 3;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(64/*'@'*/, input));\n        }\n      } else if (userParser.isError()) {\n        return userParser.asError();\n      }\n    }\n    if (step === 3) {\n      if (hostParser === void 0) {\n        hostParser = UriHostParser.parse(input);\n      } else {\n        hostParser = hostParser.feed(input);\n      }\n      if (hostParser.isDone()) {\n        if (input.isCont() && input.head() === 58/*':'*/) {\n          input = input.step();\n          step = 4;\n        } else if (!input.isEmpty()) {\n          return Parser.done(UriAuthority.create(userParser !== void 0 ? userParser.bind() : void 0,\n                                                 hostParser.bind()));\n        }\n      } else if (hostParser.isError()) {\n        return hostParser.asError();\n      }\n    }\n    if (step === 4) {\n      if (portParser === void 0) {\n        portParser = UriPortParser.parse(input);\n      } else {\n        portParser = portParser.feed(input);\n      }\n      if (portParser.isDone()) {\n        return Parser.done(UriAuthority.create(userParser !== void 0 ? userParser.bind() : void 0,\n                                               hostParser!.bind(),\n                                               portParser.bind()));\n      } else if (portParser.isError()) {\n        return portParser.asError();\n      }\n    }\n    return new UriAuthorityParser(userParser, hostParser, portParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport {Strings} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport type {Display} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport {Base16} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Utf8} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\n\n/** @public */\nexport type UriUserLike = UriUser | UriUserInit | string;\n\n/** @public */\nexport const UriUserLike = {\n  [Symbol.hasInstance](instance: unknown): instance is UriUserLike {\n    return instance instanceof UriUser\n        || UriUserInit[Symbol.hasInstance](instance)\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport interface UriUserInit {\n  /** @internal */\n  readonly typeid?: \"UriUserInit\" | \"UriAuthorityInit\" | \"UriInit\";\n  username?: string;\n  password?: string;\n}\n\n/** @public */\nexport const UriUserInit = {\n  [Symbol.hasInstance](instance: unknown): instance is UriUserInit {\n    return Objects.hasAnyKey<UriUserInit>(instance, \"username\", \"password\");\n  },\n};\n\n/** @public */\nexport class UriUser implements HashCode, Debug, Display {\n  /** @internal */\n  constructor(username: string | undefined, password: string | undefined) {\n    this.username = username;\n    this.password = password;\n  }\n\n  /** @internal */\n  declare readonly typeid?: \"UriUser\";\n\n  likeType?(like: UriUserInit | string): void;\n\n  isDefined(): boolean {\n    return this.username !== void 0;\n  }\n\n  readonly username: string | undefined;\n\n  withUsername(username: string | undefined): UriUser {\n    if (username === this.username) {\n      return this;\n    }\n    return this.copy(username, this.password);\n  }\n\n  readonly password: string | undefined;\n\n  withPassword(password: string | undefined): UriUser {\n    if (password === this.password) {\n      return this;\n    }\n    return this.copy(this.username, password);\n  }\n\n  protected copy(username: string | undefined, password: string | undefined): UriUser {\n    return UriUser.create(username, password);\n  }\n\n  toLike(user?: {username?: string, password?: string}): {username?: string, password?: string} | undefined {\n    if (this.username !== void 0) {\n      if (user === void 0) {\n        user = {};\n      }\n      user.username = this.username;\n      if (this.password !== void 0) {\n        user.password = this.password;\n      }\n    }\n    return user;\n  }\n\n  /** @override */\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UriUser) {\n      return this.username === that.username && this.password === that.password;\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Strings.hash(this.toString());\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"UriUser\").write(46/*'.'*/);\n    if (this.isDefined()) {\n      output = output.write(\"parse\").write(40/*'('*/).write(34/*'\"'*/)\n                     .display(this).write(34/*'\"'*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"undefined\").write(40/*'('*/).write(41/*')'*/);\n    }\n    return output;\n  }\n\n  /** @override */\n  display<T>(output: Output<T>): Output<T> {\n    if (this.username !== void 0) {\n      output = Uri.writeUser(output, this.username);\n      if (this.password !== void 0) {\n        output = output.write(58/*':'*/);\n        output = Uri.writeUser(output, this.password);\n      }\n    }\n    return output;\n  }\n\n  /** @override */\n  toString(): string {\n    return Format.display(this);\n  }\n\n  @Lazy\n  static undefined(): UriUser {\n    return new UriUser(void 0, void 0);\n  }\n\n  static create(username: string | undefined, password?: string | undefined): UriUser {\n    if (username === void 0 && password === void 0) {\n      return UriUser.undefined();\n    }\n    return new UriUser(username, password);\n  }\n\n  static fromInit(init: UriUserInit): UriUser {\n    return UriUser.create(init.username, init.password);\n  }\n\n  static fromLike<T extends UriUserLike | null | undefined>(value: T): UriUser | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof UriUser) {\n      return value as UriUser | Uninitable<T>;\n    } else if (typeof value === \"object\") {\n      return UriUser.fromInit(value);\n    } else if (typeof value === \"string\") {\n      return UriUser.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static parse(input: Input): Parser<UriUser>;\n  static parse(string: string): UriUser;\n  static parse(string: Input | string): Parser<UriUser> | UriUser {\n    const input = typeof string === \"string\" ? Unicode.stringInput(string) : string;\n    let parser = UriUserParser.parse(input);\n    if (typeof string === \"string\" && input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return typeof string === \"string\" ? parser.bind() : parser;\n  }\n}\n\n/** @internal */\nexport class UriUserParser extends Parser<UriUser> {\n  private readonly usernameOutput: Output<string> | undefined;\n  private readonly passwordOutput: Output<string> | undefined;\n  private readonly c1: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(usernameOutput?: Output<string>, passwordOutput?: Output<string>,\n              c1?: number, step?: number) {\n    super();\n    this.usernameOutput = usernameOutput;\n    this.passwordOutput = passwordOutput;\n    this.c1 = c1;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<UriUser> {\n    return UriUserParser.parse(input, this.usernameOutput, this.passwordOutput,\n                               this.c1, this.step);\n  }\n\n  static parse(input: Input, usernameOutput?: Output<string>, passwordOutput?: Output<string>,\n               c1: number = 0, step: number = 1): Parser<UriUser> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        usernameOutput = usernameOutput || Utf8.decodedString();\n        while (input.isCont() && (c = input.head(), Uri.isUserChar(c))) {\n          input = input.step();\n          usernameOutput!.write(c);\n        }\n        if (input.isCont() && c === 58/*':'*/) {\n          input = input.step();\n          step = 4;\n        } else if (input.isCont() && c === 37/*'%'*/) {\n          input = input.step();\n          step = 2;\n        } else if (!input.isEmpty()) {\n          return Parser.done(UriUser.create(usernameOutput.bind()));\n        }\n      }\n      if (step === 2) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          c1 = c;\n          step = 3;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 3) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          usernameOutput!.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));\n          c1 = 0;\n          step = 1;\n          continue;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 4) {\n        passwordOutput = passwordOutput || Utf8.decodedString();\n        while (input.isCont() && (c = input.head(), Uri.isUserInfoChar(c))) {\n          input = input.step();\n          passwordOutput.write(c);\n        }\n        if (input.isCont() && c === 37/*'%'*/) {\n          input = input.step();\n          step = 5;\n        } else if (!input.isEmpty()) {\n          return Parser.done(UriUser.create(usernameOutput!.bind(), passwordOutput.bind()));\n        }\n      }\n      if (step === 5) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          c1 = c;\n          step = 6;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 6) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          passwordOutput!.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));\n          c1 = 0;\n          step = 4;\n          continue;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      break;\n    } while (true);\n    return new UriUserParser(usernameOutput, passwordOutput, c1, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Compare} from \"@swim/util\";\nimport {Strings} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport type {Display} from \"@swim/codec\";\nimport {Base10} from \"@swim/codec\";\nimport {Base16} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Utf8} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\n\n/** @public */\nexport type UriHostLike = UriHost | string;\n\n/** @public */\nexport const UriHostLike = {\n  [Symbol.hasInstance](instance: unknown): instance is UriHostLike {\n    return instance instanceof UriHost\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport abstract class UriHost implements HashCode, Compare, Debug, Display {\n  protected constructor() {\n    // nop\n  }\n\n  likeType?(like: string): void;\n\n  isDefined(): boolean {\n    return true;\n  }\n\n  abstract readonly address: string;\n\n  get name(): string | undefined {\n    return void 0;\n  }\n\n  get ipv4(): string | undefined {\n    return void 0;\n  }\n\n  get ipv6(): string | undefined {\n    return void 0;\n  }\n\n  toLike(): string {\n    return this.toString();\n  }\n\n  /** @override */\n  compareTo(that: unknown): number {\n    if (that instanceof UriHost) {\n      return this.toString().localeCompare(that.toString());\n    }\n    return NaN;\n  }\n\n  /** @override */\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UriHost) {\n      return this.toString() === that.toString();\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Strings.hash(this.toString());\n  }\n\n  /** @override */\n  abstract debug<T>(output: Output<T>): Output<T>;\n\n  /** @override */\n  abstract display<T>(output: Output<T>): Output<T>;\n\n  /** @override */\n  abstract toString(): string;\n\n  @Lazy\n  static undefined(): UriHost {\n    return new UriHostUndefined();\n  }\n\n  static hostname(name: string): UriHost {\n    return new UriHostName(name);\n  }\n\n  static ipv4(ipv4: string): UriHost {\n    return new UriHostIPv4(ipv4);\n  }\n\n  static ipv6(ipv6: string): UriHost {\n    return new UriHostIPv6(ipv6);\n  }\n\n  static fromLike<T extends UriHostLike | null | undefined>(value: T): UriHost | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof UriHost) {\n      return value as UriHost | Uninitable<T>;\n    } else if (typeof value === \"string\") {\n      return UriHost.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static parse(input: Input): Parser<UriHost>;\n  static parse(string: string): UriHost;\n  static parse(string: Input | string): Parser<UriHost> | UriHost {\n    const input = typeof string === \"string\" ? Unicode.stringInput(string) : string;\n    let parser = UriHostParser.parse(input);\n    if (typeof string === \"string\" && input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return typeof string === \"string\" ? parser.bind() : parser;\n  }\n}\n\n/** @internal */\nexport class UriHostUndefined extends UriHost {\n  /** @internal */\n  constructor() {\n    super();\n  }\n\n  override isDefined(): boolean {\n    return false;\n  }\n\n  override get address(): string {\n    return \"\";\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"UriHost\").write(46/*'.'*/).write(\"undefined\")\n                   .write(40/*'('*/).write(41/*')'*/);\n    return output;\n  }\n\n  override display<T>(output: Output<T>): Output<T> {\n    return output; // blank\n  }\n\n  override toString(): string {\n    return \"\";\n  }\n}\n\n/** @internal */\nexport class UriHostName extends UriHost {\n  /** @internal */\n  constructor(address: string) {\n    super();\n    this.address = address;\n  }\n\n  override readonly address: string;\n\n  override get name(): string {\n    return this.address;\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"UriHost\").write(46/*'.'*/).write(\"hostname\")\n                   .write(40/*'('*/).debug(this.address).write(41/*')'*/);\n    return output;\n  }\n\n  override display<T>(output: Output<T>): Output<T> {\n    output = Uri.writeHost(output, this.address);\n    return output;\n  }\n\n  override toString(): string {\n    return this.address;\n  }\n}\n\n/** @internal */\nexport class UriHostIPv4 extends UriHost {\n  /** @internal */\n  constructor(address: string) {\n    super();\n    this.address = address;\n  }\n\n  override readonly address: string;\n\n  override get ipv4(): string {\n    return this.address;\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"UriHost\").write(46/*'.'*/).write(\"ipv4\")\n                   .write(40/*'('*/).debug(this.address).write(41/*')'*/);\n    return output;\n  }\n\n  override display<T>(output: Output<T>): Output<T> {\n    output = Uri.writeHost(output, this.address);\n    return output;\n  }\n\n  override toString(): string {\n    return this.address;\n  }\n}\n\n/** @internal */\nexport class UriHostIPv6 extends UriHost {\n  /** @internal */\n  constructor(address: string) {\n    super();\n    this.address = address;\n  }\n\n  override readonly address: string;\n\n  override get ipv6(): string {\n    return this.address;\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"UriHost\").write(46/*'.'*/).write(\"ipv6\")\n                   .write(40/*'('*/).debug(this.address).write(41/*')'*/);\n    return output;\n  }\n\n  override display<T>(output: Output<T>): Output<T> {\n    output = output.write(91/*'['*/);\n    output = Uri.writeHostLiteral(output, this.address);\n    output = output.write(93/*']'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return \"[\" + this.address + \"]\";\n  }\n}\n\n/** @internal */\nexport class UriHostParser extends Parser<UriHost> {\n  override feed(input: Input): Parser<UriHost> {\n    return UriHostParser.parse(input);\n  }\n\n  static parse(input: Input): Parser<UriHost> {\n    if (input.isCont()) {\n      const c = input.head();\n      if (c === 91/*'['*/) {\n        return UriHostLiteralParser.parse(input);\n      } else {\n        return UriHostAddressParser.parse(input);\n      }\n    } else if (input.isDone()) {\n      return Parser.done(UriHost.hostname(\"\"));\n    }\n    return new UriHostParser();\n  }\n}\n\n/** @internal */\nexport class UriHostAddressParser extends Parser<UriHost> {\n  private readonly output: Output<string> | undefined;\n  private readonly c1: number | undefined;\n  private readonly x: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(output?: Output<string>, c1?: number, x?: number, step?: number) {\n    super();\n    this.output = output;\n    this.c1 = c1;\n    this.x = x;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<UriHost> {\n    return UriHostAddressParser.parse(input, this.output, this.c1, this.x, this.step);\n  }\n\n  static parse(input: Input, output?: Output<string>, c1: number = 0,\n               x: number = 0, step: number = 1): Parser<UriHost> {\n    let c = 0;\n    output = output || Utf8.decodedString();\n    while (step <= 4) {\n      while (input.isCont() && (c = input.head(), Base10.isDigit(c))) {\n        input = input.step();\n        output = output.write(c);\n        x = 10 * x + Base10.decodeDigit(c);\n      }\n      if (input.isCont()) {\n        if (c === 46/*'.'*/ && step < 4 && x <= 255) {\n          input = input.step();\n          output = output.write(c);\n          x = 0;\n          step += 1;\n        } else if (!Uri.isHostChar(c) && c !== 37/*'%'*/ && step === 4 && x <= 255) {\n          return Parser.done(UriHost.ipv4(output.bind()));\n        } else {\n          x = 0;\n          step = 5;\n          break;\n        }\n      } else if (!input.isEmpty()) {\n        if (step === 4 && x <= 255) {\n          return Parser.done(UriHost.ipv4(output.bind()));\n        } else {\n          return Parser.done(UriHost.hostname(output.bind()));\n        }\n      } else {\n        break;\n      }\n    }\n    do {\n      if (step === 5) {\n        while (input.isCont() && (c = input.head(), Uri.isHostChar(c))) {\n          input = input.step();\n          output!.write(Uri.toLowerCase(c));\n        }\n        if (input.isCont() && c === 37/*'%'*/) {\n          input = input.step();\n          step = 6;\n        } else if (!input.isEmpty()) {\n          return Parser.done(UriHost.hostname(output!.bind()));\n        }\n      }\n      if (step === 6) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          c1 = c;\n          step = 7;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 7) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          output!.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));\n          c1 = 0;\n          step = 5;\n          continue;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      break;\n    } while (true);\n    return new UriHostAddressParser(output, c1, x, step);\n  }\n}\n\n/** @internal */\nexport class UriHostLiteralParser extends Parser<UriHost> {\n  private readonly output: Output<string> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(output?: Output<string>, step?: number) {\n    super();\n    this.output = output;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<UriHost> {\n    return UriHostLiteralParser.parse(input, this.output, this.step);\n  }\n\n  static parse(input: Input, output?: Output<string>, step: number = 1): Parser<UriHost> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont() && input.head() === 91/*'['*/) {\n        input = input.step();\n        step = 2;\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.expected(91/*'['*/, input));\n      }\n    }\n    if (step === 2) {\n      output = output || Utf8.decodedString();\n      while (input.isCont() && (c = input.head(), Uri.isHostChar(c) || c === 58/*':'*/)) {\n        input = input.step();\n        output = output.write(Uri.toLowerCase(c));\n      }\n      if (input.isCont() && c === 93/*']'*/) {\n        input = input.step();\n        return Parser.done(UriHost.ipv6(output.bind()));\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.expected(93/*']'*/, input));\n      }\n    }\n    return new UriHostLiteralParser(output, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Compare} from \"@swim/util\";\nimport {Strings} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport type {Display} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport {Base10} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\n\n/** @public */\nexport type UriPortLike = UriPort | number | string;\n\n/** @public */\nexport const UriPortLike = {\n  [Symbol.hasInstance](instance: unknown): instance is UriPortLike {\n    return instance instanceof UriPort\n        || typeof instance === \"number\"\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport class UriPort implements HashCode, Compare, Debug, Display {\n  /** @internal */\n  constructor(portNumber: number) {\n    this.number = portNumber;\n  }\n\n  likeType?(like: number | string): void;\n\n  isDefined(): boolean {\n    return this.number !== 0;\n  }\n\n  readonly number!: number;\n\n  valueOf(): number {\n    return this.number;\n  }\n\n  toLike(): number {\n    return this.number;\n  }\n\n  /** @override */\n  compareTo(that: unknown): number {\n    if (that instanceof UriPort) {\n      return this.number < that.number ? -1 : this.number > that.number ? 1 : 0;\n    }\n    return NaN;\n  }\n\n  /** @override */\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UriPort) {\n      return this.number === that.number;\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Strings.hash(this.toString());\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"UriPort\").write(46/*'.'*/);\n    if (this.isDefined()) {\n      output = output.write(\"create\").write(40/*'('*/);\n      output = Format.displayNumber(output, this.number);\n    } else {\n      output = output.write(\"undefined\").write(40/*'('*/);\n    }\n    output = output.write(41/*')'*/);\n    return output;\n  }\n\n  /** @override */\n  display<T>(output: Output<T>): Output<T> {\n    output = Format.displayNumber(output, this.number);\n    return output;\n  }\n\n  /** @override */\n  toString(): string {\n    return \"\" + this.number;\n  }\n\n  @Lazy\n  static undefined(): UriPort {\n    return new UriPort(0);\n  }\n\n  static create(number: number): UriPort {\n    if (number < 0) {\n      throw new TypeError(\"\" + number);\n    } else if (number === 0) {\n      return UriPort.undefined();\n    }\n    return new UriPort(number);\n  }\n\n  static fromLike<T extends UriPortLike | null | undefined>(value: T): UriPort | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof UriPort) {\n      return value as UriPort | Uninitable<T>;\n    } else if (typeof value === \"number\") {\n      return UriPort.create(value);\n    } else if (typeof value === \"string\") {\n      return UriPort.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static parse(input: Input): Parser<UriPort>;\n  static parse(string: string): UriPort;\n  static parse(string: Input | string): Parser<UriPort> | UriPort {\n    const input = typeof string === \"string\" ? Unicode.stringInput(string) : string;\n    let parser = UriPortParser.parse(input);\n    if (typeof string === \"string\" && input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return typeof string === \"string\" ? parser.bind() : parser;\n  }\n}\n\n/** @internal */\nexport class UriPortParser extends Parser<UriPort> {\n  private readonly number: number | undefined;\n\n  constructor(number?: number) {\n    super();\n    this.number = number;\n  }\n\n  override feed(input: Input): Parser<UriPort> {\n    return UriPortParser.parse(input, this.number);\n  }\n\n  static parse(input: Input, number: number = 0): Parser<UriPort> {\n    let c = 0;\n    while (input.isCont() && (c = input.head(), Base10.isDigit(c))) {\n      input = input.step();\n      number = 10 * number + Base10.decodeDigit(c);\n    }\n    if (!input.isEmpty()) {\n      return Parser.done(UriPort.create(number));\n    }\n    return new UriPortParser(number);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Compare} from \"@swim/util\";\nimport {Strings} from \"@swim/util\";\nimport type {Builder} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport type {Display} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport {Base16} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Utf8} from \"@swim/codec\";\nimport type {Item} from \"@swim/structure\";\nimport {Text} from \"@swim/structure\";\nimport {Form} from \"@swim/structure\";\nimport {Uri} from \"./Uri\";\n\n/** @public */\nexport type UriPathLike = UriPath | readonly string[] | string;\n\n/** @public */\nexport const UriPathLike = {\n  [Symbol.hasInstance](instance: unknown): instance is UriPathLike {\n    return instance instanceof UriPath\n        || Array.isArray(instance)\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport abstract class UriPath implements HashCode, Compare, Debug, Display {\n  /** @internal */\n  protected constructor() {\n    // sealed\n  }\n\n  likeType?(like: readonly string[] | string): void;\n\n  abstract isDefined(): boolean;\n\n  abstract isAbsolute(): boolean;\n\n  abstract isRelative(): boolean;\n\n  abstract isSegment(): boolean;\n\n  abstract isEmpty(): boolean;\n\n  get length(): number {\n    let n = 0;\n    let path: UriPath = this;\n    while (!path.isEmpty()) {\n      n += 1;\n      path = path.tail();\n    }\n    return n;\n  }\n\n  get(index: number): string | undefined {\n    let i = 0;\n    let path: UriPath = this;\n    while (!path.isEmpty()) {\n      if (i >= index) {\n        return path.head();\n      }\n      i += 1;\n      path = path.tail();\n    }\n    return void 0;\n  }\n\n  abstract head(): string;\n\n  abstract tail(): UriPath;\n\n  /** @internal */\n  abstract setTail(tail: UriPath): void;\n\n  /** @internal */\n  abstract dealias(): UriPath;\n\n  abstract parent(): UriPath;\n\n  abstract base(): UriPath;\n\n  get name(): string {\n    if (this.isEmpty()) {\n      return \"\";\n    }\n    let path: UriPath = this;\n    do {\n      const tail = path.tail();\n      if (tail.isEmpty()) {\n        return path.isRelative() ? path.head() : \"\";\n      }\n      path = tail;\n    } while (true);\n  }\n\n  withName(name: string): UriPath {\n    const builder = new UriPathBuilder();\n    builder.addPath(this.base());\n    builder.addSegment(name);\n    return builder.build();\n  }\n\n  body(): UriPath {\n    if (this.isEmpty()) {\n      return this;\n    }\n    const builder = new UriPathBuilder();\n    let path: UriPath = this;\n    do {\n      const tail = path.tail();\n      if (tail.isEmpty()) {\n        return builder.build();\n      } else if (path.isSegment()) {\n        builder.addSegment(path.head());\n      } else if (path.isAbsolute()) {\n        builder.addSlash();\n      }\n      path = tail;\n    } while (true);\n  }\n\n  foot(): UriPath {\n    if (this.isEmpty()) {\n      return this;\n    }\n    let path: UriPath = this;\n    do {\n      const tail = path.tail();\n      if (tail.isEmpty()) {\n        return path;\n      }\n      path = tail;\n    } while (true);\n  }\n\n  isSubpathOf(b: UriPathLike): boolean {\n    b = UriPath.fromLike(b);\n    let a: UriPath = this;\n    while (!a.isEmpty() && !b.isEmpty()) {\n      if (a.isRelative() != b.isRelative() || a.head() !== b.head()) {\n        return false;\n      }\n      a = a.tail();\n      b = b.tail();\n    }\n    return b.isEmpty();\n  }\n\n  appended(...components: UriPathLike[]): UriPath {\n    if (arguments.length === 0) {\n      return this;\n    }\n    const builder = new UriPathBuilder();\n    builder.addPath(this);\n    builder.push(...components);\n    return builder.build();\n  }\n\n  appendedSlash(): UriPath {\n    const builder = new UriPathBuilder();\n    builder.addPath(this);\n    builder.addSlash();\n    return builder.build();\n  }\n\n  appendedSegment(segment: string): UriPath {\n    const builder = new UriPathBuilder();\n    builder.addPath(this);\n    builder.addSegment(segment);\n    return builder.build();\n  }\n\n  prepended(...components: UriPathLike[]): UriPath {\n    if (arguments.length === 0) {\n      return this;\n    }\n    const builder = new UriPathBuilder();\n    builder.push(...components);\n    builder.addPath(this);\n    return builder.build();\n  }\n\n  prependedSlash(): UriPath {\n    return new UriPathSlash(this);\n  }\n\n  prependedSegment(segment: string): UriPath {\n    if (this.isEmpty() || this.isAbsolute()) {\n      return UriPath.segment(segment, this);\n    }\n    return UriPath.segment(segment, this.prependedSlash());\n  }\n\n  resolve(that: UriPath): UriPath {\n    if (that.isEmpty()) {\n      return this;\n    } else if (that.isAbsolute() || this.isEmpty()) {\n      return that.removeDotSegments();\n    }\n    return this.merge(that).removeDotSegments();\n  }\n\n  removeDotSegments(): UriPath {\n    let path: UriPath = this;\n    const builder = new UriPathBuilder();\n    while (!path.isEmpty()) {\n      const head = path.head();\n      if (head === \".\" || head === \"..\") {\n        path = path.tail();\n        if (!path.isEmpty()) {\n          path = path.tail();\n        }\n      } else if (path.isAbsolute()) {\n        const rest = path.tail();\n        if (!rest.isEmpty()) {\n          const next = rest.head();\n          if (next === \".\") {\n            path = rest.tail();\n            if (path.isEmpty()) {\n              path = UriPath.slash();\n            }\n          } else if (next === \"..\") {\n            path = rest.tail();\n            if (path.isEmpty()) {\n              path = UriPath.slash();\n            }\n            if (!builder.isEmpty() && !builder.pop().isAbsolute()) {\n              if (!builder.isEmpty()) {\n                builder.pop();\n              }\n            }\n          } else {\n            builder.push(head, next);\n            path = rest.tail();\n          }\n        } else {\n          builder.push(path.head());\n          path = path.tail();\n        }\n      } else {\n        builder.push(path.head());\n        path = path.tail();\n      }\n    }\n    return builder.build();\n  }\n\n  merge(that: UriPath): UriPath {\n    if (this.isEmpty()) {\n      return that;\n    }\n    const builder = new UriPathBuilder();\n    let prev: UriPath = this;\n    do {\n      const next = prev.tail();\n      if (next.isEmpty()) {\n        if (prev.isAbsolute()) {\n          builder.addSlash();\n        }\n        break;\n      } else if (prev.isAbsolute()) {\n        builder.addSlash();\n      } else {\n        builder.addSegment(prev.head());\n      }\n      prev = next;\n    } while (true);\n    builder.addPath(that);\n    return builder.build();\n  }\n\n  unmerge(that: UriPath): UriPath {\n    let base: UriPath = this;\n    let relative = that;\n    if (base.isEmpty()) {\n      return relative;\n    }\n    do {\n      if (base.isEmpty()) {\n        if (relative.isEmpty() || relative.tail().isEmpty()) {\n          return relative;\n        }\n        return relative.tail();\n      } else if (base.isRelative()) {\n        return relative;\n      } else if (relative.isRelative()) {\n        return relative.prependedSlash();\n      }\n      let a = base.tail();\n      let b = relative.tail();\n      if (!a.isEmpty() && b.isEmpty()) {\n        return UriPath.slash();\n      } else if (a.isEmpty() || b.isEmpty()\n          || a.isRelative() != b.isRelative()\n          || a.head() !== b.head()) {\n        return b;\n      }\n      a = a.tail();\n      b = b.tail();\n      if (!a.isEmpty() && b.isEmpty()) {\n        return that;\n      }\n      base = a;\n      relative = b;\n    } while (true);\n  }\n\n  /**\n   * Returns this path relative to the given `base` path.\n   */\n  relativeTo(base: UriPath): UriPath {\n    return UriPath.difference(base, this);\n  }\n\n  /** @internal */\n  static difference(base: UriPath, target: UriPath): UriPath {\n    let commonSlash = false;\n    while (!base.isEmpty() && !target.isEmpty()\n        && base.isRelative() === target.isRelative()\n        && base.head() === target.head()) {\n      commonSlash = base.isAbsolute();\n      base = base.tail();\n      target = target.tail();\n    }\n    if (base.isEmpty()) {\n      return target;\n    }\n    const builder = new UriPathBuilder();\n    while (!base.isEmpty()) {\n      if (base.isRelative()) {\n        builder.addSegment(\"..\");\n      }\n      base = base.tail();\n    }\n    if (commonSlash) {\n      builder.addSlash();\n    }\n    builder.addPath(target);\n    return builder.build();\n  }\n\n  toLike(): string[] {\n    const components = [];\n    let path: UriPath = this;\n    while (!path.isEmpty()) {\n      components.push(path.head());\n      path = path.tail();\n    }\n    return components;\n  }\n\n  /** @override */\n  compareTo(that: unknown): number {\n    if (that instanceof UriPath) {\n      return this.toString().localeCompare(that.toString());\n    }\n    return NaN;\n  }\n\n  /** @override */\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UriPath) {\n      return this.toString() === that.toString();\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Strings.hash(this.toString());\n  }\n\n  /** @override */\n  abstract debug<T>(output: Output<T>): Output<T>;\n\n  /** @override */\n  display<T>(output: Output<T>): Output<T> {\n    let path: UriPath = this;\n    while (!path.isEmpty()) {\n      if (path.isAbsolute()) {\n        output = output.write(47/*'/'*/);\n      } else {\n        output = Uri.writePathSegment(output, path.head());\n      }\n      path = path.tail();\n    }\n    return output;\n  }\n\n  /** @override */\n  abstract toString(): string;\n\n  static builder(): UriPathBuilder {\n    return new UriPathBuilder();\n  }\n\n  @Lazy\n  static empty(): UriPath {\n    return new UriPathEmpty();\n  }\n\n  static slash(segment?: string | UriPath): UriPath {\n    if (segment === void 0) {\n      return UriPathSlash.slash();\n    } else if (typeof segment === \"string\") {\n      segment = this.segment(segment);\n    }\n    return new UriPathSlash(segment);\n  }\n\n  static segment(segment: string, tail?: UriPath): UriPath {\n    if (tail === void 0) {\n      tail = UriPath.empty();\n    }\n    return new UriPathSegment(segment, tail);\n  }\n\n  static of(...components: UriPathLike[]): UriPath {\n    const builder = new UriPathBuilder();\n    builder.push(...components);\n    return builder.build();\n  }\n\n  static fromLike<T extends UriPathLike | null | undefined>(value: T): UriPath | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof UriPath) {\n      return value as UriPath | Uninitable<T>;\n    } else if (Array.isArray(value)) {\n      return UriPath.of(...value);\n    } else if (typeof value === \"string\") {\n      return UriPath.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static parse(input: Input): Parser<UriPath>;\n  static parse(string: string): UriPath;\n  static parse(string: Input | string): Parser<UriPath> | UriPath {\n    const input = typeof string === \"string\" ? Unicode.stringInput(string) : string;\n    let parser = UriPathParser.parse(input);\n    if (typeof string === \"string\" && input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return typeof string === \"string\" ? parser.bind() : parser;\n  }\n\n  @Lazy\n  static pathForm(): Form<UriPath, UriPathLike> {\n    return new UriPathForm(UriPath.empty());\n  }\n}\n\n/** @internal */\nexport class UriPathEmpty extends UriPath {\n  /** @internal */\n  constructor() {\n    super();\n  }\n\n  override isDefined(): boolean {\n    return false;\n  }\n\n  override isAbsolute(): boolean {\n    return false;\n  }\n\n  override isRelative(): boolean {\n    return true;\n  }\n\n  override isSegment(): boolean {\n    return false;\n  }\n\n  override isEmpty(): boolean {\n    return true;\n  }\n\n  override head(): string {\n    throw new Error(\"empty path\");\n  }\n\n  override tail(): UriPath {\n    throw new Error(\"empty path\");\n  }\n\n  /** @internal */\n  override setTail(tail: UriPath): void {\n    throw new Error(\"empty path\");\n  }\n\n  /** @internal */\n  override dealias(): UriPath {\n    return this;\n  }\n\n  override parent(): UriPath {\n    return this;\n  }\n\n  override base(): UriPath {\n    return this;\n  }\n\n  override appended(...components: UriPathLike[]): UriPath {\n    return UriPath.of(...components);\n  }\n\n  override appendedSlash(): UriPath {\n    return UriPath.slash();\n  }\n\n  override appendedSegment(segment: string): UriPath {\n    return UriPath.segment(segment);\n  }\n\n  override prepended(...components: UriPathLike[]): UriPath {\n    return UriPath.of(...components);\n  }\n\n  override prependedSlash(): UriPath {\n    return UriPath.slash();\n  }\n\n  override prependedSegment(segment: string): UriPath {\n    return UriPath.segment(segment);\n  }\n\n  override merge(that: UriPath): UriPath {\n    return that;\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"UriPath\").write(46/*'.'*/).write(\"empty\")\n                   .write(40/*'('*/).write(41/*')'*/);\n    return output;\n  }\n\n  override display<T>(output: Output<T>): Output<T> {\n    return output; // blank\n  }\n\n  override toString(): string {\n    return \"\";\n  }\n}\n\n/** @internal */\nexport class UriPathSlash extends UriPath {\n  /** @internal */\n  constructor(tail: UriPath) {\n    super();\n    this.rest = tail;\n    this.stringValue = void 0;\n  }\n\n  /** @internal */\n  readonly rest: UriPath;\n\n  override isDefined(): boolean {\n    return true;\n  }\n\n  override isAbsolute(): boolean {\n    return true;\n  }\n\n  override isRelative(): boolean {\n    return false;\n  }\n\n  override isSegment(): boolean {\n    return false;\n  }\n\n  override isEmpty(): boolean {\n    return false;\n  }\n\n  override head(): string {\n    return \"/\";\n  }\n\n  override tail(): UriPath {\n    return this.rest;\n  }\n\n  /** @internal */\n  override setTail(tail: UriPath): void {\n    (this as Mutable<this>).rest = tail;\n  }\n\n  /** @internal */\n  override dealias(): UriPath {\n    return new UriPathSlash(this.rest);\n  }\n\n  override parent(): UriPath {\n    const tail = this.rest;\n    if (tail.isEmpty()) {\n      return UriPath.empty();\n    }\n    const rest = tail.tail();\n    if (rest.isEmpty()) {\n      return UriPath.slash();\n    }\n    return new UriPathSlash(tail.parent());\n  }\n\n  override base(): UriPath {\n    const tail = this.rest;\n    if (tail.isEmpty()) {\n      return this;\n    }\n    return new UriPathSlash(tail.base());\n  }\n\n  override prependedSegment(segment: string): UriPath {\n    return UriPath.segment(segment, this);\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"UriPath\").write(46/*'.'*/).write(\"parse\").write(40/*'('*/)\n                   .write(34/*'\"'*/) .display(this).write(34/*'\"'*/).write(41/*')'*/);\n    return output;\n  }\n\n  override display<T>(output: Output<T>): Output<T> {\n    const stringValue = this.stringValue;\n    if (stringValue !== void 0) {\n      output = output.write(stringValue);\n    } else {\n      output = super.display(output);\n    }\n    return output;\n  }\n\n  /** @internal */\n  readonly stringValue: string | undefined;\n\n  override toString(): string {\n    let stringValue = this.stringValue;\n    if (stringValue === void 0) {\n      stringValue = Format.display(this);\n      (this as Mutable<this>).stringValue = stringValue;\n    }\n    return stringValue;\n  }\n\n  /** @internal */\n  @Lazy\n  static override slash(): UriPathSlash {\n    return new UriPathSlash(UriPath.empty());\n  }\n}\n\n/** @internal */\nexport class UriPathSegment extends UriPath {\n  /** @internal */\n  constructor(head: string, tail: UriPath) {\n    super();\n    this.segment = head;\n    this.rest = tail;\n    this.stringValue = void 0;\n  }\n\n  /** @internal */\n  readonly segment: string;\n\n  /** @internal */\n  readonly rest: UriPath;\n\n  override isDefined(): boolean {\n    return true;\n  }\n\n  override isAbsolute(): boolean {\n    return false;\n  }\n\n  override isRelative(): boolean {\n    return true;\n  }\n\n  override isSegment(): boolean {\n    return true;\n  }\n\n  override isEmpty(): boolean {\n    return false;\n  }\n\n  override head(): string {\n    return this.segment;\n  }\n\n  override tail(): UriPath {\n    return this.rest;\n  }\n\n  /** @internal */\n  override setTail(tail: UriPath): void {\n    if (tail instanceof UriPathSegment) {\n      throw new Error(\"adjacent path segments\");\n    }\n    (this as Mutable<this>).rest = tail;\n  }\n\n  /** @internal */\n  override dealias(): UriPath {\n    return new UriPathSegment(this.segment, this.rest);\n  }\n\n  override parent(): UriPath {\n    const tail = this.rest;\n    if (tail.isEmpty()) {\n      return UriPath.empty();\n    }\n    const rest = tail.tail();\n    if (rest.isEmpty()) {\n      return UriPath.empty();\n    }\n    return new UriPathSegment(this.segment, tail.parent());\n  }\n\n  override base(): UriPath {\n    const tail = this.rest;\n    if (tail.isEmpty()) {\n      return UriPath.empty();\n    }\n    return new UriPathSegment(this.segment, tail.base());\n  }\n\n  override prependedSegment(segment: string): UriPath {\n    return UriPath.segment(segment, this.prependedSlash());\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"UriPath\").write(46/*'.'*/).write(\"parse\").write(40/*'('*/)\n                   .write(34/*'\"'*/).display(this).write(34/*'\"'*/).write(41/*')'*/);\n    return output;\n  }\n\n  override display<T>(output: Output<T>): Output<T> {\n    const stringValue = this.stringValue;\n    if (stringValue !== void 0) {\n      output = output.write(stringValue);\n    } else {\n      output = super.display(output);\n    }\n    return output;\n  }\n\n  /** @internal */\n  readonly stringValue: string | undefined;\n\n  override toString(): string {\n    let stringValue = this.stringValue;\n    if (stringValue === void 0) {\n      stringValue = Format.display(this);\n      (this as Mutable<this>).stringValue = stringValue;\n    }\n    return stringValue;\n  }\n}\n\n/** @public */\nexport class UriPathBuilder implements Builder<string, UriPath> {\n  /** @internal */\n  first: UriPath;\n  /** @internal */\n  last: UriPath | null;\n  /** @internal */\n  size: number;\n  /** @internal */\n  aliased: number;\n\n  constructor() {\n    this.first = UriPath.empty();\n    this.last = null;\n    this.size = 0;\n    this.aliased = 0;\n  }\n\n  isEmpty(): boolean {\n    return this.size === 0;\n  }\n\n  push(...components: UriPathLike[]): void {\n    for (let i = 0; i < components.length; i += 1) {\n      const component = components[i]!;\n      if (component instanceof UriPath) {\n        this.addPath(component);\n      } else if (Array.isArray(component)) {\n        this.push(...component);\n      } else if (component === \"/\") {\n        this.addSlash();\n      } else {\n        this.addSegment(component as string);\n      }\n    }\n  }\n\n  build(): UriPath {\n    this.aliased = 0;\n    return this.first;\n  }\n\n  addSlash(): void {\n    const tail = UriPath.slash().dealias();\n    const size = this.size;\n    if (size === 0) {\n      this.first = tail;\n    } else {\n      this.dealias(size - 1).setTail(tail);\n    }\n    this.last = tail;\n    this.size = size + 1;\n    this.aliased += 1;\n  }\n\n  addSegment(segment: string): void {\n    const tail = UriPath.segment(segment, UriPath.empty());\n    let size = this.size;\n    if (size === 0) {\n      this.first = tail;\n    } else {\n      const last = this.dealias(size - 1);\n      if (last.isAbsolute()) {\n        last.setTail(tail);\n      } else {\n        last.setTail(tail.prependedSlash());\n        size += 1;\n        this.aliased += 1;\n      }\n    }\n    this.last = tail;\n    this.size = size + 1;\n    this.aliased += 1;\n  }\n\n  addPath(path: UriPath): void {\n    if (path.isEmpty()) {\n      return;\n    }\n    let size = this.size;\n    if (size === 0) {\n      this.first = path;\n    } else {\n      const last = this.dealias(size - 1);\n      if (last.isAbsolute() || path.isAbsolute()) {\n        last.setTail(path);\n      } else {\n        last.setTail(path.prependedSlash());\n        size += 1;\n        this.aliased += 1;\n      }\n    }\n    size += 1;\n    do {\n      const tail = path.tail();\n      if (tail.isEmpty()) {\n        break;\n      }\n      path = tail;\n      size += 1;\n    } while (true);\n    this.last = path;\n    this.size = size;\n  }\n\n  pop(): UriPath {\n    const size = this.size;\n    const aliased = this.aliased;\n    if (size === 0) {\n      throw new Error(\"Empty UriPath\");\n    } else if (size === 1) {\n      const first = this.first;\n      this.first = first.tail();\n      if (first.tail().isEmpty()) {\n        this.last = null;\n      }\n      this.size = size - 1;\n      if (aliased > 0) {\n        this.aliased = aliased - 1;\n      }\n      return first;\n    }\n    const last = this.dealias(size - 2);\n    last.setTail(UriPath.empty());\n    this.last = last;\n    this.size = size - 1;\n    this.aliased = aliased - 1;\n    return last.tail();\n  }\n\n  /** @internal */\n  dealias(n: number): UriPath {\n    let i = 0;\n    let xi: UriPath | null = null;\n    let xs = this.first;\n    if (this.aliased <= n) {\n      while (i < this.aliased) {\n        xi = xs;\n        xs = xs.tail();\n        i += 1;\n      }\n      while (i <= n) {\n        const xn = xs.dealias();\n        if (i === 0) {\n          this.first = xn;\n        } else {\n          xi!.setTail(xn);\n        }\n        xi = xn;\n        xs = xs.tail();\n        i += 1;\n      }\n      if (i === this.size) {\n        this.last = xi;\n      }\n      this.aliased = i;\n    } else if (n === 0) {\n      xi = this.first;\n    } else if (n === this.size - 1) {\n      xi = this.last;\n    } else {\n      while (i <= n) {\n        xi = xs;\n        xs = xs.tail();\n        i += 1;\n      }\n    }\n    return xi!;\n  }\n\n  /** @override */\n  toString(): string {\n    return this.build().toString();\n  }\n}\n\n/** @internal */\nexport class UriPathForm extends Form<UriPath, UriPathLike> {\n  constructor(unit: UriPath | undefined) {\n    super();\n    Object.defineProperty(this, \"unit\", {\n      value: unit,\n      enumerable: true,\n      configurable: true,\n    });\n  }\n\n  override readonly unit: UriPath | undefined;\n\n  override withUnit(unit: UriPath | undefined): Form<UriPath, UriPathLike> {\n    if (unit === this.unit) {\n      return this;\n    }\n    return new UriPathForm(unit);\n  }\n\n  override mold(object: UriPathLike, item?: Item): Item {\n    object = UriPath.fromLike(object);\n    if (item === void 0) {\n      return Text.from(object.toString());\n    } else {\n      return item.concat(Text.from(object.toString()));\n    }\n  }\n\n  override cast(item: Item, object?: UriPath): UriPath | undefined {\n    const value = item.target;\n    try {\n      const string = value.stringValue();\n      if (typeof string === \"string\") {\n        return UriPath.parse(string);\n      }\n    } catch (error) {\n      // swallow\n    }\n    return void 0;\n  }\n}\n\n/** @internal */\nexport class UriPathParser extends Parser<UriPath> {\n  private readonly builder: UriPathBuilder | undefined;\n  private readonly output: Output<string> | undefined;\n  private readonly c1: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(builder?: UriPathBuilder, output?: Output<string>,\n              c1?: number, step?: number) {\n    super();\n    this.builder = builder;\n    this.output = output;\n    this.c1 = c1;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<UriPath> {\n    return UriPathParser.parse(input, this.builder, this.output, this.c1, this.step);\n  }\n\n  static parse(input: Input, builder?: UriPathBuilder, output?: Output<string>,\n               c1: number = 0, step: number = 1): Parser<UriPath> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        while (input.isCont() && (c = input.head(), Uri.isPathChar(c))) {\n          output = output || Utf8.decodedString();\n          input = input.step();\n          output = output.write(c);\n        }\n        if (input.isCont() && c === 47/*'/'*/) {\n          input = input.step();\n          builder = builder || new UriPathBuilder();\n          if (output !== void 0) {\n            builder.addSegment(output.bind());\n            output = void 0;\n          }\n          builder.addSlash();\n          continue;\n        } else if (input.isCont() && c === 37/*'%'*/) {\n          input = input.step();\n          step = 2;\n        } else if (!input.isEmpty()) {\n          if (output !== void 0) {\n            builder = builder || new UriPathBuilder();\n            builder.addSegment(output.bind());\n          }\n          if (builder !== void 0) {\n            return Parser.done(builder.build());\n          } else {\n            return Parser.done(UriPath.empty());\n          }\n        }\n      }\n      if (step === 2) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          c1 = c;\n          step = 3;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 3) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          output = output || Utf8.decodedString();\n          input = input.step();\n          output = output.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));\n          c1 = 0;\n          step = 1;\n          continue;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      break;\n    } while (true);\n    return new UriPathParser(builder, output, c1, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Compare} from \"@swim/util\";\nimport {Strings} from \"@swim/util\";\nimport type {PairBuilder} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport type {Display} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport {Base16} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Utf8} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\n\n/** @public */\nexport type UriQueryLike = UriQuery | {[key: string]: string} | string;\n\n/** @public */\nexport const UriQueryLike = {\n  [Symbol.hasInstance](instance: unknown): instance is UriQueryLike {\n    return instance instanceof UriQuery\n        || typeof instance === \"object\" && instance !== null\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport abstract class UriQuery implements HashCode, Compare, Debug, Display {\n  likeType?(like: {[key: string]: string} | string): void;\n\n  abstract isDefined(): boolean;\n\n  abstract isEmpty(): boolean;\n\n  get length(): number {\n    let n = 0;\n    let query: UriQuery = this;\n    while (!query.isEmpty()) {\n      n += 1;\n      query = query.tail();\n    }\n    return n;\n  }\n\n  abstract head(): [string | undefined, string];\n\n  abstract readonly key: string | undefined;\n\n  abstract readonly value: string;\n\n  abstract tail(): UriQuery;\n\n  /** @internal */\n  abstract setTail(tail: UriQuery): void;\n\n  /** @internal */\n  abstract dealias(): UriQuery;\n\n  has(key: string): boolean {\n    let query: UriQuery = this;\n    while (!query.isEmpty()) {\n      if (key === query.key) {\n        return true;\n      }\n      query = query.tail();\n    }\n    return false;\n  }\n\n  get(key: string): string | undefined {\n    let query: UriQuery = this;\n    while (!query.isEmpty()) {\n      if (key === query.key) {\n        return query.value;\n      }\n      query = query.tail();\n    }\n    return void 0;\n  }\n\n  updated(key: string, value: string): UriQuery {\n    let query: UriQuery = this;\n    const builder = new UriQueryBuilder();\n    let updated = false;\n    while (!query.isEmpty()) {\n      if (key === query.key) {\n        builder.addParam(key, value);\n        updated = true;\n      } else {\n        builder.addParam(query.key, query.value);\n      }\n      query = query.tail();\n    }\n    if (!updated) {\n      builder.addParam(key, value);\n    }\n    return builder.build();\n  }\n\n  removed(key: string): UriQuery {\n    let query: UriQuery = this;\n    const builder = new UriQueryBuilder();\n    let updated = false;\n    while (!query.isEmpty()) {\n      if (key === query.key) {\n        updated = true;\n      } else {\n        builder.addParam(query.key, query.value);\n      }\n      query = query.tail();\n    }\n    if (!updated) {\n      return this;\n    }\n    return builder.build();\n  }\n\n  appended(key: string | undefined, value: string): UriQuery;\n  appended(params: UriQueryLike): UriQuery;\n  appended(key: UriQueryLike | undefined, value?: string): UriQuery {\n    const builder = new UriQueryBuilder();\n    builder.addQuery(this);\n    builder.add(key as any, value as any);\n    return builder.build();\n  }\n\n  prepended(key: string | undefined, value: string): UriQuery;\n  prepended(params: UriQueryLike): UriQuery;\n  prepended(key: UriQueryLike | undefined, value?: string): UriQuery {\n    const builder = new UriQueryBuilder();\n    builder.add(key as any, value as any);\n    builder.addQuery(this);\n    return builder.build();\n  }\n\n  toLike(params?: {[key: string]: string}): {[key: string]: string} | undefined {\n    if (this.isDefined()) {\n      params = params || {};\n      let query: UriQuery = this;\n      let i = 0;\n      while (!query.isEmpty()) {\n        const key = query.key;\n        if (key !== void 0) {\n          params[key] = query.value;\n        } else {\n          params[\"$\" + i] = query.value;\n        }\n        query = query.tail();\n        i += 1;\n      }\n    }\n    return params;\n  }\n\n  /** @override */\n  compareTo(that: UriQuery): number {\n    if (that instanceof UriQuery) {\n      return this.toString().localeCompare(that.toString());\n    }\n    return NaN;\n  }\n\n  /** @override */\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UriQuery) {\n      return this.toString() === that.toString();\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Strings.hash(this.toString());\n  }\n\n  /** @override */\n  abstract debug<T>(output: Output<T>): Output<T>;\n\n  /** @override */\n  display<T>(output: Output<T>): Output<T> {\n    let query: UriQuery = this;\n    let first = true;\n    while (!query.isEmpty()) {\n      if (!first) {\n        output = output.write(38/*'&'*/);\n      } else {\n        first = false;\n      }\n      const key = query.key;\n      if (key !== void 0) {\n        output = Uri.writeParam(output, key);\n        output = output.write(61/*'='*/);\n      }\n      output = Uri.writeQuery(output, query.value);\n      query = query.tail();\n    }\n    return output;\n  }\n\n  /** @override */\n  abstract toString(): string;\n\n  static builder(): UriQueryBuilder {\n    return new UriQueryBuilder();\n  }\n\n  @Lazy\n  static undefined(): UriQuery {\n    return new UriQueryUndefined();\n  }\n\n  static param(value: string, tail?: UriQuery): UriQuery;\n  static param(key: string | undefined, value: string, tail?: UriQuery): UriQuery;\n  static param(key: string | undefined, value?: UriQuery | string, tail?: UriQuery): UriQuery {\n    if (tail === void 0) {\n      tail = value as UriQuery | undefined;\n      value = key!;\n      key = void 0;\n    }\n    if (tail === void 0) {\n      tail = UriQuery.undefined();\n    }\n    return new UriQueryParam(key, value as string, tail);\n  }\n\n  static fromLike<T extends UriQueryLike | null | undefined>(value: T): UriQuery | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof UriQuery) {\n      return value as UriQuery | Uninitable<T>;\n    } else if (typeof value === \"object\") {\n      const builder = new UriQueryBuilder();\n      builder.add(value);\n      return builder.build();\n    } else if (typeof value === \"string\") {\n      return UriQuery.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static parse(input: Input): Parser<UriQuery>;\n  static parse(string: string): UriQuery;\n  static parse(string: Input | string): Parser<UriQuery> | UriQuery {\n    const input = typeof string === \"string\" ? Unicode.stringInput(string) : string;\n    let parser = UriQueryParser.parse(input);\n    if (typeof string === \"string\" && input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return typeof string === \"string\" ? parser.bind() : parser;\n  }\n}\n\n/** @internal */\nexport class UriQueryUndefined extends UriQuery {\n  override isDefined(): boolean {\n    return false;\n  }\n\n  override isEmpty(): boolean {\n    return true;\n  }\n\n  override head(): [string | undefined, string] {\n    throw new Error(\"undefined query\");\n  }\n\n  override get key(): string | undefined {\n    throw new Error(\"undefined query\");\n  }\n\n  override get value(): string {\n    throw new Error(\"undefined query\");\n  }\n\n  override tail(): UriQuery {\n    throw new Error(\"undefined query\");\n  }\n\n  /** @internal */\n  override setTail(tail: UriQuery): void {\n    throw new Error(\"undefined query\");\n  }\n\n  /** @internal */\n  override dealias(): UriQuery {\n    return this;\n  }\n\n  override updated(key: string, value: string): UriQuery {\n    return UriQuery.param(key, value, this);\n  }\n\n  override removed(key: string): UriQuery {\n    return this;\n  }\n\n  override appended(key: string | undefined, value: string): UriQuery;\n  override appended(params: UriQueryLike): UriQuery;\n  override appended(key: UriQueryLike | undefined, value?: string): UriQuery {\n    const builder = new UriQueryBuilder();\n    builder.add(key as any, value as any);\n    return builder.build();\n  }\n\n  override prepended(key: string | undefined, value: string): UriQuery;\n  override prepended(params: UriQueryLike): UriQuery;\n  override prepended(key: UriQueryLike | undefined, value?: string): UriQuery {\n    const builder = new UriQueryBuilder();\n    builder.add(key as any, value as any);\n    return builder.build();\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"UriQuery\").write(46/*'.'*/).write(\"undefined\")\n                   .write(40/*'('*/).write(41/*')'*/);\n    return output;\n  }\n\n  override display<T>(output: Output<T>): Output<T> {\n    return output; // blank\n  }\n\n  override toString(): string {\n    return \"\";\n  }\n}\n\n/** @internal */\nexport class UriQueryParam extends UriQuery {\n  constructor(key: string | undefined, value: string, tail: UriQuery) {\n    super();\n    this.key = key;\n    this.value = value;\n    this.rest = tail;\n    this.stringValue = void 0;\n  }\n\n  override readonly key: string | undefined;\n\n  override readonly value: string;\n\n  /** @internal */\n  readonly rest: UriQuery;\n\n  override isDefined(): boolean {\n    return true;\n  }\n\n  override isEmpty(): boolean {\n    return false;\n  }\n\n  override head(): [string | undefined, string] {\n    return [this.key, this.value];\n  }\n\n  override tail(): UriQuery {\n    return this.rest;\n  }\n\n  /** @internal */\n  override setTail(tail: UriQuery): void {\n    (this as Mutable<this>).rest = tail;\n  }\n\n  /** @internal */\n  override dealias(): UriQuery {\n    return new UriQueryParam(this.key, this.value, this.rest);\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"UriQuery\").write(46/*'.'*/).write(\"parse\").write(40/*'('*/)\n                   .write(34/*'\"'*/).display(this).write(34/*'\"'*/).write(41/*')'*/);\n    return output;\n  }\n\n  override display<T>(output: Output<T>): Output<T> {\n    const stringValue = this.stringValue;\n    if (stringValue !== void 0) {\n      output = output.write(stringValue);\n    } else {\n      output = super.display(output);\n    }\n    return output;\n  }\n\n  /** @internal */\n  readonly stringValue: string | undefined;\n\n  override toString(): string {\n    let stringValue = this.stringValue;\n    if (stringValue === void 0) {\n      stringValue = Format.display(this);\n      (this as Mutable<this>).stringValue = stringValue;\n    }\n    return stringValue;\n  }\n}\n\n/** @public */\nexport class UriQueryBuilder implements PairBuilder<string | undefined, string, UriQuery> {\n  /** @internal */\n  first: UriQuery;\n  /** @internal */\n  last: UriQuery | null;\n  /** @internal */\n  size: number;\n  /** @internal */\n  aliased: number;\n\n  constructor() {\n    this.first = UriQuery.undefined();\n    this.last = null;\n    this.size = 0;\n    this.aliased = 0;\n  }\n\n  isEmpty(): boolean {\n    return this.size === 0;\n  }\n\n  add(key: string | undefined, value: string): void;\n  add(params: UriQueryLike): void;\n  add(key: UriQueryLike | undefined, value?: string): void {\n    if (value !== void 0) {\n      this.addParam(key as string | undefined, value);\n    } else if (typeof key === \"string\") {\n      this.addParam(void 0, key);\n    } else if (key instanceof UriQuery) {\n      this.addQuery(key);\n    } else {\n      const params = key!;\n      for (const k in params) {\n        let key = k as string | undefined;\n        const value = params[k]!;\n        if (k.charCodeAt(0) === 36/*'$'*/) {\n          key = void 0;\n        }\n        this.addParam(key, value);\n      }\n    }\n  }\n\n  build(): UriQuery {\n    this.aliased = 0;\n    return this.first;\n  }\n\n  addParam(value: string): void;\n  addParam(key: string | undefined, value: string): void;\n  addParam(key: string | undefined, value?: string): void {\n    if (value === void 0) {\n      value = key!;\n      key = void 0;\n    }\n    const tail = UriQuery.param(key, value, UriQuery.undefined());\n    const size = this.size;\n    if (size === 0) {\n      this.first = tail;\n    } else {\n      this.dealias(size - 1).setTail(tail);\n    }\n    this.last = tail;\n    this.size = size + 1;\n    this.aliased += 1;\n  }\n\n  addQuery(query: UriQuery): void {\n    if (query.isEmpty()) {\n      return;\n    }\n    let size = this.size;\n    if (size === 0) {\n      this.first = query;\n    } else {\n      this.dealias(size - 1).setTail(query);\n    }\n    size += 1;\n    do {\n      const tail = query.tail();\n      if (tail.isEmpty()) {\n        break;\n      }\n      query = tail;\n      size += 1;\n    } while (true);\n    this.last = query;\n    this.size = size;\n  }\n\n  /** @internal */\n  dealias(n: number): UriQuery {\n    let i = 0;\n    let xi: UriQuery | null = null;\n    let xs = this.first;\n    if (this.aliased <= n) {\n      while (i < this.aliased) {\n        xi = xs;\n        xs = xs.tail();\n        i += 1;\n      }\n      while (i <= n) {\n        const xn = xs.dealias();\n        if (i === 0) {\n          this.first = xn;\n        } else {\n          xi!.setTail(xn);\n        }\n        xi = xn;\n        xs = xs.tail();\n        i += 1;\n      }\n      if (i === this.size) {\n        this.last = xi;\n      }\n      this.aliased = i;\n    } else if (n === 0) {\n      xi = this.first;\n    } else if (n === this.size - 1) {\n      xi = this.last;\n    } else {\n      while (i <= n) {\n        xi = xs;\n        xs = xs.tail();\n        i += 1;\n      }\n    }\n    return xi!;\n  }\n\n  /** @override */\n  toString(): string {\n    return this.build().toString();\n  }\n}\n\n/** @internal */\nexport class UriQueryParser extends Parser<UriQuery> {\n  private readonly builder: UriQueryBuilder | undefined;\n  private readonly keyOutput: Output<string> | undefined;\n  private readonly valueOutput: Output<string> | undefined;\n  private readonly c1: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(builder?: UriQueryBuilder, keyOutput?: Output<string>,\n              valueOutput?: Output<string>, c1?: number, step?: number) {\n    super();\n    this.builder = builder;\n    this.keyOutput = keyOutput;\n    this.valueOutput = valueOutput;\n    this.c1 = c1;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<UriQuery> {\n    return UriQueryParser.parse(input, this.builder, this.keyOutput,\n                                this.valueOutput, this.c1, this.step);\n  }\n\n  static parse(input: Input, builder?: UriQueryBuilder, keyOutput?: Output<string>,\n               valueOutput?: Output<string>, c1: number = 0, step: number = 1): Parser<UriQuery> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        keyOutput = keyOutput || Utf8.decodedString();\n        while (input.isCont() && (c = input.head(), Uri.isParamChar(c))) {\n          input = input.step();\n          keyOutput.write(c);\n        }\n        if (input.isCont() && c === 61/*'='*/) {\n          input = input.step();\n          step = 4;\n        } else if (input.isCont() && c === 38/*'&'*/) {\n          input = input.step();\n          builder = builder || new UriQueryBuilder();\n          builder.addParam(keyOutput.bind());\n          keyOutput = void 0;\n          continue;\n        } else if (input.isCont() && c === 37/*'%'*/) {\n          input = input.step();\n          step = 2;\n        } else if (!input.isEmpty()) {\n          builder = builder || new UriQueryBuilder();\n          builder.addParam(keyOutput.bind());\n          return Parser.done(builder.build());\n        }\n      }\n      if (step === 2) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          c1 = c;\n          step = 3;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 3) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          keyOutput!.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));\n          c1 = 0;\n          step = 1;\n          continue;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 4) {\n        valueOutput = valueOutput || Utf8.decodedString();\n        while (input.isCont() && (c = input.head(), Uri.isParamChar(c) || c === 61/*'='*/)) {\n          input = input.step();\n          valueOutput.write(c);\n        }\n        if (input.isCont() && c === 38/*'&'*/) {\n          input = input.step();\n          builder = builder || new UriQueryBuilder();\n          builder.addParam(keyOutput!.bind(), valueOutput.bind());\n          keyOutput = void 0;\n          valueOutput = void 0;\n          step = 1;\n          continue;\n        } else if (input.isCont() && c === 37/*'%'*/) {\n          input = input.step();\n          step = 5;\n        } else if (!input.isEmpty()) {\n          builder = builder || new UriQueryBuilder();\n          builder.addParam(keyOutput!.bind(), valueOutput.bind());\n          return Parser.done(builder.build());\n        }\n      }\n      if (step === 5) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          c1 = c;\n          step = 6;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 6) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          valueOutput!.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));\n          c1 = 0;\n          step = 4;\n          continue;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      break;\n    } while (true);\n    return new UriQueryParser(builder, keyOutput, valueOutput, c1, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Compare} from \"@swim/util\";\nimport {Strings} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport type {Display} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport {Base16} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {Utf8} from \"@swim/codec\";\n\n/** @public */\nexport type UriFragmentLike = UriFragment | string;\n\n/** @public */\nexport const UriFragmentLike = {\n  [Symbol.hasInstance](instance: unknown): instance is UriFragmentLike {\n    return instance instanceof UriFragment\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport class UriFragment implements HashCode, Compare, Debug, Display {\n  /** @internal */\n  constructor(identifier: string | undefined) {\n    this.identifier = identifier;\n    this.stringValue = void 0;\n  }\n\n  likeType?(like: string): void;\n\n  isDefined(): boolean {\n    return this.identifier !== void 0;\n  }\n\n  readonly identifier: string | undefined;\n\n  toLike(): string | undefined {\n    return this.identifier;\n  }\n\n  /** @override */\n  compareTo(that: UriFragment): number {\n    if (that instanceof UriFragment) {\n      return this.toString().localeCompare(that.toString());\n    }\n    return NaN;\n  }\n\n  /** @override */\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UriFragment) {\n      return this.identifier === that.identifier;\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Strings.hash(this.identifier);\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"UriFragment\").write(46/*'.'*/);\n    if (this.isDefined()) {\n      output = output.write(\"parse\").write(40/*'('*/).write(34/*'\"'*/)\n                     .display(this).write(34/*'\"'*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"undefined\").write(40/*'('*/).write(41/*')'*/);\n    }\n    return output;\n  }\n\n  /** @override */\n  display<T>(output: Output<T>): Output<T> {\n    const stringValue = this.stringValue;\n    if (stringValue !== void 0) {\n      output = output.write(stringValue);\n    } else if (this.identifier !== void 0) {\n      output = Uri.writeFragment(output, this.identifier);\n    }\n    return output;\n  }\n\n  /** @internal */\n  readonly stringValue: string | undefined;\n\n  /** @override */\n  toString(): string {\n    let stringValue = this.stringValue;\n    if (stringValue === void 0) {\n      stringValue = Format.display(this);\n      (this as Mutable<this>).stringValue = stringValue;\n    }\n    return stringValue;\n  }\n\n  @Lazy\n  static undefined(): UriFragment {\n    return new UriFragment(void 0);\n  }\n\n  static create(identifier: string | undefined): UriFragment {\n    if (identifier === void 0) {\n      return UriFragment.undefined();\n    }\n    return new UriFragment(identifier);\n  }\n\n  static fromLike<T extends UriFragmentLike | null | undefined>(value: T): UriFragment | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof UriFragment) {\n      return value as UriFragment | Uninitable<T>;\n    } else if (typeof value === \"string\") {\n      return UriFragment.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static parse(input: Input): Parser<UriFragment>;\n  static parse(string: string): UriFragment;\n  static parse(string: Input | string): Parser<UriFragment> | UriFragment {\n    const input = typeof string === \"string\" ? Unicode.stringInput(string) : string;\n    let parser = UriFragmentParser.parse(input);\n    if (typeof string === \"string\" && input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return typeof string === \"string\" ? parser.bind() : parser;\n  }\n}\n\n/** @internal */\nexport class UriFragmentParser extends Parser<UriFragment> {\n  private readonly output: Output<string> | undefined;\n  private readonly c1: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(output?: Output<string>, c1?: number, step?: number) {\n    super();\n    this.output = output;\n    this.c1 = c1;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<UriFragment> {\n    return UriFragmentParser.parse(input, this.output, this.c1, this.step);\n  }\n\n  static parse(input: Input, output?: Output<string>,\n               c1: number = 0, step: number = 1): Parser<UriFragment> {\n    let c = 0;\n    output = output || Utf8.decodedString();\n    do {\n      if (step === 1) {\n        while (input.isCont() && (c = input.head(), Uri.isFragmentChar(c))) {\n          input = input.step();\n          output = output.write(c);\n        }\n        if (input.isCont() && c === 37/*'%'*/) {\n          input = input.step();\n          step = 2;\n        } else if (!input.isEmpty()) {\n          return Parser.done(UriFragment.create(output.bind()));\n        }\n      }\n      if (step === 2) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          c1 = c;\n          step = 3;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 3) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          output = output.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));\n          c1 = 0;\n          step = 1;\n          continue;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      break;\n    } while (true);\n    return new UriFragmentParser(output, c1, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Equivalent} from \"@swim/util\";\nimport type {Compare} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Interpolate} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Base10} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport type {Item} from \"@swim/structure\";\nimport {Attr} from \"@swim/structure\";\nimport {Value} from \"@swim/structure\";\nimport {Text} from \"@swim/structure\";\nimport {Form} from \"@swim/structure\";\n\n/** @public */\nexport type LengthUnits = \"px\" | \"em\" | \"rem\" | \"%\" | \"\";\n\n/** @public */\nexport interface LengthBasis {\n  emUnit?: Node | number;\n  remUnit?: number;\n  pctUnit?: number;\n}\n\n/** @public */\nexport type LengthLike = Length | number | string;\n\n/** @public */\nexport const LengthLike = {\n  [Symbol.hasInstance](instance: unknown): instance is LengthLike {\n    return instance instanceof Length\n        || typeof instance === \"number\"\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport abstract class Length implements Interpolate<Length>, HashCode, Equivalent, Compare, Debug {\n  isDefined(): boolean {\n    return isFinite(this.value);\n  }\n\n  likeType?(like: number | string): void;\n\n  abstract readonly value: number;\n\n  abstract readonly units: LengthUnits;\n\n  plus(that: LengthLike, units: LengthUnits = this.units, basis?: LengthBasis | number): Length {\n    that = Length.fromLike(that);\n    return Length.of(this.toValue(units, basis) + that.toValue(units, basis), units);\n  }\n\n  negative(units: LengthUnits = this.units, basis?: LengthBasis | number): Length {\n    return Length.of(-this.toValue(units, basis), units);\n  }\n\n  minus(that: LengthLike, units: LengthUnits = this.units, basis?: LengthBasis | number): Length {\n    that = Length.fromLike(that);\n    return Length.of(this.toValue(units, basis) - that.toValue(units, basis), units);\n  }\n\n  times(scalar: number, units: LengthUnits = this.units, basis?: LengthBasis | number): Length {\n    return Length.of(this.toValue(units, basis) * scalar, units);\n  }\n\n  divide(scalar: number, units: LengthUnits = this.units, basis?: LengthBasis | number): Length {\n    return Length.of(this.toValue(units, basis) / scalar, units);\n  }\n\n  combine(that: LengthLike, scalar: number = 1, units: LengthUnits = this.units, basis?: LengthBasis | number): Length {\n    that = Length.fromLike(that);\n    return Length.of(this.toValue(units, basis) + that.toValue(units, basis) * scalar, units);\n  }\n\n  abstract pxValue(basis?: LengthBasis | number): number;\n\n  emValue(basis?: LengthBasis | number): number {\n    return this.value !== 0 ? this.pxValue(basis) / Length.emUnit(basis) : 0;\n  }\n\n  remValue(basis?: LengthBasis | number): number {\n    return this.value !== 0 ? this.pxValue(basis) / Length.remUnit(basis) : 0;\n  }\n\n  pctValue(basis?: LengthBasis | number): number {\n    return this.value !== 0 ? this.pxValue(basis) / Length.pctUnit(basis) : 0;\n  }\n\n  px(basis?: LengthBasis | number): PxLength {\n    return PxLength.of(this.pxValue(basis));\n  }\n\n  em(basis?: LengthBasis | number): EmLength {\n    return EmLength.of(this.emValue(basis));\n  }\n\n  rem(basis?: LengthBasis | number): RemLength {\n    return RemLength.of(this.remValue(basis));\n  }\n\n  pct(basis?: LengthBasis | number): PctLength {\n    return PctLength.of(this.pctValue(basis));\n  }\n\n  toValue(): Value;\n  toValue(units: LengthUnits, basis?: LengthBasis | number): number;\n  toValue(units?: LengthUnits, basis?: LengthBasis | number): Value | number {\n    if (units === void 0) {\n      return Text.from(this.toString());\n    }\n    switch (units) {\n      case \"px\": return this.pxValue(basis);\n      case \"em\": return this.emValue(basis);\n      case \"rem\": return this.remValue(basis);\n      case \"%\": return this.pctValue(basis);\n      default: throw new Error(\"unknown length units: \" + units);\n    }\n  }\n\n  to(units: LengthUnits, basis?: LengthBasis | number): Length {\n    switch (units) {\n      case \"px\": return this.px(basis);\n      case \"em\": return this.em(basis);\n      case \"rem\": return this.rem(basis);\n      case \"%\": return this.pct(basis);\n      default: throw new Error(\"unknown length units: \" + units);\n    }\n  }\n\n  abstract toCssValue(): CSSUnitValue | null;\n\n  /** @override */\n  interpolateTo(that: Length): Interpolator<Length>;\n  interpolateTo(that: unknown): Interpolator<Length> | null;\n  interpolateTo(that: unknown): Interpolator<Length> | null {\n    if (that instanceof Length) {\n      return LengthInterpolator(this, that);\n    }\n    return null;\n  }\n\n  /** @override */\n  abstract compareTo(that: unknown): number;\n\n  /** @override */\n  abstract equivalentTo(that: unknown, epsilon?: number): boolean;\n\n  /** @override */\n  abstract equals(that: unknown): boolean;\n\n  /** @override */\n  abstract hashCode(): number;\n\n  /** @override */\n  abstract debug<T>(output: Output<T>): Output<T>;\n\n  /** @override */\n  abstract toString(): string;\n\n  static zero(units?: LengthUnits): Length {\n    switch (units) {\n      case void 0:\n      case \"px\": return PxLength.zero();\n      case \"em\": return EmLength.zero();\n      case \"rem\": return RemLength.zero();\n      case \"%\": return PctLength.zero();\n      case \"\": return UnitlessLength.zero();\n      default: throw new Error(\"unknown length units: \" + units);\n    }\n  }\n\n  static px(value: number): PxLength {\n    return PxLength.of(value);\n  }\n\n  static em(value: number): EmLength {\n    return EmLength.of(value);\n  }\n\n  static rem(value: number): RemLength {\n    return RemLength.of(value);\n  }\n\n  static pct(value: number): PctLength {\n    return PctLength.of(value);\n  }\n\n  static unitless(value: number): UnitlessLength {\n    return UnitlessLength.of(value);\n  }\n\n  static of(value: number, units?: LengthUnits): Length {\n    switch (units) {\n      case void 0:\n      case \"px\": return PxLength.of(value);\n      case \"em\": return EmLength.of(value);\n      case \"rem\": return RemLength.of(value);\n      case \"%\": return PctLength.of(value);\n      case \"\": return UnitlessLength.of(value);\n      default: throw new Error(\"unknown length units: \" + units);\n    }\n  }\n\n  static fromCssValue(value: CSSStyleValue): Length {\n    if (value instanceof CSSUnitValue) {\n      return Length.of(value.value, value.unit as LengthUnits);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromLike<T extends LengthLike | null | undefined>(value: T, defaultUnits?: LengthUnits): Length | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof Length) {\n      return value as Length | Uninitable<T>;\n    } else if (typeof value === \"number\") {\n      return Length.of(value, defaultUnits);\n    } else if (typeof value === \"string\") {\n      return Length.parse(value, defaultUnits);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromValue(value: Value): Length | null {\n    if (value.length !== 2) {\n      return null;\n    }\n    const num = value.getItem(0).numberValue(void 0);\n    const units = value.getItem(1);\n    if (num === void 0 || !isFinite(num) || !(units instanceof Attr) || units.value !== Value.extant()) {\n      return null;\n    }\n    switch (units.key.value) {\n      case \"px\": return PxLength.of(num);\n      case \"em\": return EmLength.of(num);\n      case \"rem\": return RemLength.of(num);\n      case \"pct\": return PctLength.of(num);\n      default: return null;\n    }\n  }\n\n  static parse(string: string, defaultUnits?: LengthUnits): Length {\n    let input = Unicode.stringInput(string);\n    while (input.isCont() && Unicode.isWhitespace(input.head())) {\n      input = input.step();\n    }\n    let parser = LengthParser.parse(input, defaultUnits);\n    if (parser.isDone()) {\n      while (input.isCont() && Unicode.isWhitespace(input.head())) {\n        input = input.step();\n      }\n    }\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n\n  @Lazy\n  static form(): Form<Length, LengthLike> {\n    return new LengthForm(void 0, Length.zero());\n  }\n\n  /** @internal */\n  static emUnit(basis?: LengthBasis | number): number {\n    if (basis === void 0 || typeof basis === \"number\") {\n      throw new Error(\"unknown em unit: \" + basis);\n    }\n    const emUnit = basis.emUnit;\n    if (typeof emUnit === \"number\") {\n      return emUnit;\n    } else if (!(emUnit instanceof Node)) {\n      throw new Error(\"unknown em unit: \" + emUnit);\n    }\n    let node: Node | null = emUnit;\n    while (node !== null) {\n      if (node instanceof Element) {\n        const fontSize = getComputedStyle(node).fontSize;\n        if (typeof fontSize === \"string\") {\n          return parseFloat(fontSize);\n        }\n      }\n      node = node.parentNode;\n    }\n    throw new Error(\"unknown em unit: \" + emUnit);\n  }\n\n  /** @internal */\n  static remUnit(basis?: LengthBasis | number): number {\n    if (basis !== void 0 && typeof basis !== \"number\") {\n      const remUnit = basis.remUnit;\n      if (typeof remUnit === \"number\") {\n        return remUnit;\n      }\n    }\n    const fontSize = getComputedStyle(document.documentElement).fontSize;\n    if (typeof fontSize === \"string\") {\n      return parseFloat(fontSize);\n    }\n    throw new Error(\"unknown rem unit\");\n  }\n\n  /** @internal */\n  static pctUnit(basis?: LengthBasis | number): number {\n    if (typeof basis === \"number\") {\n      return basis;\n    } else if (basis !== void 0) {\n      const pctUnit = basis.pctUnit;\n      if (typeof pctUnit === \"number\") {\n        return pctUnit;\n      }\n    }\n    throw new Error(\"unknown percentage unit\");\n  }\n}\n\n/** @public */\nexport class PxLength extends Length {\n  constructor(value: number) {\n    super();\n    this.value = value;\n  }\n\n  override readonly value: number;\n\n  override get units(): \"px\" {\n    return \"px\";\n  }\n\n  override pxValue(basis?: LengthBasis | number): number {\n    return this.value;\n  }\n\n  override px(basis?: LengthBasis | number): PxLength {\n    return this;\n  }\n\n  override toCssValue(): CSSUnitValue | null {\n    if (typeof CSSUnitValue !== \"undefined\") {\n      return new CSSUnitValue(this.value, \"px\");\n    }\n    return null;\n  }\n\n  override valueOf(): number {\n    return this.value;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Length) {\n      const x = this.value;\n      const y = that.pxValue();\n      return x < y ? -1 : x > y ? 1 : isNaN(y) ? (isNaN(x) ? 0 : -1) : isNaN(x) ? 1 : 0;\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (that instanceof Length) {\n      return Numbers.equivalent(this.value, that.pxValue());\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (that instanceof PxLength) {\n      return this.value === that.value;\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(PxLength), Numbers.hash(this.value)));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Length\").write(46/*'.'*/).write(\"px\")\n                   .write(40/*'('*/).debug(this.value).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return this.value + \"px\";\n  }\n\n  @Lazy\n  static override zero(): PxLength {\n    return new PxLength(0);\n  }\n\n  static override of(value: number): PxLength {\n    if (value === 0) {\n      return this.zero();\n    }\n    return new PxLength(value);\n  }\n}\n\n/** @public */\nexport class EmLength extends Length {\n  constructor(value: number) {\n    super();\n    this.value = value;\n  }\n\n  override readonly value: number;\n\n  override get units(): \"em\" {\n    return \"em\";\n  }\n\n  override pxValue(basis?: LengthBasis | number): number {\n    return this.value !== 0 ? this.value * Length.emUnit(basis) : 0;\n  }\n\n  override emValue(basis?: LengthBasis | number): number {\n    return this.value;\n  }\n\n  override em(basis?: LengthBasis | number): EmLength {\n    return this;\n  }\n\n  override toCssValue(): CSSUnitValue | null {\n    if (typeof CSSUnitValue !== \"undefined\") {\n      return new CSSUnitValue(this.value, \"em\");\n    }\n    return null;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Length) {\n      const x = this.value;\n      const y = that.emValue();\n      return x < y ? -1 : x > y ? 1 : isNaN(y) ? (isNaN(x) ? 0 : -1) : isNaN(x) ? 1 : 0;\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (that instanceof Length) {\n      return Numbers.equivalent(this.value, that.emValue());\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (that instanceof EmLength) {\n      return this.value === that.value;\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(EmLength), Numbers.hash(this.value)));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Length\").write(46/*'.'*/).write(\"em\")\n                   .write(40/*'('*/).debug(this.value).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return this.value + \"em\";\n  }\n\n  @Lazy\n  static override zero(): EmLength {\n    return new EmLength(0);\n  }\n\n  static override of(value: number): EmLength {\n    if (value === 0) {\n      return this.zero();\n    }\n    return new EmLength(value);\n  }\n}\n\n/** @public */\nexport class RemLength extends Length {\n  constructor(value: number) {\n    super();\n    this.value = value;\n  }\n\n  override readonly value: number;\n\n  override get units(): \"rem\" {\n    return \"rem\";\n  }\n\n  override pxValue(basis?: LengthBasis | number): number {\n    return this.value !== 0 ? this.value * Length.remUnit(basis) : 0;\n  }\n\n  override remValue(basis?: LengthBasis | number): number {\n    return this.value;\n  }\n\n  override rem(basis?: LengthBasis | number): RemLength {\n    return this;\n  }\n\n  override toCssValue(): CSSUnitValue | null {\n    if (typeof CSSUnitValue !== \"undefined\") {\n      return new CSSUnitValue(this.value, \"rem\");\n    }\n    return null;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof RemLength) {\n      const x = this.value;\n      const y = that.remValue();\n      return x < y ? -1 : x > y ? 1 : isNaN(y) ? (isNaN(x) ? 0 : -1) : isNaN(x) ? 1 : 0;\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (that instanceof RemLength) {\n      return Numbers.equivalent(this.value, that.remValue());\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (that instanceof RemLength) {\n      return this.value === that.value;\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(RemLength), Numbers.hash(this.value)));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Length\").write(46/*'.'*/).write(\"rem\")\n                   .write(40/*'('*/).debug(this.value).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return this.value + \"rem\";\n  }\n\n  @Lazy\n  static override zero(): RemLength {\n    return new RemLength(0);\n  }\n\n  static override of(value: number): RemLength {\n    if (value === 0) {\n      return this.zero();\n    }\n    return new RemLength(value);\n  }\n}\n\n/** @public */\nexport class PctLength extends Length {\n  constructor(value: number) {\n    super();\n    this.value = value;\n  }\n\n  override readonly value: number;\n\n  override get units(): \"%\" {\n    return \"%\";\n  }\n\n  override pxValue(basis?: LengthBasis | number): number {\n    return this.value !== 0 ? this.value * Length.pctUnit(basis) / 100 : 0;\n  }\n\n  override pctValue(basis?: LengthBasis | number): number {\n    return this.value;\n  }\n\n  override pct(basis?: LengthBasis | number): PctLength {\n    return this;\n  }\n\n  override toCssValue(): CSSUnitValue | null {\n    if (typeof CSSUnitValue !== \"undefined\") {\n      return new CSSUnitValue(this.value, \"percent\");\n    }\n    return null;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Length) {\n      const x = this.value;\n      const y = that.pctValue();\n      return x < y ? -1 : x > y ? 1 : isNaN(y) ? (isNaN(x) ? 0 : -1) : isNaN(x) ? 1 : 0;\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (that instanceof Length) {\n      return Numbers.equivalent(this.value, that.pctValue());\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (that instanceof PctLength) {\n      return this.value === that.value;\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(PctLength), Numbers.hash(this.value)));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Length\").write(46/*'.'*/).write(\"pct\")\n                   .write(40/*'('*/).debug(this.value).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return this.value + \"%\";\n  }\n\n  @Lazy\n  static override zero(): PctLength {\n    return new PctLength(0);\n  }\n\n  static override of(value: number): PctLength {\n    if (value === 0) {\n      return this.zero();\n    }\n    return new PctLength(value);\n  }\n}\n\n/** @public */\nexport class UnitlessLength extends Length {\n  constructor(value: number) {\n    super();\n    this.value = value;\n  }\n\n  override readonly value: number;\n\n  override get units(): \"\" {\n    return \"\";\n  }\n\n  override pxValue(basis?: LengthBasis | number): number {\n    throw new Error(\"unitless length\");\n  }\n\n  override toCssValue(): CSSUnitValue | null {\n    return null;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Length) {\n      const x = this.value;\n      const y = that.value;\n      return x < y ? -1 : x > y ? 1 : isNaN(y) ? (isNaN(x) ? 0 : -1) : isNaN(x) ? 1 : 0;\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (that instanceof Length) {\n      return Numbers.equivalent(this.value, that.value);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (that instanceof UnitlessLength) {\n      return this.value === that.value;\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(UnitlessLength), Numbers.hash(this.value)));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Length\").write(46/*'.'*/).write(\"unitless\")\n                   .write(40/*'('*/).debug(this.value).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return this.value + \"\";\n  }\n\n  @Lazy\n  static override zero(): UnitlessLength {\n    return new UnitlessLength(0);\n  }\n\n  static override of(value: number): UnitlessLength {\n    if (value === 0) {\n      return this.zero();\n    }\n    return new UnitlessLength(value);\n  }\n}\n\n/** @internal */\nexport const LengthInterpolator = (function (_super: typeof Interpolator) {\n  const LengthInterpolator = function (l0: Length, l1: Length): Interpolator<Length> {\n    const interpolator = function (u: number): Length {\n      const l0 = interpolator[0];\n      const l1 = interpolator[1];\n      return Length.of(l0.value + u * (l1.value - l0.value), l1.units);\n    } as Interpolator<Length>;\n    Object.setPrototypeOf(interpolator, LengthInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = l0.to(l1.units);\n    (interpolator as Mutable<typeof interpolator>)[1] = l1;\n    return interpolator;\n  } as {\n    (l0: Length, l1: Length): Interpolator<Length>;\n\n    /** @internal */\n    prototype: Interpolator<Length>;\n  };\n\n  LengthInterpolator.prototype = Object.create(_super.prototype);\n  LengthInterpolator.prototype.constructor = LengthInterpolator;\n\n  return LengthInterpolator;\n})(Interpolator);\n\n/** @internal */\nexport class LengthForm extends Form<Length, LengthLike> {\n  constructor(defaultUnits: LengthUnits | undefined, unit: Length | undefined) {\n    super();\n    this.defaultUnits = defaultUnits;\n    Object.defineProperty(this, \"unit\", {\n      value: unit,\n      enumerable: true,\n      configurable: true,\n    });\n  }\n\n  readonly defaultUnits: LengthUnits | undefined;\n\n  override readonly unit: Length | undefined;\n\n  override withUnit(unit: Length | undefined): Form<Length, LengthLike> {\n    if (unit === this.unit) {\n      return this;\n    }\n    return new LengthForm(this.defaultUnits, unit);\n  }\n\n  override mold(length: LengthLike): Item {\n    length = Length.fromLike(length, this.defaultUnits);\n    return Text.from(length.toString());\n  }\n\n  override cast(item: Item): Length | undefined {\n    const value = item.toValue();\n    let length: Length | null = null;\n    try {\n      length = Length.fromValue(value);\n      if (length !== void 0) {\n        const string = value.stringValue(void 0);\n        if (string !== void 0) {\n          length = Length.parse(string, this.defaultUnits);\n        }\n      }\n    } catch (e) {\n      // swallow\n    }\n    return length !== null ? length : void 0;\n  }\n}\n\n/** @internal */\nexport class LengthParser extends Parser<Length> {\n  private readonly defaultUnits: LengthUnits | undefined;\n  private readonly valueParser: Parser<number> | undefined;\n  private readonly unitsOutput: Output<string> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(defaultUnits?: LengthUnits, valueParser?: Parser<number>,\n              unitsOutput?: Output<string>, step?: number) {\n    super();\n    this.defaultUnits = defaultUnits;\n    this.valueParser = valueParser;\n    this.unitsOutput = unitsOutput;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<Length> {\n    return LengthParser.parse(input, this.defaultUnits, this.valueParser,\n                              this.unitsOutput, this.step);\n  }\n\n  static parse(input: Input, defaultUnits?: LengthUnits, valueParser?: Parser<number>,\n               unitsOutput?: Output<string>, step: number = 1): Parser<Length> {\n    let c = 0;\n    if (step === 1) {\n      if (valueParser === void 0) {\n        valueParser = Base10.parseDecimal(input);\n      } else {\n        valueParser = valueParser.feed(input);\n      }\n      if (valueParser.isDone()) {\n        step = 2;\n      } else if (valueParser.isError()) {\n        return valueParser.asError();\n      }\n    }\n    if (step === 2) {\n      unitsOutput = unitsOutput || Unicode.stringOutput();\n      while (input.isCont() && (c = input.head(), Unicode.isAlpha(c) || c === 37/*'%'*/)) {\n        input = input.step();\n        unitsOutput.push(c);\n      }\n      if (!input.isEmpty()) {\n        const value = valueParser!.bind();\n        const units = unitsOutput.bind() || defaultUnits;\n        switch (units) {\n          case \"px\": return Parser.done(Length.px(value));\n          case \"em\": return Parser.done(Length.em(value));\n          case \"rem\": return Parser.done(Length.rem(value));\n          case \"%\": return Parser.done(Length.pct(value));\n          case \"\":\n          case void 0: return Parser.done(Length.unitless(value));\n          default: return Parser.error(Diagnostic.message(\"unknown length units: \" + units, input));\n        }\n      }\n    }\n    return new LengthParser(defaultUnits, valueParser, unitsOutput, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Equivalent} from \"@swim/util\";\nimport type {Compare} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Interpolate} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Base10} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport type {Item} from \"@swim/structure\";\nimport {Attr} from \"@swim/structure\";\nimport {Value} from \"@swim/structure\";\nimport {Text} from \"@swim/structure\";\nimport {Form} from \"@swim/structure\";\n\n/** @public */\nexport type AngleUnits = \"deg\" | \"rad\" | \"grad\" | \"turn\";\n\n/** @public */\nexport type AngleLike = Angle | string | number;\n\n/** @public */\nexport const AngleLike = {\n  [Symbol.hasInstance](instance: unknown): instance is AngleLike {\n    return instance instanceof Angle\n        || typeof instance === \"number\"\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport abstract class Angle implements Interpolate<Angle>, HashCode, Equivalent, Compare, Debug {\n  isDefined(): boolean {\n    return isFinite(this.value);\n  }\n\n  likeType?(like: string | number): void;\n\n  abstract readonly value: number;\n\n  abstract readonly units: AngleUnits;\n\n  plus(that: AngleLike, units: AngleUnits = this.units): Angle {\n    that = Angle.fromLike(that);\n    return Angle.of(this.toValue(units) + that.toValue(units), units);\n  }\n\n  negative(units: AngleUnits = this.units): Angle {\n    return Angle.of(-this.toValue(units), units);\n  }\n\n  minus(that: AngleLike, units: AngleUnits = this.units): Angle {\n    that = Angle.fromLike(that);\n    return Angle.of(this.toValue(units) - that.toValue(units), units);\n  }\n\n  times(scalar: number, units: AngleUnits = this.units): Angle {\n    return Angle.of(this.toValue(units) * scalar, units);\n  }\n\n  divide(scalar: number, units: AngleUnits = this.units): Angle {\n    return Angle.of(this.toValue(units) / scalar, units);\n  }\n\n  combine(that: AngleLike, scalar: number = 1, units: AngleUnits = this.units): Angle {\n    that = Angle.fromLike(that);\n    return Angle.of(this.toValue(units) + that.toValue(units) * scalar, units);\n  }\n\n  norm(total: AngleLike, units: AngleUnits = this.units): Angle {\n    total = Angle.fromLike(total);\n    return Angle.of(this.toValue(units) / total.toValue(units), units);\n  }\n\n  abstract degValue(): number;\n\n  abstract gradValue(): number;\n\n  abstract radValue(): number;\n\n  abstract turnValue(): number;\n\n  deg(): DegAngle {\n    return DegAngle.of(this.degValue());\n  }\n\n  rad(): RadAngle {\n    return RadAngle.of(this.radValue());\n  }\n\n  grad(): GradAngle {\n    return GradAngle.of(this.gradValue());\n  }\n\n  turn(): TurnAngle {\n    return TurnAngle.of(this.turnValue());\n  }\n\n  toValue(): Value;\n  toValue(units: AngleUnits): number;\n  toValue(units?: AngleUnits): Value | number {\n    if (units === void 0) {\n      return Text.from(this.toString());\n    }\n    switch (units) {\n      case \"deg\": return this.degValue();\n      case \"rad\": return this.radValue();\n      case \"grad\": return this.gradValue();\n      case \"turn\": return this.turnValue();\n      default: throw new Error(\"unknown angle units: \" + units);\n    }\n  }\n\n  to(units: AngleUnits): Angle {\n    switch (units) {\n      case \"deg\": return this.deg();\n      case \"rad\": return this.rad();\n      case \"grad\": return this.grad();\n      case \"turn\": return this.turn();\n      default: throw new Error(\"unknown angle units: \" + units);\n    }\n  }\n\n  abstract toCssValue(): CSSUnitValue | null;\n\n  /** @override */\n  interpolateTo(that: Angle): Interpolator<Angle>;\n  interpolateTo(that: unknown): Interpolator<Angle> | null;\n  interpolateTo(that: unknown): Interpolator<Angle> | null {\n    if (that instanceof Angle) {\n      return AngleInterpolator(this, that);\n    }\n    return null;\n  }\n\n  /** @override */\n  abstract compareTo(that: unknown): number;\n\n  /** @override */\n  abstract equivalentTo(that: unknown, epsilon?: number): boolean;\n\n  /** @override */\n  abstract equals(that: unknown): boolean;\n\n  /** @override */\n  abstract hashCode(): number;\n\n  /** @override */\n  abstract debug<T>(output: Output<T>): Output<T>;\n\n  /** @override */\n  abstract toString(): string;\n\n  static zero(units?: AngleUnits): Angle {\n    switch (units) {\n      case \"deg\": return DegAngle.zero();\n      case void 0:\n      case \"rad\": return RadAngle.zero();\n      case \"grad\": return GradAngle.zero();\n      case \"turn\": return TurnAngle.zero();\n      default: throw new Error(\"unknown angle units: \" + units);\n    }\n  }\n\n  static deg(value: number): DegAngle {\n    return DegAngle.of(value);\n  }\n\n  static rad(value: number): RadAngle {\n    return RadAngle.of(value);\n  }\n\n  static grad(value: number): GradAngle {\n    return GradAngle.of(value);\n  }\n\n  static turn(value: number): TurnAngle {\n    return TurnAngle.of(value);\n  }\n\n  static of(value: number, units?: AngleUnits): Angle {\n    switch (units) {\n      case \"deg\": return DegAngle.of(value);\n      case void 0:\n      case \"rad\": return RadAngle.of(value);\n      case \"grad\": return GradAngle.of(value);\n      case \"turn\": return TurnAngle.of(value);\n      default: throw new Error(\"unknown angle units: \" + units);\n    }\n  }\n\n  static fromCssValue(value: CSSStyleValue): Angle {\n    if (value instanceof CSSUnitValue) {\n      return Angle.of(value.value, value.unit as AngleUnits);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromLike<T extends AngleLike | null | undefined>(value: T, defaultUnits?: AngleUnits): Angle | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof Angle) {\n      return value as Angle | Uninitable<T>;\n    } else if (typeof value === \"number\") {\n      return Angle.of(value, defaultUnits);\n    } else if (typeof value === \"string\") {\n      return Angle.parse(value, defaultUnits);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromValue(value: Value): Angle | null {\n    if (value.length !== 2) {\n      return null;\n    }\n    const num = value.getItem(0).numberValue();\n    const units = value.getItem(1);\n    if (num === void 0 || !isFinite(num) || !(units instanceof Attr) || units.toValue() !== Value.extant()) {\n      return null;\n    }\n    switch (units.key.value) {\n      case \"deg\": return DegAngle.of(num);\n      case \"rad\": return RadAngle.of(num);\n      case \"grad\": return GradAngle.of(num);\n      case \"turn\": return TurnAngle.of(num);\n      default: return null;\n    }\n  }\n\n  static parse(string: string, defaultUnits?: AngleUnits): Angle {\n    let input = Unicode.stringInput(string);\n    while (input.isCont() && Unicode.isWhitespace(input.head())) {\n      input = input.step();\n    }\n    let parser = AngleParser.parse(input, defaultUnits);\n    if (parser.isDone()) {\n      while (input.isCont() && Unicode.isWhitespace(input.head())) {\n        input = input.step();\n      }\n    }\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n\n  @Lazy\n  static form(): Form<Angle, AngleLike> {\n    return new AngleForm(void 0, Angle.zero());\n  }\n}\n\n/** @public */\nexport class DegAngle extends Angle {\n  constructor(value: number) {\n    super();\n    this.value = value;\n  }\n\n  override readonly value: number;\n\n  override get units(): \"deg\" {\n    return \"deg\";\n  }\n\n  override degValue(): number {\n    return this.value;\n  }\n\n  override gradValue(): number {\n    return this.value * 10 / 9;\n  }\n\n  override radValue(): number {\n    return this.value * Math.PI / 180;\n  }\n\n  override turnValue(): number {\n    return this.value / 360;\n  }\n\n  override deg(): DegAngle {\n    return this;\n  }\n\n  override toCssValue(): CSSUnitValue | null {\n    if (typeof CSSUnitValue !== \"undefined\") {\n      return new CSSUnitValue(this.value, \"deg\");\n    }\n    return null;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Angle) {\n      const x = this.value;\n      const y = that.degValue();\n      return x < y ? -1 : x > y ? 1 : isNaN(y) ? (isNaN(x) ? 0 : -1) : isNaN(x) ? 1 : 0;\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (that instanceof Angle) {\n      return Numbers.equivalent(this.value, that.degValue());\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (that instanceof DegAngle) {\n      return this.value === that.value;\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(DegAngle), Numbers.hash(this.value)));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Angle\").write(46/*'.'*/).write(\"deg\")\n                   .write(40/*'('*/).debug(this.value).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return this.value + \"deg\";\n  }\n\n  @Lazy\n  static override zero(): DegAngle {\n    return new DegAngle(0);\n  }\n\n  static override of(value: number): DegAngle {\n    if (value === 0) {\n      return this.zero();\n    }\n    return new DegAngle(value);\n  }\n}\n\n/** @public */\nexport class RadAngle extends Angle {\n  constructor(value: number) {\n    super();\n    this.value = value;\n  }\n\n  override readonly value: number;\n\n  override get units(): \"rad\" {\n    return \"rad\";\n  }\n\n  override degValue(): number {\n    return this.value * 180 / Math.PI;\n  }\n\n  override gradValue(): number {\n    return this.value * 200 / Math.PI;\n  }\n\n  override radValue(): number {\n    return this.value;\n  }\n\n  override turnValue(): number {\n    return this.value / (2 * Math.PI);\n  }\n\n  override rad(): RadAngle {\n    return this;\n  }\n\n  override toCssValue(): CSSUnitValue | null {\n    if (typeof CSSUnitValue !== \"undefined\") {\n      return new CSSUnitValue(this.value, \"rad\");\n    }\n    return null;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Angle) {\n      const x = this.value;\n      const y = that.radValue();\n      return x < y ? -1 : x > y ? 1 : isNaN(y) ? (isNaN(x) ? 0 : -1) : isNaN(x) ? 1 : 0;\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (that instanceof Angle) {\n      return Numbers.equivalent(this.value, that.radValue());\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (that instanceof RadAngle) {\n      return this.value === that.value;\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(RadAngle), Numbers.hash(this.value)));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Angle\").write(46/*'.'*/).write(\"rad\")\n                   .write(40/*'('*/).debug(this.value).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return this.value + \"rad\";\n  }\n\n  @Lazy\n  static override zero(): RadAngle {\n    return new RadAngle(0);\n  }\n\n  static override of(value: number): RadAngle {\n    if (value === 0) {\n      return this.zero();\n    }\n    return new RadAngle(value);\n  }\n}\n\n/** @public */\nexport class GradAngle extends Angle {\n  constructor(value: number) {\n    super();\n    this.value = value;\n  }\n\n  override readonly value: number;\n\n  override get units(): \"grad\" {\n    return \"grad\";\n  }\n\n  override degValue(): number {\n    return this.value * 0.9;\n  }\n\n  override gradValue(): number {\n    return this.value;\n  }\n\n  override radValue(): number {\n    return this.value * Math.PI / 200;\n  }\n\n  override turnValue(): number {\n    return this.value / 400;\n  }\n\n  override grad(): GradAngle {\n    return this;\n  }\n\n  override toCssValue(): CSSUnitValue | null {\n    if (typeof CSSUnitValue !== \"undefined\") {\n      return new CSSUnitValue(this.value, \"grad\");\n    }\n    return null;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Angle) {\n      const x = this.value;\n      const y = that.gradValue();\n      return x < y ? -1 : x > y ? 1 : isNaN(y) ? (isNaN(x) ? 0 : -1) : isNaN(x) ? 1 : 0;\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (that instanceof Angle) {\n      return Numbers.equivalent(this.value, that.gradValue());\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (that instanceof GradAngle) {\n      return this.value === that.value;\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(GradAngle), Numbers.hash(this.value)));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Angle\").write(46/*'.'*/).write(\"grad\")\n                   .write(40/*'('*/).debug(this.value).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return this.value + \"grad\";\n  }\n\n  @Lazy\n  static override zero(): GradAngle {\n    return new GradAngle(0);\n  }\n\n  static override of(value: number): GradAngle {\n    if (value === 0) {\n      return this.zero();\n    }\n    return new GradAngle(value);\n  }\n}\n\n/** @public */\nexport class TurnAngle extends Angle {\n  constructor(value: number) {\n    super();\n    this.value = value;\n  }\n\n  readonly value: number;\n\n  override get units(): \"turn\" {\n    return \"turn\";\n  }\n\n  override degValue(): number {\n    return this.value * 360;\n  }\n\n  override gradValue(): number {\n    return this.value * 400;\n  }\n\n  override radValue(): number {\n    return this.value * (2 * Math.PI);\n  }\n\n  override turnValue(): number {\n    return this.value;\n  }\n\n  override turn(): TurnAngle {\n    return this;\n  }\n\n  override toCssValue(): CSSUnitValue | null {\n    if (typeof CSSUnitValue !== \"undefined\") {\n      return new CSSUnitValue(this.value, \"turn\");\n    }\n    return null;\n  }\n\n  override compareTo(that: unknown): number {\n    if (that instanceof Angle) {\n      const x = this.value;\n      const y = that.turnValue();\n      return x < y ? -1 : x > y ? 1 : isNaN(y) ? (isNaN(x) ? 0 : -1) : isNaN(x) ? 1 : 0;\n    }\n    return NaN;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (that instanceof Angle) {\n      return Numbers.equivalent(this.value, that.turnValue());\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (that instanceof TurnAngle) {\n      return this.value === that.value;\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(TurnAngle), Numbers.hash(this.value)));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Angle\").write(46/*'.'*/).write(\"turn\")\n                   .write(40/*'('*/).debug(this.value).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return this.value + \"turn\";\n  }\n\n  @Lazy\n  static override zero(): TurnAngle {\n    return new TurnAngle(0);\n  }\n\n  static override of(value: number): TurnAngle {\n    if (value === 0) {\n      return this.zero();\n    }\n    return new TurnAngle(value);\n  }\n}\n\n/** @internal */\nexport const AngleInterpolator = (function (_super: typeof Interpolator) {\n  const AngleInterpolator = function (a0: Angle, a1: Angle): Interpolator<Angle> {\n    const interpolator = function (u: number): Angle {\n      const a0 = interpolator[0];\n      const a1 = interpolator[1];\n      return Angle.of(a0.value + u * (a1.value - a0.value), a1.units);\n    } as Interpolator<Angle>;\n    Object.setPrototypeOf(interpolator, AngleInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = a0.to(a1.units);\n    (interpolator as Mutable<typeof interpolator>)[1] = a1;\n    return interpolator;\n  } as {\n    (a0: Angle, a1: Angle): Interpolator<Angle>;\n\n    /** @internal */\n    prototype: Interpolator<Angle>;\n  };\n\n  AngleInterpolator.prototype = Object.create(_super.prototype);\n  AngleInterpolator.prototype.constructor = AngleInterpolator;\n\n  return AngleInterpolator;\n})(Interpolator);\n\n/** @internal */\nexport class AngleForm extends Form<Angle, AngleLike> {\n  constructor(defaultUnits: AngleUnits | undefined, unit: Angle | undefined) {\n    super();\n    this.defaultUnits = defaultUnits;\n    Object.defineProperty(this, \"unit\", {\n      value: unit,\n      enumerable: true,\n      configurable: true,\n    });\n  }\n\n  readonly defaultUnits: AngleUnits | undefined;\n\n  override readonly unit: Angle | undefined;\n\n  override withUnit(unit: Angle | undefined): Form<Angle, AngleLike> {\n    if (unit === this.unit) {\n      return this;\n    }\n    return new AngleForm(this.defaultUnits, unit);\n  }\n\n  override mold(angle: AngleLike): Item {\n    angle = Angle.fromLike(angle, this.defaultUnits);\n    return Text.from(angle.toString());\n  }\n\n  override cast(item: Item): Angle | undefined {\n    const value = item.toValue();\n    let angle: Angle | null = null;\n    try {\n      angle = Angle.fromValue(value);\n      if (angle === void 0) {\n        const string = value.stringValue(void 0);\n        if (string !== void 0) {\n          angle = Angle.parse(string, this.defaultUnits);\n        }\n      }\n    } catch (e) {\n      // swallow\n    }\n    return angle !== null ? angle : void 0;\n  }\n}\n\n/** @internal */\nexport class AngleParser extends Parser<Angle> {\n  private readonly defaultUnits: AngleUnits | undefined;\n  private readonly valueParser: Parser<number> | undefined;\n  private readonly unitsOutput: Output<string> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(defaultUnits?: AngleUnits, valueParser?: Parser<number>,\n              unitsOutput?: Output<string>, step?: number) {\n    super();\n    this.defaultUnits = defaultUnits;\n    this.valueParser = valueParser;\n    this.unitsOutput = unitsOutput;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<Angle> {\n    return AngleParser.parse(input, this.defaultUnits, this.valueParser,\n                             this.unitsOutput, this.step);\n  }\n\n  static parse(input: Input, defaultUnits?: AngleUnits, valueParser?: Parser<number>,\n               unitsOutput?: Output<string>, step: number = 1): Parser<Angle> {\n    let c = 0;\n    if (step === 1) {\n      if (valueParser === void 0) {\n        valueParser = Base10.parseDecimal(input);\n      } else {\n        valueParser = valueParser.feed(input);\n      }\n      if (valueParser.isDone()) {\n        step = 2;\n      } else if (valueParser.isError()) {\n        return valueParser.asError();\n      }\n    }\n    if (step === 2) {\n      unitsOutput = unitsOutput || Unicode.stringOutput();\n      while (input.isCont() && (c = input.head(), Unicode.isAlpha(c))) {\n        input = input.step();\n        unitsOutput.push(c);\n      }\n      if (!input.isEmpty()) {\n        const value = valueParser!.bind();\n        const units = unitsOutput.bind() || defaultUnits;\n        switch (units) {\n          case \"deg\": return Parser.done(Angle.deg(value));\n          case \"\":\n          case \"rad\": return Parser.done(Angle.rad(value));\n          case \"grad\": return Parser.done(Angle.grad(value));\n          case \"turn\": return Parser.done(Angle.turn(value));\n          default: return Parser.error(Diagnostic.message(\"unknown units: \" + units, input));\n        }\n      }\n    }\n    return new AngleParser(defaultUnits, valueParser, unitsOutput, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {Equivalent} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport type {Interpolate} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\n\n/** @public */\nexport type R2VectorLike = R2Vector | R2VectorInit;\n\n/** @public */\nexport const R2VectorLike = {\n  [Symbol.hasInstance](instance: unknown): instance is R2VectorLike {\n    return instance instanceof R2Vector\n        || R2VectorInit[Symbol.hasInstance](instance);\n  },\n};\n\n/** @public */\nexport interface R2VectorInit {\n  /** @internal */\n  readonly typeid?: \"R2VectorInit\";\n  x: number;\n  y: number;\n}\n\n/** @public */\nexport const R2VectorInit = {\n  [Symbol.hasInstance](instance: unknown): instance is R2VectorInit {\n    return Objects.hasAllKeys<R2VectorInit>(instance, \"x\", \"y\");\n  },\n};\n\n/** @public */\nexport class R2Vector implements Interpolate<R2Vector>, Equivalent, HashCode, Debug {\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /** @internal */\n  declare readonly typeid?: \"R2Vector\";\n\n  likeType?(like: R2VectorInit): void;\n\n  isDefined(): boolean {\n    return isFinite(this.x) && isFinite(this.y);\n  }\n\n  readonly x: number;\n\n  readonly y: number;\n\n  plus(that: R2VectorLike): R2Vector {\n    return new R2Vector(this.x + that.x, this.y + that.y);\n  }\n\n  negative(): R2Vector {\n    return new R2Vector(-this.x, -this.y);\n  }\n\n  minus(that: R2VectorLike): R2Vector {\n    return new R2Vector(this.x - that.x, this.y - that.y);\n  }\n\n  times(scalar: number): R2Vector {\n    return new R2Vector(this.x * scalar, this.y * scalar);\n  }\n\n  toLike(): R2VectorInit {\n    return {\n      x: this.x,\n      y: this.y,\n    };\n  }\n\n  /** @override */\n  interpolateTo(that: R2Vector): Interpolator<R2Vector>;\n  interpolateTo(that: unknown): Interpolator<R2Vector> | null;\n  interpolateTo(that: unknown): Interpolator<R2Vector> | null {\n    if (that instanceof R2Vector) {\n      return R2VectorInterpolator(this, that);\n    }\n    return null;\n  }\n\n  /** @override */\n  equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2Vector) {\n      return Numbers.equivalent(this.x, that.x, epsilon)\n          && Numbers.equivalent(this.y, that.y, epsilon);\n    }\n    return false;\n  }\n\n  /** @override */\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2Vector) {\n      return this.x === that.x && this.y === that.y;\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(R2Vector),\n        Numbers.hash(this.x)), Numbers.hash(this.y)));\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"R2Vector\").write(46/*'.'*/).write(\"of\").write(40/*'('*/)\n                   .debug(this.x).write(\", \").debug(this.y).write(41/*')'*/);\n    return output;\n  }\n\n  /** @override */\n  toString(): string {\n    return Format.debug(this);\n  }\n\n  @Lazy\n  static zero(): R2Vector {\n    return new R2Vector(0, 0);\n  }\n\n  static of(x: number, y: number): R2Vector {\n    return new R2Vector(x, y);\n  }\n\n  static fromLike<T extends R2VectorLike | null | undefined>(value: T): R2Vector | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof R2Vector) {\n      return value as R2Vector | Uninitable<T>;\n    } else if (R2VectorInit[Symbol.hasInstance](value)) {\n      return R2Vector.fromInit(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromInit(init: R2VectorInit): R2Vector {\n    return new R2Vector(init.x, init.y);\n  }\n}\n\n/** @internal */\nexport const R2VectorInterpolator = (function (_super: typeof Interpolator) {\n  const R2VectorInterpolator = function (v0: R2Vector, v1: R2Vector): Interpolator<R2Vector> {\n    const interpolator = function (u: number): R2Vector {\n      const v0 = interpolator[0];\n      const v1 = interpolator[1];\n      const x = v0.x + u * (v1.x - v0.x);\n      const y = v0.y + u * (v1.y - v0.y);\n      return new R2Vector(x, y);\n    } as Interpolator<R2Vector>;\n    Object.setPrototypeOf(interpolator, R2VectorInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = v0;\n    (interpolator as Mutable<typeof interpolator>)[1] = v1;\n    return interpolator;\n  } as {\n    (v0: R2Vector, v1: R2Vector): Interpolator<R2Vector>;\n\n    /** @internal */\n    prototype: Interpolator<R2Vector>;\n  };\n\n  R2VectorInterpolator.prototype = Object.create(_super.prototype);\n  R2VectorInterpolator.prototype.constructor = R2VectorInterpolator;\n\n  return R2VectorInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Equals} from \"@swim/util\";\nimport type {Equivalent} from \"@swim/util\";\nimport type {R2Function} from \"./R2Function\";\nimport {R2PointInit} from \"./\"; // forward import\nimport {R2PointTuple} from \"./\"; // forward import\nimport {R2Point} from \"./\"; // forward import\nimport {R2SegmentInit} from \"./\"; // forward import\nimport {R2Segment} from \"./\"; // forward import\nimport {R2Path} from \"./\"; // forward import\nimport {R2BoxInit} from \"./\"; // forward import\nimport {R2Box} from \"./\"; // forward import\nimport {R2CircleInit} from \"./\"; // forward import\nimport {R2Circle} from \"./\"; // forward import\n\n/** @public */\nexport type R2ShapeLike = R2Shape\n                        | R2PointInit\n                        | R2PointTuple\n                        | R2SegmentInit\n                        | R2BoxInit\n                        | R2CircleInit\n                        | string;\n\n/** @public */\nexport const R2ShapeLike = {\n  [Symbol.hasInstance](instance: unknown): instance is R2ShapeLike {\n    return instance instanceof R2Shape\n        || R2PointInit[Symbol.hasInstance](instance)\n        || R2PointTuple[Symbol.hasInstance](instance)\n        || R2SegmentInit[Symbol.hasInstance](instance)\n        || R2BoxInit[Symbol.hasInstance](instance)\n        || R2Circle[Symbol.hasInstance](instance)\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport abstract class R2Shape implements Equals, Equivalent {\n  /** @internal */\n  declare readonly typeid?: string;\n\n  likeType?(like: R2PointInit\n                | R2PointTuple\n                | R2SegmentInit\n                | R2BoxInit\n                | R2CircleInit\n                | string): void;\n\n  abstract isDefined(): boolean;\n\n  abstract readonly xMin: number;\n\n  abstract readonly yMin: number;\n\n  abstract readonly xMax: number;\n\n  abstract readonly yMax: number;\n\n  abstract contains(that: R2ShapeLike): boolean;\n\n  abstract contains(x: number, y: number): boolean;\n\n  abstract intersects(that: R2ShapeLike): boolean;\n\n  union(that: R2ShapeLike): R2Shape {\n    that = R2Shape.fromLike(that);\n    return new R2Box(Math.min(this.xMin, that.xMin),\n                     Math.min(this.yMin, that.yMin),\n                     Math.max(this.xMax, that.xMax),\n                     Math.max(this.yMax, that.yMax));\n  }\n\n  abstract transform(f: R2Function): R2Shape;\n\n  get bounds(): R2Box {\n    return new R2Box(this.xMin, this.yMin, this.xMax, this.yMax);\n  }\n\n  /** @override */\n  abstract equivalentTo(that: unknown, epsilon?: number): boolean\n\n  /** @override */\n  abstract equals(that: unknown): boolean;\n\n  static fromLike<T extends R2ShapeLike | null | undefined>(value: T): R2Shape | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof R2Shape) {\n      return value as R2Shape | Uninitable<T>;\n    } else if (R2PointInit[Symbol.hasInstance](value)) {\n      return R2Point.fromInit(value);\n    } else if (R2PointTuple[Symbol.hasInstance](value)) {\n      return R2Point.fromTuple(value);\n    } else if (R2SegmentInit[Symbol.hasInstance](value)) {\n      return R2Segment.fromInit(value);\n    } else if (R2BoxInit[Symbol.hasInstance](value)) {\n      return R2Box.fromInit(value);\n    } else if (R2CircleInit[Symbol.hasInstance](value)) {\n      return R2Circle.fromInit(value);\n    } else if (typeof value === \"string\") {\n      return R2Path.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport type {Interpolate} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport type {R2Function} from \"./R2Function\";\nimport type {R2VectorLike} from \"./R2Vector\";\nimport {R2Vector} from \"./R2Vector\";\nimport type {R2ShapeLike} from \"./R2Shape\";\nimport {R2Shape} from \"./R2Shape\";\n\n/** @public */\nexport type R2PointLike = R2Point | R2PointInit | R2PointTuple;\n\n/** @public */\nexport const R2PointLike = {\n  [Symbol.hasInstance](instance: unknown): instance is R2PointLike {\n    return instance instanceof R2Point\n        || R2PointInit[Symbol.hasInstance](instance)\n        || R2PointTuple[Symbol.hasInstance](instance);\n  },\n};\n\n/** @public */\nexport interface R2PointInit {\n  /** @internal */\n  readonly typeid?: \"R2PointInit\";\n  x: number;\n  y: number;\n}\n\n/** @public */\nexport const R2PointInit = {\n  [Symbol.hasInstance](instance: unknown): instance is R2PointInit {\n    return Objects.hasAllKeys<R2PointInit>(instance, \"x\", \"y\");\n  },\n};\n\n/** @public */\nexport type R2PointTuple = [number, number];\n\n/** @public */\nexport const R2PointTuple = {\n  [Symbol.hasInstance](instance: unknown): instance is R2PointTuple {\n    return Array.isArray(instance) && instance.length === 2\n        && typeof instance[0] === \"number\"\n        && typeof instance[1] === \"number\";\n  },\n};\n\n/** @public */\nexport class R2Point extends R2Shape implements Interpolate<R2Point>, HashCode, Debug {\n  constructor(x: number, y: number) {\n    super();\n    this.x = x;\n    this.y = y;\n  }\n\n  /** @internal */\n  declare readonly typeid?: \"R2Point\";\n\n  override likeType?(like: R2PointInit | R2PointTuple): void;\n\n  override isDefined(): boolean {\n    return isFinite(this.x) && isFinite(this.y);\n  }\n\n  readonly x: number;\n\n  readonly y: number;\n\n  override get xMin(): number {\n    return this.x;\n  }\n\n  override get yMin(): number {\n    return this.y;\n  }\n\n  override get xMax(): number {\n    return this.x;\n  }\n\n  override get yMax(): number {\n    return this.y;\n  }\n\n  plus(vector: R2VectorLike): R2Point {\n    return new R2Point(this.x + vector.x, this.y + vector.y);\n  }\n\n  minus(vector: R2Vector): R2Point;\n  minus(that: R2Point): R2Vector;\n  minus(that: R2Vector | R2Point): R2Point | R2Vector {\n    if (that instanceof R2Vector) {\n      return new R2Point(this.x - that.x, this.y - that.y);\n    }\n    return new R2Vector(this.x - that.x, this.y - that.y);\n  }\n\n  override contains(that: R2ShapeLike): boolean;\n  override contains(x: number, y: number): boolean;\n  override contains(that: R2ShapeLike | number, y?: number): boolean {\n    if (typeof that === \"number\") {\n      return this.x === that && this.y === y!;\n    }\n    that = R2Shape.fromLike(that);\n    if (that instanceof R2Point) {\n      return this.x === that.x && this.y === that.y;\n    } else if (that instanceof R2Shape) {\n      return this.x <= that.xMin && that.xMax <= this.x\n          && this.y <= that.yMin && that.yMax <= this.y;\n    }\n    return false;\n  }\n\n  override intersects(that: R2ShapeLike): boolean {\n    that = R2Shape.fromLike(that);\n    return that.intersects(this);\n  }\n\n  override transform(f: R2Function): R2Point {\n    return new R2Point(f.transformX(this.x, this.y), f.transformY(this.x, this.y));\n  }\n\n  toLike(): R2PointInit {\n    return {\n      x: this.x,\n      y: this.y,\n    };\n  }\n\n  /** @override */\n  interpolateTo(that: R2Point): Interpolator<R2Point>;\n  interpolateTo(that: unknown): Interpolator<R2Point> | null;\n  interpolateTo(that: unknown): Interpolator<R2Point> | null {\n    if (that instanceof R2Point) {\n      return R2PointInterpolator(this, that);\n    }\n    return null;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2Point) {\n      return Numbers.equivalent(this.x, that.x, epsilon)\n          && Numbers.equivalent(this.y, that.y, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2Point) {\n      return this.x === that.x && this.y === that.y;\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(R2Point),\n        Numbers.hash(this.x)), Numbers.hash(this.y)));\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"R2Point\").write(46/*'.'*/).write(\"of\").write(40/*'('*/)\n                   .debug(this.x).write(\", \").debug(this.y).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n\n  @Lazy\n  static undefined(): R2Point {\n    return new R2Point(NaN, NaN);\n  }\n\n  @Lazy\n  static origin(): R2Point {\n    return new R2Point(0, 0);\n  }\n\n  static of(x: number, y: number): R2Point {\n    return new R2Point(x, y);\n  }\n\n  static override fromLike<T extends R2PointLike | null | undefined>(value: T): R2Point | Uninitable<T>;\n  static override fromLike<T extends R2ShapeLike | null | undefined>(value: T): never;\n  static override fromLike<T extends R2PointLike | null | undefined>(value: T): R2Point | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof R2Point) {\n      return value as R2Point | Uninitable<T>;\n    } else if (R2PointInit[Symbol.hasInstance](value)) {\n      return R2Point.fromInit(value);\n    } else if (R2PointTuple[Symbol.hasInstance](value)) {\n      return R2Point.fromTuple(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromInit(init: R2PointInit): R2Point {\n    return new R2Point(init.x, init.y);\n  }\n\n  static fromTuple(tuple: R2PointTuple): R2Point {\n    return new R2Point(tuple[0], tuple[1]);\n  }\n}\n\n/** @internal */\nexport const R2PointInterpolator = (function (_super: typeof Interpolator) {\n  const R2PointInterpolator = function (p0: R2Point, p1: R2Point): Interpolator<R2Point> {\n    const interpolator = function (u: number): R2Point {\n      const p0 = interpolator[0];\n      const p1 = interpolator[1];\n      const x = p0.x + u * (p1.x - p0.x);\n      const y = p0.y + u * (p1.y - p0.y);\n      return new R2Point(x, y);\n    } as Interpolator<R2Point>;\n    Object.setPrototypeOf(interpolator, R2PointInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = p0;\n    (interpolator as Mutable<typeof interpolator>)[1] = p1;\n    return interpolator;\n  } as {\n    (p0: R2Point, p1: R2Point): Interpolator<R2Point>;\n\n    /** @internal */\n    prototype: Interpolator<R2Point>;\n  };\n\n  R2PointInterpolator.prototype = Object.create(_super.prototype);\n  R2PointInterpolator.prototype.constructor = R2PointInterpolator;\n\n  return R2PointInterpolator;\n})(Interpolator);\n"," // Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {OutputSettingsLike} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Base10} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport type {R2Function} from \"./R2Function\";\nimport {R2Shape} from \"./R2Shape\";\nimport type {R2Point} from \"./R2Point\";\nimport {R2Segment} from \"./\"; // forward import\nimport {R2SegmentParser} from \"./\"; // forward import\nimport {R2QuadraticCurve} from \"./\"; // forward import\nimport {R2QuadraticCurveParser} from \"./\"; // forward import\nimport {R2CubicCurve} from \"./\"; // forward import\nimport {R2CubicCurveParser} from \"./\"; // forward import\nimport {R2EllipticCurve} from \"./\"; // forward import\nimport {R2EllipticCurveParser} from \"./\"; // forward import\n\n/** @public */\nexport interface R2CurveContext {\n  moveTo(x: number, y: number): void;\n\n  lineTo(x: number, y: number): void;\n\n  quadraticCurveTo(x1: number, y1: number, x: number, y: number): void;\n\n  bezierCurveTo(x1: number, y1: number, x2: number, y2: number, x: number, y: number): void;\n\n  arcTo(x1: number, y1: number, x2: number, y2: number, r: number): void;\n\n  arc(cx: number, cy: number, r: number, a0: number, a1: number, ccw?: boolean): void;\n\n  ellipse(cx: number, cy: number, rx: number, ry: number, phi: number, a0: number, a1: number, ccw?: boolean): void;\n}\n\n/** @public */\nexport abstract class R2Curve extends R2Shape {\n  abstract interpolateX(u: number): number;\n\n  abstract interpolateY(u: number): number;\n\n  abstract interpolate(u: number): R2Point;\n\n  abstract split(u: number): [R2Curve, R2Curve];\n\n  abstract override transform(f: R2Function): R2Curve;\n\n  abstract drawMove(context: R2CurveContext): void;\n\n  abstract drawRest(context: R2CurveContext): void;\n\n  draw(context: R2CurveContext): void {\n    this.drawMove(context);\n    this.drawRest(context);\n  }\n\n  abstract transformDrawMove(context: R2CurveContext, f: R2Function): void;\n\n  abstract transformDrawRest(context: R2CurveContext, f: R2Function): void;\n\n  transformDraw(context: R2CurveContext, f: R2Function): void {\n    this.transformDrawMove(context, f);\n    this.transformDrawRest(context, f);\n  }\n\n  abstract writeMove<T>(output: Output<T>): Output<T>;\n\n  abstract writeRest<T>(output: Output<T>): Output<T>;\n\n  writePath<T>(output: Output<T>): Output<T> {\n    output = this.writeMove(output);\n    output = this.writeRest(output);\n    return output;\n  }\n\n  toPathString(outputSettings?: OutputSettingsLike): string {\n    let output = Unicode.stringOutput(outputSettings);\n    output = this.writePath(output);\n    return output.toString();\n  }\n\n  static linear(x0: number, y0: number, x1: number, y1: number): R2Curve {\n    return new R2Segment(x0, y0, x1, y1);\n  }\n\n  static quadratic(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number): R2Curve {\n    return new R2QuadraticCurve(x0, y0, x1, y1, x2, y2);\n  }\n\n  static cubic(x0: number, y0: number, x1: number, y1: number,\n               x2: number, y2: number, x3: number, y3: number): R2Curve {\n    return new R2CubicCurve(x0, y0, x1, y1, x2, y2, x3, y3);\n  }\n\n  static elliptic(cx: number, cy: number, rx: number, ry: number,\n                  phi: number, a0: number, da: number): R2Curve {\n    return new R2EllipticCurve(cx, cy, rx, ry, phi, a0, da);\n  }\n\n  static parse(string: string): R2Curve {\n    let input = Unicode.stringInput(string);\n    while (input.isCont() && Unicode.isWhitespace(input.head())) {\n      input = input.step();\n    }\n    let parser = R2CurveParser.parse(input);\n    if (parser.isDone()) {\n      while (input.isCont() && Unicode.isWhitespace(input.head())) {\n        input = input.step();\n      }\n    }\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n}\n\n/** @public */\nexport abstract class R2BezierCurve extends R2Curve {\n  abstract override transform(f: R2Function): R2BezierCurve;\n}\n\n/** @internal */\nexport class R2CurveParser extends Parser<R2Curve> {\n  private readonly x0Parser: Parser<number> | undefined;\n  private readonly y0Parser: Parser<number> | undefined;\n  private readonly command: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(x0Parser?: Parser<number>, y0Parser?: Parser<number>,\n              command?: number, step?: number) {\n    super();\n    this.x0Parser = x0Parser;\n    this.y0Parser = y0Parser;\n    this.command = command;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<R2Curve> {\n    return R2CurveParser.parse(input, this.x0Parser, this.y0Parser,\n                               this.command, this.step);\n  }\n\n  static parse(input: Input, x0Parser?: Parser<number>, y0Parser?: Parser<number>,\n               command?: number, step: number = 1): Parser<R2Curve> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 77/*'M'*/ || c === 109/*'m'*/) {\n          input = input.step();\n          command = c;\n          step = 2;\n        } else {\n          return Parser.error(Diagnostic.expected(\"moveto\", input));\n        }\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 2) {\n      if (x0Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          x0Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        x0Parser = x0Parser.feed(input);\n      }\n      if (x0Parser !== void 0) {\n        if (x0Parser.isDone()) {\n          step = 3;\n        } else if (x0Parser.isError()) {\n          return x0Parser.asError();\n        }\n      }\n    }\n    if (step === 3) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 4;\n      } else if (!input.isEmpty()) {\n        step = 4;\n      }\n    }\n    if (step === 4) {\n      if (y0Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          y0Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        y0Parser = y0Parser.feed(input);\n      }\n      if (y0Parser !== void 0) {\n        if (y0Parser.isDone()) {\n          step = 5;\n        } else if (y0Parser.isError()) {\n          return y0Parser.asError();\n        }\n      }\n    }\n    if (step === 5) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        switch (c) {\n          case 76/*'L'*/:\n          case 108/*'l'*/:\n          case 72/*'H'*/:\n          case 104/*'h'*/:\n          case 86/*'V'*/:\n          case 118/*'v'*/:\n            return R2SegmentParser.parse(input, x0Parser, y0Parser);\n          case 81/*'Q'*/:\n          case 113/*'q'*/:\n            return R2QuadraticCurveParser.parse(input, x0Parser, y0Parser);\n          case 84/*'T'*/:\n            return R2QuadraticCurveParser.parse(input, x0Parser, y0Parser,\n                                                x0Parser, y0Parser);\n          case 116/*'t'*/:\n            return R2QuadraticCurveParser.parse(input, x0Parser, y0Parser,\n                                                Parser.done(0), Parser.done(0));\n          case 67/*'C'*/:\n          case 99/*'c'*/:\n            return R2CubicCurveParser.parse(input, x0Parser, y0Parser);\n          case 83/*'S'*/:\n            return R2CubicCurveParser.parse(input, x0Parser, y0Parser,\n                                             x0Parser, y0Parser);\n          case 115/*'s'*/:\n            return R2CubicCurveParser.parse(input, x0Parser, y0Parser,\n                                             Parser.done(0), Parser.done(0));\n          case 65/*'A'*/:\n          case 97/*'a'*/:\n            return R2EllipticCurveParser.parse(input, x0Parser, y0Parser);\n          case 44/*','*/:\n            input = input.step();\n          case 43/*'+'*/:\n          case 45/*'-'*/:\n          case 46/*'.'*/:\n          case 48/*'0'*/:\n          case 49/*'1'*/:\n          case 50/*'2'*/:\n          case 51/*'3'*/:\n          case 52/*'4'*/:\n          case 53/*'5'*/:\n          case 54/*'6'*/:\n          case 55/*'7'*/:\n          case 56/*'8'*/:\n          case 57/*'9'*/:\n            switch (command) {\n              case 77/*'M'*/:\n              case 109/*'m'*/:\n                return R2SegmentParser.parseRest(input, command, x0Parser, y0Parser);\n            }\n          default:\n            return Parser.error(Diagnostic.expected(\"draw command\", input));\n        }\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    return new R2CurveParser(x0Parser, y0Parser, command, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport type {Interpolate} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Base10} from \"@swim/codec\";\nimport type {R2Function} from \"./R2Function\";\nimport type {R2ShapeLike} from \"./R2Shape\";\nimport {R2Shape} from \"./R2Shape\";\nimport {R2Point} from \"./R2Point\";\nimport type {R2CurveContext} from \"./R2Curve\";\nimport {R2BezierCurve} from \"./R2Curve\";\n\n/** @public */\nexport type R2SegmentLike = R2Segment | R2SegmentInit;\n\n/** @public */\nexport const R2SegmentLike = {\n  [Symbol.hasInstance](instance: unknown): instance is R2SegmentLike {\n    return instance instanceof R2Segment\n        || R2SegmentInit[Symbol.hasInstance](instance);\n  },\n};\n\n/** @public */\nexport interface R2SegmentInit {\n  /** @internal */\n  readonly typeid?: \"R2SegmentInit\";\n  x0: number;\n  y0: number;\n  x1: number;\n  y1: number;\n}\n\n/** @public */\nexport const R2SegmentInit = {\n  [Symbol.hasInstance](instance: unknown): instance is R2SegmentInit {\n    return Objects.hasAllKeys<R2SegmentInit>(instance, \"x0\", \"y0\", \"x1\", \"y1\");\n  },\n};\n\n/** @public */\nexport class R2Segment extends R2BezierCurve implements Interpolate<R2Segment>, HashCode, Debug {\n  constructor(x0: number, y0: number, x1: number, y1: number) {\n    super();\n    this.x0 = x0;\n    this.y0 = y0;\n    this.x1 = x1;\n    this.y1 = y1;\n  }\n\n  /** @internal */\n  declare readonly typeid?: \"R2Segment\";\n\n  override likeType?(like: R2SegmentInit): void;\n\n  isDefined(): boolean {\n    return isFinite(this.x0) && isFinite(this.y0)\n        && isFinite(this.x1) && isFinite(this.y1);\n  }\n\n  readonly x0: number;\n\n  readonly y0: number;\n\n  readonly x1: number;\n\n  readonly y1: number;\n\n  override get xMin(): number {\n    return Math.min(this.x0, this.x1);\n  }\n\n  override get yMin(): number {\n    return Math.min(this.y0, this.y1);\n  }\n\n  override get xMax(): number {\n    return Math.max(this.x0, this.x1);\n  }\n\n  override get yMax(): number {\n    return Math.max(this.y0, this.y1);\n  }\n\n  override interpolateX(u: number): number {\n    return (1.0 - u) * this.x0 + u * this.x1;\n  }\n\n  override interpolateY(u: number): number {\n    return (1.0 - u) * this.y0 + u * this.y1;\n  }\n\n  override interpolate(u: number): R2Point {\n    const v = 1.0 - u;\n    const x01 = v * this.x0 + u * this.x1;\n    const y01 = v * this.y0 + u * this.y1;\n    return new R2Point(x01, y01);\n  }\n\n  override contains(that: R2ShapeLike): boolean;\n  override contains(x: number, y: number): boolean;\n  override contains(that: R2ShapeLike | number, y?: number): boolean {\n    if (typeof that === \"number\") {\n      return R2Segment.contains(this.x0, this.y0, this.x1, this.y1, that, y!);\n    }\n    that = R2Shape.fromLike(that);\n    if (that instanceof R2Point) {\n      return this.containsPoint(that);\n    } else if (that instanceof R2Segment) {\n      return this.containsSegment(that);\n    }\n    return false;\n  }\n\n  /** @internal */\n  containsPoint(that: R2Point): boolean {\n    return R2Segment.contains(this.x0, this.y0, this.x1, this.y1, that.x, that.y);\n  }\n\n  /** @internal */\n  containsSegment(that: R2Segment): boolean {\n    return R2Segment.contains(this.x0, this.y0, this.x1, this.y1, that.x0, that.y0)\n        && R2Segment.contains(this.x0, this.y0, this.x1, this.y1, that.x1, that.y1);\n  }\n\n  /** @internal */\n  static contains(ax: number, ay: number, bx: number, by: number, cx: number, cy: number): boolean {\n    return (ax <= cx && cx <= bx || bx <= cx && cx <= ax)\n        && (ay <= cy && cy <= by || by <= cy && cy <= ay)\n        && (bx - ax) * (cy - ay) === (cx - ax) * (by - ay);\n  }\n\n  override intersects(that: R2ShapeLike): boolean {\n    that = R2Shape.fromLike(that);\n    if (that instanceof R2Point) {\n      return this.intersectsPoint(that);\n    } else if (that instanceof R2Segment) {\n      return this.intersectsSegment(that);\n    }\n    return that.intersects(this);\n  }\n\n  /** @internal */\n  intersectsPoint(that: R2Point): boolean {\n    return R2Segment.contains(this.x0, this.y0, this.x1, this.y1, that.x, that.y);\n  }\n\n  /** @internal */\n  intersectsSegment(that: R2Segment): boolean {\n    return R2Segment.intersects(this.x0, this.y0, this.x1 - this.x0, this.y1 - this.y0,\n                                that.x0, that.y0, that.x1 - that.x0, that.y1 - that.y0);\n  }\n\n  /** @internal */\n  static intersects(px: number, py: number, rx: number, ry: number,\n                    qx: number, qy: number, sx: number, sy: number): boolean {\n    const pqx = qx - px;\n    const pqy = qy - py;\n    const pqr = pqx * ry - pqy * rx;\n    const rs = rx * sy - ry * sx;\n    if (pqr === 0 && rs === 0) { // collinear\n      const rr = rx * rx + ry * ry;\n      const sr = sx * rx + sy * ry;\n      const t0 = (pqx * rx + pqy * ry) / rr;\n      const t1 = t0 + sr / rr;\n      return sr >= 0 ? 0 < t1 && t0 < 1 : 0 < t0 && t1 < 1;\n    } else if (rs === 0) { // parallel\n      return false;\n    }\n    const pqs = pqx * sy - pqy * sx;\n    const t = pqs / rs; // (q − p) × s / (r × s)\n    const u = pqr / rs; // (q − p) × r / (r × s)\n    return 0 <= t && t <= 1 && 0 <= u && u <= 1;\n  }\n\n  override split(u: number): [R2Segment, R2Segment] {\n    const v = 1.0 - u;\n    const x01 = v * this.x0 + u * this.x1;\n    const y01 = v * this.y0 + u * this.y1;\n    const c0 = new R2Segment(this.x0, this.y0, x01, y01);\n    const c1 = new R2Segment(x01, y01, this.x1, this.y1);\n    return [c0, c1];\n  }\n\n  override transform(f: R2Function): R2Segment {\n    return new R2Segment(f.transformX(this.x0, this.y0), f.transformY(this.x0, this.y0),\n                         f.transformX(this.x1, this.y1), f.transformY(this.x1, this.y1));\n  }\n\n  toLike(): R2SegmentInit {\n    return {\n      x0: this.x0,\n      y0: this.y0,\n      x1: this.x1,\n      y1: this.y1,\n    };\n  }\n\n  override drawMove(context: R2CurveContext): void {\n    context.moveTo(this.x0, this.y0);\n  }\n\n  override drawRest(context: R2CurveContext): void {\n    context.lineTo(this.x1, this.y1);\n  }\n\n  override transformDrawMove(context: R2CurveContext, f: R2Function): void {\n    context.moveTo(f.transformX(this.x0, this.y0), f.transformY(this.x0, this.y0));\n  }\n\n  override transformDrawRest(context: R2CurveContext, f: R2Function): void {\n    context.lineTo(f.transformX(this.x1, this.y1), f.transformY(this.x1, this.y1));\n  }\n\n  override writeMove<T>(output: Output<T>): Output<T> {\n    output = output.write(77/*'M'*/);\n    output = Format.displayNumber(output, this.x0);\n    output = output.write(44/*','*/);\n    output = Format.displayNumber(output, this.y0);\n    return output;\n  }\n\n  override writeRest<T>(output: Output<T>): Output<T> {\n    output = output.write(76/*'L'*/);\n    output = Format.displayNumber(output, this.x1);\n    output = output.write(44/*','*/);\n    output = Format.displayNumber(output, this.y1);\n    return output;\n  }\n\n  /** @override */\n  interpolateTo(that: R2Segment): Interpolator<R2Segment>;\n  interpolateTo(that: unknown): Interpolator<R2Segment> | null;\n  interpolateTo(that: unknown): Interpolator<R2Segment> | null {\n    if (that instanceof R2Segment) {\n      return R2SegmentInterpolator(this, that);\n    }\n    return null;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2Segment) {\n      return Numbers.equivalent(this.x0, that.x0, epsilon)\n          && Numbers.equivalent(this.y0, that.y0, epsilon)\n          && Numbers.equivalent(this.x1, that.x1, epsilon)\n          && Numbers.equivalent(this.y1, that.y1, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2Segment) {\n      return this.x0 === that.x0 && this.y0 === that.y0\n          && this.x1 === that.x1 && this.y1 === that.y1;\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(\n        Constructors.hash(R2Segment), Numbers.hash(this.x0)), Numbers.hash(this.y0)),\n        Numbers.hash(this.x1)), Numbers.hash(this.y1)));\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"R2Segment\").write(46/*'.'*/).write(\"of\").write(40/*'('*/)\n                   .debug(this.x0).write(\", \").debug(this.y0).write(\", \")\n                   .debug(this.x1).write(\", \").debug(this.y1).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n\n  static of(x0: number, y0: number, x1: number, y1: number): R2Segment {\n    return new R2Segment(x0, y0, x1, y1);\n  }\n\n  static override fromLike<T extends R2SegmentLike | null | undefined>(value: T): R2Segment | Uninitable<T>;\n  static override fromLike<T extends R2ShapeLike | null | undefined>(value: T): never;\n  static override fromLike<T extends R2SegmentLike | null | undefined>(value: T): R2Segment | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof R2Segment) {\n      return value as R2Segment | Uninitable<T>;\n    } else if (R2SegmentInit[Symbol.hasInstance](value)) {\n      return R2Segment.fromInit(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromInit(init: R2SegmentInit): R2Segment {\n    return new R2Segment(init.x0, init.y0, init.x1, init.y1);\n  }\n}\n\n/** @internal */\nexport const R2SegmentInterpolator = (function (_super: typeof Interpolator) {\n  const R2SegmentInterpolator = function (s0: R2Segment, s1: R2Segment): Interpolator<R2Segment> {\n    const interpolator = function (u: number): R2Segment {\n      const s0 = interpolator[0];\n      const s1 = interpolator[1];\n      const x0 = s0.x0 + u * (s1.x0 - s0.x0);\n      const y0 = s0.y0 + u * (s1.y0 - s0.y0);\n      const x1 = s0.x1 + u * (s1.x1 - s0.x1);\n      const y1 = s0.y1 + u * (s1.y1 - s0.y1);\n      return new R2Segment(x0, y0, x1, y1);\n    } as Interpolator<R2Segment>;\n    Object.setPrototypeOf(interpolator, R2SegmentInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = s0;\n    (interpolator as Mutable<typeof interpolator>)[1] = s1;\n    return interpolator;\n  } as {\n    (s0: R2Segment, s1: R2Segment): Interpolator<R2Segment>;\n\n    /** @internal */\n    prototype: Interpolator<R2Segment>;\n  };\n\n  R2SegmentInterpolator.prototype = Object.create(_super.prototype);\n  R2SegmentInterpolator.prototype.constructor = R2SegmentInterpolator;\n\n  return R2SegmentInterpolator;\n})(Interpolator);\n\n/** @internal */\nexport class R2SegmentParser extends Parser<R2Segment> {\n  private readonly x0Parser: Parser<number> | undefined;\n  private readonly y0Parser: Parser<number> | undefined;\n  private readonly x1Parser: Parser<number> | undefined;\n  private readonly y1Parser: Parser<number> | undefined;\n  private readonly command: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(x0Parser?: Parser<number>, y0Parser?: Parser<number>,\n              x1Parser?: Parser<number>, y1Parser?: Parser<number>,\n              command?: number, step?: number) {\n    super();\n    this.x0Parser = x0Parser;\n    this.y0Parser = y0Parser;\n    this.x1Parser = x1Parser;\n    this.y1Parser = y1Parser;\n    this.command = command;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<R2Segment> {\n    return R2SegmentParser.parse(input, this.x0Parser, this.y0Parser,\n                                 this.x1Parser, this.y1Parser,\n                                 this.command, this.step);\n  }\n\n  static parse(input: Input, x0Parser?: Parser<number>, y0Parser?: Parser<number>,\n               x1Parser?: Parser<number>, y1Parser?: Parser<number>,\n               command?: number, step: number = 1): Parser<R2Segment> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        switch (c) {\n          case 77/*'M'*/:\n          case 109/*'m'*/:\n          case 76/*'L'*/:\n          case 108/*'l'*/:\n            input = input.step();\n            command = c;\n            step = 2;\n            break;\n          case 72/*'H'*/:\n            input = input.step();\n            y1Parser = y0Parser;\n            command = c;\n            step = 2;\n            break;\n          case 104/*'h'*/:\n            input = input.step();\n            y1Parser = Parser.done(0);\n            command = c;\n            step = 2;\n            break;\n          case 86/*'V'*/:\n            input = input.step();\n            x1Parser = x0Parser;\n            command = c;\n            step = 4;\n            break;\n          case 118/*'v'*/:\n            input = input.step();\n            x1Parser = Parser.done(0);\n            command = c;\n            step = 4;\n            break;\n          default:\n            return Parser.error(Diagnostic.expected(\"lineto\", input));\n        }\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 2) {\n      if (x1Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          x1Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        x1Parser = x1Parser.feed(input);\n      }\n      if (x1Parser !== void 0) {\n        if (x1Parser.isDone()) {\n          if (y1Parser === void 0 || !y1Parser.isDone()) {\n            step = 3;\n          } else { // H or h\n            step = 4;\n          }\n        } else if (x1Parser.isError()) {\n          return x1Parser.asError();\n        }\n      }\n    }\n    if (step === 3) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 4;\n      } else if (!input.isEmpty()) {\n        step = 4;\n      }\n    }\n    if (step === 4) {\n      if (y1Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          y1Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        y1Parser = y1Parser.feed(input);\n      }\n      if (y1Parser !== void 0) {\n        if (y1Parser.isDone()) {\n          const x0 = x0Parser!.bind();\n          const y0 = y0Parser!.bind();\n          let x1 = x1Parser!.bind();\n          let y1 = y1Parser.bind();\n          if (command === 109/*'m'*/ || command === 108/*'l'*/ ||\n              command === 104/*'h'*/ || command === 118/*'v'*/) {\n            x1 += x0;\n            y1 += y0;\n          }\n          return Parser.done(new R2Segment(x0, y0, x1, y1));\n        } else if (y1Parser.isError()) {\n          return y1Parser.asError();\n        }\n      }\n    }\n    return new R2SegmentParser(x0Parser, y0Parser, x1Parser, y1Parser, command, step);\n  }\n\n  static parseRest(input: Input, command?: number, x0Parser?: Parser<number>,\n                   y0Parser?: Parser<number>): Parser<R2Segment> {\n    let x1Parser: Parser<number> | undefined;\n    let y1Parser: Parser<number> | undefined;\n    let step: number;\n    switch (command) {\n      case 72/*'H'*/:\n        y1Parser = y0Parser;\n        step = 2;\n        break;\n      case 104/*'h'*/:\n        y1Parser = Parser.done(0);\n        step = 2;\n        break;\n      case 86/*'V'*/:\n        x1Parser = x0Parser;\n        step = 4;\n        break;\n      case 118/*'v'*/:\n        x1Parser = Parser.done(0);\n        step = 4;\n        break;\n      default:\n        step = 2;\n    }\n    return this.parse(input, x0Parser, y0Parser, x1Parser, y1Parser, command, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Numbers} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Base10} from \"@swim/codec\";\nimport type {R2Function} from \"./R2Function\";\nimport type {R2ShapeLike} from \"./R2Shape\";\nimport {R2Point} from \"./R2Point\";\nimport type {R2CurveContext} from \"./R2Curve\";\nimport {R2BezierCurve} from \"./R2Curve\";\n\n/** @public */\nexport class R2QuadraticCurve extends R2BezierCurve implements Debug {\n  constructor(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number) {\n    super();\n    this.x0 = x0;\n    this.y0 = y0;\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  override isDefined(): boolean {\n    return isFinite(this.x0) && isFinite(this.y0)\n        && isFinite(this.x1) && isFinite(this.y1)\n        && isFinite(this.x2) && isFinite(this.y2);\n  }\n\n  readonly x0: number;\n\n  readonly y0: number;\n\n  readonly x1: number;\n\n  readonly y1: number;\n\n  readonly x2: number;\n\n  readonly y2: number;\n\n  override get xMin(): number {\n    return Math.min(this.x0, this.x1, this.x2);\n  }\n\n  override get yMin(): number {\n    return Math.min(this.y0, this.y1, this.y2);\n  }\n\n  override get xMax(): number {\n    return Math.max(this.x0, this.x1, this.x2);\n  }\n\n  override get yMax(): number {\n    return Math.max(this.y0, this.y1, this.y2);\n  }\n\n  override interpolateX(u: number): number {\n    const v = 1.0 - u;\n    const x01 = v * this.x0 + u * this.x1;\n    const x12 = v * this.x1 + u * this.x2;\n    return v * x01 + u * x12;\n  }\n\n  override interpolateY(u: number): number {\n    const v = 1.0 - u;\n    const y01 = v * this.y0 + u * this.y1;\n    const y12 = v * this.y1 + u * this.y2;\n    return v * y01 + u * y12;\n  }\n\n  override interpolate(u: number): R2Point {\n    const v = 1.0 - u;\n    const x01 = v * this.x0 + u * this.x1;\n    const y01 = v * this.y0 + u * this.y1;\n    const x12 = v * this.x1 + u * this.x2;\n    const y12 = v * this.y1 + u * this.y2;\n    const x02 = v * x01 + u * x12;\n    const y02 = v * y01 + u * y12;\n    return new R2Point(x02, y02);\n  }\n\n  override contains(that: R2ShapeLike): boolean;\n  override contains(x: number, y: number): boolean;\n  override contains(that: R2ShapeLike | number, y?: number): boolean {\n    return false; // TODO\n  }\n\n  override intersects(that: R2ShapeLike): boolean {\n    return false; // TODO\n  }\n\n  override split(u: number): [R2QuadraticCurve, R2QuadraticCurve] {\n    const v = 1.0 - u;\n    const x01 = v * this.x0 + u * this.x1;\n    const y01 = v * this.y0 + u * this.y1;\n    const x12 = v * this.x1 + u * this.x2;\n    const y12 = v * this.y1 + u * this.y2;\n    const x02 = v * x01 + u * x12;\n    const y02 = v * y01 + u * y12;\n    const c0 = new R2QuadraticCurve(this.x0, this.y0, x01, y01, x02, y02);\n    const c1 = new R2QuadraticCurve(x02, y02, x12, y12, this.x2, this.y2);\n    return [c0, c1];\n  }\n\n  override transform(f: R2Function): R2QuadraticCurve {\n    return new R2QuadraticCurve(f.transformX(this.x0, this.y0), f.transformY(this.x0, this.y0),\n                                f.transformX(this.x1, this.y1), f.transformY(this.x1, this.y1),\n                                f.transformX(this.x2, this.y2), f.transformY(this.x2, this.y2));\n  }\n\n  override drawMove(context: R2CurveContext): void {\n    context.moveTo(this.x0, this.y0);\n  }\n\n  override drawRest(context: R2CurveContext): void {\n    context.quadraticCurveTo(this.x1, this.y1, this.x2, this.y2);\n  }\n\n  override transformDrawMove(context: R2CurveContext, f: R2Function): void {\n    context.moveTo(f.transformX(this.x0, this.y0), f.transformY(this.x0, this.y0));\n  }\n\n  override transformDrawRest(context: R2CurveContext, f: R2Function): void {\n    context.quadraticCurveTo(f.transformX(this.x1, this.y1), f.transformY(this.x1, this.y1),\n                             f.transformX(this.x2, this.y2), f.transformY(this.x2, this.y2));\n  }\n\n  override writeMove<T>(output: Output<T>): Output<T> {\n    output = output.write(77/*'M'*/);\n    output = Format.displayNumber(output, this.x0);\n    output = output.write(44/*','*/);\n    output = Format.displayNumber(output, this.y0);\n    return output;\n  }\n\n  override writeRest<T>(output: Output<T>): Output<T> {\n    output = output.write(81/*'Q'*/);\n    output = Format.displayNumber(output, this.x1);\n    output = output.write(44/*','*/);\n    output = Format.displayNumber(output, this.y1);\n    output = output.write(44/*','*/);\n    output = Format.displayNumber(output, this.x2);\n    output = output.write(44/*','*/);\n    output = Format.displayNumber(output, this.y2);\n    return output;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2QuadraticCurve) {\n      return Numbers.equivalent(this.x0, that.x0, epsilon)\n          && Numbers.equivalent(this.y0, that.y0, epsilon)\n          && Numbers.equivalent(this.x1, that.x1, epsilon)\n          && Numbers.equivalent(this.y1, that.y1, epsilon)\n          && Numbers.equivalent(this.x2, that.x2, epsilon)\n          && Numbers.equivalent(this.y2, that.y2, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2QuadraticCurve) {\n      return this.x0 === that.x0 && this.y0 === that.y0\n          && this.x1 === that.x1 && this.y1 === that.y1\n          && this.x2 === that.x2 && this.y2 === that.y2;\n    }\n    return false;\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"R2Curve\").write(46/*'.'*/).write(\"quadratic\").write(40/*'('*/)\n                   .debug(this.x0).write(\", \").debug(this.y0).write(\", \")\n                   .debug(this.x1).write(\", \").debug(this.y1).write(\", \")\n                   .debug(this.x2).write(\", \").debug(this.y2).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n}\n\n/** @internal */\nexport class R2QuadraticCurveParser extends Parser<R2QuadraticCurve> {\n  private readonly x0Parser: Parser<number> | undefined;\n  private readonly y0Parser: Parser<number> | undefined;\n  private readonly x1Parser: Parser<number> | undefined;\n  private readonly y1Parser: Parser<number> | undefined;\n  private readonly x2Parser: Parser<number> | undefined;\n  private readonly y2Parser: Parser<number> | undefined;\n  private readonly command: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(x0Parser?: Parser<number>, y0Parser?: Parser<number>,\n              x1Parser?: Parser<number>, y1Parser?: Parser<number>,\n              x2Parser?: Parser<number>, y2Parser?: Parser<number>,\n              command?: number, step?: number) {\n    super();\n    this.x0Parser = x0Parser;\n    this.y0Parser = y0Parser;\n    this.x1Parser = x1Parser;\n    this.y1Parser = y1Parser;\n    this.x2Parser = x2Parser;\n    this.y2Parser = y2Parser;\n    this.command = command;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<R2QuadraticCurve> {\n    return R2QuadraticCurveParser.parse(input, this.x0Parser, this.y0Parser,\n                                        this.x1Parser, this.y1Parser,\n                                        this.x2Parser, this.y2Parser,\n                                        this.command, this.step);\n  }\n\n  static parse(input: Input, x0Parser?: Parser<number>, y0Parser?: Parser<number>,\n               x1Parser?: Parser<number>, y1Parser?: Parser<number>,\n               x2Parser?: Parser<number>, y2Parser?: Parser<number>,\n               command?: number, step: number = 1): Parser<R2QuadraticCurve> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        switch (c) {\n          case 81/*'Q'*/:\n          case 113/*'q'*/:\n            input = input.step();\n            command = c;\n            step = 2;\n            break;\n          case 84/*'T'*/:\n          case 116/*'t'*/:\n            input = input.step();\n            command = c;\n            step = 6;\n            break;\n          default:\n            return Parser.error(Diagnostic.expected(\"curveto\", input));\n        }\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 2) {\n      if (x1Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          x1Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        x1Parser = x1Parser.feed(input);\n      }\n      if (x1Parser !== void 0) {\n        if (x1Parser.isDone()) {\n          step = 3;\n        } else if (x1Parser.isError()) {\n          return x1Parser.asError();\n        }\n      }\n    }\n    if (step === 3) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 4;\n      } else if (!input.isEmpty()) {\n        step = 4;\n      }\n    }\n    if (step === 4) {\n      if (y1Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          y1Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        y1Parser = y1Parser.feed(input);\n      }\n      if (y1Parser !== void 0) {\n        if (y1Parser.isDone()) {\n          step = 5;\n        } else if (y1Parser.isError()) {\n          return y1Parser.asError();\n        }\n      }\n    }\n    if (step === 5) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 6;\n      } else if (!input.isEmpty()) {\n        step = 6;\n      }\n    }\n    if (step === 6) {\n      if (x2Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          x2Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        x2Parser = x2Parser.feed(input);\n      }\n      if (x2Parser !== void 0) {\n        if (x2Parser.isDone()) {\n          step = 7;\n        } else if (x2Parser.isError()) {\n          return x2Parser.asError();\n        }\n      }\n    }\n    if (step === 7) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 8;\n      } else if (!input.isEmpty()) {\n        step = 8;\n      }\n    }\n    if (step === 8) {\n      if (y2Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          y2Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        y2Parser = y2Parser.feed(input);\n      }\n      if (y2Parser !== void 0) {\n        if (y2Parser.isDone()) {\n          const x0 = x0Parser!.bind();\n          const y0 = y0Parser!.bind();\n          let x1 = x1Parser!.bind();\n          let y1 = y1Parser!.bind();\n          let x2 = x2Parser!.bind();\n          let y2 = y2Parser.bind();\n          if (command === 113/*'q'*/ || command === 116/*'t'*/) {\n            x1 += x0;\n            y1 += y0;\n            x2 += x0;\n            y2 += y0;\n          }\n          return Parser.done(new R2QuadraticCurve(x0, y0, x1, y1, x2, y2));\n        } else if (y2Parser.isError()) {\n          return y2Parser.asError();\n        }\n      }\n    }\n    return new R2QuadraticCurveParser(x0Parser, y0Parser, x1Parser, y1Parser,\n                                      x2Parser, y2Parser, command, step);\n  }\n\n  static parseRest(input: Input, command?: number, x0Parser?: Parser<number>,\n                   y0Parser?: Parser<number>, x1Parser?: Parser<number>,\n                   y1Parser?: Parser<number>): Parser<R2QuadraticCurve> {\n    const step = command === 84/*'T'*/ || command === 116/*'t'*/ ? 6 : 2;\n    return R2QuadraticCurveParser.parse(input, x0Parser, y0Parser, x1Parser, y1Parser,\n                                        void 0, void 0, command, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Numbers} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Base10} from \"@swim/codec\";\nimport type {R2Function} from \"./R2Function\";\nimport type {R2ShapeLike} from \"./R2Shape\";\nimport {R2Point} from \"./R2Point\";\nimport type {R2CurveContext} from \"./R2Curve\";\nimport {R2BezierCurve} from \"./R2Curve\";\n\n/** @public */\nexport class R2CubicCurve extends R2BezierCurve implements Debug {\n  constructor(x0: number, y0: number, x1: number, y1: number,\n              x2: number, y2: number, x3: number, y3: number) {\n    super();\n    this.x0 = x0;\n    this.y0 = y0;\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n    this.x3 = x3;\n    this.y3 = y3;\n  }\n\n  override isDefined(): boolean {\n    return isFinite(this.x0) && isFinite(this.y0)\n        && isFinite(this.x1) && isFinite(this.y1)\n        && isFinite(this.x2) && isFinite(this.y2)\n        && isFinite(this.x3) && isFinite(this.y3);\n  }\n\n  readonly x0: number;\n\n  readonly y0: number;\n\n  readonly x1: number;\n\n  readonly y1: number;\n\n  readonly x2: number;\n\n  readonly y2: number;\n\n  readonly x3: number;\n\n  readonly y3: number;\n\n  override get xMin(): number {\n    return Math.min(this.x0, this.x1, this.x2, this.x3);\n  }\n\n  override get yMin(): number {\n    return Math.min(this.y0, this.y1, this.y2, this.y3);\n  }\n\n  override get xMax(): number {\n    return Math.max(this.x0, this.x1, this.x2, this.x3);\n  }\n\n  override get yMax(): number {\n    return Math.max(this.y0, this.y1, this.y2, this.y3);\n  }\n\n  override interpolateX(u: number): number {\n    const v = 1.0 - u;\n    const x01 = v * this.x0 + u * this.x1;\n    const x12 = v * this.x1 + u * this.x2;\n    const x23 = v * this.x2 + u * this.x3;\n    const x02 = v * x01 + u * x12;\n    const x13 = v * x12 + u * x23;\n    return v * x02 + u * x13;\n  }\n\n  override interpolateY(u: number): number {\n    const v = 1.0 - u;\n    const y01 = v * this.y0 + u * this.y1;\n    const y12 = v * this.y1 + u * this.y2;\n    const y23 = v * this.y2 + u * this.y3;\n    const y02 = v * y01 + u * y12;\n    const y13 = v * y12 + u * y23;\n    return v * y02 + u * y13;\n  }\n\n  override interpolate(u: number): R2Point {\n    const v = 1.0 - u;\n    const x01 = v * this.x0 + u * this.x1;\n    const y01 = v * this.y0 + u * this.y1;\n    const x12 = v * this.x1 + u * this.x2;\n    const y12 = v * this.y1 + u * this.y2;\n    const x23 = v * this.x2 + u * this.x3;\n    const y23 = v * this.y2 + u * this.y3;\n    const x02 = v * x01 + u * x12;\n    const y02 = v * y01 + u * y12;\n    const x13 = v * x12 + u * x23;\n    const y13 = v * y12 + u * y23;\n    const x03 = v * x02 + u * x13;\n    const y03 = v * y02 + u * y13;\n    return new R2Point(x03, y03);\n  }\n\n  override contains(that: R2ShapeLike): boolean;\n  override contains(x: number, y: number): boolean;\n  override contains(that: R2ShapeLike | number, y?: number): boolean {\n    return false; // TODO\n  }\n\n  override intersects(that: R2ShapeLike): boolean {\n    return false; // TODO\n  }\n\n  override split(u: number): [R2CubicCurve, R2CubicCurve] {\n    const v = 1.0 - u;\n    const x01 = v * this.x0 + u * this.x1;\n    const y01 = v * this.y0 + u * this.y1;\n    const x12 = v * this.x1 + u * this.x2;\n    const y12 = v * this.y1 + u * this.y2;\n    const x23 = v * this.x2 + u * this.x3;\n    const y23 = v * this.y2 + u * this.y3;\n    const x02 = v * x01 + u * x12;\n    const y02 = v * y01 + u * y12;\n    const x13 = v * x12 + u * x23;\n    const y13 = v * y12 + u * y23;\n    const x03 = v * x02 + u * x13;\n    const y03 = v * y02 + u * y13;\n    const c0 = new R2CubicCurve(this.x0, this.y0, x01, y01, x02, y02, x03, y03);\n    const c1 = new R2CubicCurve(x03, y03, x13, y13, x23, y23, this.x3, this.y3);\n    return [c0, c1];\n  }\n\n  override transform(f: R2Function): R2CubicCurve {\n    return new R2CubicCurve(f.transformX(this.x0, this.y0), f.transformY(this.x0, this.y0),\n                            f.transformX(this.x1, this.y1), f.transformY(this.x1, this.y1),\n                            f.transformX(this.x2, this.y2), f.transformY(this.x2, this.y2),\n                            f.transformX(this.x3, this.y3), f.transformY(this.x3, this.y3));\n  }\n\n  override drawMove(context: R2CurveContext): void {\n    context.moveTo(this.x0, this.y0);\n  }\n\n  override drawRest(context: R2CurveContext): void {\n    context.bezierCurveTo(this.x1, this.y1, this.x2, this.y2, this.x3, this.y3);\n  }\n\n  override transformDrawMove(context: R2CurveContext, f: R2Function): void {\n    context.moveTo(f.transformX(this.x0, this.y0), f.transformY(this.x0, this.y0));\n  }\n\n  override transformDrawRest(context: R2CurveContext, f: R2Function): void {\n    context.bezierCurveTo(f.transformX(this.x1, this.y1), f.transformY(this.x1, this.y1),\n                          f.transformX(this.x2, this.y2), f.transformY(this.x2, this.y2),\n                          f.transformX(this.x3, this.y3), f.transformY(this.x3, this.y3));\n  }\n\n  override writeMove<T>(output: Output<T>): Output<T> {\n    output = output.write(77/*'M'*/);\n    output = Format.displayNumber(output, this.x0);\n    output = output.write(44/*','*/);\n    output = Format.displayNumber(output, this.y0);\n    return output;\n  }\n\n  override writeRest<T>(output: Output<T>): Output<T> {\n    output = output.write(67/*'C'*/);\n    output = Format.displayNumber(output, this.x1);\n    output = output.write(44/*','*/);\n    output = Format.displayNumber(output, this.y1);\n    output = output.write(44/*','*/);\n    output = Format.displayNumber(output, this.x2);\n    output = output.write(44/*','*/);\n    output = Format.displayNumber(output, this.y2);\n    output = output.write(44/*','*/);\n    output = Format.displayNumber(output, this.x3);\n    output = output.write(44/*','*/);\n    output = Format.displayNumber(output, this.y3);\n    return output;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2CubicCurve) {\n      return Numbers.equivalent(this.x0, that.x0, epsilon)\n          && Numbers.equivalent(this.y0, that.y0, epsilon)\n          && Numbers.equivalent(this.x1, that.x1, epsilon)\n          && Numbers.equivalent(this.y1, that.y1, epsilon)\n          && Numbers.equivalent(this.x2, that.x2, epsilon)\n          && Numbers.equivalent(this.y2, that.y2, epsilon)\n          && Numbers.equivalent(this.x3, that.x3, epsilon)\n          && Numbers.equivalent(this.y3, that.y3, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2CubicCurve) {\n      return this.x0 === that.x0 && this.y0 === that.y0\n          && this.x1 === that.x1 && this.y1 === that.y1\n          && this.x2 === that.x2 && this.y2 === that.y2\n          && this.x3 === that.x3 && this.y3 === that.y3;\n    }\n    return false;\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"R2Curve\").write(46/*'.'*/).write(\"cubic\").write(40/*'('*/)\n                   .debug(this.x0).write(\", \").debug(this.y0).write(\", \")\n                   .debug(this.x1).write(\", \").debug(this.y1).write(\", \")\n                   .debug(this.x2).write(\", \").debug(this.y2).write(\", \")\n                   .debug(this.x3).write(\", \").debug(this.y3).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n}\n\n/** @internal */\nexport class R2CubicCurveParser extends Parser<R2CubicCurve> {\n  private readonly x0Parser: Parser<number> | undefined;\n  private readonly y0Parser: Parser<number> | undefined;\n  private readonly x1Parser: Parser<number> | undefined;\n  private readonly y1Parser: Parser<number> | undefined;\n  private readonly x2Parser: Parser<number> | undefined;\n  private readonly y2Parser: Parser<number> | undefined;\n  private readonly x3Parser: Parser<number> | undefined;\n  private readonly y3Parser: Parser<number> | undefined;\n  private readonly command: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(x0Parser?: Parser<number>, y0Parser?: Parser<number>,\n              x1Parser?: Parser<number>, y1Parser?: Parser<number>,\n              x2Parser?: Parser<number>, y2Parser?: Parser<number>,\n              x3Parser?: Parser<number>, y3Parser?: Parser<number>,\n              command?: number, step?: number) {\n    super();\n    this.x0Parser = x0Parser;\n    this.y0Parser = y0Parser;\n    this.x1Parser = x1Parser;\n    this.y1Parser = y1Parser;\n    this.x2Parser = x2Parser;\n    this.y2Parser = y2Parser;\n    this.x3Parser = x3Parser;\n    this.y3Parser = y3Parser;\n    this.command = command;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<R2CubicCurve> {\n    return R2CubicCurveParser.parse(input, this.x0Parser, this.y0Parser,\n                                    this.x1Parser, this.y1Parser,\n                                    this.x2Parser, this.y2Parser,\n                                    this.x3Parser, this.y3Parser,\n                                    this.command, this.step);\n  }\n\n  static parse(input: Input, x0Parser?: Parser<number>, y0Parser?: Parser<number>,\n               x1Parser?: Parser<number>, y1Parser?: Parser<number>,\n               x2Parser?: Parser<number>, y2Parser?: Parser<number>,\n               x3Parser?: Parser<number>, y3Parser?: Parser<number>,\n               command?: number, step: number = 1): Parser<R2CubicCurve> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        switch (c) {\n          case 67/*'C'*/:\n          case 99/*'c'*/:\n            input = input.step();\n            command = c;\n            step = 2;\n            break;\n          case 83/*'S'*/:\n          case 115/*'s'*/:\n            input = input.step();\n            command = c;\n            step = 6;\n            break;\n          default:\n            return Parser.error(Diagnostic.expected(\"curveto\", input));\n        }\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 2) {\n      if (x1Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          x1Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        x1Parser = x1Parser.feed(input);\n      }\n      if (x1Parser !== void 0) {\n        if (x1Parser.isDone()) {\n          step = 3;\n        } else if (x1Parser.isError()) {\n          return x1Parser.asError();\n        }\n      }\n    }\n    if (step === 3) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 4;\n      } else if (!input.isEmpty()) {\n        step = 4;\n      }\n    }\n    if (step === 4) {\n      if (y1Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          y1Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        y1Parser = y1Parser.feed(input);\n      }\n      if (y1Parser !== void 0) {\n        if (y1Parser.isDone()) {\n          step = 5;\n        } else if (y1Parser.isError()) {\n          return y1Parser.asError();\n        }\n      }\n    }\n    if (step === 5) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 6;\n      } else if (!input.isEmpty()) {\n        step = 6;\n      }\n    }\n    if (step === 6) {\n      if (x2Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          x2Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        x2Parser = x2Parser.feed(input);\n      }\n      if (x2Parser !== void 0) {\n        if (x2Parser.isDone()) {\n          step = 7;\n        } else if (x2Parser.isError()) {\n          return x2Parser.asError();\n        }\n      }\n    }\n    if (step === 7) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 8;\n      } else if (!input.isEmpty()) {\n        step = 8;\n      }\n    }\n    if (step === 8) {\n      if (y2Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          y2Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        y2Parser = y2Parser.feed(input);\n      }\n      if (y2Parser !== void 0) {\n        if (y2Parser.isDone()) {\n          step = 9;\n        } else if (y2Parser.isError()) {\n          return y2Parser.asError();\n        }\n      }\n    }\n    if (step === 9) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 10;\n      } else if (!input.isEmpty()) {\n        step = 10;\n      }\n    }\n    if (step === 10) {\n      if (x3Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          x3Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        x3Parser = x3Parser.feed(input);\n      }\n      if (x3Parser !== void 0) {\n        if (x3Parser.isDone()) {\n          step = 11;\n        } else if (x3Parser.isError()) {\n          return x3Parser.asError();\n        }\n      }\n    }\n    if (step === 11) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 12;\n      } else if (!input.isEmpty()) {\n        step = 12;\n      }\n    }\n    if (step === 12) {\n      if (y3Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          y3Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        y3Parser = y3Parser.feed(input);\n      }\n      if (y3Parser !== void 0) {\n        if (y3Parser.isDone()) {\n          const x0 = x0Parser!.bind();\n          const y0 = y0Parser!.bind();\n          let x1 = x1Parser!.bind();\n          let y1 = y1Parser!.bind();\n          let x2 = x2Parser!.bind();\n          let y2 = y2Parser!.bind();\n          let x3 = x3Parser!.bind();\n          let y3 = y3Parser.bind();\n          if (command === 99/*'c'*/ || command === 115/*'s'*/) {\n            x1 += x0;\n            y1 += y0;\n            x2 += x0;\n            y2 += y0;\n            x3 += x0;\n            y3 += y0;\n          }\n          return Parser.done(new R2CubicCurve(x0, y0, x1, y1, x2, y2, x3, y3));\n        } else if (y3Parser.isError()) {\n          return y3Parser.asError();\n        }\n      }\n    }\n    return new R2CubicCurveParser(x0Parser, y0Parser, x1Parser, y1Parser,\n                                  x2Parser, y2Parser, x3Parser, y3Parser,\n                                  command, step);\n  }\n\n  static parseRest(input: Input, command?: number, x0Parser?: Parser<number>,\n                   y0Parser?: Parser<number>, x1Parser?: Parser<number>,\n                   y1Parser?: Parser<number>): Parser<R2CubicCurve> {\n    const step = command === 83/*'S'*/ || command === 115/*'s'*/ ? 6 : 2;\n    return R2CubicCurveParser.parse(input, x0Parser, y0Parser, x1Parser, y1Parser,\n                                    void 0, void 0, void 0, void 0, command, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Numbers} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Base10} from \"@swim/codec\";\nimport type {R2Function} from \"./R2Function\";\nimport type {R2ShapeLike} from \"./R2Shape\";\nimport {R2Point} from \"./R2Point\";\nimport type {R2CurveContext} from \"./R2Curve\";\nimport {R2Curve} from \"./R2Curve\";\n\n/** @public */\nexport class R2EllipticCurve extends R2Curve implements Debug {\n  constructor(cx: number, cy: number, rx: number, ry: number,\n              phi: number, a0: number, da: number) {\n    super();\n    this.cx = cx;\n    this.cy = cy;\n    this.rx = rx;\n    this.ry = ry;\n    this.phi = phi;\n    this.a0 = a0;\n    this.da = da;\n  }\n\n  override isDefined(): boolean {\n    return isFinite(this.cx) && isFinite(this.cy)\n        && isFinite(this.rx) && isFinite(this.ry)\n        && isFinite(this.phi)\n        && isFinite(this.a0) && isFinite(this.da);\n  }\n\n  readonly cx: number;\n\n  readonly cy: number;\n\n  readonly rx: number;\n\n  readonly ry: number;\n\n  readonly phi: number;\n\n  readonly a0: number;\n\n  readonly da: number;\n\n  override get xMin(): number {\n    return this.cx - Math.max(this.rx, this.ry);\n  }\n\n  override get yMin(): number {\n    return this.cy - Math.max(this.rx, this.ry);\n  }\n\n  override get xMax(): number {\n    return this.cx + Math.max(this.rx, this.ry);\n  }\n\n  override get yMax(): number {\n    return this.cy + Math.max(this.rx, this.ry);\n  }\n\n  override interpolateX(u: number): number {\n    const a0 = this.a0;\n    const da = this.da;\n    const a = a0 + u * da;\n    const dx = this.rx * Math.cos(a);\n    const dy = this.ry * Math.sin(a);\n    const phi = this.phi;\n    if (phi === 0) {\n      return this.cx + dx;\n    }\n    return this.cx + dx * Math.cos(phi) - dy * Math.sin(phi);\n  }\n\n  override interpolateY(u: number): number {\n    const a0 = this.a0;\n    const da = this.da;\n    const a = a0 + u * da;\n    const dx = this.rx * Math.cos(a);\n    const dy = this.ry * Math.sin(a);\n    const phi = this.phi;\n    if (phi === 0) {\n      return this.cy + dy;\n    }\n    return this.cy + dx * Math.sin(phi) + dy * Math.cos(phi);\n  }\n\n  override interpolate(u: number): R2Point {\n    const a0 = this.a0;\n    const da = this.da;\n    const a = a0 + u * da;\n    const dx = this.rx * Math.cos(a);\n    const dy = this.ry * Math.sin(a);\n    const phi = this.phi;\n    if (phi === 0) {\n      return new R2Point(this.cx + dx, this.cy + dy);\n    }\n    return new R2Point(this.cx + dx * Math.cos(phi) - dy * Math.sin(phi),\n                       this.cy + dx * Math.sin(phi) + dy * Math.cos(phi));\n  }\n\n  override contains(that: R2ShapeLike): boolean;\n  override contains(x: number, y: number): boolean;\n  override contains(that: R2ShapeLike | number, y?: number): boolean {\n    return false; // TODO\n  }\n\n  override intersects(that: R2ShapeLike): boolean {\n    return false; // TODO\n  }\n\n  override split(u: number): [R2EllipticCurve, R2EllipticCurve] {\n    const a0 = this.a0;\n    const da = this.da;\n    const a = a0 + u * da;\n    const c0 = new R2EllipticCurve(this.cx, this.cy, this.rx, this.ry,\n                                   this.phi, a0, a - a0);\n    const c1 = new R2EllipticCurve(this.cx, this.cy, this.rx, this.ry,\n                                   this.phi, a, a0 + da - a);\n    return [c0, c1];\n  }\n\n  override transform(f: R2Function): R2EllipticCurve {\n    const cx = f.transformX(this.cx, this.cy);\n    const cy = f.transformY(this.cx, this.cy);\n    const rx = f.transformX(this.cx + this.rx, this.cy + this.ry) - cx;\n    const ry = f.transformY(this.cx + this.rx, this.cy + this.ry) - cy;\n    const a0 = this.a0;\n    const da = this.da;\n    const a1 = a0 + da;\n    const a0x = Math.cos(a0);\n    const a0y = Math.sin(a0);\n    const a1x = Math.cos(a1);\n    const a1y = Math.sin(a1);\n    const b0x = f.transformX(this.cx + a0x, this.cy - a0y) - cx;\n    const b0y = f.transformY(this.cx + a0x, this.cy - a0y) - cy;\n    const b1x = f.transformX(this.cx + a1x, this.cy - a1y) - cx;\n    const b1y = f.transformY(this.cx + a1x, this.cy - a1y) - cy;\n    const b0 = Math.atan2(b0y, b0x);\n    let b1 = Math.atan2(b1y, b1x);\n    if (Math.abs(da) > Math.PI) {\n      if (b1 > 0) {\n        b1 = -2 * Math.PI + b1;\n      } else if (b1 < 0) {\n        b1 = 2 * Math.PI - b1;\n      }\n    }\n    const db = b1 - b0;\n    return new R2EllipticCurve(cx, cy, rx, ry, this.phi, b0, db);\n  }\n\n  override drawMove(context: R2CurveContext): void {\n    const {x0, y0} = this.toEndpoints();\n    context.moveTo(x0, y0);\n  }\n\n  override drawRest(context: R2CurveContext): void {\n    context.ellipse(this.cx, this.cy, this.rx, this.ry, this.phi,\n                    this.a0, this.a0 + this.da, this.da < 0);\n  }\n\n  override transformDrawMove(context: R2CurveContext, f: R2Function): void {\n    const {x0, y0} = this.toEndpoints();\n    context.moveTo(f.transformX(x0, y0), f.transformY(x0, y0));\n  }\n\n  override transformDrawRest(context: R2CurveContext, f: R2Function): void {\n    const cx = f.transformX(this.cx, this.cy);\n    const cy = f.transformY(this.cx, this.cy);\n    const rx = f.transformX(this.cx + this.rx, this.cy + this.ry) - cx;\n    const ry = f.transformY(this.cx + this.rx, this.cy + this.ry) - cy;\n    const a0 = this.a0;\n    const da = this.da;\n    const a1 = a0 + da;\n    const a0x = Math.cos(a0);\n    const a0y = Math.sin(a0);\n    const a1x = Math.cos(a1);\n    const a1y = Math.sin(a1);\n    const b0x = f.transformX(this.cx + a0x, this.cy - a0y) - cx;\n    const b0y = f.transformY(this.cx + a0x, this.cy - a0y) - cy;\n    const b1x = f.transformX(this.cx + a1x, this.cy - a1y) - cx;\n    const b1y = f.transformY(this.cx + a1x, this.cy - a1y) - cy;\n    const b0 = Math.atan2(b0y, b0x);\n    let b1 = Math.atan2(b1y, b1x);\n    if (Math.abs(da) > Math.PI) {\n      if (b1 > 0) {\n        b1 = -2 * Math.PI + b1;\n      } else if (b1 < 0) {\n        b1 = 2 * Math.PI - b1;\n      }\n    }\n    const ccw = b1 < b0;\n    context.ellipse(cx, cy, rx, ry, this.phi, b0, b1, ccw);\n  }\n\n  override writeMove<T>(output: Output<T>): Output<T> {\n    const {x0, y0} = this.toEndpoints();\n    output = output.write(77/*'M'*/);\n    output = Format.displayNumber(output, x0);\n    output = output.write(44/*','*/);\n    output = Format.displayNumber(output, y0);\n    return output;\n  }\n\n  override writeRest<T>(output: Output<T>): Output<T> {\n    const {rx, ry, phi, large, sweep, x1, y1} = this.toEndpoints();\n    output = output.write(65/*'A'*/);\n    output = Format.displayNumber(output, rx);\n    output = output.write(44/*','*/);\n    output = Format.displayNumber(output, ry);\n    output = output.write(32/*' '*/);\n    output = Format.displayNumber(output, phi);\n    output = output.write(32/*' '*/);\n    output = output.write(large ? 49/*'1'*/ : 48/*'0'*/);\n    output = output.write(44/*','*/);\n    output = output.write(sweep ? 49/*'1'*/ : 48/*'0'*/);\n    output = output.write(32/*' '*/);\n    output = Format.displayNumber(output, x1);\n    output = output.write(44/*','*/);\n    output = Format.displayNumber(output, y1);\n    return output;\n  }\n\n  toEndpoints(): {x0: number, y0: number, rx: number, ry: number, phi: number,\n                  large: boolean, sweep: boolean, x1: number, y1: number} {\n    const cx = this.cx;\n    const cy = this.cy;\n    const rx = this.rx;\n    const ry = this.ry;\n    const phi = this.phi;\n    const a0 = this.a0;\n    const da = this.da;\n    const a1 = a0 + da;\n\n    const cosPhi = Math.cos(phi);\n    const sinPhi = Math.sin(phi);\n    const cosA0 = Math.cos(a0);\n    const sinA0 = Math.sin(a0);\n    const cosA1 = Math.cos(a1);\n    const sinA1 = Math.sin(a1);\n    const x0 = cosPhi * rx * cosA0 - sinPhi * ry * sinA0 + cx;\n    const y0 = sinPhi * rx * cosA0 + cosPhi * ry * sinA0 + cy;\n    const x1 = cosPhi * rx * cosA1 - sinPhi * ry * sinA1 + cx;\n    const y1 = sinPhi * rx * cosA1 + cosPhi * ry * sinA1 + cy;\n    const large = Math.abs(da) > Math.PI;\n    const sweep = da > 0;\n    return {x0, y0, rx, ry, phi, large, sweep, x1, y1};\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2EllipticCurve) {\n      return Numbers.equivalent(this.cx, that.cx, epsilon)\n          && Numbers.equivalent(this.cy, that.cy, epsilon)\n          && Numbers.equivalent(this.rx, that.rx, epsilon)\n          && Numbers.equivalent(this.ry, that.ry, epsilon)\n          && Numbers.equivalent(this.phi, that.phi, epsilon)\n          && Numbers.equivalent(this.a0, that.a0, epsilon)\n          && Numbers.equivalent(this.da, that.da, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2EllipticCurve) {\n      return this.cx === that.cx && this.cy === that.cy\n          && this.rx === that.rx && this.ry === that.ry\n          && this.phi === that.phi && this.a0 === that.a0\n          && this.da === that.da;\n    }\n    return false;\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"R2Curve\").write(46/*'.'*/).write(\"elliptic\").write(40/*'('*/)\n                   .debug(this.cx).write(\", \").debug(this.cy).write(\", \")\n                   .debug(this.rx).write(\", \").debug(this.ry).write(\", \")\n                   .debug(this.phi).write(\", \").debug(this.a0).write(\", \")\n                   .debug(this.da).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n\n  static fromEndpoints(x0: number, y0: number, rx: number, ry: number, phi: number,\n                       large: boolean, sweep: boolean, x1: number, y1: number): R2EllipticCurve {\n    const cosPhi = Math.cos(phi);\n    const sinPhi = Math.sin(phi);\n    const x0p =  cosPhi * ((x0 - x1) / 2) + sinPhi * ((y0 - y1) / 2);\n    const y0p = -sinPhi * ((x0 - x1) / 2) + cosPhi * ((y0 - y1) / 2);\n\n    const rx2 = rx * rx;\n    const ry2 = ry * ry;\n    const x0p2 = x0p * x0p;\n    const y0p2 = y0p * y0p;\n    let sp = Math.sqrt((rx2 * ry2 - rx2 * y0p2 - ry2 * x0p2) / (rx2 * y0p2 + ry2 * x0p2));\n    if (large === sweep) {\n      sp = -sp;\n    }\n    const cxp =  sp * rx * y0p / ry;\n    const cyp = -sp * ry * x0p / rx;\n    const cx = cosPhi * cxp - sinPhi * cyp + (x0 + x1) / 2;\n    const cy = sinPhi * cxp + cosPhi * cyp + (y0 + y1) / 2;\n\n    function angle(ux: number, uy: number, vx: number, vy: number): number {\n      const uv = ux * vx + uy * vy;\n      const uu = ux * ux + uy * uy;\n      const vv = vx * vx + vy * vy;\n      let a = Math.acos(uv / (Math.sqrt(uu) * Math.sqrt(vv)));\n      if (ux * vy - uy * vx < 0) {\n        a = -a;\n      }\n      return a;\n    }\n    const a0 = angle(1, 0, (x0p - cxp) / rx, (y0p - cyp) / ry);\n    let da = angle((x0p - cxp) / rx, (y0p - cyp) / ry, (-x0p - cxp) / rx, (-y0p - cyp) / ry) % (2 * Math.PI);\n    if (sweep && da < 0) {\n      da += 2 * Math.PI;\n    } else if (!sweep && da > 0) {\n      da -= 2 * Math.PI;\n    }\n\n    return new R2EllipticCurve(cx, cy, rx, ry, phi, a0, da);\n  }\n}\n\n/** @internal */\nexport class R2EllipticCurveParser extends Parser<R2EllipticCurve> {\n  private readonly x0Parser: Parser<number> | undefined;\n  private readonly y0Parser: Parser<number> | undefined;\n  private readonly rxParser: Parser<number> | undefined;\n  private readonly ryParser: Parser<number> | undefined;\n  private readonly phiParser: Parser<number> | undefined;\n  private readonly large: boolean | undefined;\n  private readonly sweep: boolean | undefined;\n  private readonly x1Parser: Parser<number> | undefined;\n  private readonly y1Parser: Parser<number> | undefined;\n  private readonly command: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(x0Parser?: Parser<number>, y0Parser?: Parser<number>,\n              rxParser?: Parser<number>, ryParser?: Parser<number>,\n              phiParser?: Parser<number>, large?: boolean, sweep?: boolean,\n              x1Parser?: Parser<number>, y1Parser?: Parser<number>,\n              command?: number, step?: number) {\n    super();\n    this.x0Parser = x0Parser;\n    this.y0Parser = y0Parser;\n    this.rxParser = rxParser;\n    this.ryParser = ryParser;\n    this.phiParser = phiParser;\n    this.large = large;\n    this.sweep = sweep;\n    this.x1Parser = x1Parser;\n    this.y1Parser = y1Parser;\n    this.command = command;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<R2EllipticCurve> {\n    return R2EllipticCurveParser.parse(input, this.x0Parser, this.y0Parser,\n                                       this.rxParser, this.ryParser,\n                                       this.phiParser, this.large, this.sweep,\n                                       this.x1Parser, this.y1Parser,\n                                       this.command, this.step);\n  }\n\n  static parse(input: Input, x0Parser?: Parser<number>, y0Parser?: Parser<number>,\n               rxParser?: Parser<number>, ryParser?: Parser<number>,\n               phiParser?: Parser<number>, large?: boolean, sweep?: boolean,\n               x1Parser?: Parser<number>, y1Parser?: Parser<number>,\n               command?: number, step: number = 1): Parser<R2EllipticCurve> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        switch (c) {\n          case 65/*'A'*/:\n          case 97/*'a'*/:\n            input = input.step();\n            command  = c;\n            step = 2;\n            break;\n          default:\n            return Parser.error(Diagnostic.expected(\"arcto\", input));\n        }\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 2) {\n      if (rxParser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          rxParser = Base10.parseDecimal(input);\n        }\n      } else {\n        rxParser = rxParser.feed(input);\n      }\n      if (rxParser !== void 0) {\n        if (rxParser.isDone()) {\n          step = 3;\n        } else if (rxParser.isError()) {\n          return rxParser.asError();\n        }\n      }\n    }\n    if (step === 3) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 4;\n      } else if (!input.isEmpty()) {\n        step = 4;\n      }\n    }\n    if (step === 4) {\n      if (ryParser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          ryParser = Base10.parseDecimal(input);\n        }\n      } else {\n        ryParser = ryParser.feed(input);\n      }\n      if (ryParser !== void 0) {\n        if (ryParser.isDone()) {\n          step = 5;\n        } else if (ryParser.isError()) {\n          return ryParser.asError();\n        }\n      }\n    }\n    if (step === 5) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 6;\n      } else if (!input.isEmpty()) {\n        step = 6;\n      }\n    }\n    if (step === 6) {\n      if (phiParser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          phiParser = Base10.parseDecimal(input);\n        }\n      } else {\n        phiParser = phiParser.feed(input);\n      }\n      if (phiParser !== void 0) {\n        if (phiParser.isDone()) {\n          step = 7;\n        } else if (phiParser.isError()) {\n          return phiParser.asError();\n        }\n      }\n    }\n    if (step === 7) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 8;\n      } else if (!input.isEmpty()) {\n        step = 8;\n      }\n    }\n    if (step === 8) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 48/*'0'*/) {\n          input = input.step();\n          large = false;\n          step = 9;\n        } else if (c === 49/*'1'*/) {\n          input = input.step();\n          large = true;\n          step = 9;\n        } else {\n          return Parser.error(Diagnostic.expected(\"flag\", input));\n        }\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 9) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 10;\n      } else if (!input.isEmpty()) {\n        step = 10;\n      }\n    }\n    if (step === 10) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 48/*'0'*/) {\n          input = input.step();\n          sweep = false;\n          step = 11;\n        } else if (c === 49/*'1'*/) {\n          input = input.step();\n          sweep = true;\n          step = 11;\n        } else {\n          return Parser.error(Diagnostic.expected(\"flag\", input));\n        }\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 11) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 12;\n      } else if (!input.isEmpty()) {\n        step = 12;\n      }\n    }\n    if (step === 12) {\n      if (x1Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          x1Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        x1Parser = x1Parser.feed(input);\n      }\n      if (x1Parser !== void 0) {\n        if (x1Parser.isDone()) {\n          step = 13;\n        } else if (x1Parser.isError()) {\n          return x1Parser.asError();\n        }\n      }\n    }\n    if (step === 13) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 14;\n      } else if (!input.isEmpty()) {\n        step = 14;\n      }\n    }\n    if (step === 14) {\n      if (y1Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          y1Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        y1Parser = y1Parser.feed(input);\n      }\n      if (y1Parser !== void 0) {\n        if (y1Parser.isDone()) {\n          const x0 = x0Parser!.bind();\n          const y0 = y0Parser!.bind();\n          const rx = rxParser!.bind();\n          const ry = ryParser!.bind();\n          const phi = phiParser!.bind() * Math.PI / 180;\n          let x1 = x1Parser!.bind();\n          let y1 = y1Parser.bind();\n          if (command === 97/*'a'*/) {\n            x1 += x0;\n            y1 += y0;\n          }\n          return Parser.done(R2EllipticCurve.fromEndpoints(x0, y0, rx, ry, phi, large!, sweep!, x1, y1));\n        } else if (y1Parser.isError()) {\n          return y1Parser.asError();\n        }\n      }\n    }\n    return new R2EllipticCurveParser(x0Parser, y0Parser, rxParser, ryParser,\n                                     phiParser, large, sweep, x1Parser, y1Parser,\n                                     command, step);\n  }\n\n  static parseRest(input: Input, command?: number, x0Parser?: Parser<number>,\n                   y0Parser?: Parser<number>): Parser<R2EllipticCurve> {\n    return R2EllipticCurveParser.parse(input, x0Parser, y0Parser, void 0, void 0, void 0,\n                                       void 0, void 0, void 0, void 0, command, 2);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport {Arrays} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {OutputSettingsLike} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport {Base10} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport type {R2Function} from \"./R2Function\";\nimport type {R2ShapeLike} from \"./R2Shape\";\nimport {R2Point} from \"./R2Point\";\nimport type {R2CurveContext} from \"./R2Curve\";\nimport {R2Curve} from \"./R2Curve\";\nimport {R2Segment} from \"./R2Segment\";\nimport {R2SegmentParser} from \"./R2Segment\";\nimport {R2QuadraticCurve} from \"./R2QuadraticCurve\";\nimport {R2QuadraticCurveParser} from \"./R2QuadraticCurve\";\nimport {R2CubicCurve} from \"./R2CubicCurve\";\nimport {R2CubicCurveParser} from \"./R2CubicCurve\";\nimport {R2EllipticCurve} from \"./R2EllipticCurve\";\nimport {R2EllipticCurveParser} from \"./R2EllipticCurve\";\nimport {R2Box} from \"./\"; // forward import\n\n/** @public */\nexport interface R2SplineContext extends R2CurveContext {\n  rect(x: number, y: number, w: number, h: number): void;\n\n  closePath(): void;\n}\n\n/** @public */\nexport class R2Spline extends R2Curve implements Debug {\n  constructor(curves: readonly R2Curve[], closed: boolean) {\n    super();\n    this.curves = curves;\n    this.closed = closed;\n    this.boundingBox = null;\n    this.pathString = void 0;\n  }\n\n  readonly curves: readonly R2Curve[];\n\n  /** @internal */\n  readonly closed: boolean;\n\n  override isDefined(): boolean {\n    return this.curves.length !== 0;\n  }\n\n  isClosed(): boolean {\n    return this.closed;\n  }\n\n  override get xMin(): number {\n    return this.bounds.xMin;\n  }\n\n  override get yMin(): number {\n    return this.bounds.yMin;\n  }\n\n  override get xMax(): number {\n    return this.bounds.xMax;\n  }\n\n  override get yMax(): number {\n    return this.bounds.yMax;\n  }\n\n  override interpolateX(u: number): number {\n    const curves = this.curves;\n    const n = curves.length;\n    if (n === 0) {\n      return NaN;\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n - 1);\n    const v = n * (u - k * l);\n    return curves[k]!.interpolateX(v);\n  }\n\n  override interpolateY(u: number): number {\n    const curves = this.curves;\n    const n = curves.length;\n    if (n === 0) {\n      return NaN;\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n - 1);\n    const v = n * (u - k * l);\n    return curves[k]!.interpolateY(v);\n  }\n\n  override interpolate(u: number): R2Point {\n    const curves = this.curves;\n    const n = curves.length;\n    if (n === 0) {\n      return R2Point.undefined();\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n - 1);\n    const v = n * (u - k * l);\n    return curves[k]!.interpolate(v);\n  }\n\n  override contains(that: R2ShapeLike): boolean;\n  override contains(x: number, y: number): boolean;\n  override contains(that: R2ShapeLike | number, y?: number): boolean {\n    return false; // TODO\n  }\n\n  override intersects(that: R2ShapeLike): boolean {\n    return false; // TODO\n  }\n\n  override split(u: number): [R2Spline, R2Spline] {\n    const curves = this.curves;\n    const n = curves.length;\n    if (n === 0) {\n      return [R2Spline.empty(), R2Spline.empty()];\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n - 1);\n    const v = n * (u - k * l);\n    const [c0, c1] = curves[k]!.split(v);\n    const curves0 = new Array<R2Curve>(k + 1);\n    const curves1 = new Array<R2Curve>(n - k);\n    for (let i = 0; i < k; i += 1) {\n      curves0[i] = curves[i]!;\n    }\n    curves0[k] = c0;\n    curves1[0] = c1;\n    for (let i = k + 1; i < n; i += 1) {\n      curves1[i - k] = curves[i]!;\n    }\n    return [new R2Spline(curves0, false), new R2Spline(curves1, false)];\n  }\n\n  subdivide(u: number): R2Spline {\n    const oldCurves = this.curves;\n    const n = oldCurves.length;\n    if (n === 0) {\n      return R2Spline.empty();\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n - 1);\n    const v = n * (u - k * l);\n    const [c0, c1] = oldCurves[k]!.split(v);\n    const newCurves = new Array<R2Curve>(n + 1);\n    for (let i = 0; i < k; i += 1) {\n      newCurves[i] = oldCurves[i]!;\n    }\n    newCurves[k] = c0;\n    newCurves[k + 1] = c1;\n    for (let i = k + 1; i < n; i += 1) {\n      newCurves[i + 1] = oldCurves[i]!;\n    }\n    return new R2Spline(newCurves, this.closed);\n  }\n\n  override transform(f: R2Function): R2Spline {\n    const oldCurves = this.curves;\n    const n = oldCurves.length;\n    if (n === 0) {\n      return R2Spline.empty();\n    }\n    const newCurves = new Array<R2Curve>(n);\n    for (let i = 0; i < n; i += 1) {\n      newCurves[i] = oldCurves[i]!.transform(f);\n    }\n    return new R2Spline(newCurves, this.closed);\n  }\n\n  /** @internal */\n  readonly boundingBox: R2Box | null;\n\n  override get bounds(): R2Box {\n    let boundingBox = this.boundingBox;\n    if (boundingBox === null) {\n      let xMin = Infinity;\n      let yMin = Infinity;\n      let xMax = -Infinity;\n      let yMax = -Infinity;\n      const curves = this.curves;\n      for (let i = 0; i < curves.length; i += 1) {\n        const curve = curves[i]!;\n        xMin = Math.min(xMin, curve.xMin);\n        yMin = Math.min(yMin, curve.yMin);\n        xMax = Math.max(curve.xMax, xMax);\n        yMax = Math.max(curve.yMax, yMax);\n      }\n      boundingBox = new R2Box(xMin, yMin, xMax, yMax);\n      (this as Mutable<this>).boundingBox = boundingBox;\n    }\n    return boundingBox;\n  }\n\n  override drawMove(context: R2SplineContext): void {\n    const curves = this.curves;\n    if (curves.length !== 0) {\n      curves[0]!.drawMove(context);\n    }\n  }\n\n  override drawRest(context: R2SplineContext): void {\n    const curves = this.curves;\n    const closed = this.closed;\n    const n = curves.length - (closed && context.closePath !== void 0 ? 1 : 0);\n    for (let i = 0; i < n; i += 1) {\n      curves[i]!.drawRest(context);\n    }\n    if (closed && context.closePath !== void 0) {\n      context.closePath();\n    }\n  }\n\n  override transformDrawMove(context: R2SplineContext, f: R2Function): void {\n    const curves = this.curves;\n    if (curves.length !== 0) {\n      curves[0]!.transformDrawMove(context, f);\n    }\n  }\n\n  override transformDrawRest(context: R2SplineContext, f: R2Function): void {\n    const curves = this.curves;\n    const closed = this.closed;\n    const n = curves.length - (closed && context.closePath !== void 0 ? 1 : 0);\n    for (let i = 0; i < n; i += 1) {\n      curves[i]!.transformDrawRest(context, f);\n    }\n    if (closed && context.closePath !== void 0) {\n      context.closePath();\n    }\n  }\n\n  override writeMove<T>(output: Output<T>): Output<T> {\n    const curves = this.curves;\n    if (curves.length !== 0) {\n      output = curves[0]!.writeMove(output);\n    }\n    return output;\n  }\n\n  override writeRest<T>(output: Output<T>): Output<T> {\n    const curves = this.curves;\n    const closed = this.closed;\n    const n = curves.length - (closed ? 1 : 0);\n    for (let i = 0; i < n; i += 1) {\n      output = curves[i]!.writeRest(output);\n    }\n    if (closed) {\n      output = output.write(90/*'Z'*/);\n    }\n    return output;\n  }\n\n  /** @internal */\n  readonly pathString: string | undefined;\n\n  override toPathString(outputSettings?: OutputSettingsLike): string {\n    let pathString: string | undefined;\n    if (outputSettings !== void 0 || (pathString = this.pathString, pathString === void 0)) {\n      const output = Unicode.stringOutput(outputSettings);\n      this.writePath(output);\n      pathString = output.bind();\n      if (outputSettings === void 0) {\n        (this as Mutable<this>).pathString = pathString;\n      }\n    }\n    return pathString;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2Spline) {\n      return Arrays.equivalent(this.curves, that.curves, epsilon)\n          && this.closed === that.closed;\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2Spline) {\n      return Arrays.equal(this.curves, that.curves)\n          && this.closed === that.closed;\n    }\n    return false;\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    const curves = this.curves;\n    const n = curves.length;\n    output = output.write(\"R2Spline\").write(46/*'.'*/);\n    if (n === 0) {\n      output = output.write(\"empty\").write(40/*'('*/);\n    } else if (n !== 0) {\n      output = output.write(this.closed ? \"closed\" : \"open\").write(40/*'('*/);\n      output = output.debug(curves[0]!);\n      for (let i = 1; i < n; i += 1) {\n        output = output.write(\", \").debug(curves[i]!);\n      }\n    }\n    output = output.write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n\n  static builder(): R2SplineBuilder {\n    return new R2SplineBuilder();\n  }\n\n  @Lazy\n  static empty(): R2Spline {\n    return new R2Spline(Arrays.empty(), false);\n  }\n\n  static open(...curves: R2Curve[]): R2Spline {\n    return new R2Spline(curves, false);\n  }\n\n  static closed(...curves: R2Curve[]): R2Spline {\n    return new R2Spline(curves, true);\n  }\n\n  static override parse(string: string): R2Spline {\n    let input = Unicode.stringInput(string);\n    while (input.isCont() && Unicode.isWhitespace(input.head())) {\n      input = input.step();\n    }\n    let parser = R2SplineParser.parse(input);\n    if (parser.isDone()) {\n      while (input.isCont() && Unicode.isWhitespace(input.head())) {\n        input = input.step();\n      }\n    }\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n}\n\n/** @public */\nexport class R2SplineBuilder implements R2SplineContext {\n  /** @internal */\n  curves: R2Curve[];\n  /** @internal */\n  closed: boolean;\n  /** @internal */\n  aliased: boolean;\n  /** @internal */\n  x0: number;\n  /** @internal */\n  y0: number;\n  /** @internal */\n  x: number;\n  /** @internal */\n  y: number;\n\n  constructor() {\n    this.curves = [];\n    this.closed = false;\n    this.aliased = false;\n    this.x0 = 0;\n    this.y0 = 0;\n    this.x = 0;\n    this.y = 0;\n  }\n\n  private dealias(): void {\n    if (!this.aliased) {\n      return;\n    }\n    this.curves = this.curves.slice(0);\n    this.aliased = false;\n  }\n\n  moveTo(x: number, y: number): void {\n    if (this.aliased) {\n      this.curves = [];\n      this.aliased = false;\n    } else {\n      this.curves.length = 0;\n    }\n    this.closed = false;\n    this.x0 = x;\n    this.y0 = y;\n    this.x = x;\n    this.y = y;\n  }\n\n  closePath(): void {\n    this.dealias();\n    this.curves.push(new R2Segment(this.x, this.y, this.x0, this.y0));\n    this.closed = true;\n    this.x = this.x0;\n    this.y = this.y0;\n  }\n\n  lineTo(x: number, y: number): void {\n    this.dealias();\n    this.curves.push(new R2Segment(this.x, this.y, x, y));\n    this.x = x;\n    this.y = y;\n  }\n\n  quadraticCurveTo(x1: number, y1: number, x: number, y: number): void {\n    this.dealias();\n    this.curves.push(new R2QuadraticCurve(this.x, this.y, x1, y1, x, y));\n    this.x = x;\n    this.y = y;\n  }\n\n  bezierCurveTo(x1: number, y1: number, x2: number, y2: number, x: number, y: number): void {\n    this.dealias();\n    this.curves.push(new R2CubicCurve(this.x, this.y, x1, y1, x2, y2, x, y));\n    this.x = x;\n    this.y = y;\n  }\n\n  arcTo(x1: number, y1: number, x2: number, y2: number, r: number): void {\n    this.dealias();\n    const x0 = this.x;\n    const y0 = this.y;\n    const dx01 = x1 - x0;\n    const dy01 = y1 - y0;\n    const dx12 = x2 - x1;\n    const dy12 = y2 - y1;\n    const a0 = Math.atan2(dy01, dx01) - Math.PI / 2;\n    const a1 = Math.atan2(dy12, dx12) - Math.PI / 2;\n    const da = a1 - a0;\n    const r0x = Math.cos(a0);\n    const r0y = Math.sin(a0);\n    const r1x = Math.cos(a1);\n    const r1y = Math.sin(a1);\n    const r0x0 = x0 - r0x;\n    const r0y0 = y0 - r0y;\n    const r0x1 = x1 - r0x;\n    const r0y1 = y1 - r0y;\n    const r1x1 = x1 - r1x;\n    const r1y1 = y1 - r1y;\n    const r1x2 = x2 - r1x;\n    const r1y2 = y2 - r1y;\n    const u = R2SplineBuilder.intersection(r0x0, r0y0, r0x1 - r0x0, r0y1 - r0y0,\n                                           r1x1, r1y1, r1x2 - r1x1, r1y2 - r1y1);\n    const cx = r0x0 + u * (r0x1 - r0x0);\n    const cy = r0y0 + u * (r0y1 - r0y0);\n    this.curves.push(new R2EllipticCurve(cx, cy, r, r, 0, a0, da));\n    this.x = x2;\n    this.y = y2;\n  }\n\n  private static intersection(px: number, py: number, rx: number, ry: number,\n                              qx: number, qy: number, sx: number, sy: number): number {\n    const pqx = qx - px;\n    const pqy = qy - py;\n    const pqr = pqx * ry - pqy * rx;\n    const rs = rx * sy - ry * sx;\n    if (pqr === 0 && rs === 0) { // collinear\n      const rr = rx * rx + ry * ry;\n      const sr = sx * rx + sy * ry;\n      const t0 = (pqx * rx + pqy * ry) / rr;\n      const t1 = t0 + sr / rr;\n      if (sr >= 0 ? 0 < t1 && t0 < 1 : 0 < t0 && t1 < 1) {\n        return t0;\n      } else {\n        return NaN;\n      }\n    } else if (rs === 0) { // parallel\n      return NaN;\n    }\n    const pqs = pqx * sy - pqy * sx;\n    const t = pqs / rs; // (q − p) × s / (r × s)\n    const u = pqr / rs; // (q − p) × r / (r × s)\n    if (t < 0 || t > 1 || u < 0 || u > 1) {\n      return NaN;\n    }\n    return t;\n  }\n\n  arc(cx: number, cy: number, r: number, a0: number, a1: number, ccw: boolean = false): void {\n    this.dealias();\n    let da = a1 - a0;\n    if (ccw === true && da > 0) {\n      da -= 2 * Math.PI;\n    } else if (ccw === false && da < 0) {\n      da += 2 * Math.PI;\n    }\n    const curve = new R2EllipticCurve(cx, cy, r, r, 0, a0, da);\n    this.curves.push(curve);\n    const {x, y} = curve.interpolate(1);\n    this.x = x;\n    this.y = y;\n  }\n\n  ellipse(cx: number, cy: number, rx: number, ry: number, phi: number, a0: number, a1: number, ccw?: boolean): void {\n    this.dealias();\n    let da = a1 - a0;\n    if (ccw === true && da > 0) {\n      da -= 2 * Math.PI;\n    } else if (ccw === false && da < 0) {\n      da += 2 * Math.PI;\n    }\n    const curve = new R2EllipticCurve(cx, cy, rx, ry, phi, a0, da);\n    this.curves.push(curve);\n    const {x, y} = curve.interpolate(1);\n    this.x = x;\n    this.y = y;\n  }\n\n  rect(x: number, y: number, w: number, h: number): void {\n    this.dealias();\n    this.curves.push(new R2Segment(x, y, x + w, y),\n                     new R2Segment(x + w, y, x + w, y + h),\n                     new R2Segment(x + w, y + h, x, y + h),\n                     new R2Segment(x, y + h, x, y));\n    this.x = x;\n    this.y = y;\n  }\n\n  build(): R2Spline {\n    this.aliased = true;\n    return new R2Spline(this.curves, this.closed);\n  }\n}\n\n/** @internal */\nexport class R2SplineParser extends Parser<R2Spline> {\n  private readonly xParser: Parser<number> | undefined;\n  private readonly yParser: Parser<number> | undefined;\n  private readonly x0Parser: Parser<number> | undefined;\n  private readonly y0Parser: Parser<number> | undefined;\n  private readonly curveParser: Parser<R2Curve> | undefined;\n  private readonly curves: R2Curve[] | undefined;\n  private readonly command: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(xParser?: Parser<number>, yParser?: Parser<number>,\n              x0Parser?: Parser<number>, y0Parser?: Parser<number>,\n              curveParser?: Parser<R2Curve>, curves?: R2Curve[],\n              command?: number, step?: number) {\n    super();\n    this.xParser = xParser;\n    this.yParser = yParser;\n    this.x0Parser = x0Parser;\n    this.y0Parser = y0Parser;\n    this.curveParser = curveParser;\n    this.curves = curves;\n    this.command = command;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<R2Spline> {\n    return R2SplineParser.parse(input, this.xParser, this.yParser,\n                                this.x0Parser, this.y0Parser,\n                                this.curveParser, this.curves,\n                                this.command, this.step);\n  }\n\n  static parse(input: Input, xParser?: Parser<number>, yParser?: Parser<number>,\n               x0Parser?: Parser<number>, y0Parser?: Parser<number>,\n               curveParser?: Parser<R2Curve>, curves?: R2Curve[],\n               command?: number, step: number = 1): Parser<R2Spline> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 77/*'M'*/ || c === 109/*'m'*/) {\n          input = input.step();\n          command = c;\n          step = 2;\n        } else {\n          return Parser.error(Diagnostic.expected(\"moveto\", input));\n        }\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 2) {\n      if (x0Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          x0Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        x0Parser = x0Parser.feed(input);\n      }\n      if (x0Parser !== void 0) {\n        if (x0Parser.isDone()) {\n          if (command === 109/*'m'*/ && xParser !== void 0) {\n            x0Parser = Parser.done(xParser.bind() + x0Parser.bind());\n          }\n          xParser = x0Parser;\n          step = 3;\n        } else if (x0Parser.isError()) {\n          return x0Parser.asError();\n        }\n      }\n    }\n    if (step === 3) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 44/*','*/) {\n          input = input.step();\n        }\n        step = 4;\n      } else if (!input.isEmpty()) {\n        step = 4;\n      }\n    }\n    if (step === 4) {\n      if (y0Parser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (!input.isEmpty()) {\n          y0Parser = Base10.parseDecimal(input);\n        }\n      } else {\n        y0Parser = y0Parser.feed(input);\n      }\n      if (y0Parser !== void 0) {\n        if (y0Parser.isDone()) {\n          if (command === 109/*'m'*/ && yParser !== void 0) {\n            y0Parser = Parser.done(yParser.bind() + y0Parser.bind());\n          }\n          yParser = y0Parser;\n          step = 5;\n        } else if (y0Parser.isError()) {\n          return y0Parser.asError();\n        }\n      }\n    }\n    do {\n      if (step === 5) {\n        if (curveParser === void 0) {\n          while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n            input = input.step();\n          }\n          if (input.isCont()) {\n            const prevCurve = curves !== void 0 && curves.length !== 0 ? curves[curves.length - 1] : null;\n            switch (c) {\n              case 76/*'L'*/:\n              case 108/*'l'*/:\n              case 72/*'H'*/:\n              case 104/*'h'*/:\n              case 86/*'V'*/:\n              case 118/*'v'*/:\n                curveParser = R2SegmentParser.parse(input, xParser, yParser);\n                command = c;\n                break;\n              case 81/*'Q'*/:\n              case 113/*'q'*/:\n                curveParser = R2QuadraticCurveParser.parse(input, xParser, yParser);\n                command = c;\n                break;\n              case 84/*'T'*/:\n                if (prevCurve instanceof R2QuadraticCurve) {\n                  const dx = prevCurve.x2 - prevCurve.x1;\n                  const dy = prevCurve.y2 - prevCurve.y1;\n                  const x1 = xParser!.bind() + dx;\n                  const y1 = yParser!.bind() + dy;\n                  curveParser = R2QuadraticCurveParser.parse(input, xParser, yParser,\n                                                             Parser.done(x1), Parser.done(y1));\n                } else {\n                  curveParser = R2QuadraticCurveParser.parse(input, xParser, yParser,\n                                                             xParser, yParser);\n                }\n                command = c;\n                break;\n              case 116/*'t'*/:\n                if (prevCurve instanceof R2QuadraticCurve) {\n                  const dx = prevCurve.x2 - prevCurve.x1;\n                  const dy = prevCurve.y2 - prevCurve.y1;\n                  curveParser = R2QuadraticCurveParser.parse(input, xParser, yParser,\n                                                             Parser.done(dx), Parser.done(dy));\n                } else {\n                  curveParser = R2QuadraticCurveParser.parse(input, xParser, yParser,\n                                                             Parser.done(0), Parser.done(0));\n                }\n                command = c;\n                break;\n              case 67/*'C'*/:\n              case 99/*'c'*/:\n                curveParser = R2CubicCurveParser.parse(input, xParser, yParser);\n                command = c;\n                break;\n              case 83/*'S'*/:\n                if (prevCurve instanceof R2CubicCurve) {\n                  const dx = prevCurve.x3 - prevCurve.x2;\n                  const dy = prevCurve.y3 - prevCurve.y2;\n                  const x1 = xParser!.bind() + dx;\n                  const y1 = yParser!.bind() + dy;\n                  curveParser = R2CubicCurveParser.parse(input, xParser, yParser,\n                                                         Parser.done(x1), Parser.done(y1));\n                } else {\n                  curveParser = R2CubicCurveParser.parse(input, xParser, yParser,\n                                                         xParser, yParser);\n                }\n                command = c;\n                break;\n              case 115/*'s'*/:\n                if (prevCurve instanceof R2CubicCurve) {\n                  const dx = prevCurve.x3 - prevCurve.x2;\n                  const dy = prevCurve.y3 - prevCurve.y2;\n                  curveParser = R2CubicCurveParser.parse(input, xParser, yParser,\n                                                         Parser.done(dx), Parser.done(dy));\n                } else {\n                  curveParser = R2CubicCurveParser.parse(input, xParser, yParser,\n                                                         Parser.done(0), Parser.done(0));\n                }\n                command = c;\n                break;\n              case 65/*'A'*/:\n              case 97/*'a'*/:\n                curveParser = R2EllipticCurveParser.parse(input, xParser, yParser);\n                command = c;\n                break;\n              case 90/*'Z'*/:\n              case 122/*'z'*/:\n                input = input.step();\n                if (curves === void 0) {\n                  curves = [];\n                }\n                curves.push(new R2Segment(xParser!.bind(), yParser!.bind(),\n                                          x0Parser!.bind(), y0Parser!.bind()));\n                return Parser.done(new R2Spline(curves, true));\n              case 44/*','*/:\n                input = input.step();\n              case 43/*'+'*/:\n              case 45/*'-'*/:\n              case 46/*'.'*/:\n              case 48/*'0'*/:\n              case 49/*'1'*/:\n              case 50/*'2'*/:\n              case 51/*'3'*/:\n              case 52/*'4'*/:\n              case 53/*'5'*/:\n              case 54/*'6'*/:\n              case 55/*'7'*/:\n              case 56/*'8'*/:\n              case 57/*'9'*/:\n                switch (command) {\n                  case 77/*'M'*/:\n                  case 109/*'m'*/:\n                  case 76/*'L'*/:\n                  case 108/*'l'*/:\n                  case 72/*'H'*/:\n                  case 104/*'h'*/:\n                  case 86/*'V'*/:\n                  case 118/*'v'*/:\n                    curveParser = R2SegmentParser.parseRest(input, command, xParser, yParser);\n                    break;\n                  case 81/*'Q'*/:\n                  case 113/*'q'*/:\n                    curveParser = R2QuadraticCurveParser.parseRest(input, command, xParser, yParser);\n                    break;\n                  case 84/*'T'*/:\n                    if (prevCurve instanceof R2QuadraticCurve) {\n                      const dx = prevCurve.x2 - prevCurve.x1;\n                      const dy = prevCurve.y2 - prevCurve.y1;\n                      const x1 = xParser!.bind() + dx;\n                      const y1 = yParser!.bind() + dy;\n                      curveParser = R2QuadraticCurveParser.parseRest(input, command, xParser, yParser,\n                                                                     Parser.done(x1), Parser.done(y1));\n                    } else {\n                      curveParser = R2QuadraticCurveParser.parseRest(input, command, xParser, yParser,\n                                                                     xParser, yParser);\n                    }\n                    break;\n                  case 116/*'t'*/:\n                    if (prevCurve instanceof R2QuadraticCurve) {\n                      const dx = prevCurve.x2 - prevCurve.x1;\n                      const dy = prevCurve.y2 - prevCurve.y1;\n                      curveParser = R2QuadraticCurveParser.parseRest(input, command, xParser, yParser,\n                                                                     Parser.done(dx), Parser.done(dy));\n                    } else {\n                      curveParser = R2QuadraticCurveParser.parseRest(input, command, xParser, yParser,\n                                                                     Parser.done(0), Parser.done(0));\n                    }\n                    break;\n                  case 67/*'C'*/:\n                  case 99/*'c'*/:\n                    curveParser = R2CubicCurveParser.parseRest(input, command, xParser, yParser);\n                    break;\n                  case 83/*'S'*/:\n                    if (prevCurve instanceof R2CubicCurve) {\n                      const dx = prevCurve.x3 - prevCurve.x2;\n                      const dy = prevCurve.y3 - prevCurve.y2;\n                      const x1 = xParser!.bind() + dx;\n                      const y1 = yParser!.bind() + dy;\n                      curveParser = R2CubicCurveParser.parseRest(input, command, xParser, yParser,\n                                                                 Parser.done(x1), Parser.done(y1));\n                    } else {\n                      curveParser = R2CubicCurveParser.parseRest(input, command, xParser, yParser,\n                                                                 xParser, yParser);\n                    }\n                    break;\n                  case 115/*'s'*/:\n                    if (prevCurve instanceof R2CubicCurve) {\n                      const dx = prevCurve.x3 - prevCurve.x2;\n                      const dy = prevCurve.y3 - prevCurve.y2;\n                      curveParser = R2CubicCurveParser.parseRest(input, command, xParser, yParser,\n                                                                 Parser.done(dx), Parser.done(dy));\n                    } else {\n                      curveParser = R2CubicCurveParser.parseRest(input, command, xParser, yParser,\n                                                                 Parser.done(0), Parser.done(0));\n                    }\n                    break;\n                  case 65/*'A'*/:\n                  case 97/*'a'*/:\n                    curveParser = R2EllipticCurveParser.parseRest(input, command, xParser, yParser);\n                    break;\n                  default:\n                    if (curves !== void 0) {\n                      return Parser.done(new R2Spline(curves, false));\n                    } else {\n                      return Parser.done(R2Spline.empty());\n                    }\n                }\n                break;\n              default:\n                if (curves !== void 0) {\n                  return Parser.done(new R2Spline(curves, false));\n                } else {\n                  return Parser.done(R2Spline.empty());\n                }\n            }\n          } else if (!input.isEmpty()) {\n            if (curves !== void 0) {\n              return Parser.done(new R2Spline(curves, false));\n            } else {\n              return Parser.done(R2Spline.empty());\n            }\n          }\n        } else {\n          curveParser = curveParser.feed(input);\n        }\n        if (curveParser !== void 0) {\n          if (curveParser.isDone()) {\n            const curve = curveParser.bind();\n            curveParser = void 0;\n            if (curves === void 0) {\n              curves = [];\n            }\n            curves.push(curve);\n            xParser = Parser.done(curve.interpolateX(1));\n            yParser = Parser.done(curve.interpolateY(1));\n            continue;\n          } else if (curveParser.isError()) {\n            return curveParser.asError();\n          }\n        }\n      }\n      break;\n    } while (true);\n    return new R2SplineParser(xParser, yParser, x0Parser, y0Parser,\n                              curveParser, curves, command, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport {Arrays} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {OutputSettingsLike} from \"@swim/codec\";\nimport {OutputSettings} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport type {R2Function} from \"./R2Function\";\nimport type {R2ShapeLike} from \"./R2Shape\";\nimport {R2Shape} from \"./R2Shape\";\nimport {R2Point} from \"./R2Point\";\nimport type {R2Curve} from \"./R2Curve\";\nimport type {R2SplineContext} from \"./R2Spline\";\nimport {R2Spline} from \"./R2Spline\";\nimport {R2SplineBuilder} from \"./R2Spline\";\nimport {R2SplineParser} from \"./R2Spline\";\nimport {R2Box} from \"./\"; // forward import\n\n/** @public */\nexport interface R2PathContext extends R2SplineContext {\n}\n\n/** @public */\nexport type R2PathLike = R2Path | string;\n\n/** @public */\nexport const R2PathLike = {\n  [Symbol.hasInstance](instance: unknown): instance is R2PathLike {\n    return instance instanceof R2Path\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport class R2Path extends R2Shape implements Debug {\n  constructor(splines: readonly R2Spline[]) {\n    super();\n    this.splines = splines;\n    this.boundingBox = null;\n    this.pathString = void 0;\n  }\n\n  override likeType?(like: string): void;\n\n  readonly splines: readonly R2Spline[];\n\n  override isDefined(): boolean {\n    return this.splines.length !== 0;\n  }\n\n  override get xMin(): number {\n    return this.bounds.xMin;\n  }\n\n  override get yMin(): number {\n    return this.bounds.yMin;\n  }\n\n  override get xMax(): number {\n    return this.bounds.xMax;\n  }\n\n  override get yMax(): number {\n    return this.bounds.yMax;\n  }\n\n  interpolateX(u: number): number {\n    const splines = this.splines;\n    const n = splines.length;\n    if (n === 0) {\n      return NaN;\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n);\n    const v = u * n - k * l;\n    return splines[k]!.interpolateX(v);\n  }\n\n  interpolateY(u: number): number {\n    const splines = this.splines;\n    const n = splines.length;\n    if (n === 0) {\n      return NaN;\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n);\n    const v = u * n - k * l;\n    return splines[k]!.interpolateY(v);\n  }\n\n  interpolate(u: number): R2Point {\n    const splines = this.splines;\n    const n = splines.length;\n    if (n === 0) {\n      return R2Point.undefined();\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n);\n    const v = u * n - k * l;\n    return splines[k]!.interpolate(v);\n  }\n\n  override contains(that: R2ShapeLike): boolean;\n  override contains(x: number, y: number): boolean;\n  override contains(that: R2ShapeLike | number, y?: number): boolean {\n    return false; // TODO\n  }\n\n  override intersects(that: R2ShapeLike): boolean {\n    return false; // TODO\n  }\n\n  split(u: number): [R2Path, R2Path] {\n    const splines = this.splines;\n    const n = splines.length;\n    if (n === 0) {\n      return [R2Path.empty(), R2Path.empty()];\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n);\n    const v = u * n - k * l;\n    const [s0, s1] = splines[k]!.split(v);\n    const splines0 = new Array<R2Spline>(k + 1);\n    const splines1 = new Array<R2Spline>(n - k);\n    for (let i = 0; i < k; i += 1) {\n      splines0[i] = splines[i]!;\n    }\n    splines0[k] = s0;\n    splines1[0] = s1;\n    for (let i = k + 1; i < n; i += 1) {\n      splines1[i - k] = splines[i]!;\n    }\n    return [new R2Path(splines0), new R2Path(splines1)];\n  }\n\n  subdivide(u: number): R2Path {\n    const oldSplines = this.splines;\n    const n = oldSplines.length;\n    if (n === 0) {\n      return R2Path.empty();\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n);\n    const v = u * n - k * l;\n    const newSplines = new Array<R2Spline>(n);\n    for (let i = 0; i < k; i += 1) {\n      newSplines[i] = oldSplines[i]!;\n    }\n    newSplines[k] = oldSplines[k]!.subdivide(v);\n    for (let i = k + 1; i < n; i += 1) {\n      newSplines[i] = oldSplines[i]!;\n    }\n    return new R2Path(newSplines);\n  }\n\n  override transform(f: R2Function): R2Path {\n    const oldSplines = this.splines;\n    const n = oldSplines.length;\n    if (n === 0) {\n      return R2Path.empty();\n    }\n    const newSplines = new Array<R2Spline>(n);\n    for (let i = 0; i < n; i += 1) {\n      newSplines[i] = oldSplines[i]!.transform(f);\n    }\n    return new R2Path(newSplines);\n  }\n\n  /** @internal */\n  readonly boundingBox: R2Box | null;\n\n  override get bounds(): R2Box {\n    let boundingBox = this.boundingBox;\n    if (boundingBox === null) {\n      let xMin = Infinity;\n      let yMin = Infinity;\n      let xMax = -Infinity;\n      let yMax = -Infinity;\n      const splines = this.splines;\n      for (let i = 0; i < splines.length; i += 1) {\n        const spline = splines[i]!;\n        xMin = Math.min(xMin, spline.xMin);\n        yMin = Math.min(yMin, spline.yMin);\n        xMax = Math.max(spline.xMax, xMax);\n        yMax = Math.max(spline.yMax, yMax);\n      }\n      boundingBox = new R2Box(xMin, yMin, xMax, yMax);\n      (this as Mutable<this>).boundingBox = boundingBox;\n    }\n    return boundingBox;\n  }\n\n  draw(context: R2PathContext): void {\n    const splines = this.splines;\n    for (let i = 0; i < splines.length; i += 1) {\n      splines[i]!.draw(context);\n    }\n  }\n\n  transformDraw(context: R2PathContext, f: R2Function): void {\n    const splines = this.splines;\n    for (let i = 0; i < splines.length; i += 1) {\n      splines[i]!.transformDraw(context, f);\n    }\n  }\n\n  writePath<T>(output: Output<T>): Output<T> {\n    const splines = this.splines;\n    const n = splines.length;\n    if (output.settings === OutputSettings.standard()) {\n      for (let i = 0; i < n; i += 1) {\n        output = output.write(splines[i]!.toPathString()); // write memoized subpath strings\n      }\n    } else {\n      for (let i = 0; i < n; i += 1) {\n        output = splines[i]!.writePath(output);\n      }\n    }\n    return output;\n  }\n\n  /** @internal */\n  readonly pathString: string | undefined;\n\n  toPathString(outputSettings?: OutputSettingsLike): string {\n    let pathString: string | undefined;\n    if (outputSettings !== void 0 || (pathString = this.pathString, pathString === void 0)) {\n      const output = Unicode.stringOutput(outputSettings);\n      this.writePath(output);\n      pathString = output.bind();\n      if (outputSettings === void 0) {\n        (this as Mutable<this>).pathString = pathString;\n      }\n    }\n    return pathString;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2Path) {\n      return Arrays.equivalent(this.splines, that.splines, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2Path) {\n      return Arrays.equal(this.splines, that.splines);\n    }\n    return false;\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    const splines = this.splines;\n    const n = splines.length;\n    output = output.write(\"R2Path\").write(46/*'.'*/);\n    if (n === 0) {\n      output = output.write(\"empty\").write(40/*'('*/);\n    } else if (n === 1) {\n      const spline = splines[0]!;\n      output = output.write(spline.closed ? \"closed\" : \"open\").write(40/*'('*/);\n      const curves = spline.curves;\n      const m = curves.length;\n      if (m !== 0) {\n        output = output.debug(curves[0]!);\n        for (let i = 1; i < m; i += 1) {\n          output = output.write(\", \").debug(curves[i]!);\n        }\n      }\n    } else {\n      output = output.write(\"of\").write(40/*'('*/);\n      output = output.debug(splines[0]!);\n      for (let i = 1; i < n; i += 1) {\n        output = output.write(\", \").debug(splines[i]!);\n      }\n    }\n    output = output.write(41/*')'*/);\n    return output;\n  }\n\n  toAttributeString(): string {\n    return this.toPathString();\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n\n  static builder(): R2PathBuilder {\n    return new R2PathBuilder();\n  }\n\n  @Lazy\n  static empty(): R2Path {\n    return new R2Path(Arrays.empty());\n  }\n\n  static of(...splines: R2Spline[]): R2Path {\n    return new R2Path(splines);\n  }\n\n  static open(...curves: R2Curve[]): R2Path {\n    return new R2Path([new R2Spline(curves, false)]);\n  }\n\n  static closed(...curves: R2Curve[]): R2Path {\n    return new R2Path([new R2Spline(curves, true)]);\n  }\n\n  static override fromLike<T extends R2PathLike | null | undefined>(value: T): R2Path | Uninitable<T>;\n  static override fromLike<T extends R2ShapeLike | null | undefined>(value: T): R2Path | never;\n  static override fromLike<T extends R2PathLike | null | undefined>(value: T): R2Path | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof R2Path) {\n      return value as R2Path | Uninitable<T>;\n    } else if (typeof value === \"string\") {\n      return R2Path.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static parse(string: string): R2Path {\n    let input = Unicode.stringInput(string);\n    while (input.isCont() && Unicode.isWhitespace(input.head())) {\n      input = input.step();\n    }\n    let parser = R2PathParser.parse(input);\n    if (parser.isDone()) {\n      while (input.isCont() && Unicode.isWhitespace(input.head())) {\n        input = input.step();\n      }\n    }\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n}\n\n/** @public */\nexport class R2PathBuilder implements R2PathContext {\n  /** @internal */\n  splines: R2Spline[];\n  /** @internal */\n  builder: R2SplineBuilder | null;\n\n  constructor() {\n    this.splines = [];\n    this.builder = null;\n  }\n\n  moveTo(x: number, y: number): void {\n    let builder = this.builder;\n    if (builder !== null) {\n      const spline = builder.build();\n      if (spline.isDefined()) {\n        this.splines.push(spline);\n      }\n    }\n    builder = new R2SplineBuilder();\n    this.builder = builder;\n    builder.moveTo(x, y);\n  }\n\n  closePath(): void {\n    const builder = this.builder;\n    if (builder !== null) {\n      builder.closePath();\n    } else {\n      throw new Error();\n    }\n  }\n\n  lineTo(x: number, y: number): void {\n    const builder = this.builder;\n    if (builder !== null) {\n      builder.lineTo(x, y);\n    } else {\n      throw new Error();\n    }\n  }\n\n  quadraticCurveTo(x1: number, y1: number, x: number, y: number): void {\n    const builder = this.builder;\n    if (builder !== null) {\n      builder.quadraticCurveTo(x1, y1, x, y);\n    } else {\n      throw new Error();\n    }\n  }\n\n  bezierCurveTo(x1: number, y1: number, x2: number, y2: number, x: number, y: number): void {\n    const builder = this.builder;\n    if (builder !== null) {\n      builder.bezierCurveTo(x1, y1, x2, y2, x, y);\n    } else {\n      throw new Error();\n    }\n  }\n\n  arcTo(x1: number, y1: number, x2: number, y2: number, r: number): void {\n    const builder = this.builder;\n    if (builder !== null) {\n      builder.arcTo(x1, y1, x2, y2, r);\n    } else {\n      throw new Error();\n    }\n  }\n\n  arc(cx: number, cy: number, r: number, a0: number, a1: number, ccw?: boolean): void {\n    const builder = this.builder;\n    if (builder !== null) {\n      builder.arc(cx, cy, r, a0, a1, ccw);\n    } else {\n      throw new Error();\n    }\n  }\n\n  ellipse(cx: number, cy: number, rx: number, ry: number, phi: number, a0: number, a1: number, ccw?: boolean): void {\n    const builder = this.builder;\n    if (builder !== null) {\n      builder.ellipse(cx, cy, rx, ry, phi, a0, a1, ccw);\n    } else {\n      throw new Error();\n    }\n  }\n\n  rect(x: number, y: number, w: number, h: number): void {\n    const builder = this.builder;\n    if (builder !== null) {\n      builder.rect(x, y, w, h);\n    } else {\n      throw new Error();\n    }\n  }\n\n  build(): R2Path {\n    const splines = this.splines.slice(0);\n    const builder = this.builder;\n    if (builder !== null) {\n      const spline = builder.build();\n      if (spline.isDefined()) {\n        splines.push(spline);\n      }\n    }\n    return new R2Path(splines);\n  }\n}\n\n/** @internal */\nexport class R2PathParser extends Parser<R2Path> {\n  private readonly splineParser: Parser<R2Spline> | undefined;\n  private readonly splines: R2Spline[] | undefined;\n  private readonly step: number | undefined;\n\n  constructor(splineParser?: Parser<R2Spline>, splines?: R2Spline[], step?: number) {\n    super();\n    this.splineParser = splineParser;\n    this.splines = splines;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<R2Path> {\n    return R2PathParser.parse(input, this.splineParser, this.splines, this.step);\n  }\n\n  static parse(input: Input, splineParser?: Parser<R2Spline>,\n               splines?: R2Spline[], step: number = 1): Parser<R2Path> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (splineParser === void 0) {\n          while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n            input = input.step();\n          }\n          if (input.isCont()) {\n            switch (c) {\n              case 77/*'M'*/:\n                splineParser = R2SplineParser.parse(input);\n                break;\n              case 109/*'m'*/: {\n                let xParser: Parser<number> | undefined;\n                let yParser: Parser<number> | undefined;\n                if (splines !== void 0 && splines.length !== 0) {\n                  const spline = splines[splines.length - 1]!;\n                  xParser = Parser.done(spline.interpolateX(1));\n                  yParser = Parser.done(spline.interpolateY(1));\n                }\n                splineParser = R2SplineParser.parse(input, xParser, yParser);\n                break;\n              }\n              case 110/*'n'*/:\n                step = 2;\n                break;\n              default:\n                if (splines !== void 0) {\n                  return Parser.done(new R2Path(splines));\n                } else {\n                  return Parser.done(R2Path.empty());\n                }\n            }\n          } else if (!input.isEmpty()) {\n            if (splines !== void 0) {\n              return Parser.done(new R2Path(splines));\n            } else {\n              return Parser.done(R2Path.empty());\n            }\n          }\n        } else {\n          splineParser = splineParser.feed(input);\n        }\n        if (splineParser !== void 0) {\n          if (splineParser.isDone()) {\n            const spline = splineParser.bind();\n            splineParser = void 0;\n            if (spline.isDefined()) {\n              if (splines === void 0) {\n                splines = [];\n              }\n              splines.push(spline);\n            }\n            continue;\n          } else if (splineParser.isError()) {\n            return splineParser.asError();\n          }\n        }\n      }\n      break;\n    } while (true);\n    if (step >= 2 && step <= 5) {\n      do {\n        if (input.isCont()) {\n          if (input.head() === \"none\".charCodeAt(step - 2)) {\n            input = input.step();\n            if (step < 5) {\n              step += 1;\n              continue;\n            } else {\n              return Parser.done(R2Path.empty());\n            }\n          } else {\n            return Parser.error(Diagnostic.expected(\"none\", input));\n          }\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.unexpected(input));\n        }\n        break;\n      } while (true);\n    }\n    return new R2PathParser(splineParser, splines, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Equivalent} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport type {Interpolate} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport type {R2Function} from \"./R2Function\";\nimport type {R2ShapeLike} from \"./R2Shape\";\nimport {R2Shape} from \"./R2Shape\";\nimport {R2Point} from \"./R2Point\";\nimport {R2Segment} from \"./R2Segment\";\nimport {R2Box} from \"./R2Box\";\n\n/** @public */\nexport type R2CircleLike = R2Circle | R2CircleInit;\n\n/** @public */\nexport const R2CircleLike = {\n  [Symbol.hasInstance](instance: unknown): instance is R2CircleLike {\n    return instance instanceof R2Circle\n        || R2CircleInit[Symbol.hasInstance](instance);\n  },\n};\n\n/** @public */\nexport interface R2CircleInit {\n  /** @internal */\n  readonly typeid?: \"R2CircleInit\";\n  cx: number;\n  cy: number;\n  r: number;\n}\n\n/** @public */\nexport const R2CircleInit = {\n  [Symbol.hasInstance](instance: unknown): instance is R2CircleInit {\n    return Objects.hasAllKeys<R2CircleInit>(instance, \"cx\", \"cy\", \"r\");\n  },\n};\n\n/** @public */\nexport class R2Circle extends R2Shape implements Interpolate<R2Circle>, HashCode, Equivalent, Debug {\n  constructor(cx: number, cy: number, r: number) {\n    super();\n    this.cx = cx;\n    this.cy = cy;\n    this.r = r;\n  }\n\n  /** @internal */\n  declare readonly typeid?: \"R2Circle\";\n\n  override likeType?(like: R2CircleInit): void;\n\n  override isDefined(): boolean {\n    return isFinite(this.cx) && isFinite(this.cy) && isFinite(this.r);\n  }\n\n  readonly cx: number;\n\n  readonly cy: number;\n\n  readonly r: number;\n\n  override get xMin(): number {\n    return this.cx - this.r;\n  }\n\n  override get yMin(): number {\n    return this.cy - this.r;\n  }\n\n  override get xMax(): number {\n    return this.cx + this.r;\n  }\n\n  override get yMax(): number {\n    return this.cy + this.r;\n  }\n\n  override contains(that: R2ShapeLike): boolean;\n  override contains(x: number, y: number): boolean;\n  override contains(that: R2ShapeLike | number, y?: number): boolean {\n    if (typeof that === \"number\") {\n      const dx = that - this.cx;\n      const dy = y! - this.cy;\n      return dx * dx + dy * dy <= this.r * this.r;\n    }\n    that = R2Shape.fromLike(that);\n    if (that instanceof R2Point) {\n      return this.containsPoint(that);\n    } else if (that instanceof R2Segment) {\n      return this.containsSegment(that);\n    } else if (that instanceof R2Box) {\n      return this.containsBox(that);\n    } else if (that instanceof R2Circle) {\n      return this.containsCircle(that);\n    }\n    return false;\n  }\n\n  /** @internal */\n  containsPoint(that: R2Point): boolean {\n    const dx = that.x - this.cx;\n    const dy = that.y - this.cy;\n    return dx * dx + dy * dy <= this.r * this.r;\n  }\n\n  /** @internal */\n  containsSegment(that: R2Segment): boolean {\n    const dx0 = that.x0 - this.cx;\n    const dy0 = that.y0 - this.cy;\n    const dx1 = that.x1 - this.cx;\n    const dy1 = that.y1 - this.cy;\n    const r2 = this.r * this.r;\n    return dx0 * dx0 + dy0 * dy0 <= r2\n        && dx1 * dx1 + dy1 * dy1 <= r2;\n  }\n\n  /** @internal */\n  containsBox(that: R2Box): boolean {\n    const dxMin = that.xMin - this.cx;\n    const dyMin = that.yMin - this.cy;\n    const dxMax = that.xMax - this.cx;\n    const dyMax = that.yMax - this.cy;\n    const r2 = this.r * this.r;\n    return dxMin * dxMin + dyMin * dyMin <= r2\n        && dxMin * dxMin + dyMax * dyMax <= r2\n        && dxMax * dxMax + dyMin * dyMin <= r2\n        && dxMax * dxMax + dyMax * dyMax <= r2;\n  }\n\n  /** @internal */\n  containsCircle(that: R2Circle): boolean {\n    const dx = that.cx - this.cx;\n    const dy = that.cy - this.cy;\n    return dx * dx + dy * dy + that.r * that.r <= this.r * this.r;\n  }\n\n  override intersects(that: R2ShapeLike): boolean {\n    that = R2Shape.fromLike(that);\n    if (that instanceof R2Point) {\n      return this.intersectsPoint(that);\n    } else if (that instanceof R2Segment) {\n      return this.intersectsSegment(that);\n    } else if (that instanceof R2Box) {\n      return this.intersectsBox(that);\n    } else if (that instanceof R2Circle) {\n      return this.intersectsCircle(that);\n    }\n    return that.intersects(this);\n  }\n\n  /** @internal */\n  intersectsPoint(that: R2Point): boolean {\n    const dx = that.x - this.cx;\n    const dy = that.y - this.cy;\n    return dx * dx + dy * dy <= this.r * this.r;\n  }\n\n  /** @internal */\n  intersectsSegment(that: R2Segment): boolean {\n    const cx = this.cx;\n    const cy = this.cy;\n    const r = this.r;\n    const x0 = that.x0;\n    const y0 = that.y0;\n    const x1 = that.x1;\n    const y1 = that.y1;\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    const l = Math.sqrt(dx * dx + dy * dy);\n    const unitX = dx / l;\n    const unitY = dy / l;\n    const d = (cx - x0) * unitY - (cy - y0) * unitX;\n    if (d < -r || r < d) {\n      return false;\n    }\n    const dcx0 = x0 - cx;\n    const dcy0 = y0 - cy;\n    const dcx1 = x1 - cx;\n    const dcy1 = y1 - cy;\n    const r2 = r * r;\n    if (dcx0 * dcx0 + dcy0 * dcy0 <= r2 || dcx1 * dcx1 + dcy1 * dcy1 <= r2) {\n      return true;\n    }\n    const uc = unitX * cx + unitY * cy;\n    const u0 = unitX * x0 + unitY * y0;\n    const u1 = unitX * x1 + unitY * y1;\n    return u0 < uc && uc <= u1 || u1 < uc && uc <= u0;\n  }\n\n  /** @internal */\n  intersectsBox(that: R2Box): boolean {\n    const dx = (this.cx < that.xMin ? that.xMin : that.xMax < this.cx ? that.xMax : this.cx) - this.cx;\n    const dy = (this.cy < that.yMin ? that.yMin : that.yMax < this.cy ? that.yMax : this.cy) - this.cy;\n    return dx * dx + dy * dy <= this.r * this.r;\n  }\n\n  /** @internal */\n  intersectsCircle(that: R2Circle): boolean {\n    const dx = that.cx - this.cx;\n    const dy = that.cy - this.cy;\n    const rr = this.r + that.r;\n    return dx * dx + dy * dy <= rr * rr;\n  }\n\n  override transform(f: R2Function): R2Circle {\n    const cx = f.transformX(this.cx, this.cy);\n    const cy = f.transformY(this.cx, this.cy);\n    const rx = f.transformX(this.cx + this.r, this.cy);\n    const ry = f.transformY(this.cx + this.r, this.cy);\n    const dx = rx - cx;\n    const dy = ry - cy;\n    const r = Math.sqrt(dx * dx + dy * dy);\n    return new R2Circle(cx, cy, r);\n  }\n\n  toLike(): R2CircleInit {\n    return {\n      cx: this.cx,\n      cy: this.cy,\n      r: this.r,\n    };\n  }\n\n  /** @override */\n  interpolateTo(that: R2Circle): Interpolator<R2Circle>;\n  interpolateTo(that: unknown): Interpolator<R2Circle> | null;\n  interpolateTo(that: unknown): Interpolator<R2Circle> | null {\n    if (that instanceof R2Circle) {\n      return R2CircleInterpolator(this, that);\n    }\n    return null;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2Circle) {\n      return Numbers.equivalent(this.cx, that.cx, epsilon)\n          && Numbers.equivalent(this.cy, that.cy, epsilon)\n          && Numbers.equivalent(this.r, that.r, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2Circle) {\n      return this.cx === that.cx && this.cy === that.cy && this.r === that.r;\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Constructors.hash(R2Circle),\n        Numbers.hash(this.cx)), Numbers.hash(this.cy)), Numbers.hash(this.r)));\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"R2Circle\").write(46/*'.'*/).write(\"of\").write(40/*'('*/)\n                   .debug(this.cx).write(\", \").debug(this.cy).write(\", \")\n                   .debug(this.r).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n\n  static of(cx: number, cy: number, r: number): R2Circle {\n    return new R2Circle(cx, cy, r);\n  }\n\n  static override fromLike<T extends R2CircleLike | null | undefined>(value: T): R2Circle | Uninitable<T>;\n  static override fromLike<T extends R2ShapeLike | null | undefined>(value: T): never;\n  static override fromLike<T extends R2CircleLike | null | undefined>(value: T): R2Circle | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof R2Circle) {\n      return value as R2Circle | Uninitable<T>;\n    } else if (R2CircleInit[Symbol.hasInstance](value)) {\n      return R2Circle.fromInit(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromInit(init: R2CircleInit): R2Circle {\n    return new R2Circle(init.cx, init.cy, init.r);\n  }\n}\n\n/** @internal */\nexport const R2CircleInterpolator = (function (_super: typeof Interpolator) {\n  const R2CircleInterpolator = function (s0: R2Circle, s1: R2Circle): Interpolator<R2Circle> {\n    const interpolator = function (u: number): R2Circle {\n      const s0 = interpolator[0];\n      const s1 = interpolator[1];\n      const cx = s0.cx + u * (s1.cx - s0.cx);\n      const cy = s0.cy + u * (s1.cy - s0.cy);\n      const r = s0.r + u * (s1.r - s0.r);\n      return new R2Circle(cx, cy, r);\n    } as Interpolator<R2Circle>;\n    Object.setPrototypeOf(interpolator, R2CircleInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = s0;\n    (interpolator as Mutable<typeof interpolator>)[1] = s1;\n    return interpolator;\n  } as {\n    (s0: R2Circle, s1: R2Circle): Interpolator<R2Circle>;\n\n    /** @internal */\n    prototype: Interpolator<R2Circle>;\n  };\n\n  R2CircleInterpolator.prototype = Object.create(_super.prototype);\n  R2CircleInterpolator.prototype.constructor = R2CircleInterpolator;\n\n  return R2CircleInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport type {Interpolate} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport type {R2Function} from \"./R2Function\";\nimport type {R2ShapeLike} from \"./R2Shape\";\nimport {R2Shape} from \"./R2Shape\";\nimport {R2Point} from \"./R2Point\";\nimport {R2Segment} from \"./R2Segment\";\nimport {R2Circle} from \"./R2Circle\";\n\n/** @public */\nexport type R2BoxLike = R2Box | R2BoxInit;\n\n/** @public */\nexport const R2BoxLike = {\n  [Symbol.hasInstance](instance: unknown): instance is R2BoxLike {\n    return instance instanceof R2Box\n        || R2BoxInit[Symbol.hasInstance](instance);\n  },\n};\n\n/** @public */\nexport interface R2BoxInit {\n  /** @internal */\n  readonly typeid?: \"R2BoxInit\";\n  xMin: number;\n  yMin: number;\n  xMax: number;\n  yMax: number;\n}\n\n/** @public */\nexport const R2BoxInit = {\n  [Symbol.hasInstance](instance: unknown): instance is R2BoxInit {\n    return Objects.hasAllKeys<R2BoxInit>(instance, \"xMin\", \"yMin\", \"xMax\", \"yMax\");\n  },\n};\n\n/** @public */\nexport class R2Box extends R2Shape implements Interpolate<R2Box>, HashCode, Debug {\n  constructor(xMin: number, yMin: number, xMax: number, yMax: number) {\n    super();\n    this.xMin = xMin;\n    this.yMin = yMin;\n    this.xMax = xMax;\n    this.yMax = yMax;\n  }\n\n  /** @internal */\n  declare readonly typeid?: \"R2Box\";\n\n  override likeType?(like: R2BoxInit): void;\n\n  override isDefined(): boolean {\n    return isFinite(this.xMin) && isFinite(this.yMin)\n        && isFinite(this.xMax) && isFinite(this.yMax);\n  }\n\n  override readonly xMin: number;\n\n  override readonly yMin: number;\n\n  override readonly xMax: number;\n\n  override readonly yMax: number;\n\n  get x(): number {\n    return this.xMin;\n  }\n\n  get y(): number {\n    return this.yMin;\n  }\n\n  get width(): number {\n    return this.xMax - this.xMin;\n  }\n\n  get height(): number {\n    return this.yMax - this.yMin;\n  }\n\n  get top(): number {\n    return this.yMin;\n  }\n\n  get right(): number {\n    return this.xMax;\n  }\n\n  get bottom(): number {\n    return this.yMax;\n  }\n\n  get left(): number {\n    return this.xMin;\n  }\n\n  get center(): R2Point {\n    return new R2Point((this.xMin + this.xMax) / 2, (this.yMin + this.yMax) / 2);\n  }\n\n  override contains(that: R2ShapeLike): boolean;\n  override contains(x: number, y: number): boolean;\n  override contains(that: R2ShapeLike | number, y?: number): boolean {\n    if (typeof that === \"number\") {\n      return this.xMin <= that && that <= this.xMax\n          && this.yMin <= y! && y! <= this.yMax;\n    }\n    that = R2Shape.fromLike(that);\n    if (that instanceof R2Point) {\n      return this.containsPoint(that);\n    } else if (that instanceof R2Segment) {\n      return this.containsSegment(that);\n    } else if (that instanceof R2Box) {\n      return this.containsBox(that);\n    } else if (that instanceof R2Circle) {\n      return this.containsCircle(that);\n    } else if (that instanceof R2Shape) {\n      return this.xMin <= that.xMin && that.xMax <= this.xMax\n          && this.yMin <= that.yMin && that.yMax <= this.yMax;\n    }\n    return false;\n  }\n\n  /** @internal */\n  containsPoint(that: R2Point): boolean {\n    return this.xMin <= that.x && that.x <= this.xMax\n        && this.yMin <= that.y && that.y <= this.yMax;\n  }\n\n  /** @internal */\n  containsSegment(that: R2Segment): boolean {\n    return this.xMin <= that.x0 && that.x0 <= this.xMax\n        && this.yMin <= that.y0 && that.y0 <= this.yMax\n        && this.xMin <= that.x1 && that.x1 <= this.xMax\n        && this.yMin <= that.y1 && that.y1 <= this.yMax;\n  }\n\n  /** @internal */\n  containsBox(that: R2Box): boolean {\n    return this.xMin <= that.xMin && that.xMax <= this.xMax\n        && this.yMin <= that.yMin && that.yMax <= this.yMax;\n  }\n\n  /** @internal */\n  containsCircle(that: R2Circle): boolean {\n    return this.xMin <= that.cx - that.r && that.cx + that.r <= this.xMax\n        && this.yMin <= that.cy - that.r && that.cy + that.r <= this.yMax;\n  }\n\n  override intersects(that: R2ShapeLike): boolean {\n    that = R2Shape.fromLike(that);\n    if (that instanceof R2Point) {\n      return this.intersectsPoint(that);\n    } else if (that instanceof R2Segment) {\n      return this.intersectsSegment(that);\n    } else if (that instanceof R2Box) {\n      return this.intersectsBox(that);\n    } else if (that instanceof R2Circle) {\n      return this.intersectsCircle(that);\n    }\n    return that.intersects(this);\n  }\n\n  /** @internal */\n  intersectsPoint(that: R2Point): boolean {\n    return this.xMin <= that.x && that.x <= this.xMax\n        && this.yMin <= that.y && that.y <= this.yMax;\n  }\n\n  /** @internal */\n  intersectsSegment(that: R2Segment): boolean {\n    const xMin = this.xMin;\n    const yMin = this.yMin;\n    const xMax = this.xMax;\n    const yMax = this.yMax;\n    const x0 = that.x0;\n    const y0 = that.y0;\n    const x1 = that.x1;\n    const y1 = that.y1;\n    if (x0 < xMin && x1 < xMin || x0 > xMax && x1 > xMax ||\n        y0 < yMin && y1 < yMin || y0 > yMax && y1 > yMax) {\n      return false;\n    } else if (x0 > xMin && x0 < xMax && y0 > yMin && y0 < yMax) {\n      return true;\n    } else if ((R2Box.intersectsSegment(x0 - xMin, x1 - xMin, x0, y0, x1, y1) && R2Box.hitY > yMin && R2Box.hitY < yMax)\n            || (R2Box.intersectsSegment(y0 - yMin, y1 - yMin, x0, y0, x1, y1) && R2Box.hitX > xMin && R2Box.hitX < xMax)\n            || (R2Box.intersectsSegment(x0 - xMax, x1 - xMax, x0, y0, x1, y1) && R2Box.hitY > yMin && R2Box.hitY < yMax)\n            || (R2Box.intersectsSegment(y0 - yMax, y1 - yMax, x0, y0, x1, y1) && R2Box.hitX > xMin && R2Box.hitX < xMax)) {\n      return true;\n    }\n    return false;\n  }\n\n  /** @internal */\n  static hitX: number = 0; // stack local hit register\n  /** @internal */\n  static hitY: number = 0; // stack local hit register\n  static intersectsSegment(d0: number, d1: number, x0: number, y0: number, x1: number, y1: number): boolean {\n    if (d0 === d1 && d0 * d1 >= 0) {\n      return false;\n    }\n    const scale = -d0 / (d1 - d0);\n    R2Box.hitX = x0 + (x1 - x0) * scale;\n    R2Box.hitY = y0 + (y1 - y0) * scale;\n    return true;\n  }\n\n  /** @internal */\n  intersectsBox(that: R2Box): boolean {\n    return this.xMin <= that.xMax && that.xMin <= this.xMax\n        && this.yMin <= that.yMax && that.yMin <= this.yMax;\n  }\n\n  /** @internal */\n  intersectsCircle(that: R2Circle): boolean {\n    const dx = (that.cx < this.xMin ? this.xMin : this.xMax < that.cx ? this.xMax : that.cx) - that.cx;\n    const dy = (that.cy < this.yMin ? this.yMin : this.yMax < that.cy ? this.yMax : that.cy) - that.cy;\n    return dx * dx + dy * dy <= that.r * that.r;\n  }\n\n  override union(that: R2ShapeLike): R2Box {\n    return super.union(that) as R2Box;\n  }\n\n  override transform(f: R2Function): R2Box {\n    return new R2Box(f.transformX(this.xMin, this.yMin), f.transformY(this.xMin, this.yMin),\n                     f.transformX(this.xMax, this.yMax), f.transformY(this.xMax, this.yMax));\n  }\n\n  override get bounds(): R2Box {\n    return this;\n  }\n\n  toLike(): R2BoxInit {\n    return {\n      xMin: this.xMin,\n      yMin: this.yMin,\n      xMax: this.xMax,\n      yMax: this.yMax,\n    };\n  }\n\n  /** @override */\n  interpolateTo(that: R2Box): Interpolator<R2Box>;\n  interpolateTo(that: unknown): Interpolator<R2Box> | null;\n  interpolateTo(that: unknown): Interpolator<R2Box> | null {\n    if (that instanceof R2Box) {\n      return R2BoxInterpolator(this, that);\n    }\n    return null;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2Box) {\n      return Numbers.equivalent(this.xMin, that.xMin, epsilon)\n          && Numbers.equivalent(this.yMin, that.yMin, epsilon)\n          && Numbers.equivalent(this.xMax, that.xMax, epsilon)\n          && Numbers.equivalent(this.yMax, that.yMax, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2Box) {\n      return this.xMin === that.xMin && this.yMin === that.yMin\n          && this.xMax === that.xMax && this.yMax === that.yMax;\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(\n        Constructors.hash(R2Box), Numbers.hash(this.xMin)), Numbers.hash(this.yMin)),\n        Numbers.hash(this.xMax)), Numbers.hash(this.yMax)));\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"R2Box\").write(46/*'.'*/).write(\"of\").write(40/*'('*/)\n                   .debug(this.xMin).write(\", \").debug(this.yMin).write(\", \")\n                   .debug(this.xMax).write(\", \").debug(this.yMax).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n\n  @Lazy\n  static undefined(): R2Box {\n    return new R2Box(Infinity, Infinity, -Infinity, -Infinity);\n  }\n\n  static of(xMin: number, yMin: number, xMax?: number, yMax?: number): R2Box {\n    if (xMax === void 0) {\n      xMax = xMin;\n    }\n    if (yMax === void 0) {\n      yMax = yMin;\n    }\n    return new R2Box(xMin, yMin, xMax, yMax);\n  }\n\n  static override fromLike<T extends R2BoxLike | null | undefined>(value: T): R2Box | Uninitable<T>;\n  static override fromLike<T extends R2ShapeLike | null | undefined>(value: T): never;\n  static override fromLike<T extends R2BoxLike | null | undefined>(value: T): R2Box | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof R2Box) {\n      return value as R2Box | Uninitable<T>;\n    } else if (R2BoxInit[Symbol.hasInstance](value)) {\n      return R2Box.fromInit(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromInit(init: R2BoxInit): R2Box {\n    return new R2Box(init.xMin, init.yMin, init.xMax, init.yMax);\n  }\n}\n\n/** @internal */\nexport const R2BoxInterpolator = (function (_super: typeof Interpolator) {\n  const R2BoxInterpolator = function (s0: R2Box, s1: R2Box): Interpolator<R2Box> {\n    const interpolator = function (u: number): R2Box {\n      const s0 = interpolator[0];\n      const s1 = interpolator[1];\n      const xMin = s0.xMin + u * (s1.xMin - s0.xMin);\n      const yMin = s0.yMin + u * (s1.yMin - s0.yMin);\n      const xMax = s0.xMax + u * (s1.xMax - s0.xMax);\n      const yMax = s0.yMax + u * (s1.yMax - s0.yMax);\n      return new R2Box(xMin, yMin, xMax, yMax);\n    } as Interpolator<R2Box>;\n    Object.setPrototypeOf(interpolator, R2BoxInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = s0;\n    (interpolator as Mutable<typeof interpolator>)[1] = s1;\n    return interpolator;\n  } as {\n    (s0: R2Box, s1: R2Box): Interpolator<R2Box>;\n\n    /** @internal */\n    prototype: Interpolator<R2Box>;\n  };\n\n  R2BoxInterpolator.prototype = Object.create(_super.prototype);\n  R2BoxInterpolator.prototype.constructor = R2BoxInterpolator;\n\n  return R2BoxInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport {Arrays} from \"@swim/util\";\nimport type {Equals} from \"@swim/util\";\nimport type {Equivalent} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport type {R2Function} from \"./R2Function\";\nimport type {R2ShapeLike} from \"./R2Shape\";\nimport {R2Shape} from \"./R2Shape\";\nimport {R2Box} from \"./R2Box\";\n\n/** @public */\nexport class R2Group<S extends R2Shape = R2Shape> extends R2Shape implements Equals, Equivalent, Debug {\n  constructor(shapes: readonly S[]) {\n    super();\n    this.shapes = shapes;\n    this.boundingBox = null;\n  }\n\n  readonly shapes: readonly S[];\n\n  override isDefined(): boolean {\n    return this.shapes.length !== 0;\n  }\n\n  override get xMin(): number {\n    return this.bounds.xMin;\n  }\n\n  override get yMin(): number {\n    return this.bounds.yMin;\n  }\n\n  override get xMax(): number {\n    return this.bounds.xMax;\n  }\n\n  override get yMax(): number {\n    return this.bounds.yMax;\n  }\n\n  override contains(that: R2ShapeLike): boolean;\n  override contains(x: number, y: number): boolean;\n  override contains(that: R2ShapeLike | number, y?: number): boolean {\n    return false; // TODO\n  }\n\n  override intersects(that: R2ShapeLike): boolean {\n    return false; // TODO\n  }\n\n  override transform(f: R2Function): R2Group {\n    const oldShapes = this.shapes;\n    const n = oldShapes.length;\n    if (n === 0) {\n      return R2Group.empty();\n    }\n    const newShapes = new Array<R2Shape>(n);\n    for (let i = 0; i < n; i += 1) {\n      newShapes[i] = oldShapes[i]!.transform(f);\n    }\n    return new R2Group(newShapes);\n  }\n\n  /** @internal */\n  readonly boundingBox: R2Box | null;\n\n  override get bounds(): R2Box {\n    let boundingBox = this.boundingBox;\n    if (boundingBox === null) {\n      let xMin = Infinity;\n      let yMin = Infinity;\n      let xMax = -Infinity;\n      let yMax = -Infinity;\n      const shapes = this.shapes;\n      for (let i = 0; i < shapes.length; i += 1) {\n        const shape = shapes[i]!;\n        xMin = Math.min(xMin, shape.xMin);\n        yMin = Math.min(yMin, shape.yMin);\n        xMax = Math.max(shape.xMax, xMax);\n        yMax = Math.max(shape.yMax, yMax);\n      }\n      boundingBox = new R2Box(xMin, yMin, xMax, yMax);\n      (this as Mutable<this>).boundingBox = boundingBox;\n    }\n    return boundingBox;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2Group) {\n      return Arrays.equivalent(this.shapes, that.shapes, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof R2Group) {\n      return Arrays.equal(this.shapes, that.shapes);\n    }\n    return false;\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    const shapes = this.shapes;\n    const n = shapes.length;\n    output = output.write(\"R2Group\").write(46/*'.'*/);\n    if (n === 0) {\n      output = output.write(\"empty\").write(40/*'('*/);\n    } else {\n      output = output.write(\"of\").write(40/*'('*/);\n      output = output.debug(shapes[0]!);\n      for (let i = 1; i < n; i += 1) {\n        output = output.write(\", \").debug(shapes[i]!);\n      }\n    }\n    output = output.write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n\n  @Lazy\n  static empty<S extends R2Shape>(): R2Group<S> {\n    return new R2Group(Arrays.empty());\n  }\n\n  static of<S extends R2Shape>(...shapes: S[]): R2Group<S> {\n    return new R2Group(shapes);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Equivalent} from \"@swim/util\";\nimport type {Interpolate} from \"@swim/util\";\nimport type {Interpolator} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport type {Item} from \"@swim/structure\";\nimport type {Value} from \"@swim/structure\";\nimport {Record} from \"@swim/structure\";\nimport {Form} from \"@swim/structure\";\nimport type {LengthLike} from \"./Length\";\nimport {Length} from \"./Length\";\nimport {PxLength} from \"./Length\";\nimport type {AngleLike} from \"./Angle\";\nimport {Angle} from \"./Angle\";\nimport {DegAngle} from \"./Angle\";\nimport type {R2Operator} from \"./R2Function\";\nimport type {R2Point} from \"./R2Point\";\nimport {IdentityTransform} from \"./\"; // forward import\nimport {TranslateTransform} from \"./\"; // forward import\nimport {TranslateTransformParser} from \"./\"; // forward import\nimport {ScaleTransform} from \"./\"; // forward import\nimport {ScaleTransformParser} from \"./\"; // forward import\nimport {RotateTransform} from \"./\"; // forward import\nimport {RotateTransformParser} from \"./\"; // forward import\nimport {SkewTransform} from \"./\"; // forward import\nimport {SkewTransformParser} from \"./\"; // forward import\nimport {AffineTransform} from \"./\"; // forward import\nimport {AffineTransformInterpolator} from \"./\"; // forward import\nimport {AffineTransformParser} from \"./\"; // forward import\nimport {TransformList} from \"./\"; // forward import\nimport {TransformListParser} from \"./\"; // forward import\n\n/** @public */\nexport type TransformLike = Transform | string;\n\n/** @public */\nexport const TransformLike = {\n  [Symbol.hasInstance](instance: unknown): instance is TransformLike {\n    return instance instanceof Transform\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport abstract class Transform implements R2Operator, Interpolate<Transform>, HashCode, Equivalent, Debug {\n  likeType?(like: string): void;\n\n  abstract transform(that: Transform): Transform;\n  abstract transform(x: number, y: number): R2Point;\n\n  abstract transformX(x: number, y: number): number;\n\n  abstract transformY(x: number, y: number): number;\n\n  abstract inverse(): Transform;\n\n  translate(x: LengthLike, y: LengthLike): Transform {\n    return this.transform(Transform.translate(x, y));\n  }\n\n  translateX(x: LengthLike): Transform {\n    return this.transform(Transform.translateX(x));\n  }\n\n  translateY(y: LengthLike): Transform {\n    return this.transform(Transform.translateY(y));\n  }\n\n  scale(x: number, y: number): Transform {\n    return this.transform(Transform.scale(x, y));\n  }\n\n  scaleX(x: number): Transform {\n    return this.transform(Transform.scaleX(x));\n  }\n\n  scaleY(y: number): Transform {\n    return this.transform(Transform.scaleY(y));\n  }\n\n  rotate(a: AngleLike): Transform {\n    return this.transform(Transform.rotate(a));\n  }\n\n  skew(x: AngleLike, y: AngleLike): Transform {\n    return this.transform(Transform.skew(x, y));\n  }\n\n  skewX(x: AngleLike): Transform {\n    return this.transform(Transform.skewX(x));\n  }\n\n  skewY(y: AngleLike): Transform {\n    return this.transform(Transform.skewY(y));\n  }\n\n  abstract toAffine(): AffineTransform;\n\n  toMatrix(): DOMMatrix {\n    return this.toAffine().toMatrix();\n  }\n\n  toCssTransformComponent(): CSSTransformComponent | null {\n    return null;\n  }\n\n  toCssValue(): CSSStyleValue | null {\n    if (typeof CSSTransformValue === \"undefined\") {\n      return null;\n    }\n    const component = this.toCssTransformComponent();\n    if (component === null) {\n      return null;\n    }\n    return new CSSTransformValue([component]);\n  }\n\n  abstract toValue(): Value;\n\n  /** @override */\n  interpolateTo(that: Transform): Interpolator<Transform>;\n  interpolateTo(that: unknown): Interpolator<Transform> | null;\n  interpolateTo(that: unknown): Interpolator<Transform> | null {\n    if (that instanceof Transform) {\n      return AffineTransformInterpolator(this.toAffine(), that.toAffine());\n    }\n    return null;\n  }\n\n  abstract conformsTo(that: Transform): boolean;\n\n  /** @override */\n  abstract equivalentTo(that: unknown, epsilon?: number): boolean;\n\n  /** @override */\n  abstract equals(that: unknown): boolean;\n\n  /** @override */\n  abstract hashCode(): number;\n\n  /** @override */\n  abstract debug<T>(output: Output<T>): Output<T>;\n\n  /** @override */\n  abstract toString(): string;\n\n  toAttributeString(): string {\n    return this.toString();\n  }\n\n  @Lazy\n  static identity(): Transform {\n    return new IdentityTransform();\n  }\n\n  static translate(x: LengthLike, y: LengthLike): TranslateTransform {\n    x = Length.fromLike(x);\n    y = Length.fromLike(y);\n    return new TranslateTransform(x, y);\n  }\n\n  static translateX(x: LengthLike): TranslateTransform {\n    x = Length.fromLike(x);\n    return new TranslateTransform(x, PxLength.zero());\n  }\n\n  static translateY(y: LengthLike): TranslateTransform {\n    y = Length.fromLike(y);\n    return new TranslateTransform(PxLength.zero(), y);\n  }\n\n  static scale(x: number, y: number): ScaleTransform {\n    return new ScaleTransform(x, y);\n  }\n\n  static scaleX(x: number): ScaleTransform {\n    return new ScaleTransform(x, 1);\n  }\n\n  static scaleY(y: number): ScaleTransform {\n    return new ScaleTransform(1, y);\n  }\n\n  static rotate(a: AngleLike): RotateTransform {\n    a = Angle.fromLike(a, \"deg\");\n    return new RotateTransform(a);\n  }\n\n  static skew(x: AngleLike, y: AngleLike): SkewTransform {\n    x = Angle.fromLike(x, \"deg\");\n    y = Angle.fromLike(y, \"deg\");\n    return new SkewTransform(x, y);\n  }\n\n  static skewX(x: AngleLike): SkewTransform {\n    x = Angle.fromLike(x, \"deg\");\n    return new SkewTransform(x, DegAngle.zero());\n  }\n\n  static skewY(y: AngleLike): SkewTransform {\n    y = Angle.fromLike(y, \"deg\");\n    return new SkewTransform(DegAngle.zero(), y);\n  }\n\n  static affine(x0: number = 1, y0: number = 0,\n                x1: number = 0, y1: number = 1,\n                tx: number = 0, ty: number = 0): AffineTransform {\n    return new AffineTransform(x0, y0, x1, y1, tx, ty);\n  }\n\n  static list(...transforms: TransformLike[]): TransformList {\n    const list: Transform[] = [];\n    for (let i = 0; i < transforms.length; i += 1) {\n      const transform = Transform.fromLike(transforms[i]!);\n      if (transform instanceof TransformList) {\n        list.push(...transform.transforms);\n      } else if (!(transform instanceof IdentityTransform)) {\n        list.push(transform);\n      }\n    }\n    return new TransformList(list);\n  }\n\n  static fromCssValue(value: CSSStyleValue): Transform {\n    if (value instanceof CSSTransformValue) {\n      return Transform.fromCssTransform(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  /** @internal */\n  static fromCssTransform(value: CSSTransformValue): Transform {\n    const n = value.length;\n    if (n === 1) {\n      return Transform.fromCssTransformComponent(value[0]!);\n    }\n    const transforms = new Array<Transform>(n);\n    for (let i = 0; i < n; i += 1) {\n      transforms[i] = Transform.fromCssTransformComponent(value[i]!);\n    }\n    return new TransformList(transforms);\n  }\n\n  static fromCssTransformComponent(component: CSSTransformComponent): Transform {\n    if (component instanceof CSSTranslate) {\n      return TranslateTransform.fromCssTransformComponent(component);\n    } else if (component instanceof CSSRotate) {\n      return RotateTransform.fromCssTransformComponent(component);\n    } else if (component instanceof CSSScale) {\n      return ScaleTransform.fromCssTransformComponent(component);\n    } else if (component instanceof CSSSkew) {\n      return SkewTransform.fromCssTransformComponent(component);\n    } else if (component instanceof CSSMatrixComponent) {\n      return AffineTransform.fromCssTransformComponent(component);\n    }\n    throw new TypeError(\"\" + component);\n  }\n\n  static fromLike<T extends TransformLike | null | undefined>(value: T): Transform | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof Transform) {\n      return value as Transform | Uninitable<T>;\n    } else if (typeof value === \"string\") {\n      return Transform.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromValue(value: Value): Transform | null {\n    const tag = value.tag;\n    switch (tag) {\n      case \"identity\": return IdentityTransform.fromValue(value);\n      case \"translate\": return TranslateTransform.fromValue(value);\n      case \"scale\": return ScaleTransform.fromValue(value);\n      case \"rotate\": return RotateTransform.fromValue(value);\n      case \"skew\": return SkewTransform.fromValue(value);\n      case \"matrix\": return AffineTransform.fromValue(value);\n      default: return TransformList.fromValue(value);\n    }\n  }\n\n  static parse(string: string): Transform {\n    let input = Unicode.stringInput(string);\n    while (input.isCont() && Unicode.isWhitespace(input.head())) {\n      input = input.step();\n    }\n    let parser = TransformListParser.parse(input);\n    if (parser.isDone()) {\n      while (input.isCont() && Unicode.isWhitespace(input.head())) {\n        input = input.step();\n      }\n    }\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n\n  @Lazy\n  static form(): Form<Transform, TransformLike> {\n    return new TransformForm(Transform.identity());\n  }\n}\n\n/** @internal */\nexport class TransformForm extends Form<Transform, TransformLike> {\n  constructor(unit: Transform | undefined) {\n    super();\n    Object.defineProperty(this, \"unit\", {\n      value: unit,\n      enumerable: true,\n      configurable: true,\n    });\n  }\n\n  override readonly unit: Transform | undefined;\n\n  override withUnit(unit: Transform | undefined): Form<Transform, TransformLike> {\n    if (unit === this.unit) {\n      return this;\n    }\n    return new TransformForm(unit);\n  }\n\n  override mold(transform: TransformLike): Item {\n    transform = Transform.fromLike(transform);\n    return transform.toValue();\n  }\n\n  override cast(item: Item): Transform | undefined {\n    const value = item.toValue();\n    try {\n      if (value instanceof Record) {\n        const transform = Transform.fromValue(value);\n        return transform !== null ? transform : void 0;\n      } else {\n        const string = value.stringValue(void 0);\n        if (string !== void 0) {\n          return Transform.parse(string);\n        }\n      }\n    } catch (e) {\n      // swallow\n    }\n    return void 0;\n  }\n}\n\n/** @internal */\nexport class TransformParser extends Parser<Transform> {\n  private readonly identOutput: Output<string> | undefined;\n\n  constructor(identOutput?: Output<string>) {\n    super();\n    this.identOutput = identOutput;\n  }\n\n  override feed(input: Input): Parser<Transform> {\n    return TransformParser.parse(input, this.identOutput);\n  }\n\n  static parse(input: Input, identOutput?: Output<string>): Parser<Transform> {\n    let c = 0;\n    identOutput = identOutput || Unicode.stringOutput();\n    while (input.isCont() && (c = input.head(), Unicode.isAlpha(c) || Unicode.isDigit(c) || c === 45/*'-'*/)) {\n      input = input.step();\n      identOutput.write(c);\n    }\n    if (!input.isEmpty()) {\n      const ident = identOutput.bind();\n      switch (ident) {\n        case \"translate3d\":\n        case \"translateX\":\n        case \"translateY\":\n        case \"translate\": return TranslateTransformParser.parseRest(input, identOutput);\n        case \"scaleX\":\n        case \"scaleY\":\n        case \"scale\": return ScaleTransformParser.parseRest(input, identOutput);\n        case \"rotate\": return RotateTransformParser.parseRest(input, identOutput);\n        case \"skewX\":\n        case \"skewY\":\n        case \"skew\": return SkewTransformParser.parseRest(input, identOutput);\n        case \"matrix\": return AffineTransformParser.parseRest(input, identOutput);\n        case \"none\": return Parser.done(Transform.identity());\n        default: return Parser.error(Diagnostic.message(\"unknown transform function: \" + ident, input));\n      }\n    }\n    return new TransformParser(identOutput);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Constructors} from \"@swim/util\";\nimport type {Interpolator} from \"@swim/util\";\nimport {IdentityInterpolator} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Value} from \"@swim/structure\";\nimport {Record} from \"@swim/structure\";\nimport {R2Point} from \"./R2Point\";\nimport {Transform} from \"./Transform\";\nimport {AffineTransform} from \"./\"; // forward import\n\n/** @public */\nexport class IdentityTransform extends Transform {\n  override transform(that: Transform): Transform;\n  override transform(x: number, y: number): R2Point;\n  override transform(x: Transform | number, y?: number): Transform | R2Point {\n    if (arguments.length === 2) {\n      return new R2Point(x as number, y!);\n    } else if (x instanceof Transform) {\n      return x;\n    }\n    throw new TypeError(\"\" + x);\n  }\n\n  override transformX(x: number, y: number): number {\n    return x;\n  }\n\n  override transformY(x: number, y: number): number {\n    return y;\n  }\n\n  override inverse(): Transform {\n    return this;\n  }\n\n  override toAffine(): AffineTransform {\n    return new AffineTransform(1, 0, 0, 1, 0, 0);\n  }\n\n  override toCssValue(): CSSStyleValue | null {\n    return new CSSKeywordValue(\"identity\");\n  }\n\n  override toValue(): Value {\n    return Record.create(1).attr(\"identity\");\n  }\n\n  override interpolateTo(that: IdentityTransform): Interpolator<IdentityTransform>;\n  override interpolateTo(that: Transform): Interpolator<Transform>;\n  override interpolateTo(that: unknown): Interpolator<Transform> | null;\n  override interpolateTo(that: unknown): Interpolator<Transform> | null {\n    if (that instanceof IdentityTransform) {\n      return IdentityInterpolator(this);\n    }\n    return super.interpolateTo(that);\n  }\n\n  override conformsTo(that: Transform): boolean {\n    return that instanceof IdentityTransform;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    return that instanceof IdentityTransform;\n  }\n\n  override equals(that: unknown): boolean {\n    return that instanceof IdentityTransform;\n  }\n\n  override hashCode(): number {\n    return Constructors.hash(IdentityTransform);\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Transform\").write(46/*'.'*/).write(\"identity\")\n                   .write(40/*'('*/).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return \"none\";\n  }\n\n  static override fromValue(value: Value): IdentityTransform | null {\n    if (value.tag === \"identity\") {\n      return Transform.identity();\n    }\n    return null;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport type {Item} from \"@swim/structure\";\nimport {Value} from \"@swim/structure\";\nimport {Record} from \"@swim/structure\";\nimport {Length} from \"./Length\";\nimport {PxLength} from \"./Length\";\nimport {LengthParser} from \"./Length\";\nimport {R2Point} from \"./R2Point\";\nimport type {TransformLike} from \"./Transform\";\nimport {Transform} from \"./Transform\";\nimport {IdentityTransform} from \"./IdentityTransform\";\nimport {AffineTransform} from \"./\"; // forward import\n\n/** @public */\nexport type TranslateTransformLike = TranslateTransform | string;\n\n/** @public */\nexport const TranslateTransformLike = {\n  [Symbol.hasInstance](instance: unknown): instance is TranslateTransformLike {\n    return instance instanceof TranslateTransform\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport class TranslateTransform extends Transform {\n  constructor(x: Length, y: Length) {\n    super();\n    this.x = x;\n    this.y = y;\n    this.stringValue = void 0;\n  }\n\n  readonly x: Length;\n\n  readonly y: Length;\n\n  override transform(that: Transform): Transform;\n  override transform(x: number, y: number): R2Point;\n  override transform(x: Transform | number, y?: number): Transform | R2Point {\n    if (arguments.length === 2) {\n      return new R2Point(this.x.pxValue() + (x as number), this.y.pxValue() + y!);\n    } else if (x instanceof IdentityTransform) {\n      return this;\n    } else if (x instanceof TranslateTransform) {\n      return new TranslateTransform(this.x.plus(x.x), this.y.plus(x.y));\n    } else if (x instanceof Transform) {\n      return Transform.list(this, x);\n    }\n    throw new TypeError(\"\" + x);\n  }\n\n  override transformX(x: number, y: number): number {\n    return this.x.pxValue() + x;\n  }\n\n  override transformY(x: number, y: number): number {\n    return this.y.pxValue() + y;\n  }\n\n  override inverse(): Transform {\n    return new TranslateTransform(this.x.negative(), this.y.negative());\n  }\n\n  override toAffine(): AffineTransform {\n    return new AffineTransform(1, 0, 0, 1, this.x.pxValue(), this.y.pxValue());\n  }\n\n  override toCssTransformComponent(): CSSTransformComponent | null {\n    if (typeof CSSTranslate === \"undefined\") {\n      return null;\n    }\n    return new CSSTranslate(this.x.toCssValue()!, this.y.toCssValue()!);\n  }\n\n  override toValue(): Value {\n    return Record.create(1)\n                 .attr(\"translate\", Record.create(2).slot(\"x\", this.x.toValue())\n                                                    .slot(\"y\", this.y.toValue()));\n  }\n\n  override interpolateTo(that: TranslateTransform): Interpolator<TranslateTransform>;\n  override interpolateTo(that: Transform): Interpolator<Transform>;\n  override interpolateTo(that: unknown): Interpolator<Transform> | null;\n  override interpolateTo(that: unknown): Interpolator<Transform> | null {\n    if (that instanceof TranslateTransform) {\n      return TranslateTransformInterpolator(this, that);\n    }\n    return super.interpolateTo(that);\n  }\n\n  override conformsTo(that: Transform): boolean {\n    return that instanceof TranslateTransform;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (that instanceof TranslateTransform) {\n      return this.x.equivalentTo(that.x, epsilon)\n          && this.y.equivalentTo(that.y, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (that instanceof TranslateTransform) {\n      return this.x.equals(that.x) && this.y.equals(that.y);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(TranslateTransform),\n        this.x.hashCode()), this.y.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Transform\").write(46/*'.'*/).write(\"translate\");\n    if (this.x.isDefined() && !this.y.isDefined()) {\n      output = output.write(\"X\").write(40/*'('*/).debug(this.x);\n    } else if (!this.x.isDefined() && this.y.isDefined()) {\n      output = output.write(\"Y\").write(40/*'('*/).debug(this.y);\n    } else {\n      output = output.write(40/*'('*/).debug(this.x).write(\", \").debug(this.y);\n    }\n    output = output.write(41/*')'*/);\n    return output;\n  }\n\n  /** @internal */\n  readonly stringValue: string | undefined;\n\n  override toString(): string {\n    let stringValue = this.stringValue;\n    if (stringValue === void 0) {\n      if (this.x.isDefined() && !this.y.isDefined()) {\n        stringValue = \"translate(\" + this.x + \",0)\";\n      } else if (!this.x.isDefined() && this.y.isDefined()) {\n        stringValue = \"translate(0,\" + this.y + \")\";\n      } else {\n        stringValue = \"translate(\" + this.x + \",\" + this.y + \")\";\n      }\n      (this as Mutable<this>).stringValue = stringValue;\n    }\n    return stringValue;\n  }\n\n  override toAttributeString(): string {\n    if (this.x.isDefined() && !this.y.isDefined()) {\n      return \"translate(\" + this.x.pxValue() + \",0)\";\n    } else if (!this.x.isDefined() && this.y.isDefined()) {\n      return \"translate(0,\" + this.y.pxValue() + \")\";\n    }\n    return \"translate(\" + this.x.pxValue() + \",\" + this.y.pxValue() + \")\";\n  }\n\n  static override fromCssTransformComponent(component: CSSTranslate): TranslateTransform {\n    const x = typeof component.x === \"number\"\n            ? Length.px(component.x)\n            : Length.fromCssValue(component.x);\n    const y = typeof component.y === \"number\"\n            ? Length.px(component.y)\n            : Length.fromCssValue(component.y);\n    return new TranslateTransform(x, y);\n  }\n\n  static override fromLike<T extends TranslateTransformLike | null | undefined>(value: T): TranslateTransform | Uninitable<T>;\n  static override fromLike<T extends TransformLike | null | undefined>(value: T): never;\n  static override fromLike<T extends TranslateTransformLike | null | undefined>(value: T): TranslateTransform | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof TranslateTransform) {\n      return value as TranslateTransform | Uninitable<T>;\n    } else if (typeof value === \"string\") {\n      return TranslateTransform.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static override fromValue(value: Value): TranslateTransform | null {\n    const header = value.header(\"translate\");\n    if (!header.isDefined()) {\n      return null;\n    }\n    let x = Length.zero();\n    let y = Length.zero();\n    header.forEach(function (item: Item, index: number) {\n      const key = item.key.stringValue();\n      if (key !== void 0) {\n        if (key === \"x\") {\n          x = item.toValue().cast(Length.form(), x);\n        } else if (key === \"y\") {\n          y = item.toValue().cast(Length.form(), y);\n        }\n      } else if (item instanceof Value) {\n        if (index === 0) {\n          x = item.cast(Length.form(), x);\n        } else if (index === 1) {\n          y = item.cast(Length.form(), y);\n        }\n      }\n    }, this);\n    return new TranslateTransform(x, y);\n  }\n\n  static override parse(string: string): TranslateTransform {\n    let input = Unicode.stringInput(string);\n    while (input.isCont() && Unicode.isWhitespace(input.head())) {\n      input = input.step();\n    }\n    let parser = TranslateTransformParser.parse(input);\n    if (parser.isDone()) {\n      while (input.isCont() && Unicode.isWhitespace(input.head())) {\n        input = input.step();\n      }\n    }\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n}\n\n/** @internal */\nexport const TranslateTransformInterpolator = (function (_super: typeof Interpolator) {\n  const TranslateTransformInterpolator = function (f0: TranslateTransform, f1: TranslateTransform): Interpolator<TranslateTransform> {\n    const interpolator = function (u: number): TranslateTransform {\n      const f0 = interpolator[0];\n      const f1 = interpolator[1];\n      const x = Length.of(f0.x.value + u * (f1.x.value - f0.x.value), f1.x.units);\n      const y = Length.of(f0.y.value + u * (f1.y.value - f0.y.value), f1.y.units);\n      return new TranslateTransform(x, y);\n    } as Interpolator<TranslateTransform>;\n    Object.setPrototypeOf(interpolator, TranslateTransformInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = f0.x.units === f1.x.units && f0.y.units === f1.y.units\n                                                      ? f0 : new TranslateTransform(f0.x.to(f1.x.units), f0.y.to(f1.y.units));\n    (interpolator as Mutable<typeof interpolator>)[1] = f1;\n    return interpolator;\n  } as {\n    (f0: TranslateTransform, f1: TranslateTransform): Interpolator<TranslateTransform>;\n\n    /** @internal */\n    prototype: Interpolator<TranslateTransform>;\n  };\n\n  TranslateTransformInterpolator.prototype = Object.create(_super.prototype);\n  TranslateTransformInterpolator.prototype.constructor = TranslateTransformInterpolator;\n\n  return TranslateTransformInterpolator;\n})(Interpolator);\n\n/** @internal */\nexport class TranslateTransformParser extends Parser<TranslateTransform> {\n  private readonly identOutput: Output<string> | undefined;\n  private readonly xParser: Parser<Length> | undefined;\n  private readonly yParser: Parser<Length> | undefined;\n  private readonly zParser: Parser<Length> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(identOutput?: Output<string>, xParser?: Parser<Length>,\n              yParser?: Parser<Length>, zParser?: Parser<Length>, step?: number) {\n    super();\n    this.identOutput = identOutput;\n    this.xParser = xParser;\n    this.yParser = yParser;\n    this.zParser = zParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<TranslateTransform> {\n    return TranslateTransformParser.parse(input, this.identOutput, this.xParser,\n                                          this.yParser, this.zParser, this.step);\n  }\n\n  static parse(input: Input, identOutput?: Output<string>, xParser?: Parser<Length>,\n               yParser?: Parser<Length>, zParser?: Parser<Length>,\n               step: number = 1): Parser<TranslateTransform> {\n    let c = 0;\n    if (step === 1) {\n      identOutput = identOutput || Unicode.stringOutput();\n      while (input.isCont() && (c = input.head(), Unicode.isAlpha(c) || Unicode.isDigit(c) || c === 45/*'-'*/)) {\n        input = input.step();\n        identOutput.write(c);\n      }\n      if (!input.isEmpty()) {\n        const ident = identOutput.bind();\n        switch (ident) {\n          case \"translate3d\":\n          case \"translateX\":\n          case \"translateY\":\n          case \"translate\": step = 2; break;\n          default: return Parser.error(Diagnostic.message(\"unknown transform function: \" + ident, input));\n        }\n      }\n    }\n    if (step === 2) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont() && c === 40/*'('*/) {\n        input.step();\n        step = 3;\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.expected(\"(\", input));\n      }\n    }\n    if (step === 3) {\n      if (xParser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input.step();\n        }\n        if (!input.isEmpty()) {\n          xParser = LengthParser.parse(input, \"px\");\n        }\n      } else {\n        xParser = xParser.feed(input);\n      }\n      if (xParser !== void 0) {\n        if (xParser.isDone()) {\n          step = 4;\n        } else if (xParser.isError()) {\n          return xParser.asError();\n        }\n      }\n    }\n    if (step === 4) {\n      while (input.isCont() && Unicode.isSpace(input.head())) {\n        input.step();\n      }\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 41/*')'*/) {\n          input.step();\n          const ident = identOutput!.bind();\n          switch (ident) {\n            case \"translateX\": return Parser.done(new TranslateTransform(xParser!.bind(), PxLength.zero()));\n            case \"translateY\": return Parser.done(new TranslateTransform(PxLength.zero(), xParser!.bind()));\n            default: return Parser.error(Diagnostic.message(\"unknown transform function: \" + ident, input));\n          }\n        } else if (c === 44/*','*/) {\n          input.step();\n          step = 5;\n        } else {\n          return Parser.error(Diagnostic.expected(\",\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 5) {\n      if (yParser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input.step();\n        }\n        if (!input.isEmpty()) {\n          yParser = LengthParser.parse(input, \"px\");\n        }\n      } else {\n        yParser = yParser.feed(input);\n      }\n      if (yParser !== void 0) {\n        if (yParser.isDone()) {\n          step = 6;\n        } else if (yParser.isError()) {\n          return yParser.asError();\n        }\n      }\n    }\n    if (step === 6) {\n      while (input.isCont() && Unicode.isSpace(input.head())) {\n        input.step();\n      }\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 41/*')'*/) {\n          input.step();\n          const ident = identOutput!.bind();\n          switch (ident) {\n            case \"translate\": return Parser.done(new TranslateTransform(xParser!.bind(), yParser!.bind()));\n            default: return Parser.error(Diagnostic.message(\"unknown transform function: \" + ident, input));\n          }\n        } else if (c === 44/*','*/) {\n          input.step();\n          step = 7;\n        } else {\n          return Parser.error(Diagnostic.expected(\",\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 7) {\n      if (zParser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input.step();\n        }\n        if (!input.isEmpty()) {\n          zParser = LengthParser.parse(input, \"px\");\n        }\n      } else {\n        zParser = zParser.feed(input);\n      }\n      if (zParser !== void 0) {\n        if (zParser.isDone()) {\n          step = 8;\n        } else if (zParser.isError()) {\n          return zParser.asError();\n        }\n      }\n    }\n    if (step === 8) {\n      while (input.isCont() && Unicode.isSpace(input.head())) {\n        input.step();\n      }\n      if (input.isCont() && input.head() === 41/*')'*/) {\n        input.step();\n        const ident = identOutput!.bind();\n        switch (ident) {\n          case \"translate3d\":\n            if (zParser!.bind().value === 0) {\n              return Parser.done(new TranslateTransform(xParser!.bind(), yParser!.bind()));\n            }\n          default: return Parser.error(Diagnostic.message(\"unknown transform function: \" + ident, input));\n        }\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.expected(\")\", input));\n      }\n    }\n    return new TranslateTransformParser(identOutput, xParser, yParser, zParser, step);\n  }\n\n  /** @internal */\n  static parseRest(input: Input, identOutput?: Output<string>): Parser<TranslateTransform> {\n    return TranslateTransformParser.parse(input, identOutput, void 0, void 0, void 0, 2);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Base10} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport type {Item} from \"@swim/structure\";\nimport {Value} from \"@swim/structure\";\nimport {Record} from \"@swim/structure\";\nimport {R2Point} from \"./R2Point\";\nimport type {TransformLike} from \"./Transform\";\nimport {Transform} from \"./Transform\";\nimport {IdentityTransform} from \"./IdentityTransform\";\nimport {AffineTransform} from \"./\"; // forward import\n\n/** @public */\nexport type ScaleTransformLike = ScaleTransform | string;\n\n/** @public */\nexport const ScaleTransformLike = {\n  [Symbol.hasInstance](instance: unknown): instance is ScaleTransformLike {\n    return instance instanceof ScaleTransform\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport class ScaleTransform extends Transform {\n  constructor(x: number, y: number) {\n    super();\n    this.x = x;\n    this.y = y;\n    this.stringValue = void 0;\n  }\n\n  readonly x: number;\n\n  readonly y: number;\n\n  override transform(that: Transform): Transform;\n  override transform(x: number, y: number): R2Point;\n  override transform(x: Transform | number, y?: number): Transform | R2Point {\n    if (arguments.length === 2) {\n      return new R2Point(this.x * (x as number), this.y * y!);\n    } else if (x instanceof IdentityTransform) {\n      return this;\n    } else if (x instanceof Transform) {\n      return Transform.list(this, x);\n    }\n    throw new TypeError(\"\" + x);\n  }\n\n  override transformX(x: number, y: number): number {\n    return this.x * x;\n  }\n\n  override transformY(x: number, y: number): number {\n    return this.y * y;\n  }\n\n  override inverse(): Transform {\n    return new ScaleTransform(1 / (this.x || 1), 1 / (this.y || 1));\n  }\n\n  toAffine(): AffineTransform {\n    return new AffineTransform(this.x, 0, 0, this.y, 0, 0);\n  }\n\n  override toCssTransformComponent(): CSSTransformComponent | null {\n    if (typeof CSSTranslate === \"undefined\") {\n      return null;\n    }\n    return new CSSScale(this.x, this.y);\n  }\n\n  override toValue(): Value {\n    return Record.create(1)\n                 .attr(\"scale\", Record.create(2).slot(\"x\", this.x)\n                                                .slot(\"y\", this.y));\n  }\n\n  override interpolateTo(that: ScaleTransform): Interpolator<ScaleTransform>;\n  override interpolateTo(that: Transform): Interpolator<Transform>;\n  override interpolateTo(that: unknown): Interpolator<Transform> | null;\n  override interpolateTo(that: unknown): Interpolator<Transform> | null {\n    if (that instanceof ScaleTransform) {\n      return ScaleTransformInterpolator(this, that);\n    }\n    return super.interpolateTo(that);\n  }\n\n  override conformsTo(that: Transform): boolean {\n    return that instanceof ScaleTransform;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (that instanceof ScaleTransform) {\n      return Numbers.equivalent(this.x, that.x, epsilon)\n          && Numbers.equivalent(this.y, that.y, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (that instanceof ScaleTransform) {\n      return this.x === that.x && this.y === that.y;\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(ScaleTransform),\n        Numbers.hash(this.x)), Numbers.hash(this.y)));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Transform\").write(46/*'.'*/).write(\"scale\");\n    if (this.x !== 0 && this.y === 0) {\n      output = output.write(\"X\").write(40/*'('*/).debug(this.x);\n    } else if (this.x === 0 && this.y !== 0) {\n      output = output.write(\"Y\").write(40/*'('*/).debug(this.y);\n    } else {\n      output = output.write(40/*'('*/).debug(this.x).write(\", \").debug(this.y);\n    }\n    output = output.write(41/*')'*/);\n    return output;\n  }\n\n  /** @internal */\n  readonly stringValue: string | undefined;\n\n  override toString(): string {\n    let stringValue = this.stringValue;\n    if (stringValue === void 0) {\n      if (this.x !== 0 && this.y === 0) {\n        stringValue = \"scaleX(\" + this.x + \")\";\n      } else if (this.x === 0 && this.y !== 0) {\n        stringValue = \"scaleY(\" + this.y + \")\";\n      } else {\n        stringValue = \"scale(\" + this.x + \",\" + this.y + \")\";\n      }\n      (this as Mutable<this>).stringValue = stringValue;\n    }\n    return stringValue;\n  }\n\n  static override fromCssTransformComponent(component: CSSScale): ScaleTransform {\n    const x = typeof component.x === \"number\"\n            ? component.x\n            : component.x.to(\"number\").value;\n    const y = typeof component.y === \"number\"\n            ? component.y\n            : component.y.to(\"number\").value;\n    return new ScaleTransform(x, y);\n  }\n\n  static override fromLike<T extends ScaleTransformLike | null | undefined>(value: T): ScaleTransform | Uninitable<T>;\n  static override fromLike<T extends TransformLike | null | undefined>(value: T): never;\n  static override fromLike<T extends ScaleTransformLike | null | undefined>(value: T): ScaleTransform | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof ScaleTransform) {\n      return value as ScaleTransform | Uninitable<T>;\n    } else if (typeof value === \"string\") {\n      return ScaleTransform.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static override fromValue(value: Value): ScaleTransform | null {\n    const header = value.header(\"scale\");\n    if (!header.isDefined()) {\n      return null;\n    }\n    let x = 0;\n    let y = 0;\n    header.forEach(function (item: Item, index: number) {\n      const key = item.key.stringValue();\n      if (key !== void 0) {\n        if (key === \"x\") {\n          x = item.toValue().numberValue(x);\n        } else if (key === \"y\") {\n          y = item.toValue().numberValue(y);\n        }\n      } else if (item instanceof Value) {\n        if (index === 0) {\n          x = item.numberValue(x);\n        } else if (index === 1) {\n          y = item.numberValue(y);\n        }\n      }\n    }, this);\n    return new ScaleTransform(x, y);\n  }\n\n  static override parse(string: string): ScaleTransform {\n    let input = Unicode.stringInput(string);\n    while (input.isCont() && Unicode.isWhitespace(input.head())) {\n      input = input.step();\n    }\n    let parser = ScaleTransformParser.parse(input);\n    if (parser.isDone()) {\n      while (input.isCont() && Unicode.isWhitespace(input.head())) {\n        input = input.step();\n      }\n    }\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n}\n\n/** @internal */\nexport const ScaleTransformInterpolator = (function (_super: typeof Interpolator) {\n  const ScaleTransformInterpolator = function (f0: ScaleTransform, f1: ScaleTransform): Interpolator<ScaleTransform> {\n    const interpolator = function (u: number): ScaleTransform {\n      const f0 = interpolator[0];\n      const f1 = interpolator[1];\n      const x = f0.x + u * (f1.x - f0.x);\n      const y = f0.y + u * (f1.y - f0.y);\n      return new ScaleTransform(x, y);\n    } as Interpolator<ScaleTransform>;\n    Object.setPrototypeOf(interpolator, ScaleTransformInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = f0;\n    (interpolator as Mutable<typeof interpolator>)[1] = f1;\n    return interpolator;\n  } as {\n    (f0: ScaleTransform, f1: ScaleTransform): Interpolator<ScaleTransform>;\n\n    /** @internal */\n    prototype: Interpolator<ScaleTransform>;\n  };\n\n  ScaleTransformInterpolator.prototype = Object.create(_super.prototype);\n  ScaleTransformInterpolator.prototype.constructor = Interpolator;\n\n  return ScaleTransformInterpolator;\n})(Interpolator);\n\n/** @internal */\nexport class ScaleTransformParser extends Parser<ScaleTransform> {\n  private readonly identOutput: Output<string> | undefined;\n  private readonly xParser: Parser<number> | undefined;\n  private readonly yParser: Parser<number> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(identOutput?: Output<string>, xParser?: Parser<number>,\n              yParser?: Parser<number>, step?: number) {\n    super();\n    this.identOutput = identOutput;\n    this.xParser = xParser;\n    this.yParser = yParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<ScaleTransform> {\n    return ScaleTransformParser.parse(input, this.identOutput, this.xParser, this.yParser, this.step);\n  }\n\n  static parse(input: Input, identOutput?: Output<string>, xParser?: Parser<number>,\n               yParser?: Parser<number>, step: number = 1): Parser<ScaleTransform> {\n    let c = 0;\n    if (step === 1) {\n      identOutput = identOutput || Unicode.stringOutput();\n      while (input.isCont() && (c = input.head(), Unicode.isAlpha(c))) {\n        input = input.step();\n        identOutput.write(c);\n      }\n      if (!input.isEmpty()) {\n        const ident = identOutput.bind();\n        switch (ident) {\n          case \"scaleX\":\n          case \"scaleY\":\n          case \"scale\": step = 2; break;\n          default: return Parser.error(Diagnostic.message(\"unknown transform function: \" + ident, input));\n        }\n      }\n    }\n    if (step === 2) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont() && c === 40/*'('*/) {\n        input.step();\n        step = 3;\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.expected(\"(\", input));\n      }\n    }\n    if (step === 3) {\n      if (xParser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input.step();\n        }\n        if (!input.isEmpty()) {\n          xParser = Base10.parseNumber(input);\n        }\n      } else {\n        xParser = xParser.feed(input);\n      }\n      if (xParser !== void 0) {\n        if (xParser!.isDone()) {\n          step = 4;\n        } else if (xParser.isError()) {\n          return xParser.asError();\n        }\n      }\n    }\n    if (step === 4) {\n      while (input.isCont() && Unicode.isSpace(input.head())) {\n        input.step();\n      }\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 41/*')'*/) {\n          input.step();\n          const ident = identOutput!.bind();\n          switch (ident) {\n            case \"scaleX\": return Parser.done(new ScaleTransform(xParser!.bind(), 1));\n            case \"scaleY\": return Parser.done(new ScaleTransform(1, xParser!.bind()));\n            default: return Parser.error(Diagnostic.message(\"unknown transform function: \" + ident, input));\n          }\n        } else if (c === 44/*','*/) {\n          input.step();\n          step = 5;\n        } else {\n          return Parser.error(Diagnostic.expected(\",\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 5) {\n      if (yParser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input.step();\n        }\n        if (!input.isEmpty()) {\n          yParser = Base10.parseNumber(input);\n        }\n      } else {\n        yParser = yParser.feed(input);\n      }\n      if (yParser !== void 0) {\n        if (yParser.isDone()) {\n          step = 6;\n        } else if (yParser.isError()) {\n          return yParser.asError();\n        }\n      }\n    }\n    if (step === 6) {\n      while (input.isCont() && Unicode.isSpace(input.head())) {\n        input.step();\n      }\n      if (input.isCont() && input.head() === 41/*')'*/) {\n        input.step();\n        const ident = identOutput!.bind();\n        switch (ident) {\n          case \"scale\": return Parser.done(new ScaleTransform(xParser!.bind(), yParser!.bind()));\n          default: return Parser.error(Diagnostic.message(\"unknown transform function: \" + ident, input));\n        }\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.expected(\")\", input));\n      }\n    }\n    return new ScaleTransformParser(identOutput, xParser, yParser, step);\n  }\n\n  /** @internal */\n  static parseRest(input: Input, identOutput?: Output<string>): Parser<ScaleTransform> {\n    return ScaleTransformParser.parse(input, identOutput, void 0, void 0, 2);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport type {Item} from \"@swim/structure\";\nimport {Value} from \"@swim/structure\";\nimport {Record} from \"@swim/structure\";\nimport {Angle} from \"./Angle\";\nimport {AngleParser} from \"./Angle\";\nimport {R2Point} from \"./R2Point\";\nimport type {TransformLike} from \"./Transform\";\nimport {Transform} from \"./Transform\";\nimport {IdentityTransform} from \"./IdentityTransform\";\nimport {AffineTransform} from \"./\"; // forward import\n\n/** @public */\nexport type RotateTransformLike = RotateTransform | string;\n\n/** @public */\nexport const RotateTransformLike = {\n  [Symbol.hasInstance](instance: unknown): instance is RotateTransformLike {\n    return instance instanceof RotateTransform\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport class RotateTransform extends Transform {\n  constructor(angle: Angle) {\n    super();\n    this.angle = angle;\n    this.stringValue = void 0;\n  }\n\n  readonly angle: Angle;\n\n  override transform(that: Transform): Transform;\n  override transform(x: number, y: number): R2Point;\n  override transform(x: Transform | number, y?: number): Transform | R2Point {\n    if (arguments.length === 2) {\n      const angle = this.angle.radValue();\n      const cosA = Math.cos(angle);\n      const sinA = Math.sin(angle);\n      return new R2Point((x as number) * cosA - y! * sinA,\n                         (x as number) * sinA + y! * cosA);\n    } else if (x instanceof IdentityTransform) {\n      return this;\n    } else if (x instanceof Transform) {\n      return Transform.list(this, x);\n    }\n    throw new TypeError(\"\" + x);\n  }\n\n  override transformX(x: number, y: number): number {\n    const angle = this.angle.radValue();\n    return x * Math.cos(angle) - y * Math.sin(angle);\n  }\n\n  override transformY(x: number, y: number): number {\n    const angle = this.angle.radValue();\n    return x * Math.sin(angle) + y * Math.cos(angle);\n  }\n\n  override inverse(): Transform {\n    return new RotateTransform(this.angle.negative());\n  }\n\n  override toAffine(): AffineTransform {\n    const angle = this.angle.radValue();\n    return new AffineTransform(Math.cos(angle), Math.sin(angle),\n                              -Math.sin(angle), Math.cos(angle),\n                               0, 0);\n  }\n\n  override toCssTransformComponent(): CSSTransformComponent | null {\n    if (typeof CSSTranslate === \"undefined\") {\n      return null;\n    }\n    return new CSSRotate(this.angle.toCssValue()!);\n  }\n\n  override toValue(): Value {\n    return Record.create(1).attr(\"rotate\", this.angle.toString());\n  }\n\n  override interpolateTo(that: RotateTransform): Interpolator<RotateTransform>;\n  override interpolateTo(that: Transform): Interpolator<Transform>;\n  override interpolateTo(that: unknown): Interpolator<Transform> | null;\n  override interpolateTo(that: unknown): Interpolator<Transform> | null {\n    if (that instanceof RotateTransform) {\n      return RotateTransformInterpolator(this, that);\n    }\n    return super.interpolateTo(that);\n  }\n\n  override conformsTo(that: Transform): boolean {\n    return that instanceof RotateTransform;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (that instanceof RotateTransform) {\n      return this.angle.equivalentTo(that.angle, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (that instanceof RotateTransform) {\n      return this.angle.equals(that.angle);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(RotateTransform), this.angle.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Transform\").write(46/*'.'*/).write(\"rotate\")\n                   .write(40/*'('*/).debug(this.angle).write(41/*')'*/);\n    return output;\n  }\n\n  /** @internal */\n  readonly stringValue: string | undefined;\n\n  override toString(): string {\n    let stringValue = this.stringValue;\n    if (stringValue === void 0) {\n      stringValue = \"rotate(\" + this.angle + \")\";\n      (this as Mutable<this>).stringValue = stringValue;\n    }\n    return stringValue;\n  }\n\n  override toAttributeString(): string {\n    return \"rotate(\" + this.angle.degValue() + \")\";\n  }\n\n  static override fromCssTransformComponent(component: CSSRotate): RotateTransform {\n    const angle = Angle.fromCssValue(component.angle);\n    return new RotateTransform(angle);\n  }\n\n  static override fromLike<T extends RotateTransformLike | null | undefined>(value: T): RotateTransform | Uninitable<T>;\n  static override fromLike<T extends TransformLike | null | undefined>(value: T): never;\n  static override fromLike<T extends RotateTransformLike | null | undefined>(value: T): RotateTransform | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof RotateTransform) {\n      return value as RotateTransform | Uninitable<T>;\n    } else if (typeof value === \"string\") {\n      return RotateTransform.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static override fromValue(value: Value): RotateTransform | null {\n    const header = value.header(\"rotate\");\n    if (!header.isDefined()) {\n      return null;\n    }\n    let angle = Angle.zero();\n    header.forEach(function (item: Item, index: number) {\n      const key = item.key.stringValue();\n      if (key === \"angle\") {\n        angle = item.toValue().cast(Angle.form(), angle);\n      } else if (item instanceof Value && index === 0) {\n        angle = item.cast(Angle.form(), angle);\n      }\n    }, this);\n    return new RotateTransform(angle);\n  }\n\n  static override parse(string: string): RotateTransform {\n    let input = Unicode.stringInput(string);\n    while (input.isCont() && Unicode.isWhitespace(input.head())) {\n      input = input.step();\n    }\n    let parser = RotateTransformParser.parse(input);\n    if (parser.isDone()) {\n      while (input.isCont() && Unicode.isWhitespace(input.head())) {\n        input = input.step();\n      }\n    }\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n}\n\n/** @internal */\nexport const RotateTransformInterpolator = (function (_super: typeof Interpolator) {\n  const RotateTransformInterpolator = function (f0: RotateTransform, f1: RotateTransform): Interpolator<RotateTransform> {\n    const interpolator = function (u: number): RotateTransform {\n      const f0 = interpolator[0];\n      const f1 = interpolator[1];\n      const a = Angle.of(f0.angle.value + u * (f1.angle.value - f0.angle.value), f1.angle.units);\n      return new RotateTransform(a);\n    } as Interpolator<RotateTransform>;\n    Object.setPrototypeOf(interpolator, RotateTransformInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = f0.angle.units === f1.angle.units\n                                                      ? f0 : new RotateTransform(f0.angle.to(f1.angle.units));\n    (interpolator as Mutable<typeof interpolator>)[1] = f1;\n    return interpolator;\n  } as {\n    (f0: RotateTransform, f1: RotateTransform): Interpolator<RotateTransform>;\n\n    /** @internal */\n    prototype: Interpolator<RotateTransform>;\n  };\n\n  RotateTransformInterpolator.prototype = Object.create(_super.prototype);\n  RotateTransformInterpolator.prototype.constructor = RotateTransformInterpolator;\n\n  return RotateTransformInterpolator;\n})(Interpolator);\n\n/** @internal */\nexport class RotateTransformParser extends Parser<RotateTransform> {\n  private readonly identOutput: Output<string> | undefined;\n  private readonly angleParser: Parser<Angle> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(identOutput?: Output<string>, angleParser?: Parser<Angle>, step?: number) {\n    super();\n    this.identOutput = identOutput;\n    this.angleParser = angleParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<RotateTransform> {\n    return RotateTransformParser.parse(input, this.identOutput, this.angleParser, this.step);\n  }\n\n  static parse(input: Input, identOutput?: Output<string>, angleParser?: Parser<Angle>,\n               step: number = 1): Parser<RotateTransform> {\n    let c = 0;\n    if (step === 1) {\n      identOutput = identOutput || Unicode.stringOutput();\n      while (input.isCont() && (c = input.head(), Unicode.isAlpha(c))) {\n        input = input.step();\n        identOutput.write(c);\n      }\n      if (!input.isEmpty()) {\n        const ident = identOutput.bind();\n        switch (ident) {\n          case \"rotate\": step = 2; break;\n          default: return Parser.error(Diagnostic.message(\"unknown transform function: \" + ident, input));\n        }\n      }\n    }\n    if (step === 2) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont() && c === 40/*'('*/) {\n        input.step();\n        step = 3;\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.expected(\"(\", input));\n      }\n    }\n    if (step === 3) {\n      if (angleParser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input.step();\n        }\n        if (!input.isEmpty()) {\n          angleParser = AngleParser.parse(input, \"deg\");\n        }\n      } else {\n        angleParser = angleParser.feed(input);\n      }\n      if (angleParser !== void 0) {\n        if (angleParser.isDone()) {\n          step = 4;\n        } else if (angleParser.isError()) {\n          return angleParser.asError();\n        }\n      }\n    }\n    if (step === 4) {\n      while (input.isCont() && Unicode.isSpace(input.head())) {\n        input.step();\n      }\n      if (input.isCont() && input.head() === 41/*')'*/) {\n        input.step();\n        const ident = identOutput!.bind();\n        switch (ident) {\n          case \"rotate\": return Parser.done(new RotateTransform(angleParser!.bind()));\n          default: return Parser.error(Diagnostic.message(\"unknown transform function: \" + ident, input));\n        }\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.expected(\")\", input));\n      }\n    }\n    return new RotateTransformParser(identOutput, angleParser, step);\n  }\n\n  /** @internal */\n  static parseRest(input: Input, identOutput?: Output<string>): Parser<RotateTransform> {\n    return RotateTransformParser.parse(input, identOutput, void 0, 2);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport type {Item} from \"@swim/structure\";\nimport {Value} from \"@swim/structure\";\nimport {Record} from \"@swim/structure\";\nimport {Angle} from \"./Angle\";\nimport {DegAngle} from \"./Angle\";\nimport {AngleParser} from \"./Angle\";\nimport {R2Point} from \"./R2Point\";\nimport type {TransformLike} from \"./Transform\";\nimport {Transform} from \"./Transform\";\nimport {IdentityTransform} from \"./IdentityTransform\";\nimport {AffineTransform} from \"./\"; // forward import\n\n/** @public */\nexport type SkewTransformLike = SkewTransform | string;\n\n/** @public */\nexport const SkewTransformLike = {\n  [Symbol.hasInstance](instance: unknown): instance is SkewTransformLike {\n    return instance instanceof SkewTransform\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport class SkewTransform extends Transform {\n  constructor(x: Angle, y: Angle) {\n    super();\n    this.x = x;\n    this.y = y;\n    this.stringValue = void 0;\n  }\n\n  readonly x: Angle;\n\n  readonly y: Angle;\n\n  override transform(that: Transform): Transform;\n  override transform(x: number, y: number): R2Point;\n  override transform(x: Transform | number, y?: number): Transform | R2Point {\n    if (arguments.length === 2) {\n      return new R2Point(Math.tan(this.x.radValue()) * y! + (x as number),\n                         Math.tan(this.y.radValue()) * (x as number) + y!);\n    } else if (x instanceof IdentityTransform) {\n      return this;\n    } else if (x instanceof Transform) {\n      return Transform.list(this, x);\n    }\n    throw new TypeError(\"\" + x);\n  }\n\n  override transformX(x: number, y: number): number {\n    return Math.tan(this.x.radValue()) * y + x;\n  }\n\n  override transformY(x: number, y: number): number {\n    return Math.tan(this.y.radValue()) * x + y;\n  }\n\n  override inverse(): Transform {\n    return new SkewTransform(this.x.negative(), this.y.negative());\n  }\n\n  override toAffine(): AffineTransform {\n    const x = this.x.radValue();\n    const y = this.y.radValue();\n    return new AffineTransform(1, Math.tan(y), Math.tan(x), 1, 0, 0);\n  }\n\n  override toCssTransformComponent(): CSSTransformComponent | null {\n    if (typeof CSSTranslate === \"undefined\") {\n      return null;\n    }\n    return new CSSSkew(this.x.toCssValue()!, this.y.toCssValue()!);\n  }\n\n  override toValue(): Value {\n    return Record.create(1)\n                 .attr(\"skew\", Record.create(2).slot(\"x\", this.x.toValue())\n                                               .slot(\"y\", this.y.toValue()));\n  }\n\n  override interpolateTo(that: SkewTransform): Interpolator<SkewTransform>;\n  override interpolateTo(that: Transform): Interpolator<Transform>;\n  override interpolateTo(that: unknown): Interpolator<Transform> | null;\n  override interpolateTo(that: unknown): Interpolator<Transform> | null {\n    if (that instanceof SkewTransform) {\n      return SkewTransformInterpolator(this, that);\n    }\n    return super.interpolateTo(that);\n  }\n\n  override conformsTo(that: Transform): boolean {\n    return that instanceof SkewTransform;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (that instanceof SkewTransform) {\n      return this.x.equivalentTo(that.x, epsilon)\n          && this.y.equivalentTo(that.y, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (that instanceof SkewTransform) {\n      return this.x.equals(that.x) && this.y.equals(that.y);\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(SkewTransform),\n        this.x.hashCode()), this.y.hashCode()));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Transform\").write(46/*'.'*/).write(\"skew\");\n    if (this.x.isDefined() && !this.y.isDefined()) {\n      output = output.write(\"X\").write(40/*'('*/).debug(this.x);\n    } else if (!this.x.isDefined() && this.y.isDefined()) {\n      output = output.write(\"Y\").write(40/*'('*/).debug(this.y);\n    } else {\n      output = output.write(40/*'('*/).debug(this.x).write(\", \").debug(this.y);\n    }\n    output = output.write(41/*')'*/);\n    return output;\n  }\n\n  /** @internal */\n  readonly stringValue: string | undefined;\n\n  override toString(): string {\n    let stringValue = this.stringValue;\n    if (stringValue === void 0) {\n      if (this.x.isDefined() && !this.y.isDefined()) {\n        stringValue = \"skewX(\" + this.x + \")\";\n      } else if (!this.x.isDefined() && this.y.isDefined()) {\n        stringValue = \"skewY(\" + this.y + \")\";\n      } else {\n        stringValue = \"skew(\" + this.x + \",\" + this.y + \")\";\n      }\n      (this as Mutable<this>).stringValue = stringValue;\n    }\n    return stringValue;\n  }\n\n  override toAttributeString(): string {\n    if (this.x.isDefined() && !this.y.isDefined()) {\n      return \"skewX(\" + this.x.degValue() + \")\";\n    } else if (!this.x.isDefined() && this.y.isDefined()) {\n      return \"skewY(\" + this.y.degValue() + \")\";\n    }\n    return \"skew(\" + this.x.degValue() + \",\" + this.y.degValue() + \")\";\n  }\n\n  static override fromCssTransformComponent(component: CSSSkew): SkewTransform {\n    const x = typeof component.ax === \"number\"\n            ? Angle.rad(component.ax)\n            : Angle.fromCssValue(component.ax);\n    const y = typeof component.ay === \"number\"\n            ? Angle.rad(component.ay)\n            : Angle.fromCssValue(component.ay);\n    return new SkewTransform(x, y);\n  }\n\n  static override fromLike<T extends SkewTransformLike | null | undefined>(value: T): SkewTransform | Uninitable<T>;\n  static override fromLike<T extends TransformLike | null | undefined>(value: T): never;\n  static override fromLike<T extends SkewTransformLike | null | undefined>(value: T): SkewTransform | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof SkewTransform) {\n      return value as SkewTransform | Uninitable<T>;\n    } else if (typeof value === \"string\") {\n      return SkewTransform.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static override fromValue(value: Value): SkewTransform | null {\n    const header = value.header(\"skew\");\n    if (!header.isDefined()) {\n      return null;\n    }\n    let x = Angle.zero();\n    let y = Angle.zero();\n    header.forEach(function (item: Item, index: number) {\n      const key = item.key.stringValue();\n      if (key !== void 0) {\n        if (key === \"x\") {\n          x = item.toValue().cast(Angle.form(), x);\n        } else if (key === \"y\") {\n          y = item.toValue().cast(Angle.form(), y);\n        }\n      } else if (item instanceof Value) {\n        if (index === 0) {\n          x = item.cast(Angle.form(), x);\n        } else if (index === 1) {\n          y = item.cast(Angle.form(), y);\n        }\n      }\n    }, this);\n    return new SkewTransform(x, y);\n  }\n\n  static override parse(string: string): SkewTransform {\n    let input = Unicode.stringInput(string);\n    while (input.isCont() && Unicode.isWhitespace(input.head())) {\n      input = input.step();\n    }\n    let parser = SkewTransformParser.parse(input);\n    if (parser.isDone()) {\n      while (input.isCont() && Unicode.isWhitespace(input.head())) {\n        input = input.step();\n      }\n    }\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n}\n\n/** @internal */\nexport const SkewTransformInterpolator = (function (_super: typeof Interpolator) {\n  const SkewTransformInterpolator = function (f0: SkewTransform, f1: SkewTransform): Interpolator<SkewTransform> {\n    const interpolator = function (u: number): SkewTransform {\n      const f0 = interpolator[0];\n      const f1 = interpolator[1];\n      const x = Angle.of(f0.x.value + u * (f1.x.value - f0.x.value), f1.x.units);\n      const y = Angle.of(f0.y.value + u * (f1.y.value - f0.y.value), f1.y.units);\n      return new SkewTransform(x, y);\n    } as Interpolator<SkewTransform>;\n    Object.setPrototypeOf(interpolator, SkewTransformInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = f0.x.units === f1.x.units && f0.y.units === f1.y.units\n                                                      ? f0 : new SkewTransform(f0.x.to(f1.x.units), f0.y.to(f1.y.units));\n    (interpolator as Mutable<typeof interpolator>)[1] = f1;\n    return interpolator;\n  } as {\n    (f0: SkewTransform, f1: SkewTransform): Interpolator<SkewTransform>;\n\n    /** @internal */\n    prototype: Interpolator<SkewTransform>;\n  };\n\n  SkewTransformInterpolator.prototype = Object.create(_super.prototype);\n  SkewTransformInterpolator.prototype.constructor = SkewTransformInterpolator;\n\n  return SkewTransformInterpolator;\n})(Interpolator);\n\n/** @internal */\nexport class SkewTransformParser extends Parser<SkewTransform> {\n  private readonly identOutput: Output<string> | undefined;\n  private readonly xParser: Parser<Angle> | undefined;\n  private readonly yParser: Parser<Angle> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(identOutput?: Output<string>, xParser?: Parser<Angle>,\n              yParser?: Parser<Angle>, step?: number) {\n    super();\n    this.identOutput = identOutput;\n    this.xParser = xParser;\n    this.yParser = yParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<SkewTransform> {\n    return SkewTransformParser.parse(input, this.identOutput, this.xParser, this.yParser, this.step);\n  }\n\n  static parse(input: Input, identOutput?: Output<string>, xParser?: Parser<Angle>,\n               yParser?: Parser<Angle>, step: number = 1): Parser<SkewTransform> {\n    let c = 0;\n    if (step === 1) {\n      identOutput = identOutput || Unicode.stringOutput();\n      while (input.isCont() && (c = input.head(), Unicode.isAlpha(c))) {\n        input = input.step();\n        identOutput.write(c);\n      }\n      if (!input.isEmpty()) {\n        const ident = identOutput.bind();\n        switch (ident) {\n          case \"skewX\":\n          case \"skewY\":\n          case \"skew\": step = 2; break;\n          default: return Parser.error(Diagnostic.message(\"unknown transform function: \" + ident, input));\n        }\n      }\n    }\n    if (step === 2) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont() && c === 40/*'('*/) {\n        input.step();\n        step = 3;\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.expected(\"(\", input));\n      }\n    }\n    if (step === 3) {\n      if (xParser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input.step();\n        }\n        if (!input.isEmpty()) {\n          xParser = AngleParser.parse(input, \"deg\");\n        }\n      } else {\n        xParser = xParser.feed(input);\n      }\n      if (xParser !== void 0) {\n        if (xParser.isDone()) {\n          step = 4;\n        } else if (xParser.isError()) {\n          return xParser.asError();\n        }\n      }\n    }\n    if (step === 4) {\n      while (input.isCont() && Unicode.isSpace(input.head())) {\n        input.step();\n      }\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 41/*')'*/) {\n          input.step();\n          const ident = identOutput!.bind();\n          switch (ident) {\n            case \"skewX\": return Parser.done(new SkewTransform(xParser!.bind(), DegAngle.zero()));\n            case \"skewY\": return Parser.done(new SkewTransform(DegAngle.zero(), xParser!.bind()));\n            default: return Parser.error(Diagnostic.message(\"unknown transform function: \" + ident, input));\n          }\n        } else if (c === 44/*','*/) {\n          input.step();\n          step = 5;\n        } else {\n          return Parser.error(Diagnostic.expected(\",\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 5) {\n      if (yParser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input.step();\n        }\n        if (!input.isEmpty()) {\n          yParser = AngleParser.parse(input, \"deg\");\n        }\n      } else {\n        yParser = yParser.feed(input);\n      }\n      if (yParser !== void 0) {\n        if (yParser.isDone()) {\n          step = 6;\n        } else if (yParser.isError()) {\n          return yParser.asError();\n        }\n      }\n    }\n    if (step === 6) {\n      while (input.isCont() && Unicode.isSpace(input.head())) {\n        input.step();\n      }\n      if (input.isCont() && input.head() === 41/*')'*/) {\n        input.step();\n        const ident = identOutput!.bind();\n        switch (ident) {\n          case \"skew\": return Parser.done(new SkewTransform(xParser!.bind(), yParser!.bind()));\n          default: return Parser.error(Diagnostic.message(\"unknown transform function: \" + ident, input));\n        }\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.expected(\")\", input));\n      }\n    }\n    return new SkewTransformParser(identOutput, xParser, yParser, step);\n  }\n\n  /** @internal */\n  static parseRest(input: Input, identOutput?: Output<string>): Parser<SkewTransform> {\n    return SkewTransformParser.parse(input, identOutput, void 0, void 0, 2);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Base10} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport type {Item} from \"@swim/structure\";\nimport {Value} from \"@swim/structure\";\nimport {Record} from \"@swim/structure\";\nimport {R2Point} from \"./R2Point\";\nimport type {TransformLike} from \"./Transform\";\nimport {Transform} from \"./Transform\";\nimport {IdentityTransform} from \"./IdentityTransform\";\n\n/** @public */\nexport type AffineTransformLike = AffineTransform | string;\n\n/** @public */\nexport const AffineTransformLike = {\n  [Symbol.hasInstance](instance: unknown): instance is AffineTransformLike {\n    return instance instanceof AffineTransform\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport class AffineTransform extends Transform {\n  constructor(x0: number, y0: number, x1: number, y1: number, tx: number, ty: number) {\n    super();\n    this.x0 = x0;\n    this.y0 = y0;\n    this.x1 = x1;\n    this.y1 = y1;\n    this.tx = tx;\n    this.ty = ty;\n    this.stringValue = void 0;\n  }\n\n  readonly x0: number;\n\n  readonly y0: number;\n\n  readonly x1: number;\n\n  readonly y1: number;\n\n  readonly tx: number;\n\n  readonly ty: number;\n\n  override transform(that: Transform): Transform;\n  override transform(x: number, y: number): R2Point;\n  override transform(x: Transform | number, y?: number): Transform | R2Point {\n    if (arguments.length === 2) {\n      return new R2Point(this.x0 * (x as number) + this.x1 * y! + this.tx,\n                         this.y0 * (x as number) + this.y1 * y! + this.ty);\n    } else if (x instanceof IdentityTransform) {\n      return this;\n    } else if (x instanceof Transform) {\n      return this.multiply(x.toAffine());\n    }\n    throw new TypeError(\"\" + x);\n  }\n\n  override transformX(x: number, y: number): number {\n    return this.x0 * x + this.x1 * y + this.tx;\n  }\n\n  override transformY(x: number, y: number): number {\n    return this.y0 * x + this.y1 * y + this.ty;\n  }\n\n  override inverse(): Transform {\n    const m00 = this.x0;\n    const m10 = this.y0;\n    const m01 = this.x1;\n    const m11 = this.y1;\n    const m02 = this.tx;\n    const m12 = this.ty;\n    const det = m00 * m11 - m01 * m10;\n    if (Math.abs(det) < Number.MIN_VALUE) {\n      throw new Error(\"non-invertible affine transform with determinant \" + det);\n    }\n    return new AffineTransform( m11 / det, -m10 / det,\n                               -m01 / det,  m00 / det,\n                               (m01 * m12 - m11 * m02) / det,\n                               (m10 * m02 - m00 * m12) / det);\n  }\n\n  multiply(that: AffineTransform): AffineTransform {\n    const x0 = this.x0 * that.x0 + this.x1 * that.y0;\n    const y0 = this.y0 * that.x0 + this.y1 * that.y0;\n    const x1 = this.x0 * that.x1 + this.x1 * that.y1;\n    const y1 = this.y0 * that.x1 + this.y1 * that.y1;\n    const tx = this.x0 * that.tx + this.x1 * that.ty;\n    const ty = this.y0 * that.tx + this.y1 * that.ty;\n    return new AffineTransform(x0, y0, x1, y1, tx, ty);\n  }\n\n  override toAffine(): AffineTransform {\n    return this;\n  }\n\n  override toMatrix(): DOMMatrix {\n    return new DOMMatrix([this.x0, this.y0, this.x1, this.y1, this.tx, this.ty]);\n  }\n\n  override toCssTransformComponent(): CSSTransformComponent | null {\n    if (typeof CSSTranslate === \"undefined\") {\n      return null;\n    }\n    return new CSSMatrixComponent(this.toMatrix());\n  }\n\n  override toValue(): Value {\n    return Record.create(1)\n                 .attr(\"matrix\", Record.create(6).item(this.x0).item(this.y0)\n                                                 .item(this.x1).item(this.y1)\n                                                 .item(this.tx).item(this.ty));\n  }\n\n  override interpolateTo(that: AffineTransform): Interpolator<AffineTransform>;\n  override interpolateTo(that: Transform): Interpolator<Transform>;\n  override interpolateTo(that: unknown): Interpolator<Transform> | null;\n  override interpolateTo(that: unknown): Interpolator<Transform> | null {\n    if (that instanceof AffineTransform) {\n      return AffineTransformInterpolator(this, that);\n    }\n    return super.interpolateTo(that);\n  }\n\n  override conformsTo(that: Transform): boolean {\n    return that instanceof AffineTransform;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (that instanceof AffineTransform) {\n      return Numbers.equivalent(this.x0, that.x0, epsilon)\n          && Numbers.equivalent(this.y0, that.y0, epsilon)\n          && Numbers.equivalent(this.x1, that.x1, epsilon)\n          && Numbers.equivalent(this.y1, that.y1, epsilon)\n          && Numbers.equivalent(this.tx, that.tx, epsilon)\n          && Numbers.equivalent(this.ty, that.ty, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (that instanceof AffineTransform) {\n      return this.x0 === that.x0 && this.y0 === that.y0\n          && this.x1 === that.x1 && this.y1 === that.y1\n          && this.tx === that.tx && this.ty === that.ty;\n    }\n    return false;\n  }\n\n  override hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(\n        Murmur3.mix(Murmur3.mix(Constructors.hash(AffineTransform),\n        Numbers.hash(this.x0)), Numbers.hash(this.y0)),\n        Numbers.hash(this.x1)), Numbers.hash(this.y1)),\n        Numbers.hash(this.tx)), Numbers.hash(this.ty)));\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Transform\").write(46/*'.'*/).write(\"affine\").write(40/*'('*/)\n                   .debug(this.x0).write(\", \").debug(this.y0).write(\", \")\n                   .debug(this.x1).write(\", \").debug(this.y1).write(\", \")\n                   .debug(this.tx).write(\", \").debug(this.ty).write(41/*')'*/);\n    return output;\n  }\n\n  /** @internal */\n  readonly stringValue: string | undefined;\n\n  override toString(): string {\n    let stringValue = this.stringValue;\n    if (stringValue === void 0) {\n      stringValue = \"matrix(\" + this.x0 + \",\" + this.y0 + \",\"\n                              + this.x1 + \",\" + this.y1 + \",\"\n                              + this.tx + \",\" + this.ty + \")\";\n      (this as Mutable<this>).stringValue = stringValue;\n    }\n    return stringValue;\n  }\n\n  @Lazy\n  static override identity(): AffineTransform {\n    return new AffineTransform(1, 0, 0, 1, 0, 0);\n  }\n\n  static override fromLike<T extends AffineTransformLike | null | undefined>(value: T): AffineTransform | Uninitable<T>;\n  static override fromLike<T extends TransformLike | null | undefined>(value: T): never;\n  static override fromLike<T extends AffineTransformLike | null | undefined>(value: T): AffineTransform | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof AffineTransform) {\n      return value as AffineTransform | Uninitable<T>;\n    } else if (typeof value === \"string\") {\n      return AffineTransform.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromMatrix(matrix: DOMMatrixReadOnly): AffineTransform {\n    return new AffineTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);\n  }\n\n  static override fromCssTransformComponent(component: CSSMatrixComponent): AffineTransform {\n    return AffineTransform.fromMatrix(component.matrix);\n  }\n\n  static override fromValue(value: Value): AffineTransform | null {\n    const header = value.header(\"matrix\");\n    if (!header.isDefined()) {\n      return null;\n    }\n    let x0 = 0;\n    let y0 = 0;\n    let x1 = 0;\n    let y1 = 0;\n    let tx = 0;\n    let ty = 0;\n    header.forEach(function (item: Item, index: number) {\n      const key = item.key.stringValue();\n      if (key !== void 0) {\n        if (key === \"x0\") {\n          x0 = item.toValue().numberValue(x0);\n        } else if (key === \"y0\") {\n          y0 = item.toValue().numberValue(y0);\n        } else if (key === \"x1\") {\n          x1 = item.toValue().numberValue(x1);\n        } else if (key === \"y1\") {\n          y1 = item.toValue().numberValue(y1);\n        } else if (key === \"tx\") {\n          tx = item.toValue().numberValue(tx);\n        } else if (key === \"ty\") {\n          ty = item.toValue().numberValue(ty);\n        }\n      } else if (item instanceof Value) {\n        switch (index) {\n          case 0: x0 = item.numberValue(x0); break;\n          case 1: y0 = item.numberValue(y0); break;\n          case 2: x1 = item.numberValue(x1); break;\n          case 3: y1 = item.numberValue(y1); break;\n          case 4: tx = item.numberValue(tx); break;\n          case 5: ty = item.numberValue(ty); break;\n          default:\n        }\n      }\n    }, this);\n    return new AffineTransform(x0, y0, x1, y1, tx, ty);\n  }\n\n  static override parse(string: string): AffineTransform {\n    let input = Unicode.stringInput(string);\n    while (input.isCont() && Unicode.isWhitespace(input.head())) {\n      input = input.step();\n    }\n    let parser = AffineTransformParser.parse(input);\n    if (parser.isDone()) {\n      while (input.isCont() && Unicode.isWhitespace(input.head())) {\n        input = input.step();\n      }\n    }\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n}\n\n/** @internal */\nexport const AffineTransformInterpolator = (function (_super: typeof Interpolator) {\n  const AffineTransformInterpolator = function (f0: AffineTransform, f1: AffineTransform): Interpolator<AffineTransform> {\n    const interpolator = function (u: number): AffineTransform {\n      // TODO: interpolate and recompose matrices\n      const f0 = interpolator[0];\n      const f1 = interpolator[1];\n      const x0 = f0.x0 + u * (f1.x0 - f0.x0);\n      const y0 = f0.y0 + u * (f1.y0 - f0.y0);\n      const x1 = f0.x1 + u * (f1.x1 - f0.x1);\n      const y1 = f0.y1 + u * (f1.y1 - f0.y1);\n      const tx = f0.tx + u * (f1.tx - f0.tx);\n      const ty = f0.ty + u * (f1.ty - f0.ty);\n      return new AffineTransform(x0, y0, x1, y1, tx, ty);\n    } as Interpolator<AffineTransform>;\n    Object.setPrototypeOf(interpolator, AffineTransformInterpolator.prototype);\n    // TODO: decompose matrices\n    (interpolator as Mutable<typeof interpolator>)[0] = f0;\n    (interpolator as Mutable<typeof interpolator>)[1] = f1;\n    return interpolator;\n  } as {\n    (f0: AffineTransform, f1: AffineTransform): Interpolator<AffineTransform>;\n\n    /** @internal */\n    prototype: Interpolator<AffineTransform>;\n  };\n\n  AffineTransformInterpolator.prototype = Object.create(_super.prototype);\n  AffineTransformInterpolator.prototype.constructor = AffineTransformInterpolator;\n\n  return AffineTransformInterpolator;\n})(Interpolator);\n\n/** @internal */\nexport class AffineTransformParser extends Parser<AffineTransform> {\n  private readonly identOutput: Output<string> | undefined;\n  private readonly entries: number[] | undefined;\n  private readonly entryParser: Parser<number> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(identOutput?: Output<string>, entries?: number[],\n              entryParser?: Parser<number>, step?: number) {\n    super();\n    this.identOutput = identOutput;\n    this.entries = entries;\n    this.entryParser = entryParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<AffineTransform> {\n    return AffineTransformParser.parse(input, this.identOutput, this.entries, this.entryParser, this.step);\n  }\n\n  static parse(input: Input, identOutput?: Output<string>, entries: number[] = [],\n               entryParser?: Parser<number>, step: number = 1): Parser<AffineTransform> {\n    let c = 0;\n    if (step === 1) {\n      identOutput = identOutput || Unicode.stringOutput();\n      while (input.isCont() && (c = input.head(), Unicode.isAlpha(c))) {\n        input = input.step();\n        identOutput.write(c);\n      }\n      if (!input.isEmpty()) {\n        const ident = identOutput.bind();\n        switch (ident) {\n          case \"matrix\": step = 2; break;\n          default: return Parser.error(Diagnostic.message(\"unknown transform function: \" + ident, input));\n        }\n      }\n    }\n    if (step === 2) {\n      while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont() && c === 40/*'('*/) {\n        input.step();\n        step = 3;\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.expected(\"(\", input));\n      }\n    }\n    do {\n      if (step === 3) {\n        if (entryParser === void 0) {\n          while (input.isCont() && Unicode.isSpace(input.head())) {\n            input.step();\n          }\n          if (!input.isEmpty()) {\n            entryParser = Base10.parseNumber(input);\n          }\n        } else {\n          entryParser = entryParser.feed(input);\n        }\n        if (entryParser !== void 0) {\n          if (entryParser.isDone()) {\n            entries.push(entryParser.bind());\n            entryParser = void 0;\n            step = 4;\n          } else if (entryParser.isError()) {\n            return entryParser.asError();\n          }\n        }\n      }\n      if (step === 4) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input.step();\n        }\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 41/*')'*/) {\n            input.step();\n            const ident = identOutput!.bind();\n            switch (ident) {\n              case \"matrix\": return Parser.done(Transform.affine(...entries));\n              default: return Parser.error(Diagnostic.message(\"unknown transform function: \" + ident, input));\n            }\n          } else if (entries.length >= 6) {\n            return Parser.error(Diagnostic.expected(\")\", input));\n          } else if (c === 44/*','*/) {\n            input.step();\n            step = 3;\n            continue;\n          } else {\n            return Parser.error(Diagnostic.expected(\",\", input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.unexpected(input));\n        }\n      }\n      break;\n    } while (true);\n    return new AffineTransformParser(identOutput, entries, entryParser, step);\n  }\n\n  /** @internal */\n  static parseRest(input: Input, identOutput?: Output<string>): Parser<AffineTransform> {\n    return AffineTransformParser.parse(input, identOutput, void 0, void 0, 2);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport type {Item} from \"@swim/structure\";\nimport type {Value} from \"@swim/structure\";\nimport {Record} from \"@swim/structure\";\nimport {R2Point} from \"./R2Point\";\nimport type {TransformLike} from \"./Transform\";\nimport {Transform} from \"./Transform\";\nimport {TransformParser} from \"./Transform\";\nimport {AffineTransform} from \"./AffineTransform\";\nimport {IdentityTransform} from \"./IdentityTransform\";\n\n/** @public */\nexport type TransformListLike = TransformList | string;\n\n/** @public */\nexport const TransformListLike = {\n  [Symbol.hasInstance](instance: unknown): instance is TransformListLike {\n    return instance instanceof TransformList\n        || typeof instance === \"string\";\n  },\n};\n\n/** @public */\nexport class TransformList extends Transform {\n  constructor(transforms: readonly Transform[]) {\n    super();\n    this.transforms = transforms;\n    this.stringValue = void 0;\n  }\n\n  readonly transforms: readonly Transform[];\n\n  override transform(that: Transform): Transform;\n  override transform(x: number, y: number): R2Point;\n  override transform(x: Transform | number, y?: number): Transform | R2Point {\n    if (arguments.length === 2) {\n      const transforms = this.transforms;\n      for (let i = 0; i < transforms.length; i += 1) {\n        const transform = transforms[i]!;\n        const xi = transform.transformX(x as number, y!);\n        const yi = transform.transformY(x as number, y!);\n        x = xi;\n        y = yi;\n      }\n      return new R2Point(x as number, y!);\n    } else if (x instanceof IdentityTransform) {\n      return this;\n    } else if (x instanceof Transform) {\n      return Transform.list(this, x);\n    }\n    throw new TypeError(\"\" + x);\n  }\n\n  override transformX(x: number, y: number): number {\n    const transforms = this.transforms;\n    for (let i = 0; i < transforms.length; i += 1) {\n      const transform = transforms[i]!;\n      const xi = transform.transformX(x, y);\n      const yi = transform.transformY(x, y);\n      x = xi;\n      y = yi;\n    }\n    return x;\n  }\n\n  override transformY(x: number, y: number): number {\n    const transforms = this.transforms;\n    for (let i = 0; i < transforms.length; i += 1) {\n      const transform = transforms[i]!;\n      const xi = transform.transformX(x, y);\n      const yi = transform.transformY(x, y);\n      x = xi;\n      y = yi;\n    }\n    return y;\n  }\n\n  override inverse(): Transform {\n    const transforms = this.transforms;\n    const n = transforms.length;\n    const inverseTransforms = new Array<Transform>(n);\n    for (let i = 0; i < n; i += 1) {\n      inverseTransforms[i] = transforms[n - i - 1]!.inverse();\n    }\n    return new TransformList(inverseTransforms);\n  }\n\n  override toAffine(): AffineTransform {\n    let matrix = AffineTransform.identity();\n    const transforms = this.transforms;\n    for (let i = 0; i < transforms.length; i += 1) {\n      matrix = matrix.multiply(transforms[i]!.toAffine());\n    }\n    return matrix;\n  }\n\n  override toCssTransformComponent(): CSSTransformComponent | null {\n    if (typeof CSSTranslate === \"undefined\") {\n      return null;\n    }\n    return new CSSMatrixComponent(this.toMatrix());\n  }\n\n  override toCssValue(): CSSStyleValue | null {\n    if (typeof CSSTransformValue === \"undefined\") {\n      return null;\n    }\n    const transforms = this.transforms;\n    const n = transforms.length;\n    const components = new Array<CSSTransformComponent>(n);\n    for (let i = 0; i < transforms.length; i += 1) {\n      const transform = transforms[i]!;\n      const component = transform.toCssTransformComponent();\n      if (component === null) {\n        return null;\n      }\n      components[i] = component;\n    }\n    return new CSSTransformValue(components);\n  }\n\n  override toValue(): Value {\n    const transforms = this.transforms;\n    const n = transforms.length;\n    const record = Record.create(n);\n    for (let i = 0; i < n; i += 1) {\n      record.push(transforms[i]!.toValue());\n    }\n    return record;\n  }\n\n  override interpolateTo(that: TransformList): Interpolator<TransformList>;\n  override interpolateTo(that: Transform): Interpolator<Transform>;\n  override interpolateTo(that: unknown): Interpolator<Transform> | null;\n  override interpolateTo(that: unknown): Interpolator<Transform> | null {\n    if (that instanceof TransformList) {\n      return TransformListInterpolator(this, that);\n    }\n    return super.interpolateTo(that);\n  }\n\n  override conformsTo(that: Transform): boolean {\n    if (!(that instanceof TransformList)) {\n      return false;\n    }\n    const n = this.transforms.length;\n    if (n !== that.transforms.length) {\n      return false;\n    }\n    for (let i = 0; i < n; i += 1) {\n      if (!this.transforms[i]!.conformsTo(that.transforms[i]!)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (!(that instanceof TransformList)) {\n      return false;\n    }\n    const n = this.transforms.length;\n    if (n !== that.transforms.length) {\n      return false;\n    }\n    for (let i = 0; i < n; i += 1) {\n      if (!this.transforms[i]!.equivalentTo(that.transforms[i]!, epsilon)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  override equals(that: unknown): boolean {\n    if (!(that instanceof TransformList)) {\n      return false;\n    }\n    const n = this.transforms.length;\n    if (n !== that.transforms.length) {\n      return false;\n    }\n    for (let i = 0; i < n; i += 1) {\n      if (!this.transforms[i]!.equals(that.transforms[i]!)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  override hashCode(): number {\n    let hashValue = Constructors.hash(TransformList);\n    const transforms = this.transforms;\n    for (let i = 0; i < transforms.length; i += 1) {\n      hashValue = Murmur3.mix(hashValue, transforms[i]!.hashCode());\n    }\n    return Murmur3.mash(hashValue);\n  }\n\n  override debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"Transform\").write(46/*'.'*/).write(\"list\").write(40/*'('*/);\n    const transforms = this.transforms;\n    const n = transforms.length;\n    if (n > 0) {\n      output = output.debug(transforms[0]!);\n      for (let i = 1; i < n; i += 1) {\n        output = output.write(\", \").debug(transforms[i]!);\n      }\n    }\n    output = output.write(41/*')'*/);\n    return output;\n  }\n\n  /** @internal */\n  readonly stringValue: string | undefined;\n\n  override toString(): string {\n    let stringValue = this.stringValue;\n    if (stringValue === void 0) {\n      const transforms = this.transforms;\n      const n = transforms.length;\n      if (n === 0) {\n        stringValue = \"none\";\n      } else {\n        stringValue = transforms[0]!.toString();\n        for (let i = 1; i < n; i += 1) {\n          stringValue += \" \";\n          stringValue += transforms[i]!.toString();\n        }\n      }\n      (this as Mutable<this>).stringValue = stringValue;\n    }\n    return stringValue;\n  }\n\n  override toAttributeString(): string {\n    const transforms = this.transforms;\n    const n = transforms.length;\n    if (n === 0) {\n      return \"\";\n    }\n    let s = transforms[0]!.toAttributeString();\n    for (let i = 1; i < n; i += 1) {\n      s += \" \";\n      s += transforms[i]!.toAttributeString();\n    }\n    return s;\n  }\n\n  static override fromLike<T extends TransformListLike | null | undefined>(value: T): TransformList | Uninitable<T>;\n  static override fromLike<T extends TransformLike | null | undefined>(value: T): never;\n  static override fromLike<T extends TransformListLike | null | undefined>(value: T): TransformList | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof TransformList) {\n      return value as TransformList | Uninitable<T>;\n    } else if (typeof value === \"string\") {\n      return TransformList.parse(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static override fromValue(value: Value): TransformList | null {\n    const transforms: Transform[] = [];\n    value.forEach(function (item: Item) {\n      const transform = Transform.fromValue(item.toValue());\n      if (transform !== null) {\n        transforms.push(transform);\n      }\n    }, this);\n    if (transforms.length !== 0) {\n      return new TransformList(transforms);\n    }\n    return null;\n  }\n\n  static override parse(string: string): TransformList {\n    const transform = Transform.parse(string);\n    if (transform instanceof TransformList) {\n      return transform;\n    }\n    return new TransformList([transform]);\n  }\n}\n\n/** @internal */\nexport interface TransformListInterpolator extends Interpolator<TransformList> {\n  /** @internal */\n  readonly interpolators: readonly Interpolator<Transform>[];\n\n  readonly 0: TransformList;\n\n  readonly 1: TransformList;\n\n  equals(that: unknown): boolean;\n}\n\n/** @internal */\nexport const TransformListInterpolator = (function (_super: typeof Interpolator) {\n  const TransformListInterpolator = function (f0: TransformList, f1: TransformList): TransformListInterpolator {\n    const interpolator = function (u: number): TransformList {\n      const interpolators = interpolator.interpolators;\n      const interpolatorCount = interpolators.length;\n      const transforms = new Array<Transform>(interpolatorCount);\n      for (let i = 0; i < interpolatorCount; i += 1) {\n        transforms[i] = interpolators[i]!(u);\n      }\n      return new TransformList(transforms);\n    } as TransformListInterpolator;\n    Object.setPrototypeOf(interpolator, TransformListInterpolator.prototype);\n    const transforms0 = f0.transforms;\n    const transforms1 = f1.transforms;\n    const interpolatorCount = Math.min(transforms0.length, transforms1.length);\n    const interpolators = new Array<Interpolator<Transform>>(interpolatorCount);\n    for (let i = 0; i < interpolatorCount; i += 1) {\n      interpolators[i] = transforms0[i]!.interpolateTo(transforms1[i]!);\n    }\n    (interpolator as Mutable<typeof interpolator>).interpolators = interpolators;\n    return interpolator;\n  } as {\n    (f0: TransformList, f1: TransformList): TransformListInterpolator;\n\n    /** @internal */\n    prototype: TransformListInterpolator;\n  };\n\n  TransformListInterpolator.prototype = Object.create(_super.prototype);\n  TransformListInterpolator.prototype.constructor = TransformListInterpolator;\n\n  Object.defineProperty(TransformListInterpolator.prototype, 0, {\n    get(this: TransformListInterpolator): TransformList {\n      const interpolators = this.interpolators;\n      const interpolatorCount = interpolators.length;\n      const transforms = new Array<Transform>(interpolatorCount);\n      for (let i = 0; i < interpolatorCount; i += 1) {\n        transforms[i] = interpolators[i]![0];\n      }\n      return new TransformList(transforms);\n    },\n    configurable: true,\n  });\n\n  Object.defineProperty(TransformListInterpolator.prototype, 1, {\n    get(this: TransformListInterpolator): TransformList {\n      const interpolators = this.interpolators;\n      const interpolatorCount = interpolators.length;\n      const transforms = new Array<Transform>(interpolatorCount);\n      for (let i = 0; i < interpolatorCount; i += 1) {\n        transforms[i] = interpolators[i]![1];\n      }\n      return new TransformList(transforms);\n    },\n    configurable: true,\n  });\n\n  TransformListInterpolator.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof TransformListInterpolator) {\n      const n = this.interpolators.length;\n      if (n !== that.interpolators.length) {\n        return false;\n      }\n      for (let i = 0; i < n; i += 1) {\n        if (!this.interpolators[i]!.equals(that.interpolators[i]!)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  };\n\n  return TransformListInterpolator;\n})(Interpolator);\n\n/** @internal */\nexport class TransformListParser extends Parser<Transform> {\n  private readonly transform: Transform | undefined;\n  private readonly transformParser: Parser<Transform> | undefined;\n\n  constructor(transform?: Transform, transformParser?: Parser<Transform>) {\n    super();\n    this.transform = transform;\n    this.transformParser = transformParser;\n  }\n\n  override feed(input: Input): Parser<Transform> {\n    return TransformListParser.parse(input, this.transform, this.transformParser);\n  }\n\n  static parse(input: Input, transform: Transform = Transform.identity(),\n               transformParser?: Parser<Transform>): Parser<Transform> {\n    do {\n      if (transformParser === void 0) {\n        while (input.isCont() && Unicode.isSpace(input.head())) {\n          input.step();\n        }\n        if (input.isCont()) {\n          transformParser = TransformParser.parse(input);\n        } else if (input.isDone()) {\n          return Parser.done(transform);\n        }\n      }\n      if (transformParser !== void 0) {\n        transformParser = transformParser.feed(input);\n        if (transformParser.isDone()) {\n          transform = transform.transform(transformParser.bind());\n          transformParser = void 0;\n          continue;\n        } else if (transformParser.isError()) {\n          return transformParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new TransformListParser(transform, transformParser);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Objects} from \"@swim/util\";\nimport type {R2PointLike} from \"@swim/math\";\nimport type {R2Point} from \"@swim/math\";\nimport type {GeoPointLike} from \"./GeoPoint\";\nimport type {GeoPoint} from \"./GeoPoint\";\n\n/** @public */\nexport interface GeoProjection {\n  project(lnglat: GeoPointLike): R2Point;\n  project(lng: number, lat: number): R2Point;\n\n  unproject(point: R2PointLike): GeoPoint;\n  unproject(x: number, y: number): GeoPoint;\n}\n\n/** @public */\nexport const GeoProjection = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoProjection {\n    return Objects.hasAllKeys<GeoProjection>(instance, \"project\", \"unproject\");\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Equals} from \"@swim/util\";\nimport type {Equivalent} from \"@swim/util\";\nimport type {R2Shape} from \"@swim/math\";\nimport type {GeoProjection} from \"./GeoProjection\";\nimport {GeoPointInit} from \"./\"; // forward import\nimport {GeoPointTuple} from \"./\"; // forward import\nimport {GeoPoint} from \"./\"; // forward import\nimport {GeoSegmentInit} from \"./\"; // forward import\nimport {GeoSegment} from \"./\"; // forward import\nimport {GeoSplinePoints} from \"./\"; // forward import\nimport {GeoSpline} from \"./\"; // forward import\nimport {GeoPathSplines} from \"./\"; // forward import\nimport {GeoPath} from \"./\"; // forward import\nimport {GeoBoxInit} from \"./\"; // forward import\nimport {GeoBox} from \"./\"; // forward import\nimport {GeoTileInit} from \"./\"; // forward import\nimport {GeoTileTuple} from \"./\"; // forward import\nimport {GeoTile} from \"./\"; // forward import\n\n/** @public */\nexport type GeoShapeLike = GeoShape\n                         | GeoPointInit\n                         | GeoPointTuple\n                         | GeoSegmentInit\n                         | GeoSplinePoints\n                         | GeoTileInit\n                         | GeoTileTuple\n                         | GeoBoxInit;\n\n/** @public */\nexport const GeoShapeLike = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoShapeLike {\n    return instance instanceof GeoShape\n        || GeoPointInit[Symbol.hasInstance](instance)\n        || GeoPointTuple[Symbol.hasInstance](instance)\n        || GeoSegmentInit[Symbol.hasInstance](instance)\n        || GeoSplinePoints[Symbol.hasInstance](instance)\n        || GeoPathSplines[Symbol.hasInstance](instance)\n        || GeoTileInit[Symbol.hasInstance](instance)\n        || GeoTileTuple[Symbol.hasInstance](instance)\n        || GeoBoxInit[Symbol.hasInstance](instance);\n  },\n};\n\n/** @public */\nexport abstract class GeoShape implements Equals, Equivalent {\n  /** @internal */\n  declare readonly typeid?: string;\n\n  likeType?(like: GeoPointInit\n                | GeoPointTuple\n                | GeoSegmentInit\n                | GeoSplinePoints\n                | GeoPathSplines\n                | GeoTileInit\n                | GeoTileTuple\n                | GeoBoxInit): void;\n\n  abstract isDefined(): boolean;\n\n  abstract readonly lngMin: number;\n\n  abstract readonly latMin: number;\n\n  abstract readonly lngMax: number;\n\n  abstract readonly latMax: number;\n\n  abstract contains(that: GeoShapeLike): boolean;\n\n  abstract contains(lng: number, lat: number): boolean;\n\n  abstract intersects(that: GeoShapeLike): boolean;\n\n  union(that: GeoShapeLike): GeoShape {\n    that = GeoShape.fromLike(that);\n    return new GeoBox(Math.min(this.lngMin, that.lngMin),\n                      Math.min(this.latMin, that.latMin),\n                      Math.max(this.lngMax, that.lngMax),\n                      Math.max(this.latMax, that.latMax));\n  }\n\n  abstract project(f: GeoProjection): R2Shape;\n\n  get bounds(): GeoBox {\n    return new GeoBox(this.lngMin, this.latMin, this.lngMax, this.latMax);\n  }\n\n  /** @override */\n  abstract equivalentTo(that: unknown, epsilon?: number): boolean\n\n  /** @override */\n  abstract equals(that: unknown): boolean;\n\n  static fromLike<T extends GeoShapeLike | null | undefined>(value: T): GeoShape | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof GeoShape) {\n      return value as GeoShape | Uninitable<T>;\n    } else if (GeoPointInit[Symbol.hasInstance](value)) {\n      return GeoPoint.fromInit(value);\n    } else if (GeoPointTuple[Symbol.hasInstance](value)) {\n      return GeoPoint.fromTuple(value);\n    } else if (GeoSegmentInit[Symbol.hasInstance](value)) {\n      return GeoSegment.fromInit(value);\n    } else if (GeoSplinePoints[Symbol.hasInstance](value)) {\n      return GeoSpline.fromPoints(value);\n    } else if (GeoPathSplines[Symbol.hasInstance](value)) {\n      return GeoPath.fromSplines(value);\n    } else if (GeoTileInit[Symbol.hasInstance](value)) {\n      return GeoTile.fromInit(value);\n    } else if (GeoTileTuple[Symbol.hasInstance](value)) {\n      return GeoTile.fromTuple(value);\n    } else if (GeoBoxInit[Symbol.hasInstance](value)) {\n      return GeoBox.fromInit(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport {Equivalent} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport type {Interpolate} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport type {R2Point} from \"@swim/math\";\nimport type {GeoProjection} from \"./GeoProjection\";\nimport type {GeoShapeLike} from \"./GeoShape\";\nimport {GeoShape} from \"./GeoShape\";\n\n/** @public */\nexport type GeoPointLike = GeoPoint | GeoPointInit | GeoPointTuple;\n\n/** @public */\nexport const GeoPointLike = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoPointLike {\n    return instance instanceof GeoPoint\n        || GeoPointInit[Symbol.hasInstance](instance)\n        || GeoPointTuple[Symbol.hasInstance](instance);\n  },\n};\n\n/** @public */\nexport interface GeoPointInit {\n  /** @internal */\n  readonly typeid?: \"GeoPointInit\";\n  lng: number;\n  lat: number;\n}\n\n/** @public */\nexport const GeoPointInit = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoPointInit {\n    return Objects.hasAllKeys<GeoPointInit>(instance, \"lng\", \"lat\");\n  },\n};\n\n/** @public */\nexport type GeoPointTuple = [number, number];\n\n/** @public */\nexport const GeoPointTuple = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoPointTuple {\n    return Array.isArray(instance) && instance.length === 2\n        && typeof instance[0] === \"number\"\n        && typeof instance[1] === \"number\";\n  },\n};\n\n/**\n * A geographic point represented by a WGS84 longitude and latitude.\n * @public\n */\nexport class GeoPoint extends GeoShape implements Interpolate<GeoPoint>, HashCode, Debug {\n  constructor(lng: number, lat: number) {\n    super();\n    this.lng = lng;\n    this.lat = lat;\n  }\n\n  /** @internal */\n  declare readonly typeid?: \"GeoPoint\";\n\n  override likeType?(like: GeoPointInit | GeoPointTuple): void;\n\n  override isDefined(): boolean {\n    return isFinite(this.lng) && isFinite(this.lat);\n  }\n\n  readonly lng: number;\n\n  readonly lat: number;\n\n  override get lngMin(): number {\n    return this.lng;\n  }\n\n  override get latMin(): number {\n    return this.lat;\n  }\n\n  override get lngMax(): number {\n    return this.lng;\n  }\n\n  override get latMax(): number {\n    return this.lat;\n  }\n\n  override contains(that: GeoShapeLike): boolean;\n  override contains(lng: number, lat: number): boolean;\n  override contains(that: GeoShapeLike | number, lat?: number): boolean {\n    if (typeof that === \"number\") {\n      return this.lng === that && this.lat === lat!;\n    }\n    that = GeoShape.fromLike(that);\n    if (that instanceof GeoPoint) {\n      return this.lng === that.lng && this.lat === that.lat;\n    } else if (that instanceof GeoShape) {\n      return this.lng <= that.lngMin && that.lngMax <= this.lng\n          && this.lat <= that.latMin && that.latMax <= this.lat;\n    }\n    return false;\n  }\n\n  override intersects(that: GeoShapeLike): boolean {\n    that = GeoShape.fromLike(that);\n    return that.intersects(this);\n  }\n\n  override project(f: GeoProjection): R2Point {\n    return f.project(this);\n  }\n\n  normalized(): GeoPoint {\n    const oldLng = this.lng;\n    const oldLat = this.lat;\n    const newLng = GeoPoint.normalizeLng(oldLng);\n    const newLat = GeoPoint.normalizeLat(oldLat);\n    if (oldLng === newLng && oldLat === newLat) {\n      return this;\n    }\n    return new GeoPoint(newLng, newLat);\n  }\n\n  toLike(): GeoPointInit {\n    return {\n      lng: this.lng,\n      lat: this.lat,\n    };\n  }\n\n  /** @override */\n  interpolateTo(that: GeoPoint): Interpolator<GeoPoint>;\n  interpolateTo(that: unknown): Interpolator<GeoPoint> | null;\n  interpolateTo(that: unknown): Interpolator<GeoPoint> | null {\n    if (that instanceof GeoPoint) {\n      return GeoPointInterpolator(this, that);\n    }\n    return null;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeoPoint) {\n      return Numbers.equivalent(this.lng, that.lng, epsilon)\n          && Numbers.equivalent(this.lat, that.lat, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeoPoint) {\n      return this.lng === that.lng && this.lat === that.lat;\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(GeoPoint),\n        Numbers.hash(this.lng)), Numbers.hash(this.lat)));\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"GeoPoint\").write(46/*'.'*/).write(\"of\").write(40/*'('*/)\n                   .debug(this.lng).write(\", \").debug(this.lat).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n\n  @Lazy\n  static undefined(): GeoPoint {\n    return new GeoPoint(NaN, NaN);\n  }\n\n  @Lazy\n  static origin(): GeoPoint {\n    return new GeoPoint(0, 0);\n  }\n\n  static of(lng: number, lat: number): GeoPoint {\n    return new GeoPoint(lng, lat);\n  }\n\n  static override fromLike<T extends GeoPointLike | null | undefined>(value: T): GeoPoint | Uninitable<T>;\n  static override fromLike<T extends GeoShapeLike | null | undefined>(value: T): never;\n  static override fromLike<T extends GeoPointLike | null | undefined>(value: T): GeoPoint | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof GeoPoint) {\n      return value as GeoPoint | Uninitable<T>;\n    } else if (GeoPointInit[Symbol.hasInstance](value)) {\n      return GeoPoint.fromInit(value);\n    } else if (GeoPointTuple[Symbol.hasInstance](value)) {\n      return GeoPoint.fromTuple(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromInit(init: GeoPointInit): GeoPoint {\n    return new GeoPoint(init.lng, init.lat);\n  }\n\n  static fromTuple(tuple: GeoPointTuple): GeoPoint {\n    return new GeoPoint(tuple[0], tuple[1]);\n  }\n\n  static normalized(lng: number, lat: number): GeoPoint {\n    lng = GeoPoint.normalizeLng(lng);\n    lat = GeoPoint.normalizeLat(lat);\n    return new GeoPoint(lng, lat);\n  }\n\n  /** @internal */\n  static normalizeLng(lng: number): number {\n    if (lng < -180) {\n      lng = 180 - (-lng + 180) % 360;\n    } else if (lng > 180) {\n      lng = -180 + (lng - 180) % 360;\n    }\n    return lng;\n  }\n\n  /** @internal */\n  static normalizeLat(lat: number): number {\n    lat = Math.min(Math.max(-90 + Equivalent.Epsilon, lat), 90 - Equivalent.Epsilon);\n    return lat;\n  }\n}\n\n/** @internal */\nexport const GeoPointInterpolator = (function (_super: typeof Interpolator) {\n  const GeoPointInterpolator = function (p0: GeoPoint, p1: GeoPoint): Interpolator<GeoPoint> {\n    const interpolator = function (u: number): GeoPoint {\n      const p0 = interpolator[0];\n      const lng0 = p0.lng;\n      const lat0 = p0.lat;\n      const p1 = interpolator[1];\n      const lng1 = p1.lng;\n      const lat1 = p1.lat;\n      let lng: number;\n      if (lng0 > 0 && lng1 < 0 && lng0 - lng1 > 180) {\n        // east across anti-meridian\n        const w = 180 - lng0;\n        const e = 180 + lng1;\n        const uw = w / (w + e);\n        if (u < uw) {\n          lng = lng0 + (u / uw) * w;\n        } else {\n          const ue = 1 - uw;\n          lng = -180 + ((u - uw) / ue) * e;\n        }\n      } else if (lng0 < 0 && lng1 > 0 && lng1 - lng0 > 180) {\n        // west across anti-meridian\n        const e = 180 + lng0;\n        const w = 180 - lng1;\n        const ue = e / (e + w);\n        if (u < ue) {\n          lng = lng0 - (u / ue) * e;\n        } else {\n          const uw = 1 - ue;\n          lng = 180 - ((u - ue) / uw) * w;\n        }\n      } else {\n        lng = lng0 + u * (lng1 - lng0);\n      }\n      const lat = lat0 + u * (lat1 - lat0);\n      return new GeoPoint(lng, lat);\n    } as Interpolator<GeoPoint>;\n    Object.setPrototypeOf(interpolator, GeoPointInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = p0.normalized();\n    (interpolator as Mutable<typeof interpolator>)[1] = p1.normalized();\n    return interpolator;\n  } as {\n    (p0: GeoPoint, p1: GeoPoint): Interpolator<GeoPoint>;\n\n    /** @internal */\n    prototype: Interpolator<GeoPoint>;\n  };\n\n  GeoPointInterpolator.prototype = Object.create(_super.prototype);\n  GeoPointInterpolator.prototype.constructor = GeoPointInterpolator;\n\n  return GeoPointInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {R2Curve} from \"@swim/math\";\nimport type {GeoProjection} from \"./GeoProjection\";\nimport {GeoShape} from \"./GeoShape\";\nimport type {GeoPoint} from \"./GeoPoint\";\n\n/** @public */\nexport interface GeoCurveContext {\n  moveTo(lng: number, lat: number): void;\n\n  lineTo(lng: number, lat: number): void;\n}\n\n/** @public */\nexport abstract class GeoCurve extends GeoShape {\n  abstract interpolateLng(u: number): number;\n\n  abstract interpolateLat(u: number): number;\n\n  abstract interpolate(u: number): GeoPoint;\n\n  abstract split(u: number): [GeoCurve, GeoCurve];\n\n  abstract override project(f: GeoProjection): R2Curve;\n\n  abstract forEachCoord<R>(callback: (lng: number, lat: number) => R | void): R | undefined;\n  abstract forEachCoord<R, S>(callback: (this: S, lng: number, lat: number) => R | void,\n                              thisArg: S): R | undefined;\n\n  abstract forEachCoordRest<R>(callback: (lng: number, lat: number) => R | void): R | undefined;\n  abstract forEachCoordRest<R, S>(callback: (this: S, lng: number, lat: number) => R | void,\n                                  thisArg: S): R | undefined;\n\n  abstract override equals(that: unknown): boolean;\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport type {Interpolate} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport {R2Segment} from \"@swim/math\";\nimport type {GeoProjection} from \"./GeoProjection\";\nimport type {GeoShapeLike} from \"./GeoShape\";\nimport {GeoShape} from \"./GeoShape\";\nimport {GeoPoint} from \"./GeoPoint\";\nimport {GeoCurve} from \"./GeoCurve\";\n\n/** @public */\nexport type GeoSegmentLike = GeoSegment | GeoSegmentInit;\n\n/** @public */\nexport const GeoSegmentLike = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoSegmentLike {\n    return instance instanceof GeoSegment\n        || GeoSegmentInit[Symbol.hasInstance](instance);\n  },\n};\n\n/** @public */\nexport interface GeoSegmentInit {\n  /** @internal */\n  readonly typeid?: \"GeoSegmentInit\";\n  lng0: number;\n  lat0: number;\n  lng1: number;\n  lat1: number;\n}\n\n/** @public */\nexport const GeoSegmentInit = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoSegmentInit {\n    return Objects.hasAllKeys<GeoSegmentInit>(instance, \"lng0\", \"lat0\", \"lng1\", \"lat1\");\n  },\n};\n\n/** @public */\nexport class GeoSegment extends GeoCurve implements Interpolate<GeoSegment>, HashCode, Debug {\n  constructor(lng0: number, lat0: number, lng1: number, lat1: number) {\n    super();\n    this.lng0 = lng0;\n    this.lat0 = lat0;\n    this.lng1 = lng1;\n    this.lat1 = lat1;\n  }\n\n  /** @internal */\n  declare readonly typeid?: \"GeoSegment\";\n\n  override likeType?(like: GeoSegmentInit): void;\n\n  override isDefined(): boolean {\n    return isFinite(this.lng0) && isFinite(this.lat0)\n        && isFinite(this.lng1) && isFinite(this.lat1);\n  }\n\n  readonly lng0: number;\n\n  readonly lat0: number;\n\n  readonly lng1: number;\n\n  readonly lat1: number;\n\n  override get lngMin(): number {\n    return Math.min(this.lng0, this.lng1);\n  }\n\n  override get latMin(): number {\n    return Math.min(this.lat0, this.lat1);\n  }\n\n  override get lngMax(): number {\n    return Math.max(this.lng0, this.lng1);\n  }\n\n  override get latMax(): number {\n    return Math.max(this.lat0, this.lat1);\n  }\n\n  override interpolateLng(u: number): number {\n    return (1.0 - u) * this.lng0 + u * this.lng1;\n  }\n\n  override interpolateLat(u: number): number {\n   return (1.0 - u) * this.lat0 + u * this.lat1;\n  }\n\n  override interpolate(u: number): GeoPoint {\n    const v = 1.0 - u;\n    const lng01 = v * this.lng0 + u * this.lng1;\n    const lat01 = v * this.lat0 + u * this.lat1;\n    return new GeoPoint(lng01, lat01);\n  }\n\n  override contains(that: GeoShapeLike): boolean;\n  override contains(lng: number, lat: number): boolean;\n  override contains(that: GeoShapeLike | number, lat?: number): boolean {\n    if (typeof that === \"number\") {\n      return R2Segment.contains(this.lng0, this.lat0, this.lng1, this.lat1, that, lat!);\n    }\n    that = GeoShape.fromLike(that);\n    if (that instanceof GeoPoint) {\n      return this.containsPoint(that);\n    } else if (that instanceof GeoSegment) {\n      return this.containsSegment(that);\n    }\n    return false;\n  }\n\n  /** @internal */\n  containsPoint(that: GeoPoint): boolean {\n    return R2Segment.contains(this.lng0, this.lat0, this.lng1, this.lat1, that.lng, that.lat);\n  }\n\n  /** @internal */\n  containsSegment(that: GeoSegment): boolean {\n    return R2Segment.contains(this.lng0, this.lat0, this.lng1, this.lat1, that.lng0, that.lat0)\n        && R2Segment.contains(this.lng0, this.lat0, this.lng1, this.lat1, that.lng1, that.lat1);\n  }\n\n  override intersects(that: GeoShapeLike): boolean {\n    that = GeoShape.fromLike(that);\n    if (that instanceof GeoPoint) {\n      return this.intersectsPoint(that);\n    } else if (that instanceof GeoSegment) {\n      return this.intersectsSegment(that);\n    } else {\n      return that.intersects(this);\n    }\n    return false;\n  }\n\n  /** @internal */\n  intersectsPoint(that: GeoPoint): boolean {\n    return R2Segment.contains(this.lng0, this.lat0, this.lng1, this.lat1, that.lng, that.lat);\n  }\n\n  /** @internal */\n  intersectsSegment(that: GeoSegment): boolean {\n    return R2Segment.intersects(this.lng0, this.lat0, this.lng1 - this.lat0, this.lng1 - this.lat0,\n                                that.lng0, that.lat0, that.lng1 - that.lat0, that.lng1 - that.lat0);\n  }\n\n  override split(u: number): [GeoSegment, GeoSegment] {\n    const v = 1.0 - u;\n    const lng01 = v * this.lng0 + u * this.lng1;\n    const lat01 = v * this.lat0 + u * this.lat1;\n    const c0 = new GeoSegment(this.lng0, this.lat0, lng01, lat01);\n    const c1 = new GeoSegment(lng01, lat01, this.lng1, this.lat1);\n    return [c0, c1];\n  }\n\n  override project(f: GeoProjection): R2Segment {\n    const p0 = f.project(this.lng0, this.lat0);\n    const p1 = f.project(this.lng1, this.lat1);\n    return new R2Segment(p0.x, p0.y, p1.x, p1.y);\n  }\n\n  override forEachCoord<R>(callback: (lng: number, lat: number) => R | void): R | undefined;\n  override forEachCoord<R, S>(callback: (this: S, lng: number, lat: number) => R | void, thisArg: S): R | undefined;\n  override forEachCoord<R, S>(callback: (this: S | undefined, lng: number, lat: number) => R | undefined, thisArg?: S): R | undefined {\n    let result: R | void;\n    result = callback.call(thisArg, this.lng0, this.lat0);\n    if (result !== void 0) {\n      return result;\n    }\n    result = callback.call(thisArg, this.lng1, this.lat1);\n    if (result !== void 0) {\n      return result;\n    }\n    return void 0;\n  }\n\n  override forEachCoordRest<R>(callback: (lng: number, lat: number) => R | void): R | undefined;\n  override forEachCoordRest<R, S>(callback: (this: S, lng: number, lat: number) => R | void, thisArg: S): R | undefined;\n  override forEachCoordRest<R, S>(callback: (this: S | undefined, lng: number, lat: number) => R | void, thisArg?: S): R | undefined {\n    const result = callback.call(thisArg, this.lng1, this.lat1);\n    if (result !== void 0) {\n      return result;\n    }\n    return void 0;\n  }\n\n  toLike(): GeoSegmentInit {\n    return {\n      lng0: this.lng0,\n      lat0: this.lat0,\n      lng1: this.lng1,\n      lat1: this.lat1,\n    };\n  }\n\n  /** @override */\n  interpolateTo(that: GeoSegment): Interpolator<GeoSegment>;\n  interpolateTo(that: unknown): Interpolator<GeoSegment> | null;\n  interpolateTo(that: unknown): Interpolator<GeoSegment> | null {\n    if (that instanceof GeoSegment) {\n      return GeoSegmentInterpolator(this, that);\n    }\n    return null;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeoSegment) {\n      return Numbers.equivalent(this.lng0, that.lng0, epsilon)\n          && Numbers.equivalent(this.lat0, that.lat0, epsilon)\n          && Numbers.equivalent(this.lng1, that.lng1, epsilon)\n          && Numbers.equivalent(this.lat1, that.lat1, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeoSegment) {\n      return this.lng0 === that.lng0 && this.lat0 === that.lat0\n          && this.lng1 === that.lng1 && this.lat1 === that.lat1;\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(\n        Constructors.hash(GeoSegment), Numbers.hash(this.lng0)), Numbers.hash(this.lat0)),\n        Numbers.hash(this.lng1)), Numbers.hash(this.lat1)));\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"GeoSegment\").write(46/*'.'*/).write(\"of\").write(40/*'('*/)\n                   .debug(this.lng0).write(\", \").debug(this.lat0).write(\", \")\n                   .debug(this.lng1).write(\", \").debug(this.lat1).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n\n  static of(lng0: number, lat0: number, lng1: number, lat1: number): GeoSegment {\n    return new GeoSegment(lng0, lat0, lng1, lat1);\n  }\n\n  static override fromLike<T extends GeoSegmentLike | null | undefined>(value: T): GeoSegment | Uninitable<T>;\n  static override fromLike<T extends GeoShapeLike | null | undefined>(value: T): never;\n  static override fromLike<T extends GeoSegmentLike | null | undefined>(value: T): GeoSegment | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof GeoSegment) {\n      return value as GeoSegment | Uninitable<T>;\n    } else if (GeoSegmentInit[Symbol.hasInstance](value)) {\n      return GeoSegment.fromInit(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromInit(init: GeoSegmentInit): GeoSegment {\n    return new GeoSegment(init.lng0, init.lat0, init.lng1, init.lat1);\n  }\n}\n\n/** @internal */\nexport const GeoSegmentInterpolator = (function (_super: typeof Interpolator) {\n  const GeoSegmentInterpolator = function (s0: GeoSegment, s1: GeoSegment): Interpolator<GeoSegment> {\n    const interpolator = function (u: number): GeoSegment {\n      const s0 = interpolator[0];\n      const s1 = interpolator[1];\n      const lng0 = s0.lng0 + u * (s1.lng0 - s0.lng0);\n      const lat0 = s0.lat0 + u * (s1.lat0 - s0.lat0);\n      const lng1 = s0.lng1 + u * (s1.lng1 - s0.lng1);\n      const lat1 = s0.lat1 + u * (s1.lat1 - s0.lat1);\n      return new GeoSegment(lng0, lat0, lng1, lat1);\n    } as Interpolator<GeoSegment>;\n    Object.setPrototypeOf(interpolator, GeoSegmentInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = s0;\n    (interpolator as Mutable<typeof interpolator>)[1] = s1;\n    return interpolator;\n  } as {\n    (s0: GeoSegment, s1: GeoSegment): Interpolator<GeoSegment>;\n\n    /** @internal */\n    prototype: Interpolator<GeoSegment>;\n  };\n\n  GeoSegmentInterpolator.prototype = Object.create(_super.prototype);\n  GeoSegmentInterpolator.prototype.constructor = GeoSegmentInterpolator;\n\n  return GeoSegmentInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport {Arrays} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport type {R2Curve} from \"@swim/math\";\nimport {R2Segment} from \"@swim/math\";\nimport {R2Spline} from \"@swim/math\";\nimport type {GeoProjection} from \"./GeoProjection\";\nimport type {GeoShapeLike} from \"./GeoShape\";\nimport {GeoPointLike} from \"./GeoPoint\";\nimport {GeoPoint} from \"./GeoPoint\";\nimport type {GeoCurveContext} from \"./GeoCurve\";\nimport {GeoCurve} from \"./GeoCurve\";\nimport {GeoSegment} from \"./GeoSegment\";\nimport {GeoBox} from \"./\"; // forward import\n\n/** @public */\nexport interface GeoSplineContext extends GeoCurveContext {\n  closePath(): void;\n}\n\n/** @public */\nexport type GeoSplineLike = GeoSpline | GeoSplinePoints;\n\n/** @public */\nexport const GeoSplineLike = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoSplineLike {\n    return instance instanceof GeoSpline\n        || GeoSplinePoints[Symbol.hasInstance](instance);\n  },\n};\n\n/** @public */\nexport type GeoSplinePoints = readonly GeoPointLike[];\n\n/** @public */\nexport const GeoSplinePoints = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoSplinePoints {\n    return Array.isArray(instance) && instance.length >= 2\n        && GeoPointLike[Symbol.hasInstance](instance[0]!);\n  },\n};\n\n/** @public */\nexport class GeoSpline extends GeoCurve implements Debug {\n  constructor(curves: readonly GeoCurve[], closed: boolean) {\n    super();\n    this.curves = curves;\n    this.closed = closed;\n    this.boundingBox = null;\n  }\n\n  override likeType?(like: GeoSplinePoints): void;\n\n  readonly curves: readonly GeoCurve[];\n\n  /** @internal */\n  readonly closed: boolean;\n\n  override isDefined(): boolean {\n    return this.curves.length !== 0;\n  }\n\n  isClosed(): boolean {\n    return this.closed;\n  }\n\n  override get lngMin(): number {\n    return this.bounds.lngMin;\n  }\n\n  override get latMin(): number {\n    return this.bounds.latMin;\n  }\n\n  override get lngMax(): number {\n    return this.bounds.lngMax;\n  }\n\n  override get latMax(): number {\n    return this.bounds.latMax;\n  }\n\n  override interpolateLng(u: number): number {\n    const curves = this.curves;\n    const n = curves.length;\n    if (n === 0) {\n      return NaN;\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n);\n    const v = u * n - k * l;\n    return curves[k]!.interpolateLng(v);\n  }\n\n  override interpolateLat(u: number): number {\n    const curves = this.curves;\n    const n = curves.length;\n    if (n === 0) {\n      return NaN;\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n);\n    const v = u * n - k * l;\n    return curves[k]!.interpolateLat(v);\n  }\n\n  override interpolate(u: number): GeoPoint {\n    const curves = this.curves;\n    const n = curves.length;\n    if (n === 0) {\n      return GeoPoint.undefined();\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n);\n    const v = u * n - k * l;\n    return curves[k]!.interpolate(v);\n  }\n\n  override contains(that: GeoShapeLike): boolean;\n  override contains(lng: number, lat: number): boolean;\n  override contains(that: GeoShapeLike | number, lat?: number): boolean {\n    return false; // TODO\n  }\n\n  override intersects(that: GeoShapeLike): boolean {\n    return false; // TODO\n  }\n\n  override split(u: number): [GeoSpline, GeoSpline] {\n    const curves = this.curves;\n    const n = curves.length;\n    if (n === 0) {\n      return [GeoSpline.empty(), GeoSpline.empty()];\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n);\n    const v = u * n - k * l;\n    const [c0, c1] = curves[k]!.split(v);\n    const curves0 = new Array<GeoCurve>(k + 1);\n    const curves1 = new Array<GeoCurve>(n - k);\n    for (let i = 0; i < k; i += 1) {\n      curves0[i] = curves[i]!;\n    }\n    curves0[k] = c0;\n    curves1[0] = c1;\n    for (let i = k + 1; i < n; i += 1) {\n      curves1[i - k] = curves[i]!;\n    }\n    return [new GeoSpline(curves0, false), new GeoSpline(curves1, false)];\n  }\n\n  subdivide(u: number): GeoSpline {\n    const oldCurves = this.curves;\n    const n = oldCurves.length;\n    if (n === 0) {\n      return GeoSpline.empty();\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n);\n    const v = u * n - k * l;\n    const [c0, c1] = oldCurves[k]!.split(v);\n    const newCurves = new Array<GeoCurve>(n + 1);\n    for (let i = 0; i < k; i += 1) {\n      newCurves[i] = oldCurves[i]!;\n    }\n    newCurves[k] = c0;\n    newCurves[k + 1] = c1;\n    for (let i = k + 1; i < n; i += 1) {\n      newCurves[i + 1] = oldCurves[i]!;\n    }\n    return new GeoSpline(newCurves, this.closed);\n  }\n\n  override project(f: GeoProjection): R2Spline {\n    const oldCurves = this.curves;\n    const n = oldCurves.length;\n    if (n === 0) {\n      return R2Spline.empty();\n    }\n\n    let i = 0;\n    const newCurves = new Array<R2Curve>(n);\n\n    // project leading adjacent segments\n    let curve = oldCurves[0]!;\n    if (curve instanceof GeoSegment) {\n      // project first point\n      let p0 = f.project(curve.lng0, curve.lat0);\n      while (i < n) {\n        curve = oldCurves[i]!;\n        if (!(curve instanceof GeoSegment)) {\n          break;\n        }\n        // project next point\n        const p1 = f.project(curve.lng1, curve.lat1);\n        newCurves[i] = new R2Segment(p0.x, p0.y, p1.x, p1.y);\n        p0 = p1;\n        i += 1;\n      }\n    }\n\n    // project any remaining curves\n    while (i < n) {\n      curve = oldCurves[i]!;\n      newCurves[i] = curve.project(f);\n      i += 1;\n    }\n\n    return new R2Spline(newCurves, this.closed);\n  }\n\n  /** @internal */\n  readonly boundingBox: GeoBox | null;\n\n  override get bounds(): GeoBox {\n    let boundingBox = this.boundingBox;\n    if (boundingBox === null) {\n      let lngMin = Infinity;\n      let latMin = Infinity;\n      let lngMax = -Infinity;\n      let latMax = -Infinity;\n      const curves = this.curves;\n      for (let i = 0; i < curves.length; i += 1) {\n        const curve = curves[i]!;\n        lngMin = Math.min(lngMin, curve.lngMin);\n        latMin = Math.min(latMin, curve.latMin);\n        lngMax = Math.max(curve.lngMax, lngMax);\n        latMax = Math.max(curve.latMax, latMax);\n      }\n      boundingBox = new GeoBox(lngMin, latMin, lngMax, latMax);\n      (this as Mutable<this>).boundingBox = boundingBox;\n    }\n    return boundingBox;\n  }\n\n  override forEachCoord<R>(callback: (lng: number, lat: number) => R | void): R | undefined;\n  override forEachCoord<R, S>(callback: (this: S, lng: number, lat: number) => R | void, thisArg: S): R | undefined;\n  override forEachCoord<R, S>(callback: (this: S | undefined, lng: number, lat: number) => R | void, thisArg?: S): R | undefined {\n    const curves = this.curves;\n    const n = curves.length;\n    if (n === 0) {\n      return void 0;\n    }\n    let curve = curves[0]!;\n    let result = curve.forEachCoord(callback, thisArg);\n    if (result !== void 0) {\n      return result;\n    }\n    for (let i = 1; i < n; i += 1) {\n      curve = curves[i]!;\n      result = curve.forEachCoordRest(callback, thisArg);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return void 0;\n  }\n\n  override forEachCoordRest<R>(callback: (lng: number, lat: number) => R | void): R | undefined;\n  override forEachCoordRest<R, S>(callback: (this: S, lng: number, lat: number) => R | void, thisArg: S): R | undefined;\n  override forEachCoordRest<R, S>(callback: (this: S | undefined, lng: number, lat: number) => R | void, thisArg?: S): R | undefined {\n    const curves = this.curves;\n    for (let i = 0; i < curves.length; i += 1) {\n      const curve = curves[i]!;\n      const result = curve.forEachCoordRest(callback, thisArg);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return void 0;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeoSpline) {\n      return Arrays.equivalent(this.curves, that.curves, epsilon)\n          && this.closed === that.closed;\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeoSpline) {\n      return Arrays.equal(this.curves, that.curves)\n          && this.closed === that.closed;\n    }\n    return false;\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    const curves = this.curves;\n    const n = curves.length;\n    output = output.write(\"GeoSpline\").write(46/*'.'*/);\n    if (n === 0) {\n      output = output.write(\"empty\").write(40/*'('*/);\n    } else if (n !== 0) {\n      output = output.write(this.closed ? \"closed\" : \"open\").write(40/*'('*/);\n      output = output.debug(curves[0]!);\n      for (let i = 1; i < n; i += 1) {\n        output = output.write(\", \").debug(curves[i]!);\n      }\n    }\n    output = output.write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n\n  static builder(): GeoSplineBuilder {\n    return new GeoSplineBuilder();\n  }\n\n  @Lazy\n  static empty(): GeoSpline {\n    return new GeoSpline(Arrays.empty(), false);\n  }\n\n  static open(...curves: GeoCurve[]): GeoSpline {\n    return new GeoSpline(curves, false);\n  }\n\n  static closed(...curves: GeoCurve[]): GeoSpline {\n    return new GeoSpline(curves, true);\n  }\n\n  static override fromLike<T extends GeoSplineLike | null | undefined>(value: T): GeoSpline | Uninitable<T>;\n  static override fromLike<T extends GeoShapeLike | null | undefined>(value: T): never;\n  static override fromLike<T extends GeoSplineLike | null | undefined>(value: T): GeoSpline | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof GeoSpline) {\n      return value as GeoSpline | Uninitable<T>;\n    } else if (GeoSplinePoints[Symbol.hasInstance](value)) {\n      return GeoSpline.fromPoints(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromPoints(points: GeoSplinePoints): GeoSpline {\n    const n = points.length;\n    if (n === 0 || n === 1) {\n      return GeoSpline.empty();\n    }\n    const curves = new Array<GeoCurve>(n - 1);\n    const p0 = GeoPoint.fromLike(points[0]!);\n    let p1 = p0;\n    for (let i = 1; i < n; i += 1) {\n      const p2 = GeoPoint.fromLike(points[i]!);\n      curves[i - 1] = new GeoSegment(p1.lng, p1.lat, p2.lng, p2.lat);\n      p1 = p2;\n    }\n    const closed = p0.equals(p1);\n    return new GeoSpline(curves, closed);\n  }\n}\n\n/** @public */\nexport class GeoSplineBuilder implements GeoSplineContext {\n  /** @internal */\n  curves: GeoCurve[];\n  /** @internal */\n  closed: boolean;\n  /** @internal */\n  aliased: boolean;\n  /** @internal */\n  lng0: number;\n  /** @internal */\n  lat0: number;\n  /** @internal */\n  lng: number;\n  /** @internal */\n  lat: number;\n\n  constructor() {\n    this.curves = [];\n    this.closed = false;\n    this.aliased = false;\n    this.lng0 = 0;\n    this.lat0 = 0;\n    this.lng = 0;\n    this.lat = 0;\n  }\n\n  private dealias(): void {\n    if (!this.aliased) {\n      return;\n    }\n    this.curves = this.curves.slice(0);\n    this.aliased = false;\n  }\n\n  moveTo(lng: number, lat: number): void {\n    if (this.aliased) {\n      this.curves = [];\n      this.aliased = false;\n    } else {\n      this.curves.length = 0;\n    }\n    this.closed = false;\n    this.lng0 = lng;\n    this.lat0 = lat;\n    this.lng = lng;\n    this.lat = lat;\n  }\n\n  closePath(): void {\n    this.dealias();\n    this.curves.push(new GeoSegment(this.lng, this.lat, this.lng0, this.lat0));\n    this.closed = true;\n    this.lng = this.lng0;\n    this.lat = this.lat0;\n  }\n\n  lineTo(lng: number, lat: number): void {\n    this.dealias();\n    this.curves.push(new GeoSegment(this.lng, this.lat, lng, lat));\n    this.lng = lng;\n    this.lat = lat;\n  }\n\n  build(): GeoSpline {\n    this.aliased = true;\n    return new GeoSpline(this.curves, this.closed);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport {Arrays} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport type {R2Spline} from \"@swim/math\";\nimport {R2Path} from \"@swim/math\";\nimport type {GeoProjection} from \"./GeoProjection\";\nimport type {GeoShapeLike} from \"./GeoShape\";\nimport {GeoShape} from \"./GeoShape\";\nimport {GeoPoint} from \"./GeoPoint\";\nimport type {GeoCurve} from \"./GeoCurve\";\nimport type {GeoSplineContext} from \"./GeoSpline\";\nimport {GeoSplineLike} from \"./GeoSpline\";\nimport {GeoSplinePoints} from \"./GeoSpline\";\nimport {GeoSplineBuilder} from \"./GeoSpline\";\nimport {GeoSpline} from \"./GeoSpline\";\nimport {GeoBox} from \"./\"; // forward import\n\n/** @public */\nexport interface GeoPathContext extends GeoSplineContext {\n}\n\n/** @public */\nexport type GeoPathLike = GeoPath | GeoPathSplines | GeoSplinePoints;\n\n/** @public */\nexport const GeoPathLike = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoPathLike {\n    return instance instanceof GeoPath\n        || GeoPathSplines[Symbol.hasInstance](instance);\n  },\n};\n\n/** @public */\nexport const GeoPathSplines = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoPathSplines {\n    return Array.isArray(instance) && instance.length !== 0\n        && GeoSplinePoints[Symbol.hasInstance](instance[0]!);\n  },\n};\n\n/** @public */\nexport type GeoPathSplines = readonly GeoSplineLike[];\n\n/** @public */\nexport class GeoPath extends GeoShape implements Debug {\n  constructor(splines: readonly GeoSpline[]) {\n    super();\n    this.splines = splines;\n    this.boundingBox = null;\n  }\n\n  /** @internal */\n  declare readonly typeid?: \"GeoPath\";\n\n  override likeType?(like: GeoPathSplines | GeoSplinePoints): void;\n\n  override isDefined(): boolean {\n    return this.splines.length !== 0;\n  }\n\n  isClosed(): boolean {\n    const splines = this.splines;\n    if (splines.length === 0) {\n      return false;\n    }\n    for (let i = 0; i < splines.length; i += 1) {\n      const spline = splines[i]!;\n      if (!spline.isClosed()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  readonly splines: readonly GeoSpline[];\n\n  override get lngMin(): number {\n    return this.bounds.lngMin;\n  }\n\n  override get latMin(): number {\n    return this.bounds.latMin;\n  }\n\n  override get lngMax(): number {\n    return this.bounds.lngMax;\n  }\n\n  override get latMax(): number {\n    return this.bounds.latMax;\n  }\n\n  interpolateLng(u: number): number {\n    const splines = this.splines;\n    const n = splines.length;\n    if (n === 0) {\n      return NaN;\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n);\n    const v = u * n - k * l;\n    return splines[k]!.interpolateLng(v);\n  }\n\n  interpolateLat(u: number): number {\n    const splines = this.splines;\n    const n = splines.length;\n    if (n === 0) {\n      return NaN;\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n);\n    const v = u * n - k * l;\n    return splines[k]!.interpolateLat(v);\n  }\n\n  interpolate(u: number): GeoPoint {\n    const splines = this.splines;\n    const n = splines.length;\n    if (n === 0) {\n      return GeoPoint.undefined();\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n);\n    const v = u * n - k * l;\n    return splines[k]!.interpolate(v);\n  }\n\n  override contains(that: GeoShapeLike): boolean;\n  override contains(x: number, y: number): boolean;\n  override contains(that: GeoShapeLike | number, y?: number): boolean {\n    return false; // TODO\n  }\n\n  override intersects(that: GeoShapeLike): boolean {\n    return false; // TODO\n  }\n\n  split(u: number): [GeoPath, GeoPath] {\n    const splines = this.splines;\n    const n = splines.length;\n    if (n === 0) {\n      return [GeoPath.empty(), GeoPath.empty()];\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n);\n    const v = u * n - k * l;\n    const [s0, s1] = splines[k]!.split(v);\n    const splines0 = new Array<GeoSpline>(k + 1);\n    const splines1 = new Array<GeoSpline>(n - k);\n    for (let i = 0; i < k; i += 1) {\n      splines0[i] = splines[i]!;\n    }\n    splines0[k] = s0;\n    splines1[0] = s1;\n    for (let i = k + 1; i < n; i += 1) {\n      splines1[i - k] = splines[i]!;\n    }\n    return [new GeoPath(splines0), new GeoPath(splines1)];\n  }\n\n  subdivide(u: number): GeoPath {\n    const oldSplines = this.splines;\n    const n = oldSplines.length;\n    if (n === 0) {\n      return GeoPath.empty();\n    }\n    const l = 1 / n;\n    const k = Math.min(Math.max(0, Math.floor(u / l)), n);\n    const v = u * n - k * l;\n    const newSplines = new Array<GeoSpline>(n);\n    for (let i = 0; i < k; i += 1) {\n      newSplines[i] = oldSplines[i]!;\n    }\n    newSplines[k] = oldSplines[k]!.subdivide(v);\n    for (let i = k + 1; i < n; i += 1) {\n      newSplines[i] = oldSplines[i]!;\n    }\n    return new GeoPath(newSplines);\n  }\n\n  override project(f: GeoProjection): R2Path {\n    const oldSplines = this.splines;\n    const n = oldSplines.length;\n    if (n === 0) {\n      return R2Path.empty();\n    }\n    const newSplines = new Array<R2Spline>(n);\n    for (let i = 0; i < n; i += 1) {\n      newSplines[i] = oldSplines[i]!.project(f);\n    }\n    return new R2Path(newSplines);\n  }\n\n  /** @internal */\n  readonly boundingBox: GeoBox | null;\n\n  override get bounds(): GeoBox {\n    let boundingBox = this.boundingBox;\n    if (boundingBox === null) {\n      let lngMin = Infinity;\n      let latMin = Infinity;\n      let lngMax = -Infinity;\n      let latMax = -Infinity;\n      const splines = this.splines;\n      for (let i = 0; i < splines.length; i += 1) {\n        const spline = splines[i]!;\n        lngMin = Math.min(lngMin, spline.lngMin);\n        latMin = Math.min(latMin, spline.latMin);\n        lngMax = Math.max(spline.lngMax, lngMax);\n        latMax = Math.max(spline.latMax, latMax);\n      }\n      boundingBox = new GeoBox(lngMin, latMin, lngMax, latMax);\n      (this as Mutable<this>).boundingBox = boundingBox;\n    }\n    return boundingBox;\n  }\n\n  centroid(): GeoPoint {\n    let lngSum = 0;\n    let latSum = 0;\n    let n = 0;\n    this.forEachCoord(function (lng: number, lat: number): void {\n      lngSum += lng;\n      latSum += lat;\n      n += 1;\n    }, this);\n    if (n === 0) {\n      return GeoPoint.undefined();\n    }\n    return new GeoPoint(lngSum / n, latSum / n);\n  }\n\n  forEachCoord<R>(callback: (lng: number, lat: number) => R | void): R | undefined;\n  forEachCoord<R, S>(callback: (this: S, lng: number, lat: number) => R | void, thisArg: S): R | undefined;\n  forEachCoord<R, S>(callback: (this: S | undefined, lng: number, lat: number) => R | void, thisArg?: S): R | undefined {\n    const splines = this.splines;\n    for (let i = 0; i < splines.length; i += 1) {\n      const spline = splines[i]!;\n      const result = spline.forEachCoord(callback, thisArg);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return void 0;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeoPath) {\n      return Arrays.equivalent(this.splines, that.splines, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeoPath) {\n      return Arrays.equal(this.splines, that.splines);\n    }\n    return false;\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    const splines = this.splines;\n    const n = splines.length;\n    output = output.write(\"GeoPath\").write(46/*'.'*/);\n    if (n === 0) {\n      output = output.write(\"empty\").write(40/*'('*/);\n    } else if (n === 1) {\n      const spline = splines[0]!;\n      output = output.write(spline.closed ? \"closed\" : \"open\").write(40/*'('*/);\n      const curves = spline.curves;\n      const m = curves.length;\n      if (m !== 0) {\n        output = output.debug(curves[0]!);\n        for (let i = 1; i < m; i += 1) {\n          output = output.write(\", \").debug(curves[i]!);\n        }\n      }\n    } else {\n      output = output.write(\"of\").write(40/*'('*/);\n      output = output.debug(splines[0]!);\n      for (let i = 1; i < n; i += 1) {\n        output = output.write(\", \").debug(splines[i]!);\n      }\n    }\n    output = output.write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n\n  static builder(): GeoPathBuilder {\n    return new GeoPathBuilder();\n  }\n\n  @Lazy\n  static empty(): GeoPath {\n    return new GeoPath(Arrays.empty());\n  }\n\n  static of(...splines: GeoSpline[]): GeoPath {\n    return new GeoPath(splines);\n  }\n\n  static open(...curves: GeoCurve[]): GeoPath {\n    return new GeoPath([new GeoSpline(curves, false)]);\n  }\n\n  static closed(...curves: GeoCurve[]): GeoPath {\n    return new GeoPath([new GeoSpline(curves, true)]);\n  }\n\n  static override fromLike<T extends GeoPathLike | null | undefined>(value: T): GeoPath | Uninitable<T>;\n  static override fromLike<T extends GeoShapeLike | null | undefined>(value: T): never;\n  static override fromLike<T extends GeoPathLike | null | undefined>(value: T): GeoPath | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof GeoPath) {\n      return value as GeoPath | Uninitable<T>;\n    } else if (GeoPathSplines[Symbol.hasInstance](value)) {\n      return GeoPath.fromSplines(value);\n    } else if (GeoSplineLike[Symbol.hasInstance](value)) {\n      return GeoPath.of(GeoSpline.fromLike(value as GeoSplineLike));\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromSplines(values: GeoPathSplines): GeoPath {\n    const n = values.length;\n    const splines = new Array<GeoSpline>(n);\n    for (let i = 0; i < n; i += 1) {\n      splines[i] = GeoSpline.fromLike(values[i]!);\n    }\n    return new GeoPath(splines);\n  }\n\n  static fromPoints(points: GeoSplinePoints): GeoPath {\n    return new GeoPath([GeoSpline.fromPoints(points)]);\n  }\n}\n\n/** @public */\nexport class GeoPathBuilder implements GeoPathContext {\n  /** @internal */\n  splines: GeoSpline[];\n  /** @internal */\n  builder: GeoSplineBuilder | null;\n\n  constructor() {\n    this.splines = [];\n    this.builder = null;\n  }\n\n  moveTo(lng: number, lat: number): void {\n    let builder = this.builder;\n    if (builder !== null) {\n      const spline = builder.build();\n      if (spline.isDefined()) {\n        this.splines.push(spline);\n      }\n    }\n    builder = new GeoSplineBuilder();\n    this.builder = builder;\n    builder.moveTo(lng, lat);\n  }\n\n  closePath(): void {\n    const builder = this.builder;\n    if (builder === null) {\n      throw new Error();\n    }\n    builder.closePath();\n  }\n\n  lineTo(lng: number, lat: number): void {\n    const builder = this.builder;\n    if (builder === null) {\n      throw new Error();\n    }\n    builder.lineTo(lng, lat);\n  }\n\n  build(): GeoPath {\n    const splines = this.splines.slice(0);\n    const builder = this.builder;\n    if (builder !== null) {\n      const spline = builder.build();\n      if (spline.isDefined()) {\n        splines.push(spline);\n      }\n    }\n    return new GeoPath(splines);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport {R2Box} from \"@swim/math\";\nimport type {GeoProjection} from \"./GeoProjection\";\nimport type {GeoShapeLike} from \"./GeoShape\";\nimport {GeoShape} from \"./GeoShape\";\nimport {GeoPointLike} from \"./GeoPoint\";\nimport {GeoPoint} from \"./GeoPoint\";\nimport {GeoSegmentLike} from \"./GeoSegment\";\nimport {GeoSegment} from \"./GeoSegment\";\nimport {GeoBoxLike} from \"./\"; // forward import\nimport {GeoBox} from \"./\"; // forward import\n\n/** @public */\nexport type GeoTileLike = GeoTile | GeoTileInit | GeoTileTuple;\n\n/** @public */\nexport const GeoTileLike = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoTileLike {\n    return instance instanceof GeoTile\n        || GeoTileInit[Symbol.hasInstance](instance)\n        || GeoTileTuple[Symbol.hasInstance](instance);\n  },\n};\n\n/** @public */\nexport interface GeoTileInit {\n  /** @internal */\n  readonly typeid?: \"GeoTileInit\";\n  x: number;\n  y: number;\n  z: number;\n}\n\n/** @public */\nexport const GeoTileInit = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoTileInit {\n    return Objects.hasAllKeys<GeoTileInit>(instance, \"x\", \"y\", \"z\");\n  },\n};\n\n/** @public */\nexport type GeoTileTuple = [number, number, number];\n\n/** @public */\nexport const GeoTileTuple = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoTileTuple {\n    return Array.isArray(instance) && instance.length === 3;\n  },\n};\n\n/** @public */\nexport class GeoTile extends GeoShape implements HashCode, Debug {\n  constructor(x: number, y: number, z: number) {\n    super();\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  /** @internal */\n  declare readonly typeid?: \"GeoTile\";\n\n  override likeType?(like: GeoTileInit | GeoTileTuple): void;\n\n  override isDefined(): boolean {\n    return true;\n  }\n\n  readonly x: number;\n\n  readonly y: number;\n\n  readonly z: number;\n\n  override get lngMin(): number {\n    return GeoTile.unprojectX(this.x / (1 << this.z));\n  }\n\n  override get latMin(): number {\n    return GeoTile.unprojectY(this.y / (1 << this.z));\n  }\n\n  override get lngMax(): number {\n    return GeoTile.unprojectX((this.x + 1) / (1 << this.z));\n  }\n\n  override get latMax(): number {\n    return GeoTile.unprojectY((this.y + 1) / (1 << this.z));\n  }\n\n  get west(): number {\n    return this.lngMin;\n  }\n\n  get south(): number {\n    return this.latMin;\n  }\n\n  get east(): number {\n    return this.lngMax;\n  }\n\n  get north(): number {\n    return this.latMax;\n  }\n\n  get southWest(): GeoPoint {\n    return new GeoPoint(this.lngMin, this.latMin);\n  }\n\n  get northWest(): GeoPoint {\n    return new GeoPoint(this.lngMin, this.latMax);\n  }\n\n  get southEast(): GeoPoint {\n    return new GeoPoint(this.lngMax, this.latMin);\n  }\n\n  get northEast(): GeoPoint {\n    return new GeoPoint(this.lngMax, this.latMax);\n  }\n\n  get center(): GeoPoint {\n    return new GeoPoint((this.lngMin + this.lngMax) / 2,\n                        (this.latMin + this.latMax) / 2);\n  }\n\n  get southWestTile(): GeoTile {\n    return new GeoTile(this.x * 2, this.y * 2, this.z + 1);\n  }\n\n  get northWestTile(): GeoTile {\n    return new GeoTile(this.x * 2, this.y * 2 + 1, this.z + 1);\n  }\n\n  get southEastTile(): GeoTile {\n    return new GeoTile(this.x * 2 + 1, this.y * 2, this.z + 1);\n  }\n\n  get northEastTile(): GeoTile {\n    return new GeoTile(this.x * 2 + 1, this.y * 2 + 1, this.z + 1);\n  }\n\n  get parentTile(): GeoTile {\n    return new GeoTile(this.x >> 1, this.y >> 1, this.z - 1);\n  }\n\n  override contains(that: GeoShapeLike): boolean;\n  override contains(lng: number, lat: number): boolean;\n  override contains(that: GeoShapeLike | number, lat?: number): boolean {\n    if (typeof that === \"number\") {\n      return this.lngMin <= that && that <= this.lngMax\n          && this.latMin <= lat! && lat! <= this.latMax;\n    } else if (GeoPointLike[Symbol.hasInstance](that)) {\n      return this.containsPoint(GeoPoint.fromLike(that));\n    } else if (GeoSegmentLike[Symbol.hasInstance](that)) {\n      return this.containsSegment(GeoSegment.fromLike(that));\n    } else if (GeoTileLike[Symbol.hasInstance](that)) {\n      return this.containsTile(GeoTile.fromLike(that));\n    } else if (GeoBoxLike[Symbol.hasInstance](that)) {\n      return this.containsBox(GeoBox.fromLike(that));\n    }\n    throw new TypeError(\"\" + that);\n  }\n\n  /** @internal */\n  containsPoint(that: GeoPoint): boolean {\n    return this.lngMin <= that.lng && that.lng <= this.lngMax\n        && this.latMin <= that.lat && that.lat <= this.latMax;\n  }\n\n  /** @internal */\n  containsSegment(that: GeoSegment): boolean {\n    return this.lngMin <= that.lng0 && that.lng0 <= this.lngMax\n        && this.latMin <= that.lat0 && that.lat0 <= this.latMax\n        && this.lngMin <= that.lng1 && that.lng1 <= this.lngMax\n        && this.latMin <= that.lat1 && that.lat1 <= this.latMax;\n  }\n\n  /** @internal */\n  containsTile(that: GeoTile): boolean {\n    return this.lngMin <= that.lngMin && that.lngMax <= this.lngMax\n        && this.latMin <= that.latMin && that.latMax <= this.latMax;\n  }\n\n  /** @internal */\n  containsBox(that: GeoBox): boolean {\n    return this.lngMin <= that.lngMin && that.lngMax <= this.lngMax\n        && this.latMin <= that.latMin && that.latMax <= this.latMax;\n  }\n\n  override intersects(that: GeoShapeLike): boolean {\n    if (GeoPointLike[Symbol.hasInstance](that)) {\n      return this.intersectsPoint(GeoPoint.fromLike(that));\n    } else if (GeoSegmentLike[Symbol.hasInstance](that)) {\n      return this.intersectsSegment(GeoSegment.fromLike(that));\n    } else if (GeoTileLike[Symbol.hasInstance](that)) {\n      return this.intersectsTile(GeoTile.fromLike(that));\n    } else if (GeoBoxLike[Symbol.hasInstance](that)) {\n      return this.intersectsBox(GeoBox.fromLike(that));\n    }\n    throw new TypeError(\"\" + that);\n  }\n\n  /** @internal */\n  intersectsPoint(that: GeoPoint): boolean {\n    return this.lngMin <= that.lng && that.lng <= this.lngMax\n        && this.latMin <= that.lat && that.lat <= this.latMax;\n  }\n\n  /** @internal */\n  intersectsSegment(that: GeoSegment): boolean {\n    const lngMin = this.lngMin;\n    const latMin = this.latMin;\n    const lngMax = this.lngMax;\n    const latMax = this.latMax;\n    const lng0 = that.lng0;\n    const lat0 = that.lat0;\n    const lng1 = that.lng1;\n    const lat1 = that.lat1;\n    if (lng0 < lngMin && lng1 < lngMin || lng0 > lngMax && lng1 > lngMax ||\n        lat0 < latMin && lat1 < latMin || lat0 > latMax && lat1 > latMax) {\n      return false;\n    } else if (lng0 > lngMin && lng0 < lngMax && lat0 > latMin && lat0 < latMax) {\n      return true;\n    } else if ((R2Box.intersectsSegment(lng0 - lngMin, lng1 - lngMin, lng0, lat0, lng1, lat1) && R2Box.hitY > latMin && R2Box.hitY < latMax)\n            || (R2Box.intersectsSegment(lat0 - latMin, lat1 - latMin, lng0, lat0, lng1, lat1) && R2Box.hitX > lngMin && R2Box.hitX < lngMax)\n            || (R2Box.intersectsSegment(lng0 - lngMax, lng1 - lngMax, lng0, lat0, lng1, lat1) && R2Box.hitY > latMin && R2Box.hitY < latMax)\n            || (R2Box.intersectsSegment(lat0 - latMax, lat1 - latMax, lng0, lat0, lng1, lat1) && R2Box.hitX > lngMin && R2Box.hitX < lngMax)) {\n      return true;\n    }\n    return false;\n  }\n\n  /** @internal */\n  intersectsTile(that: GeoTile): boolean {\n    return this.lngMin <= that.lngMax && that.lngMin <= this.lngMax\n        && this.latMin <= that.latMax && that.latMin <= this.latMax;\n  }\n\n  /** @internal */\n  intersectsBox(that: GeoBox): boolean {\n    return this.lngMin <= that.lngMax && that.lngMin <= this.lngMax\n        && this.latMin <= that.latMax && that.latMin <= this.latMax;\n  }\n\n  override project(f: GeoProjection): R2Box {\n    const bottomLeft = f.project(this.lngMin, this.latMin);\n    const topRight = f.project(this.lngMax, this.latMax);\n    let xMin = bottomLeft.x;\n    let yMin = bottomLeft.y;\n    let xMax = topRight.x;\n    let yMax = topRight.y;\n    if (xMin > xMax) {\n      const x = xMin;\n      xMin = xMax;\n      xMax = x;\n    }\n    if (yMin > yMax) {\n      const y = yMin;\n      yMin = yMax;\n      yMax = y;\n    }\n    if (!isFinite(xMin)) {\n      xMin = -Infinity;\n    }\n    if (!isFinite(yMin)) {\n      yMin = -Infinity;\n    }\n    if (!isFinite(xMax)) {\n      xMax = Infinity;\n    }\n    if (!isFinite(yMax)) {\n      yMax = Infinity;\n    }\n    return new R2Box(xMin, yMin, xMax, yMax);\n  }\n\n  toLike(): GeoTileInit {\n    return {\n      x: this.x,\n      y: this.y,\n      z: this.z,\n    };\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeoTile) {\n      return Numbers.equivalent(this.x, that.x, epsilon)\n          && Numbers.equivalent(this.y, that.y, epsilon)\n          && Numbers.equivalent(this.z, that.z, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeoTile) {\n      return this.x === that.x && this.y === that.y && this.z === that.z;\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Constructors.hash(GeoTile),\n        Numbers.hash(this.x)), Numbers.hash(this.y)), Numbers.hash(this.z)));\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"GeoTile\").write(46/*'.'*/).write(\"of\").write(40/*'('*/)\n                   .debug(this.x).write(\", \").debug(this.y).write(\", \")\n                   .debug(this.z).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n\n  @Lazy\n  static root(): GeoTile {\n    return new GeoTile(0, 0, 0);\n  }\n\n  static of(x: number, y: number, z: number): GeoTile {\n    return new GeoTile(x, y, z);\n  }\n\n  static override fromLike<T extends GeoTileLike | null | undefined>(value: T): GeoTile | Uninitable<T>;\n  static override fromLike<T extends GeoShapeLike | null | undefined>(value: T): never;\n  static override fromLike<T extends GeoTileLike | null | undefined>(value: T): GeoTile | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof GeoTile) {\n      return value as GeoTile | Uninitable<T>;\n    } else if (GeoTileInit[Symbol.hasInstance](value)) {\n      return GeoTile.fromInit(value);\n    } else if (GeoTileTuple[Symbol.hasInstance](value)) {\n      return GeoTile.fromTuple(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromInit(init: GeoTileInit): GeoTile {\n    return new GeoTile(init.x, init.y, init.z);\n  }\n\n  static fromTuple(tuple: GeoTileTuple): GeoTile {\n    return new GeoTile(tuple[0], tuple[1], tuple[2]);\n  }\n\n  /** @internal */\n  static unprojectX(x: number): number {\n    return (x * Math.PI * 2 - Math.PI) * (180 / Math.PI);\n  }\n\n  /** @internal */\n  static unprojectY(y: number): number {\n    return (Math.atan(Math.exp(y * Math.PI * 2 - Math.PI)) * 2 - Math.PI / 2) * (180 / Math.PI);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Interpolate} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport {R2Box} from \"@swim/math\";\nimport type {GeoProjection} from \"./GeoProjection\";\nimport type {GeoShapeLike} from \"./GeoShape\";\nimport {GeoShape} from \"./GeoShape\";\nimport {GeoPointLike} from \"./GeoPoint\";\nimport {GeoPoint} from \"./GeoPoint\";\nimport {GeoSegmentLike} from \"./GeoSegment\";\nimport {GeoSegment} from \"./GeoSegment\";\nimport {GeoTileLike} from \"./GeoTile\";\nimport {GeoTile} from \"./GeoTile\";\n\n/** @public */\nexport type GeoBoxLike = GeoBox | GeoBoxInit;\n\n/** @public */\nexport const GeoBoxLike = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoBoxLike {\n    return instance instanceof GeoBox\n        || GeoBoxInit[Symbol.hasInstance](instance);\n  },\n};\n\n/** @public */\nexport interface GeoBoxInit {\n  /** @internal */\n  readonly typeid?: \"GeoBoxInit\";\n  lngMin: number;\n  latMin: number;\n  lngMax: number;\n  latMax: number;\n}\n\n/** @public */\nexport const GeoBoxInit = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoBoxInit {\n    return Objects.hasAllKeys<GeoBoxInit>(instance, \"lngMin\", \"latMin\", \"lngMax\", \"latMax\");\n  },\n};\n\n/** @public */\nexport class GeoBox extends GeoShape implements Interpolate<GeoBox>, HashCode, Debug {\n  constructor(lngMin: number, latMin: number, lngMax: number, latMax: number) {\n    super();\n    this.lngMin = lngMin;\n    this.latMin = latMin;\n    this.lngMax = lngMax;\n    this.latMax = latMax;\n  }\n\n  /** @internal */\n  declare readonly typeid?: \"GeoBox\";\n\n  override likeType?(like: GeoBoxInit): void;\n\n  override isDefined(): boolean {\n    return isFinite(this.lngMin) && isFinite(this.latMin)\n        && isFinite(this.lngMax) && isFinite(this.latMax);\n  }\n\n  readonly lngMin: number;\n\n  readonly latMin: number;\n\n  readonly lngMax: number;\n\n  readonly latMax: number;\n\n  get west(): number {\n    return this.lngMin;\n  }\n\n  get south(): number {\n    return this.latMin;\n  }\n\n  get east(): number {\n    return this.lngMax;\n  }\n\n  get north(): number {\n    return this.latMax;\n  }\n\n  get southWest(): GeoPoint {\n    return new GeoPoint(this.lngMin, this.latMin);\n  }\n\n  get northWest(): GeoPoint {\n    return new GeoPoint(this.lngMin, this.latMax);\n  }\n\n  get southEast(): GeoPoint {\n    return new GeoPoint(this.lngMax, this.latMin);\n  }\n\n  get northEast(): GeoPoint {\n    return new GeoPoint(this.lngMax, this.latMax);\n  }\n\n  get center(): GeoPoint {\n    return new GeoPoint((this.lngMin + this.lngMax) / 2,\n                        (this.latMin + this.latMax) / 2);\n  }\n\n  override contains(that: GeoPointLike | GeoBoxLike): boolean;\n  override contains(lng: number, lat: number): boolean;\n  override contains(that: GeoPointLike | GeoBoxLike | number, y?: number): boolean {\n    if (typeof that === \"number\") {\n      return this.lngMin <= that && that <= this.lngMax\n          && this.latMin <= y! && y! <= this.latMax;\n    } else if (GeoPointLike[Symbol.hasInstance](that)) {\n      return this.containsPoint(GeoPoint.fromLike(that));\n    } else if (GeoSegmentLike[Symbol.hasInstance](that)) {\n      return this.containsSegment(GeoSegment.fromLike(that));\n    } else if (GeoTileLike[Symbol.hasInstance](that)) {\n      return this.containsTile(GeoTile.fromLike(that));\n    } else if (GeoBoxLike[Symbol.hasInstance](that)) {\n      return this.containsBox(GeoBox.fromLike(that));\n    }\n    throw new TypeError(\"\" + that);\n  }\n\n  /** @internal */\n  containsPoint(that: GeoPoint): boolean {\n    return this.lngMin <= that.lng && that.lng <= this.lngMax\n        && this.latMin <= that.lat && that.lat <= this.latMax;\n  }\n\n  /** @internal */\n  containsSegment(that: GeoSegment): boolean {\n    return this.lngMin <= that.lng0 && that.lng0 <= this.lngMax\n        && this.latMin <= that.lat0 && that.lat0 <= this.latMax\n        && this.lngMin <= that.lng1 && that.lng1 <= this.lngMax\n        && this.latMin <= that.lat1 && that.lat1 <= this.latMax;\n  }\n\n  /** @internal */\n  containsTile(that: GeoTile): boolean {\n    return this.lngMin <= that.lngMin && that.lngMax <= this.lngMax\n        && this.latMin <= that.latMin && that.latMax <= this.latMax;\n  }\n\n  /** @internal */\n  containsBox(that: GeoBox): boolean {\n    return this.lngMin <= that.lngMin && that.lngMax <= this.lngMax\n        && this.latMin <= that.latMin && that.latMax <= this.latMax;\n  }\n\n  override intersects(that: GeoPointLike | GeoBoxLike): boolean {\n    if (GeoPointLike[Symbol.hasInstance](that)) {\n      return this.intersectsPoint(GeoPoint.fromLike(that));\n    } else if (GeoSegmentLike[Symbol.hasInstance](that)) {\n      return this.intersectsSegment(GeoSegment.fromLike(that));\n    } else if (GeoTileLike[Symbol.hasInstance](that)) {\n      return this.intersectsTile(GeoTile.fromLike(that));\n    } else if (GeoBoxLike[Symbol.hasInstance](that)) {\n      return this.intersectsBox(GeoBox.fromLike(that));\n    }\n    throw new TypeError(\"\" + that);\n  }\n\n  /** @internal */\n  intersectsPoint(that: GeoPoint): boolean {\n    return this.lngMin <= that.lng && that.lng <= this.lngMax\n        && this.latMin <= that.lat && that.lat <= this.latMax;\n  }\n\n  /** @internal */\n  intersectsSegment(that: GeoSegment): boolean {\n    const lngMin = this.lngMin;\n    const latMin = this.latMin;\n    const lngMax = this.lngMax;\n    const latMax = this.latMax;\n    const lng0 = that.lng0;\n    const lat0 = that.lat0;\n    const lng1 = that.lng1;\n    const lat1 = that.lat1;\n    if (lng0 < lngMin && lng1 < lngMin || lng0 > lngMax && lng1 > lngMax ||\n        lat0 < latMin && lat1 < latMin || lat0 > latMax && lat1 > latMax) {\n      return false;\n    } else if (lng0 > lngMin && lng0 < lngMax && lat0 > latMin && lat0 < latMax) {\n      return true;\n    } else if ((R2Box.intersectsSegment(lng0 - lngMin, lng1 - lngMin, lng0, lat0, lng1, lat1) && R2Box.hitY > latMin && R2Box.hitY < latMax)\n            || (R2Box.intersectsSegment(lat0 - latMin, lat1 - latMin, lng0, lat0, lng1, lat1) && R2Box.hitX > lngMin && R2Box.hitX < lngMax)\n            || (R2Box.intersectsSegment(lng0 - lngMax, lng1 - lngMax, lng0, lat0, lng1, lat1) && R2Box.hitY > latMin && R2Box.hitY < latMax)\n            || (R2Box.intersectsSegment(lat0 - latMax, lat1 - latMax, lng0, lat0, lng1, lat1) && R2Box.hitX > lngMin && R2Box.hitX < lngMax)) {\n      return true;\n    }\n    return false;\n  }\n\n  /** @internal */\n  intersectsTile(that: GeoTile): boolean {\n    return this.lngMin <= that.lngMax && that.lngMin <= this.lngMax\n        && this.latMin <= that.latMax && that.latMin <= this.latMax;\n  }\n\n  /** @internal */\n  intersectsBox(that: GeoBox): boolean {\n    return this.lngMin <= that.lngMax && that.lngMin <= this.lngMax\n        && this.latMin <= that.latMax && that.latMin <= this.latMax;\n  }\n\n  override union(that: GeoShapeLike): GeoBox {\n    return super.union(that) as GeoBox;\n  }\n\n  override project(f: GeoProjection): R2Box {\n    const bottomLeft = f.project(this.lngMin, this.latMin);\n    const topRight = f.project(this.lngMax, this.latMax);\n    let xMin = bottomLeft.x;\n    let yMin = bottomLeft.y;\n    let xMax = topRight.x;\n    let yMax = topRight.y;\n    if (xMin > xMax) {\n      const x = xMin;\n      xMin = xMax;\n      xMax = x;\n    }\n    if (yMin > yMax) {\n      const y = yMin;\n      yMin = yMax;\n      yMax = y;\n    }\n    if (!isFinite(xMin)) {\n      xMin = -Infinity;\n    }\n    if (!isFinite(yMin)) {\n      yMin = -Infinity;\n    }\n    if (!isFinite(xMax)) {\n      xMax = Infinity;\n    }\n    if (!isFinite(yMax)) {\n      yMax = Infinity;\n    }\n    return new R2Box(xMin, yMin, xMax, yMax);\n  }\n\n  override get bounds(): GeoBox {\n    return this;\n  }\n\n  toLike(): GeoBoxInit {\n    return {\n      lngMin: this.lngMin,\n      latMin: this.latMin,\n      lngMax: this.lngMax,\n      latMax: this.latMax,\n    };\n  }\n\n  /** @override */\n  interpolateTo(that: GeoBox): Interpolator<GeoBox>;\n  interpolateTo(that: unknown): Interpolator<GeoBox> | null;\n  interpolateTo(that: unknown): Interpolator<GeoBox> | null {\n    if (that instanceof GeoBox) {\n      return GeoBoxInterpolator(this, that);\n    }\n    return null;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeoBox) {\n      return Numbers.equivalent(this.lngMin, that.lngMin, epsilon)\n          && Numbers.equivalent(this.latMin, that.latMin, epsilon)\n          && Numbers.equivalent(this.lngMax, that.lngMax, epsilon)\n          && Numbers.equivalent(this.latMax, that.latMax, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeoBox) {\n      return this.lngMin === that.lngMin && this.latMin === that.latMin\n          && this.lngMax === that.lngMax && this.latMax === that.latMax;\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(\n        Constructors.hash(GeoBox), Numbers.hash(this.lngMin)), Numbers.hash(this.latMin)),\n        Numbers.hash(this.lngMax)), Numbers.hash(this.latMax)));\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"GeoBox\").write(46/*'.'*/).write(\"of\").write(40/*'('*/)\n                   .debug(this.lngMin).write(\", \").debug(this.latMin).write(\", \")\n                   .debug(this.lngMax).write(\", \").debug(this.latMax).write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n\n  @Lazy\n  static undefined(): GeoBox {\n    return new GeoBox(Infinity, Infinity, -Infinity, -Infinity);\n  }\n\n  @Lazy\n  static globe(): GeoBox {\n    return new GeoBox(-180, -90, 180, 90);\n  }\n\n  static of(lngMin: number, latMin: number, lngMax?: number, latMax?: number): GeoBox {\n    if (lngMax === void 0) {\n      lngMax = lngMin;\n    }\n    if (latMax === void 0) {\n      latMax = latMin;\n    }\n    return new GeoBox(lngMin, latMin, lngMax, latMax);\n  }\n\n  static override fromLike<T extends GeoBoxLike | null | undefined>(value: T): GeoBox | Uninitable<T>;\n  static override fromLike<T extends GeoShapeLike | null | undefined>(value: T): never;\n  static override fromLike<T extends GeoBoxLike | null | undefined>(value: T): GeoBox | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof GeoBox) {\n      return value as GeoBox | Uninitable<T>;\n    } else if (GeoBoxInit[Symbol.hasInstance](value)) {\n      return GeoBox.fromInit(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromInit(init: GeoBoxInit): GeoBox {\n    return new GeoBox(init.lngMin, init.latMin, init.lngMax, init.latMax);\n  }\n}\n\n/** @internal */\nexport const GeoBoxInterpolator = (function (_super: typeof Interpolator) {\n  const GeoBoxInterpolator = function (s0: GeoBox, s1: GeoBox): Interpolator<GeoBox> {\n    const interpolator = function (u: number): GeoBox {\n      const s0 = interpolator[0];\n      const s1 = interpolator[1];\n      const lngMin = s0.lngMin + u * (s1.lngMin - s0.lngMin);\n      const latMin = s0.latMin + u * (s1.latMin - s0.latMin);\n      const lngMax = s0.lngMax + u * (s1.lngMax - s0.lngMax);\n      const latMax = s0.latMax + u * (s1.latMax - s0.latMax);\n      return new GeoBox(lngMin, latMin, lngMax, latMax);\n    } as Interpolator<GeoBox>;\n    Object.setPrototypeOf(interpolator, GeoBoxInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = s0;\n    (interpolator as Mutable<typeof interpolator>)[1] = s1;\n    return interpolator;\n  } as {\n    (s0: GeoBox, s1: GeoBox): Interpolator<GeoBox>;\n\n    /** @internal */\n    prototype: Interpolator<GeoBox>;\n  };\n\n  GeoBoxInterpolator.prototype = Object.create(_super.prototype);\n  GeoBoxInterpolator.prototype.constructor = GeoBoxInterpolator;\n\n  return GeoBoxInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport {Arrays} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport type {R2Shape} from \"@swim/math\";\nimport {R2Group} from \"@swim/math\";\nimport type {GeoProjection} from \"./GeoProjection\";\nimport type {GeoShapeLike} from \"./GeoShape\";\nimport {GeoShape} from \"./GeoShape\";\nimport {GeoBox} from \"./GeoBox\";\n\n/** @public */\nexport class GeoGroup<S extends GeoShape = GeoShape> extends GeoShape implements Debug {\n  constructor(shapes: readonly S[]) {\n    super();\n    this.shapes = shapes;\n    this.boundingBox = null;\n  }\n\n  /** @internal */\n  declare readonly typeid?: \"GeoGroup\";\n\n  isDefined(): boolean {\n    return this.shapes.length !== 0;\n  }\n\n  readonly shapes: readonly S[];\n\n  override get lngMin(): number {\n    return this.bounds.lngMin;\n  }\n\n  override get latMin(): number {\n    return this.bounds.latMin;\n  }\n\n  override get lngMax(): number {\n    return this.bounds.lngMax;\n  }\n\n  override get latMax(): number {\n    return this.bounds.latMax;\n  }\n\n  override contains(that: GeoShapeLike): boolean;\n  override contains(x: number, y: number): boolean;\n  override contains(that: GeoShapeLike | number, y?: number): boolean {\n    return false; // TODO\n  }\n\n  override intersects(that: GeoShapeLike): boolean {\n    return false; // TODO\n  }\n\n  override project(f: GeoProjection): R2Group {\n    const oldShapes = this.shapes;\n    const n = oldShapes.length;\n    if (n === 0) {\n      return R2Group.empty();\n    }\n    const newShapes = new Array<R2Shape>(n);\n    for (let i = 0; i < n; i += 1) {\n      newShapes[i] = oldShapes[i]!.project(f);\n    }\n    return new R2Group(newShapes);\n  }\n\n  /** @internal */\n  readonly boundingBox: GeoBox | null;\n\n  override get bounds(): GeoBox {\n    let boundingBox = this.boundingBox;\n    if (boundingBox === null) {\n      let lngMin = Infinity;\n      let latMin = Infinity;\n      let lngMax = -Infinity;\n      let latMax = -Infinity;\n      const shapes = this.shapes;\n      for (let i = 0; i < shapes.length; i += 1) {\n        const shape = shapes[i]!;\n        lngMin = Math.min(lngMin, shape.lngMin);\n        latMin = Math.min(latMin, shape.latMin);\n        lngMax = Math.max(shape.lngMax, lngMax);\n        latMax = Math.max(shape.latMax, latMax);\n      }\n      boundingBox = new GeoBox(lngMin, latMin, lngMax, latMax);\n      (this as Mutable<this>).boundingBox = boundingBox;\n    }\n    return boundingBox;\n  }\n\n  override equivalentTo(that: unknown, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeoGroup) {\n      return Arrays.equivalent(this.shapes, that.shapes, epsilon);\n    }\n    return false;\n  }\n\n  override equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeoGroup) {\n      return Arrays.equal(this.shapes, that.shapes);\n    }\n    return false;\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    const shapes = this.shapes;\n    const n = shapes.length;\n    output = output.write(\"GeoGroup\").write(46/*'.'*/);\n    if (n === 0) {\n      output = output.write(\"empty\").write(40/*'('*/);\n    } else {\n      output = output.write(\"of\").write(40/*'('*/);\n      output = output.debug(shapes[0]!);\n      for (let i = 1; i < n; i += 1) {\n        output = output.write(\", \").debug(shapes[i]!);\n      }\n    }\n    output = output.write(41/*')'*/);\n    return output;\n  }\n\n  override toString(): string {\n    return Format.debug(this);\n  }\n\n  @Lazy\n  static empty<S extends GeoShape>(): GeoGroup<S> {\n    return new GeoGroup<S>(Arrays.empty());\n  }\n\n  static of<S extends GeoShape>(...shapes: S[]): GeoGroup<S> {\n    return new GeoGroup<S>(shapes);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {GeoShape} from \"./GeoShape\";\nimport {GeoPoint} from \"./GeoPoint\";\nimport type {GeoCurve} from \"./GeoCurve\";\nimport {GeoSegment} from \"./GeoSegment\";\nimport {GeoSpline} from \"./GeoSpline\";\nimport {GeoPath} from \"./GeoPath\";\nimport {GeoGroup} from \"./GeoGroup\";\n\n/** @public */\nexport type GeoJsonPosition = [number, number] | [number, number, number];\n\n/** @public */\nexport const GeoJsonPosition = {\n  [Symbol.hasInstance](instance: unknown): instance is GeoJsonPosition {\n    return Array.isArray(instance)\n        && ((instance.length === 2 && typeof instance[0] === \"number\" && typeof instance[1] === \"number\")\n         || (instance.length === 3 && typeof instance[0] === \"number\" && typeof instance[1] === \"number\" && typeof instance[2] === \"number\"));\n  },\n};\n\n/** @public */\nexport type GeoJsonBbox = [number, number, number, number]\n                        | [number, number, number, number, number, number];\n\n/** @public */\nexport type GeoJsonType = GeoJsonGeometryType\n                        | \"Feature\"\n                        | \"FeatureCollection\";\n\n/** @public */\nexport interface GeoJsonObject {\n  type: GeoJsonType;\n  bbox?: GeoJsonBbox;\n}\n\n/** @public */\nexport type GeoJson = GeoJsonGeometry\n                    | GeoJsonFeature\n                    | GeoJsonFeatureCollection;\n\n/** @public */\nexport const GeoJson = {\n  toShape: function (object: GeoJson): GeoShape | (GeoShape | null)[] | null {\n    if (object.type === \"Feature\") {\n      return GeoJsonFeature.toShape(object);\n    } else if (object.type === \"FeatureCollection\") {\n      return GeoJsonFeatureCollection.toShapes(object);\n    }\n    return GeoJsonGeometry.toShape(object);\n  } as {\n    (geometry: GeoJsonGeometry): GeoShape;\n    (feature: GeoJsonFeature): GeoShape | null;\n    (collection: GeoJsonFeatureCollection): (GeoShape | null)[] | null;\n    (object: GeoJson): GeoShape | (GeoShape | null)[] | null;\n  },\n\n  [Symbol.hasInstance](instance: unknown): instance is GeoJson {\n    return GeoJsonGeometry[Symbol.hasInstance](instance)\n        || GeoJsonFeature[Symbol.hasInstance](instance)\n        || GeoJsonFeatureCollection[Symbol.hasInstance](instance);\n  },\n};\n\n/** @public */\nexport type GeoJsonGeometryType = \"Point\"\n                                | \"MultiPoint\"\n                                | \"LineString\"\n                                | \"MultiLineString\"\n                                | \"Polygon\"\n                                | \"MultiPolygon\"\n                                | \"GeometryCollection\";\n\n/** @public */\nexport interface GeoJsonGeometryObject extends GeoJsonObject {\n  type: GeoJsonGeometryType;\n}\n\n/** @public */\nexport type GeoJsonGeometry = GeoJsonPoint\n                            | GeoJsonMultiPoint\n                            | GeoJsonLineString\n                            | GeoJsonMultiLineString\n                            | GeoJsonPolygon\n                            | GeoJsonMultiPolygon\n                            | GeoJsonGeometryCollection;\n\n/** @public */\nexport const GeoJsonGeometry = {\n  toShape(object: GeoJsonGeometry): GeoShape {\n    if (object.type === \"Point\") {\n      return GeoJsonPoint.toShape(object);\n    } else if (object.type === \"MultiPoint\") {\n      return GeoJsonMultiPoint.toShape(object);\n    } else if (object.type === \"LineString\") {\n      return GeoJsonLineString.toShape(object);\n    } else if (object.type === \"MultiLineString\") {\n      return GeoJsonMultiLineString.toShape(object);\n    } else if (object.type === \"Polygon\") {\n      return GeoJsonPolygon.toShape(object);\n    } else if (object.type === \"MultiPolygon\") {\n      return GeoJsonMultiPolygon.toShape(object);\n    } else if (object.type === \"GeometryCollection\") {\n      return GeoJsonGeometryCollection.toShape(object);\n    }\n    throw new TypeError(\"\" + object);\n  },\n\n  [Symbol.hasInstance](instance: unknown): instance is GeoJsonGeometry {\n    return GeoJsonPoint[Symbol.hasInstance](instance)\n        || GeoJsonMultiPoint[Symbol.hasInstance](instance)\n        || GeoJsonLineString[Symbol.hasInstance](instance)\n        || GeoJsonMultiLineString[Symbol.hasInstance](instance)\n        || GeoJsonPolygon[Symbol.hasInstance](instance)\n        || GeoJsonMultiPolygon[Symbol.hasInstance](instance)\n        || GeoJsonGeometryCollection[Symbol.hasInstance](instance);\n  },\n};\n\n/** @public */\nexport interface GeoJsonPoint extends GeoJsonGeometryObject {\n  readonly type: \"Point\";\n  coordinates: GeoJsonPosition;\n}\n\n/** @public */\nexport const GeoJsonPoint = {\n  toShape(object: GeoJsonPoint): GeoPoint {\n    const position = object.coordinates;\n    return new GeoPoint(position[0], position[1]);\n  },\n\n  [Symbol.hasInstance](instance: unknown): instance is GeoJsonPoint {\n    return instance !== null && typeof instance === \"object\"\n        && (instance as GeoJsonPoint).type === \"Point\"\n        && GeoJsonPosition[Symbol.hasInstance]((instance as GeoJsonPoint).coordinates);\n  },\n};\n\n/** @public */\nexport interface GeoJsonMultiPoint extends GeoJsonGeometryObject {\n  readonly type: \"MultiPoint\";\n  coordinates: GeoJsonPosition[];\n}\n\n/** @public */\nexport const GeoJsonMultiPoint = {\n  toShape(object: GeoJsonMultiPoint): GeoGroup<GeoPoint> {\n    const positions = object.coordinates;\n    const n = positions.length;\n    const shapes = new Array<GeoPoint>(n);\n    for (let i = 0; i < n; i += 1) {\n      const position = positions[i]!;\n      shapes[i] = new GeoPoint(position[0], position[1]);\n    }\n    return new GeoGroup(shapes);\n  },\n\n  [Symbol.hasInstance](instance: unknown): instance is GeoJsonMultiPoint {\n    return instance !== null && typeof instance === \"object\"\n        && (instance as GeoJsonMultiPoint).type === \"MultiPoint\"\n        && Array.isArray((instance as GeoJsonMultiPoint).coordinates);\n  },\n};\n\n/** @public */\nexport interface GeoJsonLineString extends GeoJsonGeometryObject {\n  readonly type: \"LineString\";\n  coordinates: GeoJsonPosition[];\n}\n\n/** @public */\nexport const GeoJsonLineString = {\n  toShape(object: GeoJsonLineString): GeoSpline {\n    const lineString = object.coordinates;\n    const n = lineString.length;\n    if (n === 0) {\n      return GeoSpline.empty();\n    }\n    const curves = new Array<GeoCurve>(n - 1);\n    let position = lineString[0]!;\n    let lng = position[0];\n    let lat = position[1];\n    for (let i = 1; i < n; i += 1) {\n      position = lineString[i]!;\n      curves[i - 1] = new GeoSegment(lng, lat, (lng = position[0], lng), (lat = position[1], lat));\n    }\n    return new GeoSpline(curves, false);\n  },\n\n  [Symbol.hasInstance](instance: unknown): instance is GeoJsonLineString {\n    return instance !== null && typeof instance === \"object\"\n        && (instance as GeoJsonLineString).type === \"LineString\"\n        && Array.isArray((instance as GeoJsonLineString).coordinates);\n  },\n};\n\n/** @public */\nexport interface GeoJsonMultiLineString extends GeoJsonGeometryObject {\n  readonly type: \"MultiLineString\";\n  coordinates: GeoJsonPosition[][];\n}\n\n/** @public */\nexport const GeoJsonMultiLineString = {\n  toShape(object: GeoJsonMultiLineString): GeoGroup<GeoSpline> {\n    const multiLineString = object.coordinates;\n    const n = multiLineString.length;\n    const shapes = new Array<GeoSpline>(n);\n    for (let i = 0; i < n; i += 1) {\n      const lineString = multiLineString[i]!;\n      const m = lineString.length;\n      if (m === 0) {\n        shapes[i] = GeoSpline.empty();\n        continue;\n      }\n      const curves = new Array<GeoCurve>(m - 1);\n      let position = lineString[0]!;\n      let lng = position[0];\n      let lat = position[1];\n      for (let j = 1; j < m; j += 1) {\n        position = lineString[j]!;\n        curves[j - 1] = new GeoSegment(lng, lat, (lng = position[0], lng), (lat = position[1], lat));\n      }\n      shapes[i] = new GeoSpline(curves, false);\n    }\n    return new GeoGroup(shapes);\n  },\n\n  [Symbol.hasInstance](instance: unknown): instance is GeoJsonMultiLineString {\n    return instance !== null && typeof instance === \"object\"\n        && (instance as GeoJsonMultiLineString).type === \"MultiLineString\"\n        && Array.isArray((instance as GeoJsonMultiLineString).coordinates);\n  },\n};\n\n/** @public */\nexport interface GeoJsonPolygon extends GeoJsonGeometryObject {\n  readonly type: \"Polygon\";\n  coordinates: GeoJsonPosition[][];\n}\n\n/** @public */\nexport const GeoJsonPolygon = {\n  toShape(object: GeoJsonPolygon): GeoPath {\n    const polygons = object.coordinates;\n    const n = polygons.length;\n    const splines = new Array<GeoSpline>(n);\n    for (let i = 0; i < n; i += 1) {\n      const polygon = polygons[i]!;\n      const m = polygon.length;\n      if (m === 0) {\n        splines[i] = GeoSpline.empty();\n        continue;\n      }\n      const curves = new Array<GeoCurve>(m - 1);\n      let position = polygon[0]!;\n      let lng = position[0];\n      let lat = position[1];\n      for (let j = 1; j < m; j += 1) {\n        position = polygon[j]!;\n        curves[j - 1] = new GeoSegment(lng, lat, (lng = position[0], lng), (lat = position[1], lat));\n      }\n      splines[i] = new GeoSpline(curves, true);\n    }\n    return new GeoPath(splines);\n  },\n\n  [Symbol.hasInstance](instance: unknown): instance is GeoJsonPolygon {\n    return instance !== null && typeof instance === \"object\"\n        && (instance as GeoJsonPolygon).type === \"Polygon\"\n        && Array.isArray((instance as GeoJsonPolygon).coordinates);\n  },\n};\n\n/** @public */\nexport interface GeoJsonMultiPolygon extends GeoJsonGeometryObject {\n  readonly type: \"MultiPolygon\";\n  coordinates: GeoJsonPosition[][][];\n}\n\n/** @public */\nexport const GeoJsonMultiPolygon = {\n  toShape(object: GeoJsonMultiPolygon): GeoGroup<GeoPath> {\n    const multiPolygon = object.coordinates;\n    const n = multiPolygon.length;\n    const shapes = new Array<GeoPath>(n);\n    for (let i = 0; i < n; i += 1) {\n      const polygons = multiPolygon[i]!;\n      const m = polygons.length;\n      const splines = new Array<GeoSpline>(m);\n      for (let j = 0; j < m; j += 1) {\n        const polygon = polygons[j]!;\n        const o = polygon.length;\n        if (o === 0) {\n          splines[j] = GeoSpline.empty();\n          continue;\n        }\n        const curves = new Array<GeoCurve>(o - 1);\n        let position = polygon[0]!;\n        let lng = position[0];\n        let lat = position[1];\n        for (let k = 1; k < o; k += 1) {\n          position = polygon[k]!;\n          curves[k - 1] = new GeoSegment(lng, lat, (lng = position[0], lng), (lat = position[1], lat));\n        }\n        splines[j] = new GeoSpline(curves, true);\n      }\n      shapes[i] = new GeoPath(splines);\n    }\n    return new GeoGroup(shapes);\n  },\n\n  [Symbol.hasInstance](instance: unknown): instance is GeoJsonMultiPolygon {\n    return instance !== null && typeof instance === \"object\"\n        && (instance as GeoJsonMultiPolygon).type === \"MultiPolygon\"\n        && Array.isArray((instance as GeoJsonMultiPolygon).coordinates);\n  },\n};\n\n/** @public */\nexport interface GeoJsonGeometryCollection extends GeoJsonGeometryObject {\n  readonly type: \"GeometryCollection\";\n  geometries: GeoJsonGeometry[];\n}\n\n/** @public */\nexport const GeoJsonGeometryCollection = {\n  toShape(object: GeoJsonGeometryCollection): GeoGroup {\n    const geometries = object.geometries;\n    const n = geometries.length;\n    const shapes = new Array<GeoShape>(n);\n    for (let i = 0; i < n; i += 1) {\n      shapes[i] = GeoJsonGeometry.toShape(geometries[i]!);\n    }\n    return new GeoGroup(shapes);\n  },\n\n  [Symbol.hasInstance](instance: unknown): instance is GeoJsonGeometryCollection {\n    return instance !== null && typeof instance === \"object\"\n        && (instance as GeoJsonGeometryCollection).type === \"GeometryCollection\"\n        && Array.isArray((instance as GeoJsonGeometryCollection).geometries);\n  },\n};\n\n/** @public */\nexport type GeoJsonProperties = {[name: string]: unknown};\n\n/** @public */\nexport interface GeoJsonFeature<G extends GeoJsonGeometry = GeoJsonGeometry, P = GeoJsonProperties> extends GeoJsonObject {\n  type: \"Feature\";\n  geometry: G | null;\n  properties: P | null;\n  id?: string | number;\n}\n\n/** @public */\nexport const GeoJsonFeature = {\n  toShape(feature: GeoJsonFeature): GeoShape | null {\n    const geometry = feature.geometry;\n    return geometry !== null ? GeoJsonGeometry.toShape(geometry) : null;\n  },\n\n  [Symbol.hasInstance](instance: unknown): instance is GeoJsonFeature {\n    return instance !== null && typeof instance === \"object\"\n        && (instance as GeoJsonFeature).type === \"Feature\"\n        && GeoJsonGeometry[Symbol.hasInstance]((instance as GeoJsonFeature).geometry)\n        && typeof (instance as GeoJsonFeature).properties === \"object\";\n  },\n};\n\n/** @public */\nexport interface GeoJsonFeatureCollection<G extends GeoJsonGeometry = GeoJsonGeometry, P = GeoJsonProperties> extends GeoJsonObject {\n  type: \"FeatureCollection\";\n  features: GeoJsonFeature<G, P>[];\n}\n\n/** @public */\nexport const GeoJsonFeatureCollection = {\n  toShapes(object: GeoJsonFeatureCollection): (GeoShape | null)[] {\n    const features = object.features;\n    const n = features.length;\n    const shapes = new Array<GeoShape | null>(n);\n    for (let i = 0; i < n; i += 1) {\n      shapes[i] = GeoJsonFeature.toShape(features[i]!);\n    }\n    return shapes;\n  },\n\n  [Symbol.hasInstance](instance: unknown): instance is GeoJsonFeatureCollection {\n    return instance !== null && typeof instance === \"object\"\n        && (instance as GeoJsonFeatureCollection).type === \"FeatureCollection\"\n        && Array.isArray((instance as GeoJsonFeatureCollection).features);\n  },\n};\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport type {Output} from \"@swim/codec\";\nimport type {Debug} from \"@swim/codec\";\nimport {Format} from \"@swim/codec\";\nimport type {Item} from \"@swim/structure\";\nimport type {Value} from \"@swim/structure\";\nimport {Text} from \"@swim/structure\";\nimport {Num} from \"@swim/structure\";\nimport {Form} from \"@swim/structure\";\n\n/** @public */\nexport type TimeZoneLike = TimeZone | string | number;\n\n/** @public */\nexport const TimeZoneLike = {\n  [Symbol.hasInstance](instance: unknown): instance is TimeZoneLike {\n    return instance instanceof TimeZone\n        || typeof instance === \"string\"\n        || typeof instance === \"number\";\n  },\n};\n\n/** @public */\nexport class TimeZone implements HashCode, Debug {\n  /** @internal */\n  private constructor(name: string | undefined, offset: number) {\n    this.name = name;\n    this.offset = offset;\n  }\n\n  likeType?(like: string | number): void;\n\n  readonly name: string | undefined;\n\n  readonly offset: number;\n\n  isUTC(): boolean {\n    return this.offset === 0;\n  }\n\n  isLocal(): boolean {\n    return this.offset === -new Date().getTimezoneOffset();\n  }\n\n  /** @override */\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof TimeZone) {\n      return this.offset === that.offset;\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Constructors.hash(TimeZone), Numbers.hash(this.offset)));\n  }\n\n  /** @override */\n  debug<T>(output: Output<T>): Output<T> {\n    output = output.write(\"TimeZone\").write(46/*'.'*/);\n    if (this.name === \"UTC\" && this.offset === 0) {\n      output = output.write(\"utc\").write(40/*'('*/);\n    } else if (this.name === void 0) {\n      output = output.write(\"forOffset\").write(40/*'('*/).debug(this.offset);\n    } else {\n      output = output.write(\"create\").write(40/*'('*/)\n                     .debug(this.name).write(\", \").debug(this.offset);\n    }\n    output = output.write(41/*')'*/);\n    return output;\n  }\n\n  /** @override */\n  toString(): string {\n    return Format.debug(this);\n  }\n\n  @Lazy\n  static utc(): TimeZone {\n    return new TimeZone(\"UTC\", 0);\n  }\n\n  @Lazy\n  static local(): TimeZone {\n    return this.forOffset(-new Date().getTimezoneOffset());\n  }\n\n  static create(name: string | undefined, offset: number): TimeZone {\n    if (name === \"UTC\" && offset === 0) {\n      return TimeZone.utc();\n    }\n    return new TimeZone(name, offset);\n  }\n\n  static forName(name: string): TimeZone | null {\n    switch (name) {\n      case \"UTC\": return TimeZone.utc();\n      default: return null;\n    }\n  }\n\n  static forOffset(offset: number): TimeZone {\n    switch (offset) {\n      case 0: return TimeZone.utc();\n      default: return new TimeZone(void 0, offset);\n    }\n  }\n\n  static fromLike<T extends TimeZoneLike | null | undefined>(value: T): TimeZone | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof TimeZone) {\n      return value as TimeZone | Uninitable<T>;\n    } else if (typeof value === \"string\") {\n      const zone = TimeZone.forName(value);\n      if (zone !== null) {\n        return zone;\n      }\n    } else if (typeof value === \"number\") {\n      return TimeZone.forOffset(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromValue(value: Value): TimeZone | null {\n    const name = value.stringValue(void 0);\n    if (name !== void 0) {\n      return TimeZone.forName(name);\n    }\n    const offset = value.numberValue(void 0);\n    if (offset !== void 0) {\n      return TimeZone.forOffset(offset);\n    }\n    return null;\n  }\n\n  @Lazy\n  static form(): Form<TimeZone, TimeZoneLike> {\n    return new TimeZoneForm(TimeZone.utc());\n  }\n}\n\n/** @internal */\nexport class TimeZoneForm extends Form<TimeZone, TimeZoneLike> {\n  constructor(unit: TimeZone | undefined) {\n    super();\n    Object.defineProperty(this, \"unit\", {\n      value: unit,\n      enumerable: true,\n      configurable: true,\n    });\n  }\n\n  override readonly unit: TimeZone | undefined;\n\n  override withUnit(unit: TimeZone | undefined): Form<TimeZone, TimeZoneLike> {\n    if (unit === this.unit) {\n      return this;\n    }\n    return new TimeZoneForm(unit);\n  }\n\n  override mold(zone: TimeZoneLike): Item {\n    zone = TimeZone.fromLike(zone);\n    const name = zone.name;\n    if (name !== void 0) {\n      return Text.from(name);\n    } else {\n      return Num.from(zone.offset);\n    }\n  }\n\n  override cast(item: Item): TimeZone | undefined {\n    const value = item.toValue();\n    const zone = TimeZone.fromValue(value);\n    return zone !== null ? zone : void 0;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Uninitable} from \"@swim/util\";\nimport type {Mutable} from \"@swim/util\";\nimport {Murmur3} from \"@swim/util\";\nimport {Lazy} from \"@swim/util\";\nimport type {HashCode} from \"@swim/util\";\nimport type {Equivalent} from \"@swim/util\";\nimport type {Compare} from \"@swim/util\";\nimport {Numbers} from \"@swim/util\";\nimport {Constructors} from \"@swim/util\";\nimport {Objects} from \"@swim/util\";\nimport type {Interpolate} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport type {Display} from \"@swim/codec\";\nimport type {Item} from \"@swim/structure\";\nimport {Value} from \"@swim/structure\";\nimport {Text} from \"@swim/structure\";\nimport {Form} from \"@swim/structure\";\nimport type {TimeZoneLike} from \"./TimeZone\";\nimport {TimeZone} from \"./TimeZone\";\nimport {DateTimeFormat} from \"./\"; // forward import\n\n/** @public */\nexport type DateTimeLike = DateTime | DateTimeInit | Date | string | number;\n\n/** @public */\nexport const DateTimeLike = {\n  [Symbol.hasInstance](instance: unknown): instance is DateTimeLike {\n    return instance instanceof DateTime\n        || instance instanceof Date\n        || DateTimeInit[Symbol.hasInstance](instance)\n        || typeof instance === \"string\"\n        || typeof instance === \"number\";\n  },\n};\n\n/** @public */\nexport interface DateTimeInit {\n  /** @internal */\n  readonly typeid?: \"DateTimeInit\";\n  time?: number,\n  year?: number;\n  month?: number;\n  day?: number;\n  hour?: number;\n  minute?: number;\n  second?: number;\n  millisecond?: number;\n  zone?: TimeZoneLike;\n}\n\n/** @public */\nexport const DateTimeInit = {\n  [Symbol.hasInstance](instance: unknown): instance is DateTimeInit {\n    return Objects.hasAnyKey<DateTimeInit>(instance, \"time\", \"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"millisecond\");\n  },\n};\n\n/** @public */\nexport class DateTime implements Interpolate<DateTime>, HashCode, Equivalent, Compare, Display {\n  constructor(time: number, zone: TimeZone = TimeZone.utc()) {\n    this.time = time;\n    this.zone = zone;\n  }\n\n  /** @internal */\n  declare readonly typeid?: \"DateTime\";\n\n  likeType?(like: DateTimeInit | Date | string | number): void;\n\n  isDefined(): boolean {\n    return isFinite(new Date(this.time).getTime());\n  }\n\n  readonly time: number;\n\n  readonly zone: TimeZone;\n\n  get year(): number {\n    return this.toUTCLocalDate().getUTCFullYear();\n  }\n\n  withYear(year: number, month?: number, day?: number, hour?: number, minute?: number,\n           second?: number, millisecond?: number): DateTime {\n    const date = this.toUTCLocalDate();\n    date.setUTCFullYear(year);\n    if (month !== void 0) {\n      date.setUTCMonth(month);\n    }\n    if (day !== void 0) {\n      date.setUTCDate(day);\n    }\n    if (hour !== void 0) {\n      date.setUTCHours(hour);\n    }\n    if (minute !== void 0) {\n      date.setUTCMinutes(minute);\n    }\n    if (second !== void 0) {\n      date.setUTCSeconds(second);\n    }\n    if (millisecond !== void 0) {\n      date.setUTCMilliseconds(millisecond);\n    }\n    return DateTime.fromUTCLocalDate(date, this.zone);\n  }\n\n  get month(): number {\n    return this.toUTCLocalDate().getUTCMonth();\n  }\n\n  withMonth(month: number, day?: number, hour?: number, minute?: number,\n            second?: number, millisecond?: number): DateTime {\n    const date = this.toUTCLocalDate();\n    date.setUTCMonth(month);\n    if (day !== void 0) {\n      date.setUTCDate(day);\n    }\n    if (hour !== void 0) {\n      date.setUTCHours(hour);\n    }\n    if (minute !== void 0) {\n      date.setUTCMinutes(minute);\n    }\n    if (second !== void 0) {\n      date.setUTCSeconds(second);\n    }\n    if (millisecond !== void 0) {\n      date.setUTCMilliseconds(millisecond);\n    }\n    return DateTime.fromUTCLocalDate(date, this.zone);\n  }\n\n  get day(): number {\n    return this.toUTCLocalDate().getUTCDate();\n  }\n\n  withDay(day: number, hour?: number, minute?: number, second?: number,\n          millisecond?: number): DateTime {\n    const date = this.toUTCLocalDate();\n    date.setUTCDate(day);\n    if (hour !== void 0) {\n      date.setUTCHours(hour);\n    }\n    if (minute !== void 0) {\n      date.setUTCMinutes(minute);\n    }\n    if (second !== void 0) {\n      date.setUTCSeconds(second);\n    }\n    if (millisecond !== void 0) {\n      date.setUTCMilliseconds(millisecond);\n    }\n    return DateTime.fromUTCLocalDate(date, this.zone);\n  }\n\n  get hour(): number {\n    return this.toUTCLocalDate().getUTCHours();\n  }\n\n  withHour(hour: number, minute?: number, second?: number, millisecond?: number): DateTime {\n    const date = this.toUTCLocalDate();\n    date.setUTCHours(hour);\n    if (minute !== void 0) {\n      date.setUTCMinutes(minute);\n    }\n    if (second !== void 0) {\n      date.setUTCSeconds(second);\n    }\n    if (millisecond !== void 0) {\n      date.setUTCMilliseconds(millisecond);\n    }\n    return DateTime.fromUTCLocalDate(date, this.zone);\n  }\n\n  get minute(): number {\n    return this.toUTCLocalDate().getUTCMinutes();\n  }\n\n  withMinute(minute: number, second?: number, millisecond?: number): DateTime {\n    const date = this.toUTCLocalDate();\n    date.setUTCMinutes(minute);\n    if (second !== void 0) {\n      date.setUTCSeconds(second);\n    }\n    if (millisecond !== void 0) {\n      date.setUTCMilliseconds(millisecond);\n    }\n    return DateTime.fromUTCLocalDate(date, this.zone);\n  }\n\n  get second(): number {\n    return this.toUTCLocalDate().getUTCSeconds();\n  }\n\n  withSecond(second: number, millisecond?: number): DateTime {\n    const date = this.toUTCLocalDate();\n    date.setUTCSeconds(second);\n    if (millisecond !== void 0) {\n      date.setUTCMilliseconds(millisecond);\n    }\n    return DateTime.fromUTCLocalDate(date, this.zone);\n  }\n\n  get millisecond(): number {\n    return this.toUTCLocalDate().getUTCMilliseconds();\n  }\n\n  withMillisecond(millisecond: number): DateTime {\n    const date = this.toUTCLocalDate();\n    date.setUTCMilliseconds(millisecond);\n    return DateTime.fromUTCLocalDate(date, this.zone);\n  }\n\n  get weekday(): number {\n    return this.toUTCLocalDate().getUTCDay();\n  }\n\n  /**\n   * Returns this date time shifted by the time zone offset.\n   * @internal\n   */\n  toUTCLocalDate(): Date {\n    return new Date(this.time + 60000 * this.zone.offset);\n  }\n\n  toDate(): Date {\n    return new Date(this.time);\n  }\n\n  valueOf(): number {\n    return this.time;\n  }\n\n  /** @override */\n  interpolateTo(that: DateTime): Interpolator<DateTime>;\n  interpolateTo(that: unknown): Interpolator<DateTime> | null;\n  interpolateTo(that: unknown): Interpolator<DateTime> | null {\n    if (that instanceof DateTime) {\n      return DateTimeInterpolator(this, that);\n    }\n    return null;\n  }\n\n  /** @override */\n  compareTo(that: unknown): number {\n    if (that instanceof DateTime) {\n      const x = this.time;\n      const y = that.time;\n      return x < y ? -1 : x > y ? 1 : x === y ? 0 : NaN;\n    }\n    return NaN;\n  }\n\n  /** @override */\n  equivalentTo(that: DateTimeLike, epsilon?: number): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof DateTime) {\n      return Numbers.equivalent(this.time, that.time, epsilon);\n    }\n    return false;\n  }\n\n  /** @override */\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof DateTime) {\n      return this.time === that.time && this.zone.equals(that.zone);\n    }\n    return false;\n  }\n\n  /** @override */\n  hashCode(): number {\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(DateTime),\n        Numbers.hash(this.time)), this.zone.hashCode()));\n  }\n\n  /** @override */\n  display<T>(output: Output<T>, format: DateTimeFormat = DateTimeFormat.iso8601()): Output<T> {\n    output = format.writeDate(output, this);\n    return output;\n  }\n\n  /** @override */\n  toString(format: DateTimeFormat = DateTimeFormat.iso8601()): string {\n    return format.format(this);\n  }\n\n  static current(zone?: TimeZoneLike): DateTime {\n    zone = zone !== void 0 ? TimeZone.fromLike(zone) : TimeZone.local();\n    return new DateTime(Date.now(), zone);\n  }\n\n  /**\n   * Returns this date time shifted back by the time zone offset.\n   * @internal\n   */\n  static fromUTCLocalDate(date: Date, zone: TimeZone): DateTime {\n    return new DateTime(date.getTime() - 60000 * zone.offset, zone);\n  }\n\n  static fromLike<T extends DateTimeLike | null | undefined>(value: T, zone?: TimeZoneLike): DateTime | Uninitable<T> {\n    if (value === void 0 || value === null || value instanceof DateTime) {\n      return value as DateTime | Uninitable<T>;\n    } else if (value instanceof Date) {\n      zone = zone !== void 0 ? TimeZone.fromLike(zone) : TimeZone.utc();\n      return new DateTime(value.getTime(), zone);\n    } else if (typeof value === \"number\") {\n      zone = zone !== void 0 ? TimeZone.fromLike(zone) : TimeZone.utc();\n      return new DateTime(value, zone);\n    } else if (typeof value === \"string\") {\n      return DateTime.parse(value, zone);\n    } else if (DateTimeInit[Symbol.hasInstance](value)) {\n      return DateTime.fromInit(value, zone);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromInit(init: DateTimeInit, zone?: TimeZoneLike): DateTime {\n    let time = init.time;\n    if (time === void 0) {\n      time = Date.UTC(init.year !== void 0 ? init.year : 1970,\n                      init.month !== void 0 ? init.month : 0,\n                      init.day !== void 0 ? init.day : 1,\n                      init.hour !== void 0 ? init.hour : 0,\n                      init.minute !== void 0 ? init.minute : 0,\n                      init.second !== void 0 ? init.second : 0,\n                      init.millisecond !== void 0 ? init.millisecond : 0);\n    }\n    zone = TimeZone.fromLike(init.zone);\n    if (zone === void 0) {\n      zone = TimeZone.utc();\n    } else {\n      time += 60000 * zone.offset;\n    }\n    return new DateTime(time, zone);\n  }\n\n  static fromValue(value: Value): DateTime | null {\n    let positional: boolean;\n    const header = value.header(\"date\");\n    if (header.isDefined()) {\n      value = header;\n      positional = true;\n    } else {\n      positional = false;\n    }\n    const init: DateTimeInit = {};\n    value.forEach(function (item: Item, index: number) {\n      const key = item.key.stringValue(void 0);\n      if (key !== void 0) {\n        if (key === \"year\") {\n          init.year = item.toValue().numberValue(init.year);\n        } else if (key === \"month\") {\n          init.month = item.toValue().numberValue(init.month);\n        } else if (key === \"day\") {\n          init.day = item.toValue().numberValue(init.day);\n        } else if (key === \"hour\") {\n          init.hour = item.toValue().numberValue(init.hour);\n        } else if (key === \"minute\") {\n          init.minute = item.toValue().numberValue(init.minute);\n        } else if (key === \"second\") {\n          init.second = item.toValue().numberValue(init.second);\n        } else if (key === \"millisecond\") {\n          init.millisecond = item.toValue().numberValue(init.millisecond);\n        } else if (key === \"zone\") {\n          init.zone = item.toValue().cast(TimeZone.form(), init.zone);\n        }\n      } else if (item instanceof Value && positional) {\n        if (index === 0) {\n          init.year = item.numberValue(init.year);\n        } else if (index === 1) {\n          init.month = item.numberValue(init.month);\n        } else if (index === 2) {\n          init.day = item.numberValue(init.day);\n        } else if (index === 3) {\n          init.hour = item.numberValue(init.hour);\n        } else if (index === 4) {\n          init.minute = item.numberValue(init.minute);\n        } else if (index === 5) {\n          init.second = item.numberValue(init.second);\n        } else if (index === 6) {\n          init.millisecond = item.numberValue(init.millisecond);\n        } else if (index === 7) {\n          init.zone = item.cast(TimeZone.form(), init.zone);\n        }\n      }\n    });\n    if (DateTimeInit[Symbol.hasInstance](init)) {\n      return DateTime.fromInit(init);\n    }\n    return null;\n  }\n\n  static parse(date: string, zone?: TimeZoneLike): DateTime {\n    return DateTimeFormat.iso8601().parse(date);\n  }\n\n  static time(date: DateTimeLike): number {\n    if (date instanceof DateTime) {\n      return date.time;\n    } else if (date instanceof Date) {\n      return date.getTime();\n    } else if (typeof date === \"number\") {\n      return date;\n    } else if (typeof date === \"string\") {\n      return DateTime.parse(date).time;\n    } else if (DateTimeInit[Symbol.hasInstance](date)) {\n      return DateTime.fromInit(date).time;\n    }\n    throw new TypeError(\"\" + date);\n  }\n\n  static zone(date: DateTimeLike): TimeZone {\n    if (date instanceof DateTime) {\n      return date.zone;\n    }\n    return TimeZone.utc();\n  }\n\n  @Lazy\n  static form(): Form<DateTime, DateTimeLike> {\n    return new DateTimeForm(new DateTime(0));\n  }\n}\n\n/** @internal */\nexport const DateTimeInterpolator = (function (_super: typeof Interpolator) {\n  const DateTimeInterpolator = function (d0: DateTime, d1: DateTime): Interpolator<DateTime> {\n    const interpolator = function (u: number): DateTime {\n      const d0 = interpolator[0];\n      const d1 = interpolator[1];\n      return new DateTime(d0.time + u * (d1.time - d0.time), d1.zone);\n    } as Interpolator<DateTime>;\n    Object.setPrototypeOf(interpolator, DateTimeInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = d0;\n    (interpolator as Mutable<typeof interpolator>)[1] = d1;\n    return interpolator;\n  } as {\n    (d0: DateTime, d1: DateTime): Interpolator<DateTime>;\n\n    /** @internal */\n    prototype: Interpolator<DateTime>;\n  };\n\n  DateTimeInterpolator.prototype = Object.create(_super.prototype);\n  DateTimeInterpolator.prototype.constructor = DateTimeInterpolator;\n\n  return DateTimeInterpolator;\n})(Interpolator);\n\n/** @internal */\nexport class DateTimeForm extends Form<DateTime, DateTimeLike> {\n  constructor(unit: DateTime | undefined) {\n    super();\n    Object.defineProperty(this, \"unit\", {\n      value: unit,\n      enumerable: true,\n      configurable: true,\n    });\n  }\n\n  override readonly unit: DateTime | undefined;\n\n  override withUnit(unit: DateTime | undefined): Form<DateTime, DateTimeLike> {\n    if (unit === this.unit) {\n      return this;\n    }\n    return new DateTimeForm(unit);\n  }\n\n  override mold(date: DateTimeLike): Item {\n    date = DateTime.fromLike(date);\n    return Text.from(date.toString());\n  }\n\n  override cast(value: Value): DateTime | undefined {\n    let date: DateTime | null = null;\n    try {\n      date = DateTime.fromValue(value);\n      if (date === void 0) {\n        const millis = value.numberValue(void 0);\n        if (millis !== void 0) {\n          date = new DateTime(millis);\n        } else {\n          const string = value.stringValue(void 0);\n          if (string !== void 0) {\n            date = DateTime.parse(string);\n          }\n        }\n      }\n    } catch (e) {\n      // swallow\n    }\n    return date !== null ? date : void 0;\n  }\n}\n\n/** @internal */\nexport class DateTimeParser extends Parser<DateTime> {\n  private readonly dateParser: Parser<DateTimeInit>;\n\n  constructor(dateParser: Parser<DateTimeInit>) {\n    super();\n    this.dateParser = dateParser;\n  }\n\n  override feed(input: Input): Parser<DateTime> {\n    return DateTimeParser.parse(input, this.dateParser);\n  }\n\n  static parse(input: Input, dateParser: Parser<DateTimeInit>): Parser<DateTime> {\n    dateParser = dateParser.feed(input);\n    if (dateParser.isDone()) {\n      return Parser.done(DateTime.fromLike(dateParser.bind()));\n    } else if (dateParser.isError()) {\n      return dateParser.asError();\n    }\n    return new DateTimeParser(dateParser);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Lazy} from \"@swim/util\";\n\n/** @public */\nexport class DateTimeLocale {\n  readonly periods: readonly string[];\n  readonly weekdays: readonly string[];\n  readonly shortWeekdays: readonly string[];\n  readonly months: readonly string[];\n  readonly shortMonths: readonly string[];\n\n  constructor(periods: readonly string[] = DateTimeLocale.Periods,\n              weekdays: readonly string[] = DateTimeLocale.Weekdays,\n              shortWeekdays: readonly string[] = DateTimeLocale.ShortWeekdays,\n              months: readonly string[] = DateTimeLocale.Months,\n              shortMonths: readonly string[] = DateTimeLocale.ShortMonths) {\n    this.periods = periods;\n    this.weekdays = weekdays;\n    this.shortWeekdays = shortWeekdays;\n    this.months = months;\n    this.shortMonths = shortMonths;\n  }\n\n  /** @internal */\n  static readonly Periods: readonly string[] = [\n    \"AM\",\n    \"PM\",\n  ];\n\n  /** @internal */\n  static readonly Weekdays: readonly string[] = [\n    \"Sunday\",\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n  ];\n\n  /** @internal */\n  static readonly ShortWeekdays: readonly string[] = [\n    \"Sun\",\n    \"Mon\",\n    \"Tue\",\n    \"Wed\",\n    \"Thu\",\n    \"Fri\",\n    \"Sat\",\n  ];\n\n  /** @internal */\n  static readonly Months: readonly string[] = [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\",\n  ];\n\n  /** @internal */\n  static readonly ShortMonths: readonly string[] = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\",\n  ];\n\n  @Lazy\n  static standard(): DateTimeLocale {\n    return new DateTimeLocale();\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {DateTimeLocale} from \"./DateTimeLocale\";\nimport {DateTimeFormat} from \"./\"; // forward import\n\n/** @public */\nexport interface DateTimeSpecifiers {\n  [symbol: string]: DateTimeFormat | undefined;\n  Y: DateTimeFormat;\n  m: DateTimeFormat;\n  B: DateTimeFormat;\n  b: DateTimeFormat;\n  d: DateTimeFormat;\n  e: DateTimeFormat;\n  A: DateTimeFormat;\n  a: DateTimeFormat;\n  H: DateTimeFormat;\n  I: DateTimeFormat;\n  i: DateTimeFormat;\n  p: DateTimeFormat;\n  M: DateTimeFormat;\n  S: DateTimeFormat;\n  L: DateTimeFormat;\n}\n\n/** @public */\nexport const DateTimeSpecifiers = (function () {\n  const DateTimeSpecifiers = {} as {\n    standard(locale?: DateTimeLocale): DateTimeSpecifiers;\n  };\n\n  let standard: DateTimeSpecifiers | null = null;\n\n  DateTimeSpecifiers.standard = function (locale?: DateTimeLocale): DateTimeSpecifiers {\n    let specifiers: DateTimeSpecifiers | null = null;\n    if (locale === void 0) {\n      locale = DateTimeLocale.standard();\n    }\n    if (locale === DateTimeLocale.standard()) {\n      specifiers = standard;\n    }\n    if (specifiers === null) {\n      specifiers = {\n        Y: DateTimeFormat.year(),\n        m: DateTimeFormat.monthOfYear(),\n        B: DateTimeFormat.month(locale),\n        b: DateTimeFormat.shortMonth(locale),\n        d: DateTimeFormat.dayOfMonth(48/*'0'*/),\n        e: DateTimeFormat.dayOfMonth(32/*' '*/),\n        A: DateTimeFormat.weekday(locale),\n        a: DateTimeFormat.shortWeekday(locale),\n        H: DateTimeFormat.hour24(),\n        I: DateTimeFormat.hour12(48/*'0'*/),\n        i: DateTimeFormat.hour12(32/*' '*/),\n        p: DateTimeFormat.period(locale),\n        M: DateTimeFormat.minute(),\n        S: DateTimeFormat.second(),\n        L: DateTimeFormat.millisecond(),\n      };\n      if (locale === DateTimeLocale.standard()) {\n        standard = specifiers;\n      }\n    }\n    return specifiers;\n  };\n\n  return DateTimeSpecifiers;\n})();\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Diagnostic} from \"@swim/codec\";\nimport type {Input} from \"@swim/codec\";\nimport type {Output} from \"@swim/codec\";\nimport {Parser} from \"@swim/codec\";\nimport {Unicode} from \"@swim/codec\";\nimport {Base10} from \"@swim/codec\";\nimport type {DateTimeLike} from \"./DateTime\";\nimport type {DateTimeInit} from \"./DateTime\";\nimport {DateTime} from \"./DateTime\";\nimport {DateTimeParser} from \"./DateTime\";\nimport {DateTimeLocale} from \"./DateTimeLocale\";\nimport {DateTimeSpecifiers} from \"./DateTimeSpecifiers\";\n\n/** @internal */\nexport interface DateNumberFactory {\n  term(value: number, date: DateTimeInit, input: Input): Parser<DateTimeInit>;\n  cont(date: DateTimeInit, value: number, step: number, input: Input): Parser<DateTimeInit>;\n}\n\n/** @internal */\nexport interface DateStringFactory {\n  term(locale: DateTimeLocale, value: string, date: DateTimeInit, input: Input): Parser<DateTimeInit>;\n  cont(locale: DateTimeLocale, date: DateTimeInit, output: Output, input: Input): Parser<DateTimeInit>;\n}\n\n/** @public */\nexport abstract class DateTimeFormat {\n  withLocale(locale: DateTimeLocale): DateTimeFormat {\n    return this;\n  }\n\n  format(date: DateTimeLike): string {\n    date = DateTime.fromLike(date);\n    let output = Unicode.stringOutput();\n    output = this.writeDate(output, date);\n    return output.bind();\n  }\n\n  abstract writeDate<T>(output: Output<T>, date: DateTime): Output<T>;\n\n  parse(input: Input | string): DateTime {\n    if (typeof input === \"string\") {\n      input = Unicode.stringInput(input);\n    }\n    while (input.isCont() && Unicode.isSpace(input.head())) {\n      input = input.step();\n    }\n    let parser = this.parseDate(input, {});\n    if (parser.isDone()) {\n      while (input.isCont() && Unicode.isSpace(input.head())) {\n        input = input.step();\n      }\n    }\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n\n  /** @internal */\n  parseDate(input: Input, date: DateTimeInit): Parser<DateTime> {\n    const dateParser = this.parseDateTime(input, date);\n    if (dateParser.isDone()) {\n      return Parser.done(DateTime.fromLike(dateParser.bind()));\n    } else if (dateParser.isError()) {\n      return dateParser.asError();\n    }\n    return new DateTimeParser(dateParser);\n  }\n\n  /** @internal */\n  abstract parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit>;\n\n  /** @internal */\n  static Year: DateTimeFormat | null = null;\n  static year(): DateTimeFormat {\n    if (this.Year === null) {\n      this.Year = new YearFormat();\n    }\n    return this.Year;\n  }\n\n  /** @internal */\n  static MonthOfYear: DateTimeFormat | null = null;\n  static monthOfYear(): DateTimeFormat {\n    if (this.MonthOfYear === null) {\n      this.MonthOfYear = new MonthOfYearFormat();\n    }\n    return this.MonthOfYear;\n  }\n\n  /** @internal */\n  static Month: DateTimeFormat | null = null;\n  static month(locale?: DateTimeLocale): DateTimeFormat {\n    if (locale !== void 0 && locale !== DateTimeLocale.standard()) {\n      return new MonthFormat(locale);\n    } else if (this.Month === null) {\n      this.Month = new MonthFormat(DateTimeLocale.standard());\n    }\n    return this.Month;\n  }\n\n  /** @internal */\n  static ShortMonth: DateTimeFormat | null = null;\n  static shortMonth(locale?: DateTimeLocale): DateTimeFormat {\n    if (locale !== void 0 && locale !== DateTimeLocale.standard()) {\n      return new ShortMonthFormat(locale);\n    } else if (this.ShortMonth === null) {\n      this.ShortMonth = new ShortMonthFormat(DateTimeLocale.standard());\n    }\n    return this.ShortMonth;\n  }\n\n  /** @internal */\n  static DayOfMonthZeroPadded: DateTimeFormat | null = null;\n  /** @internal */\n  static DayOfMonthSpacePadded: DateTimeFormat | null = null;\n  static dayOfMonth(padChar?: number): DateTimeFormat {\n    if (padChar === void 0 || padChar === 48/*'0'*/) {\n      if (this.DayOfMonthZeroPadded === null) {\n        this.DayOfMonthZeroPadded = new DayOfMonthFormat(48/*'0'*/);\n      }\n      return this.DayOfMonthZeroPadded;\n    } else if (padChar === 32/*' '*/) {\n      if (this.DayOfMonthSpacePadded === null) {\n        this.DayOfMonthSpacePadded = new DayOfMonthFormat(32/*' '*/);\n      }\n      return this.DayOfMonthSpacePadded;\n    }\n    return new DayOfMonthFormat(padChar);\n  }\n\n  /** @internal */\n  static Weekday: DateTimeFormat | null = null;\n  static weekday(locale?: DateTimeLocale): DateTimeFormat {\n    if (locale !== void 0 && locale !== DateTimeLocale.standard()) {\n      return new WeekdayFormat(locale);\n    } else if (this.Weekday === null) {\n      this.Weekday = new WeekdayFormat(DateTimeLocale.standard());\n    }\n    return this.Weekday;\n  }\n\n  /** @internal */\n  static ShortWeekday: DateTimeFormat | null = null;\n  static shortWeekday(locale?: DateTimeLocale): DateTimeFormat {\n    if (locale !== void 0 && locale !== DateTimeLocale.standard()) {\n      return new ShortWeekdayFormat(locale);\n    } else if (this.ShortWeekday === null) {\n      this.ShortWeekday = new ShortWeekdayFormat(DateTimeLocale.standard());\n    }\n    return this.ShortWeekday;\n  }\n\n  /** @internal */\n  static Hour24: DateTimeFormat | null = null;\n  static hour24(): DateTimeFormat {\n    if (this.Hour24 === null) {\n      this.Hour24 = new Hour24Format();\n    }\n    return this.Hour24;\n  }\n\n  /** @internal */\n  static Hour12ZeroPadded: DateTimeFormat | null = null;\n  /** @internal */\n  static Hour12SpacePadded: DateTimeFormat | null = null;\n  static hour12(padChar?: number): DateTimeFormat {\n    if (padChar === void 0 || padChar === 48/*'0'*/) {\n      if (this.Hour12ZeroPadded === null) {\n        this.Hour12ZeroPadded = new Hour12Format(48/*'0'*/);\n      }\n      return this.Hour12ZeroPadded;\n    } else if (padChar === 32/*' '*/) {\n      if (this.Hour12SpacePadded === null) {\n        this.Hour12SpacePadded = new Hour12Format(32/*' '*/);\n      }\n      return this.Hour12SpacePadded;\n    }\n    return new Hour12Format(padChar);\n  }\n\n  /** @internal */\n  static Period: DateTimeFormat | null = null;\n  static period(locale?: DateTimeLocale): DateTimeFormat {\n    if (locale !== void 0 && locale !== DateTimeLocale.standard()) {\n      return new PeriodFormat(locale);\n    } else if (this.Period === null) {\n      this.Period = new PeriodFormat(DateTimeLocale.standard());\n    }\n    return this.Period;\n  }\n\n  /** @internal */\n  static Minute: DateTimeFormat | null = null;\n  static minute(): DateTimeFormat {\n    if (this.Minute === null) {\n      this.Minute = new MinuteFormat();\n    }\n    return this.Minute;\n  }\n\n  /** @internal */\n  static Second: DateTimeFormat | null = null;\n  static second(): DateTimeFormat {\n    if (this.Second === null) {\n      this.Second = new SecondFormat();\n    }\n    return this.Second;\n  }\n\n  /** @internal */\n  static Millisecond: DateTimeFormat | null = null;\n  static millisecond(): DateTimeFormat {\n    if (this.Millisecond === null) {\n      this.Millisecond = new MillisecondFormat();\n    }\n    return this.Millisecond;\n  }\n\n  static pattern(pattern: string, specifiers?: DateTimeSpecifiers | DateTimeLocale): DateTimeFormat {\n    if (specifiers === void 0 || specifiers instanceof DateTimeLocale) {\n      specifiers = DateTimeSpecifiers.standard(specifiers);\n    }\n    return new PatternFormat(pattern, specifiers);\n  }\n\n  /** @internal */\n  static Iso8601: DateTimeFormat | null = null;\n\n  static iso8601(): DateTimeFormat {\n    if (this.Iso8601 === null) {\n      this.Iso8601 = new PatternFormat(\"%Y-%m-%dT%H:%M:%S.%LZ\", DateTimeSpecifiers.standard());\n    }\n    return this.Iso8601;\n  }\n\n  /** @internal */\n  static parseDateNumber(input: Input, factory: DateNumberFactory, desc: string,\n                         minDigits: number, maxDigits: number, date: DateTimeInit | undefined,\n                         value: number = 0, step: number = 0): Parser<DateTimeInit> {\n    let c = 0;\n    while (step < maxDigits) {\n      if (input.isCont() && (c = input.head(), Base10.isDigit(c))) {\n        input.step();\n        value = 10 * value + Base10.decodeDigit(c);\n        step += 1;\n        continue;\n      }\n      break;\n    }\n    if (!input.isEmpty()) {\n      if (step >= minDigits) {\n        return factory.term(value, date || {}, input);\n      } else {\n        return Parser.error(Diagnostic.expected(desc, input));\n      }\n    }\n    return factory.cont(date !== void 0 ? date : {}, value, step, input);\n  }\n\n  /** @internal */\n  static parseDateString(input: Input, factory: DateStringFactory, locale: DateTimeLocale,\n                         date?: DateTimeInit, output?: Output<string>): Parser<DateTimeInit> {\n    let c = 0;\n    output = output !== void 0 ? output : Unicode.stringOutput();\n    do {\n      if (input.isCont() && (c = input.head(), Unicode.isAlpha(c))) {\n        input.step();\n        output.write(c);\n        continue;\n      } else if (!input.isEmpty()) {\n        return factory.term(locale, output.bind(), date !== void 0 ? date : {}, input);\n      }\n      break;\n    } while (true);\n    return factory.cont(locale, date !== void 0 ? date : {}, output, input);\n  }\n\n  /** @internal */\n  static writeDateNumber2<T>(output: Output<T>, value: number, padChar?: number): Output<T> {\n    if (padChar === void 0) {\n      padChar = 48/*'0'*/;\n    }\n    const c1 = Math.floor(value % 10);\n    value /= 10;\n    const c0 = Math.floor(value % 10);\n    output = output.write(c0 !== 0 ? 48/*'0'*/ + c0 : padChar);\n    output = output.write(48/*'0'*/ + c1);\n    return output;\n  }\n\n  /** @internal */\n  static writeDateNumber3<T>(output: Output<T>, value: number, padChar?: number): Output<T> {\n    if (padChar === void 0) {\n      padChar = 48/*'0'*/;\n    }\n    const c2 = Math.floor(value % 10);\n    value /= 10;\n    const c1 = Math.floor(value % 10);\n    value /= 10;\n    const c0 = Math.floor(value % 10);\n    output = output.write(c0 !== 0 ? 48/*'0'*/ + c0 : padChar);\n    output = output.write(c1 !== 0 ? 48/*'0'*/ + c1 : padChar);\n    output = output.write(48/*'0'*/ + c2);\n    return output;\n  }\n\n  /** @internal */\n  static writeDateNumber4<T>(output: Output<T>, value: number, padChar?: number): Output<T> {\n    if (padChar === void 0) {\n      padChar = 48/*'0'*/;\n    }\n    const c3 = Math.floor(value % 10);\n    value /= 10;\n    const c2 = Math.floor(value % 10);\n    value /= 10;\n    const c1 = Math.floor(value % 10);\n    value /= 10;\n    const c0 = Math.floor(value % 10);\n    output = output.write(c0 !== 0 ? 48/*'0'*/ + c0 : padChar);\n    output = output.write(c1 !== 0 ? 48/*'0'*/ + c1 : padChar);\n    output = output.write(c2 !== 0 ? 48/*'0'*/ + c2 : padChar);\n    output = output.write(48/*'0'*/ + c3);\n    return output;\n  }\n}\n\n/** @internal */\nexport class YearFormat extends DateTimeFormat {\n  override writeDate<T>(output: Output<T>, date: DateTime): Output<T> {\n    output = DateTimeFormat.writeDateNumber4(output, date.year);\n    return output;\n  }\n\n  override parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit> {\n    return YearParser.parse(input, date);\n  }\n}\n\n/** @internal */\nexport class MonthOfYearFormat extends DateTimeFormat {\n  override writeDate<T>(output: Output<T>, date: DateTime): Output<T> {\n    output = DateTimeFormat.writeDateNumber2(output, date.month + 1);\n    return output;\n  }\n\n  override parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit> {\n    return MonthOfYearParser.parse(input, date);\n  }\n}\n\n/** @internal */\nexport class MonthFormat extends DateTimeFormat {\n  private readonly locale: DateTimeLocale;\n\n  constructor(locale: DateTimeLocale) {\n    super();\n    this.locale = locale;\n  }\n\n  override withLocale(locale: DateTimeLocale): DateTimeFormat {\n    if (locale === this.locale) {\n      return this;\n    }\n    return new MonthFormat(locale);\n  }\n\n  override writeDate<T>(output: Output<T>, date: DateTime): Output<T> {\n    output = output.write(this.locale.months[date.month]!);\n    return output;\n  }\n\n  override parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit> {\n    return MonthParser.parse(input, this.locale, date);\n  }\n}\n\n/** @internal */\nexport class ShortMonthFormat extends DateTimeFormat {\n  private readonly locale: DateTimeLocale;\n\n  constructor(locale: DateTimeLocale) {\n    super();\n    this.locale = locale;\n  }\n\n  override withLocale(locale: DateTimeLocale): DateTimeFormat {\n    if (locale === this.locale) {\n      return this;\n    }\n    return new ShortMonthFormat(locale);\n  }\n\n  override writeDate<T>(output: Output<T>, date: DateTime): Output<T> {\n    output = output.write(this.locale.shortMonths[date.month]!);\n    return output;\n  }\n\n  override parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit> {\n    return ShortMonthParser.parse(input, this.locale, date);\n  }\n}\n\n/** @internal */\nexport class DayOfMonthFormat extends DateTimeFormat {\n  constructor(padChar: number) {\n    super();\n    this.padChar = padChar;\n  }\n\n  readonly padChar: number;\n\n  override writeDate<T>(output: Output<T>, date: DateTime): Output<T> {\n    output = DateTimeFormat.writeDateNumber2(output, date.day, this.padChar);\n    return output;\n  }\n\n  override parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit> {\n    return DayOfMonthParser.parse(input, date);\n  }\n}\n\n/** @internal */\nexport class WeekdayFormat extends DateTimeFormat {\n  private readonly locale: DateTimeLocale;\n\n  constructor(locale: DateTimeLocale) {\n    super();\n    this.locale = locale;\n  }\n\n  override withLocale(locale: DateTimeLocale): DateTimeFormat {\n    if (locale === this.locale) {\n      return this;\n    }\n    return new WeekdayFormat(locale);\n  }\n\n  override writeDate<T>(output: Output<T>, date: DateTime): Output<T> {\n    output = output.write(this.locale.weekdays[date.weekday]!);\n    return output;\n  }\n\n  override parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit> {\n    return WeekdayParser.parse(input, this.locale, date);\n  }\n}\n\n/** @internal */\nexport class ShortWeekdayFormat extends DateTimeFormat {\n  private readonly locale: DateTimeLocale;\n\n  constructor(locale: DateTimeLocale) {\n    super();\n    this.locale = locale;\n  }\n\n  override withLocale(locale: DateTimeLocale): DateTimeFormat {\n    if (locale === this.locale) {\n      return this;\n    }\n    return new ShortWeekdayFormat(locale);\n  }\n\n  override writeDate<T>(output: Output<T>, date: DateTime): Output<T> {\n    output = output.write(this.locale.shortWeekdays[date.weekday]!);\n    return output;\n  }\n\n  override parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit> {\n    return ShortWeekdayParser.parse(input, this.locale, date);\n  }\n}\n\n/** @internal */\nexport class Hour24Format extends DateTimeFormat {\n  override writeDate<T>(output: Output<T>, date: DateTime): Output<T> {\n    output = DateTimeFormat.writeDateNumber2(output, date.hour);\n    return output;\n  }\n\n  override parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit> {\n    return Hour24Parser.parse(input, date);\n  }\n}\n\n/** @internal */\nexport class Hour12Format extends DateTimeFormat {\n  constructor(padChar: number) {\n    super();\n    this.padChar = padChar;\n  }\n\n  readonly padChar: number;\n\n  override writeDate<T>(output: Output<T>, date: DateTime): Output<T> {\n    let hour = date.hour % 12;\n    if (hour === 0) {\n      hour = 12;\n    }\n    output = DateTimeFormat.writeDateNumber2(output, hour, this.padChar);\n    return output;\n  }\n\n  override parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit> {\n    return Hour12Parser.parse(input, date);\n  }\n}\n\n/** @internal */\nexport class PeriodFormat extends DateTimeFormat {\n  private readonly locale: DateTimeLocale;\n\n  constructor(locale: DateTimeLocale) {\n    super();\n    this.locale = locale;\n  }\n\n  override withLocale(locale: DateTimeLocale): DateTimeFormat {\n    if (locale === this.locale) {\n      return this;\n    }\n    return new PeriodFormat(locale);\n  }\n\n  override writeDate<T>(output: Output<T>, date: DateTime): Output<T> {\n    output = output.write(this.locale.periods[date.hour >= 12 ? 1 : 0]!);\n    return output;\n  }\n\n  override parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit> {\n    return PeriodParser.parse(input, this.locale, date);\n  }\n}\n\n/** @internal */\nexport class MinuteFormat extends DateTimeFormat {\n  override writeDate<T>(output: Output<T>, date: DateTime): Output<T> {\n    output = DateTimeFormat.writeDateNumber2(output, date.minute);\n    return output;\n  }\n\n  override parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit> {\n    return MinuteParser.parse(input, date);\n  }\n}\n\n/** @internal */\nexport class SecondFormat extends DateTimeFormat {\n  override writeDate<T>(output: Output<T>, date: DateTime): Output<T> {\n    output = DateTimeFormat.writeDateNumber2(output, date.second);\n    return output;\n  }\n\n  override parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit> {\n    return SecondParser.parse(input, date);\n  }\n}\n\n/** @internal */\nexport class MillisecondFormat extends DateTimeFormat {\n  override writeDate<T>(output: Output<T>, date: DateTime): Output<T> {\n    output = DateTimeFormat.writeDateNumber3(output, date.millisecond);\n    return output;\n  }\n\n  override parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit> {\n    return MillisecondParser.parse(input, date);\n  }\n}\n\n/** @internal */\nexport class PatternFormat extends DateTimeFormat {\n  private readonly pattern: string;\n  private readonly specifiers: DateTimeSpecifiers;\n\n  constructor(pattern: string, specifiers: DateTimeSpecifiers) {\n    super();\n    this.pattern = pattern;\n    this.specifiers = specifiers;\n  }\n\n  override writeDate<T>(output: Output<T>, date: DateTime): Output<T> {\n    const pattern = this.pattern;\n    const specifiers = this.specifiers;\n    let i = 0;\n    let j = 0;\n    while (j < pattern.length) {\n      if (pattern.charCodeAt(j) !== 37/*'%'*/) {\n        j += 1;\n        continue;\n      } else if (i !== j) {\n        output = output.write(pattern.slice(i, j));\n      }\n      const s = pattern.charAt(j + 1);\n      const f = specifiers[s];\n      if (f !== void 0) {\n        output = f.writeDate(output, date);\n      }\n      j += 2;\n      i = j;\n    }\n    if (i !== j) {\n      output = output.write(pattern.slice(i, j));\n    }\n    return output;\n  }\n\n  override parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit> {\n    return PatternParser.parse(input, this.pattern, this.specifiers, date);\n  }\n}\n\n/** @internal */\nexport class YearParser extends Parser<DateTimeInit> {\n  private readonly date: DateTimeInit | undefined;\n  private readonly year: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(date?: DateTimeInit, year?: number, step?: number) {\n    super();\n    this.date = date;\n    this.year = year;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<DateTimeInit> {\n    return YearParser.parse(input, this.date, this.year, this.step);\n  }\n\n  static parse(input: Input, date?: DateTimeInit, year?: number, step?: number): Parser<DateTimeInit> {\n    return DateTimeFormat.parseDateNumber(input, YearParser, \"full year\", 4, 4, date, year, step);\n  }\n\n  static term(year: number, date: DateTimeInit): Parser<DateTimeInit> {\n    date.year = year;\n    return Parser.done(date);\n  }\n\n  static cont(date: DateTimeInit, year: number, step: number): Parser<DateTimeInit> {\n    return new YearParser(date, year, step);\n  }\n}\n\n/** @internal */\nexport class MonthOfYearParser extends Parser<DateTimeInit> {\n  private readonly date: DateTimeInit | undefined;\n  private readonly month: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(date?: DateTimeInit, month?: number, step?: number) {\n    super();\n    this.date = date;\n    this.month = month;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<DateTimeInit> {\n    return MonthOfYearParser.parse(input, this.date, this.month, this.step);\n  }\n\n  static parse(input: Input, date?: DateTimeInit, month?: number, step?: number): Parser<DateTimeInit> {\n    return DateTimeFormat.parseDateNumber(input, MonthOfYearParser, \"month number\", 2, 2, date, month, step);\n  }\n\n  static term(month: number, date: DateTimeInit): Parser<DateTimeInit> {\n    date.month = month - 1;\n    return Parser.done(date);\n  }\n\n  static cont(date: DateTimeInit, month: number, step: number): Parser<DateTimeInit> {\n    return new MonthOfYearParser(date, month, step);\n  }\n}\n\n/** @internal */\nexport class MonthParser extends Parser<DateTimeInit> {\n  private readonly locale: DateTimeLocale;\n  private readonly date: DateTimeInit | undefined;\n  private readonly output: Output<string> | undefined;\n\n  constructor(locale: DateTimeLocale, date?: DateTimeInit, output?: Output<string>) {\n    super();\n    this.locale = locale;\n    this.date = date;\n    this.output = output;\n  }\n\n  override feed(input: Input): Parser<DateTimeInit> {\n    return MonthParser.parse(input, this.locale, this.date, this.output);\n  }\n\n  static parse(input: Input, locale: DateTimeLocale, date?: DateTimeInit,\n               output?: Output<string>): Parser<DateTimeInit> {\n    return DateTimeFormat.parseDateString(input, MonthParser, locale, date, output);\n  }\n\n  static term(locale: DateTimeLocale, value: string, date: DateTimeInit, input: Input): Parser<DateTimeInit> {\n    const month = locale.months.indexOf(value);\n    if (month < 0) {\n      return Parser.error(Diagnostic.message(\"expected month, but found \" + value, input));\n    }\n    date.month = month;\n    return Parser.done(date);\n  }\n\n  static cont(locale: DateTimeLocale, date: DateTimeInit, output: Output<string>): Parser<DateTimeInit> {\n    return new MonthParser(locale, date, output);\n  }\n}\n\n/** @internal */\nexport class ShortMonthParser extends Parser<DateTimeInit> {\n  private readonly locale: DateTimeLocale;\n  private readonly date: DateTimeInit | undefined;\n  private readonly output: Output<string> | undefined;\n\n  constructor(locale: DateTimeLocale, date?: DateTimeInit, output?: Output<string>) {\n    super();\n    this.locale = locale;\n    this.date = date;\n    this.output = output;\n  }\n\n  override feed(input: Input): Parser<DateTimeInit> {\n    return ShortMonthParser.parse(input, this.locale, this.date, this.output);\n  }\n\n  static parse(input: Input, locale: DateTimeLocale, date?: DateTimeInit,\n               output?: Output<string>): Parser<DateTimeInit> {\n    return DateTimeFormat.parseDateString(input, ShortMonthParser, locale, date, output);\n  }\n\n  static term(locale: DateTimeLocale, value: string, date: DateTimeInit, input: Input): Parser<DateTimeInit> {\n    const month = locale.shortMonths.indexOf(value);\n    if (month < 0) {\n      return Parser.error(Diagnostic.message(\"expected short month, but found \" + value, input));\n    }\n    date.month = month;\n    return Parser.done(date);\n  }\n\n  static cont(locale: DateTimeLocale, date: DateTimeInit, output: Output<string>): Parser<DateTimeInit> {\n    return new ShortMonthParser(locale, date, output);\n  }\n}\n\n/** @internal */\nexport class DayOfMonthParser extends Parser<DateTimeInit> {\n  private readonly date: DateTimeInit | undefined;\n  private readonly day: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(date?: DateTimeInit, day?: number, step?: number) {\n    super();\n    this.date = date;\n    this.day = day;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<DateTimeInit> {\n    return DayOfMonthParser.parse(input, this.date, this.day, this.step);\n  }\n\n  static parse(input: Input, date?: DateTimeInit, day?: number, step?: number): Parser<DateTimeInit> {\n    return DateTimeFormat.parseDateNumber(input, DayOfMonthParser, \"day of month\", 2, 2, date, day, step);\n  }\n\n  static term(day: number, date: DateTimeInit): Parser<DateTimeInit> {\n    date.day = day;\n    return Parser.done(date);\n  }\n\n  static cont(date: DateTimeInit, month: number, step: number): Parser<DateTimeInit> {\n    return new DayOfMonthParser(date, month, step);\n  }\n}\n\n/** @internal */\nexport class WeekdayParser extends Parser<DateTimeInit> {\n  private readonly locale: DateTimeLocale;\n  private readonly date: DateTimeInit | undefined;\n  private readonly output: Output<string> | undefined;\n\n  constructor(locale: DateTimeLocale, date?: DateTimeInit, output?: Output<string>) {\n    super();\n    this.locale = locale;\n    this.date = date;\n    this.output = output;\n  }\n\n  override feed(input: Input): Parser<DateTimeInit> {\n    return WeekdayParser.parse(input, this.locale, this.date, this.output);\n  }\n\n  static parse(input: Input, locale: DateTimeLocale, date?: DateTimeInit,\n               output?: Output<string>): Parser<DateTimeInit> {\n    return DateTimeFormat.parseDateString(input, WeekdayParser, locale, date, output);\n  }\n\n  static term(locale: DateTimeLocale, value: string, date: DateTimeInit, input: Input): Parser<DateTimeInit> {\n    const day = locale.weekdays.indexOf(value);\n    if (day < 0) {\n      return Parser.error(Diagnostic.message(\"expected weekday, but found \" + value, input));\n    }\n    return Parser.done(date);\n  }\n\n  static cont(locale: DateTimeLocale, date: DateTimeInit, output: Output<string>): Parser<DateTimeInit> {\n    return new WeekdayParser(locale, date, output);\n  }\n}\n\n/** @internal */\nexport class ShortWeekdayParser extends Parser<DateTimeInit> {\n  private readonly locale: DateTimeLocale;\n  private readonly date: DateTimeInit | undefined;\n  private readonly output: Output<string> | undefined;\n\n  constructor(locale: DateTimeLocale, date?: DateTimeInit, output?: Output<string>) {\n    super();\n    this.locale = locale;\n    this.date = date;\n    this.output = output;\n  }\n\n  override feed(input: Input): Parser<DateTimeInit> {\n    return ShortWeekdayParser.parse(input, this.locale, this.date, this.output);\n  }\n\n  static parse(input: Input, locale: DateTimeLocale, date?: DateTimeInit,\n               output?: Output<string>): Parser<DateTimeInit> {\n    return DateTimeFormat.parseDateString(input, ShortWeekdayParser, locale, date, output);\n  }\n\n  static term(locale: DateTimeLocale, value: string, date: DateTimeInit, input: Input): Parser<DateTimeInit> {\n    const day = locale.shortWeekdays.indexOf(value);\n    if (day < 0) {\n      return Parser.error(Diagnostic.message(\"expected short weekday, but found \" + value, input));\n    }\n    return Parser.done(date);\n  }\n\n  static cont(locale: DateTimeLocale, date: DateTimeInit, output: Output<string>): Parser<DateTimeInit> {\n    return new ShortWeekdayParser(locale, date, output);\n  }\n}\n\n/** @internal */\nexport class Hour24Parser extends Parser<DateTimeInit> {\n  private readonly date: DateTimeInit | undefined;\n  private readonly hour: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(date?: DateTimeInit, hour?: number, step?: number) {\n    super();\n    this.date = date;\n    this.hour = hour;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<DateTimeInit> {\n    return Hour24Parser.parse(input, this.date, this.hour, this.step);\n  }\n\n  static parse(input: Input, date?: DateTimeInit, hour?: number, step?: number): Parser<DateTimeInit> {\n    return DateTimeFormat.parseDateNumber(input, Hour24Parser, \"hour (24)\", 2, 2, date, hour, step);\n  }\n\n  static term(hour: number, date: DateTimeInit): Parser<DateTimeInit> {\n    date.hour = hour;\n    return Parser.done(date);\n  }\n\n  static cont(date: DateTimeInit, hour: number, step: number): Parser<DateTimeInit> {\n    return new Hour24Parser(date, hour, step);\n  }\n}\n\n/** @internal */\nexport class Hour12Parser extends Parser<DateTimeInit> {\n  private readonly date: DateTimeInit | undefined;\n  private readonly hour: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(date?: DateTimeInit, hour?: number, step?: number) {\n    super();\n    this.date = date;\n    this.hour = hour;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<DateTimeInit> {\n    return Hour12Parser.parse(input, this.date, this.hour, this.step);\n  }\n\n  static parse(input: Input, date?: DateTimeInit, hour?: number, step?: number): Parser<DateTimeInit> {\n    return DateTimeFormat.parseDateNumber(input, Hour12Parser, \"hour (12)\", 2, 2, date, hour, step);\n  }\n\n  static term(hour: number, date: DateTimeInit): Parser<DateTimeInit> {\n    date.hour = (date.hour !== void 0 ? date.hour : 0) + hour;\n    return Parser.done(date);\n  }\n\n  static cont(date: DateTimeInit, hour: number, step: number): Parser<DateTimeInit> {\n    return new Hour12Parser(date, hour, step);\n  }\n}\n\n/** @internal */\nexport class PeriodParser extends Parser<DateTimeInit> {\n  private readonly locale: DateTimeLocale;\n  private readonly date: DateTimeInit | undefined;\n  private readonly output: Output<string> | undefined;\n\n  constructor(locale: DateTimeLocale, date?: DateTimeInit, output?: Output<string>) {\n    super();\n    this.locale = locale;\n    this.date = date;\n    this.output = output;\n  }\n\n  override feed(input: Input): Parser<DateTimeInit> {\n    return PeriodParser.parse(input, this.locale, this.date, this.output);\n  }\n\n  static parse(input: Input, locale: DateTimeLocale, date?: DateTimeInit,\n               output?: Output<string>): Parser<DateTimeInit> {\n    return DateTimeFormat.parseDateString(input, PeriodParser, locale, date, output);\n  }\n\n  static term(locale: DateTimeLocale, value: string, date: DateTimeInit, input: Input): Parser<DateTimeInit> {\n    const period = locale.months.indexOf(value);\n    if (period < 0) {\n      return Parser.error(Diagnostic.message(\"expected period of day, but found \" + value, input));\n    }\n    date.hour = (date.hour || 0) + 12 * period;\n    return Parser.done(date);\n  }\n\n  static cont(locale: DateTimeLocale, date: DateTimeInit, output: Output<string>): Parser<DateTimeInit> {\n    return new PeriodParser(locale, date, output);\n  }\n}\n\n/** @internal */\nexport class MinuteParser extends Parser<DateTimeInit> {\n  private readonly date: DateTimeInit | undefined;\n  private readonly minute: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(date?: DateTimeInit, minute?: number, step?: number) {\n    super();\n    this.date = date;\n    this.minute = minute;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<DateTimeInit> {\n    return MinuteParser.parse(input, this.date, this.minute, this.step);\n  }\n\n  static parse(input: Input, date?: DateTimeInit, minute?: number, step?: number): Parser<DateTimeInit> {\n    return DateTimeFormat.parseDateNumber(input, MinuteParser, \"minute\", 2, 2, date, minute, step);\n  }\n\n  static term(minute: number, date: DateTimeInit): Parser<DateTimeInit> {\n    date.minute = minute;\n    return Parser.done(date);\n  }\n\n  static cont(date: DateTimeInit, minute: number, step: number): Parser<DateTimeInit> {\n    return new MinuteParser(date, minute, step);\n  }\n}\n\n/** @internal */\nexport class SecondParser extends Parser<DateTimeInit> {\n  private readonly date: DateTimeInit | undefined;\n  private readonly second: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(date?: DateTimeInit, second?: number, step?: number) {\n    super();\n    this.date = date;\n    this.second = second;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<DateTimeInit> {\n    return SecondParser.parse(input, this.date, this.second, this.step);\n  }\n\n  static parse(input: Input, date?: DateTimeInit, second?: number, step?: number): Parser<DateTimeInit> {\n    return DateTimeFormat.parseDateNumber(input, SecondParser, \"second\", 2, 2, date, second, step);\n  }\n\n  static term(second: number, date: DateTimeInit): Parser<DateTimeInit> {\n    date.second = second;\n    return Parser.done(date);\n  }\n\n  static cont(date: DateTimeInit, second: number, step: number): Parser<DateTimeInit> {\n    return new SecondParser(date, second, step);\n  }\n}\n\n/** @internal */\nexport class MillisecondParser extends Parser<DateTimeInit> {\n  private readonly date: DateTimeInit | undefined;\n  private readonly millisecond: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(date?: DateTimeInit, millisecond?: number, step?: number) {\n    super();\n    this.date = date;\n    this.millisecond = millisecond;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<DateTimeInit> {\n    return MillisecondParser.parse(input, this.date, this.millisecond, this.step);\n  }\n\n  static parse(input: Input, date?: DateTimeInit, millisecond?: number, step?: number): Parser<DateTimeInit> {\n    return DateTimeFormat.parseDateNumber(input, MillisecondParser, \"millisecond\", 1, 3, date, millisecond, step);\n  }\n\n  static term(millisecond: number, date: DateTimeInit): Parser<DateTimeInit> {\n    date.millisecond = millisecond;\n    return Parser.done(date);\n  }\n\n  static cont(date: DateTimeInit, millisecond: number, step: number): Parser<DateTimeInit> {\n    return new MillisecondParser(date, millisecond, step);\n  }\n}\n\n/** @internal */\nexport class PatternParser extends Parser<DateTimeInit> {\n  private readonly pattern: string;\n  private readonly specifiers: DateTimeSpecifiers;\n  private readonly date: DateTimeInit | undefined;\n  private readonly dateParser: Parser<DateTimeInit> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(pattern: string, specifiers: DateTimeSpecifiers, date?: DateTimeInit,\n              dateParser?: Parser<DateTimeInit>, step?: number) {\n    super();\n    this.pattern = pattern;\n    this.specifiers = specifiers;\n    this.date = date;\n    this.dateParser = dateParser;\n    this.step = step;\n  }\n\n  override feed(input: Input): Parser<DateTimeInit> {\n    return PatternParser.parse(input, this.pattern, this.specifiers, this.date,\n                                     this.dateParser, this.step);\n  }\n\n  static parse(input: Input, pattern: string, specifiers: DateTimeSpecifiers,\n               date: DateTimeInit = {}, dateParser?: Parser<DateTimeInit>,\n               step: number = 0): Parser<DateTimeInit> {\n    let c = 0;\n    const n = pattern.length;\n    while (step < n) {\n      const p = pattern.charCodeAt(step);\n      if (p === 37/*'%'*/) {\n        if (dateParser === void 0) {\n          const s = pattern.charAt(step + 1);\n          const format = specifiers[s];\n          if (format !== void 0) {\n            dateParser = format.parseDateTime(input, date);\n          } else {\n            return Parser.error(Diagnostic.message(\"unknown format specifier: \" + s, input));\n          }\n        } else {\n          dateParser = dateParser.feed(input);\n        }\n        if (dateParser.isDone()) {\n          date = dateParser.bind();\n          dateParser = void 0;\n          step += 2;\n          continue;\n        } else if (dateParser.isError()) {\n          return dateParser.asError();\n        }\n      } else if (input.isCont()) {\n        c = input.head();\n        if (c === p) {\n          input.step();\n          step += 1;\n          continue;\n        } else {\n          return Parser.error(Diagnostic.expected(p, input));\n        }\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n      break;\n    }\n    if (step === n) {\n      return Parser.done(date);\n    }\n    return new PatternParser(pattern, specifiers, date, dateParser, step);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {DateTimeLike} from \"./DateTime\";\nimport {DateTime} from \"./DateTime\";\n\n/** @public */\nexport abstract class TimeInterval {\n  abstract offset(d: DateTimeLike, k?: number): DateTime;\n\n  next(d: DateTimeLike, k?: number): DateTime {\n    return this.floor(this.offset(d, k));\n  }\n\n  abstract floor(d: DateTimeLike): DateTime;\n\n  ceil(d: DateTimeLike): DateTime {\n    if (d instanceof DateTime) {\n      d = new DateTime(d.time - 1, d.zone);\n    } else {\n      d = DateTime.time(d) - 1;\n    }\n    return this.next(this.floor(d), 1);\n  }\n\n  round(t: DateTimeLike): DateTime {\n    const d = DateTime.fromLike(t);\n    const d0 = this.floor(d);\n    const d1 = this.ceil(d);\n    return d.time - d0.time < d1.time - d.time ? d0 : d1;\n  }\n\n  range(t0: DateTimeLike, t1: DateTimeLike, step?: number): DateTime[] {\n    let d0 = this.ceil(t0);\n    const d1 = DateTime.time(t1);\n    const ds: DateTime[] = [];\n    step = typeof step === \"number\" ? Math.floor(step) : 1;\n    if (step > 0) {\n      while (d0.isDefined() && d0.time < d1) {\n        ds.push(d0);\n        d0 = this.next(d0, step);\n      }\n    }\n    return ds;\n  }\n\n  filter(predicate: (d: DateTime) => boolean): TimeInterval {\n    return new FilterTimeInterval(this, predicate);\n  }\n\n  /** @internal */\n  static Year: YearInterval | null = null;\n  static get year(): UnitTimeInterval {\n    if (this.Year === null) {\n      this.Year = new YearInterval();\n    }\n    return this.Year;\n  }\n\n  /** @internal */\n  static Month: MonthInterval | null = null;\n  static get month(): UnitTimeInterval {\n    if (this.Month === null) {\n      this.Month = new MonthInterval();\n    }\n    return this.Month;\n  }\n\n  /** @internal */\n  static Week: WeekInterval | null = null;\n  static get week(): TimeInterval {\n    if (this.Week === null) {\n      this.Week = new WeekInterval();\n    }\n    return this.Week;\n  }\n\n  /** @internal */\n  static Day: DayInterval | null = null;\n  static get day(): UnitTimeInterval {\n    if (this.Day === null) {\n      this.Day = new DayInterval();\n    }\n    return this.Day;\n  }\n\n  /** @internal */\n  static Hour: HourInterval | null = null;\n  static get hour(): UnitTimeInterval {\n    if (this.Hour === null) {\n      this.Hour = new HourInterval();\n    }\n    return this.Hour;\n  }\n\n  /** @internal */\n  static Minute: MinuteInterval | null = null;\n  static get minute(): UnitTimeInterval {\n    if (this.Minute === null) {\n      this.Minute = new MinuteInterval();\n    }\n    return this.Minute;\n  }\n\n  /** @internal */\n  static Second: SecondInterval | null = null;\n  static get second(): UnitTimeInterval {\n    if (this.Second === null) {\n      this.Second = new SecondInterval();\n    }\n    return this.Second;\n  }\n\n  /** @internal */\n  static Millisecond: MillisecondInterval | null = null;\n  static get millisecond(): UnitTimeInterval {\n    if (this.Millisecond === null) {\n      this.Millisecond = new MillisecondInterval();\n    }\n    return this.Millisecond;\n  }\n\n  static years(d0: DateTimeLike, d1: DateTimeLike, step?: number): DateTime[] {\n    return TimeInterval.year.range(d0, d1, step);\n  }\n\n  static months(d0: DateTimeLike, d1: DateTimeLike, step?: number): DateTime[] {\n    return TimeInterval.month.range(d0, d1, step);\n  }\n\n  static weeks(d0: DateTimeLike, d1: DateTimeLike, step?: number): DateTime[] {\n    return TimeInterval.week.range(d0, d1, step);\n  }\n\n  static days(d0: DateTimeLike, d1: DateTimeLike, step?: number): DateTime[] {\n    return TimeInterval.day.range(d0, d1, step);\n  }\n\n  static hours(d0: DateTimeLike, d1: DateTimeLike, step?: number): DateTime[] {\n    return TimeInterval.hour.range(d0, d1, step);\n  }\n\n  static minutes(d0: DateTimeLike, d1: DateTimeLike, step?: number): DateTime[] {\n    return TimeInterval.minute.range(d0, d1, step);\n  }\n\n  static seconds(d0: DateTimeLike, d1: DateTimeLike, step?: number): DateTime[] {\n    return TimeInterval.second.range(d0, d1, step);\n  }\n\n  static milliseconds(d0: DateTimeLike, d1: DateTimeLike, step?: number): DateTime[] {\n    return TimeInterval.millisecond.range(d0, d1, step);\n  }\n\n  /** @internal */\n  static readonly MillisPerSecond: number = 1000;\n  /** @internal */\n  static readonly MillisPerMinute: number = 60 * this.MillisPerSecond;\n  /** @internal */\n  static readonly MillisPerHour: number = 60 * this.MillisPerMinute;\n}\n\n/** @public */\nexport abstract class UnitTimeInterval extends TimeInterval {\n  abstract every(k: number): TimeInterval;\n}\n\n/** @internal */\nexport class FilterTimeInterval extends TimeInterval {\n  constructor(unit: TimeInterval, predicate: (d: DateTime) => boolean) {\n    super();\n    this.unit = unit;\n    this.predicate = predicate;\n  }\n\n  /** @internal */\n  readonly unit: TimeInterval;\n  /** @internal */\n  readonly predicate: (d: DateTime) => boolean;\n\n  override offset(t: DateTimeLike, k?: number): DateTime {\n    let d = DateTime.fromLike(t);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    while (k < 0) {\n      do {\n        d = this.unit.offset(d, -1);\n      } while (d.isDefined() && !this.predicate(d));\n      k += 1;\n    }\n    while (k > 0) {\n      do {\n        d = this.unit.offset(d, 1);\n      } while (d.isDefined() && !this.predicate(d));\n      k -= 1;\n    }\n    return d;\n  }\n\n  override floor(t: DateTimeLike): DateTime {\n    let d = DateTime.fromLike(t);\n    while (d = this.unit.floor(d), d.isDefined() && !this.predicate(d)) {\n      d = new DateTime(d.time - 1, d.zone);\n    }\n    return d;\n  }\n}\n\n/** @internal */\nexport class YearInterval extends UnitTimeInterval {\n  override offset(t: DateTimeLike, k?: number): DateTime {\n    let d = DateTime.fromLike(t);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    d = d.withYear(d.year + k);\n    return d;\n  }\n\n  override next(t: DateTimeLike, k?: number): DateTime {\n    const d = DateTime.fromLike(t);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    return d.withYear(d.year + k).withMonth(0, 1).withHour(0, 0, 0, 0);\n  }\n\n  override floor(t: DateTimeLike): DateTime {\n    const d = DateTime.fromLike(t);\n    return d.withMonth(0, 1).withHour(0, 0, 0, 0);\n  }\n\n  override ceil(t: DateTimeLike): DateTime {\n    let d = DateTime.fromLike(t);\n    d = new DateTime(d.time - 1, d.zone);\n    d = d.withMonth(0, 1).withHour(0, 0, 0, 0);\n    d = d.withYear(d.year + 1);\n    return d.withMonth(0, 1).withHour(0, 0, 0, 0);\n  }\n\n  override every(k: number): TimeInterval {\n    if (k === 1) {\n      return this;\n    } else if (isFinite(k) && k >= 1) {\n      return new YearsInterval(k);\n    }\n    throw new Error(\"\" + k);\n  }\n}\n\n/** @internal */\nexport class YearsInterval extends TimeInterval {\n  private readonly stride: number;\n\n  constructor(stride: number) {\n    super();\n    this.stride = stride;\n  }\n\n  override offset(t: DateTimeLike, k?: number): DateTime {\n    const d = DateTime.fromLike(t);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    return d.withYear(d.year + k * this.stride);\n  }\n\n  override next(t: DateTimeLike, k?: number): DateTime {\n    let d = DateTime.fromLike(t);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    d = d.withYear(Math.floor((d.year + k * this.stride) / this.stride) * this.stride);\n    return d.withMonth(0, 1).withHour(0, 0, 0, 0);\n  }\n\n  override floor(t: DateTimeLike): DateTime {\n    let d = DateTime.fromLike(t);\n    d = d.withYear(Math.floor(d.year / this.stride) * this.stride);\n    return d.withMonth(0, 1).withHour(0, 0, 0, 0);\n  }\n\n  override ceil(t: DateTimeLike): DateTime {\n    let d = DateTime.fromLike(t);\n    d = new DateTime(d.time - 1, d.zone);\n    d = d.withYear(Math.floor(d.year / this.stride) * this.stride);\n    d = d.withMonth(0, 1).withHour(0, 0, 0, 0);\n    d = d.withYear(Math.floor((d.year + this.stride) / this.stride) * this.stride);\n    return d.withMonth(0, 1).withHour(0, 0, 0, 0);\n  }\n}\n\n/** @internal */\nexport class MonthInterval extends UnitTimeInterval {\n  override offset(t: DateTimeLike, k?: number): DateTime {\n    const d = DateTime.fromLike(t);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    return d.withMonth(d.month + k);\n  }\n\n  override next(t: DateTimeLike, k?: number): DateTime {\n    let d = DateTime.fromLike(t);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    d = d.withMonth(d.month + k);\n    return d.withDay(1).withHour(0, 0, 0, 0);\n  }\n\n  override floor(t: DateTimeLike): DateTime {\n    const d = DateTime.fromLike(t);\n    return d.withDay(1).withHour(0, 0, 0, 0);\n  }\n\n  override ceil(t: DateTimeLike): DateTime {\n    let d = DateTime.fromLike(t);\n    d = new DateTime(d.time - 1, d.zone);\n    d = d.withDay(1).withHour(0, 0, 0, 0);\n    d = d.withMonth(d.month + 1);\n    return d.withDay(1).withHour(0, 0, 0, 0);\n  }\n\n  override every(k: number): TimeInterval {\n    if (k === 1) {\n      return this;\n    } else if (isFinite(k) && k >= 1) {\n      return new FilterTimeInterval(this, MonthInterval.modulo.bind(void 0, k));\n    }\n    throw new Error(\"\" + k);\n  }\n\n  /** @internal */\n  static modulo(k: number, d: DateTime): boolean {\n    const month = d.month;\n    return isFinite(month) && month % k === 0;\n  }\n}\n\n/** @internal */\nexport class WeekInterval extends TimeInterval {\n  readonly day: number;\n\n  constructor(day: number = 0) {\n    super();\n    this.day = day;\n  }\n\n  override offset(t: DateTimeLike, k?: number): DateTime {\n    const d = DateTime.fromLike(t);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    return d.withDay(d.day + 7 * k);\n  }\n\n  override next(t: DateTimeLike, k?: number): DateTime {\n    let d = DateTime.fromLike(t);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    d = d.withDay(d.day + 7 * k);\n    d = d.withDay(d.day - (d.weekday + 7 - this.day) % 7);\n    return d.withHour(0, 0, 0, 0);\n  }\n\n  override floor(t: DateTimeLike): DateTime {\n    let d = DateTime.fromLike(t);\n    d = d.withDay(d.day - (d.weekday + 7 - this.day) % 7);\n    return d.withHour(0, 0, 0, 0);\n  }\n\n  override ceil(t: DateTimeLike): DateTime {\n    let d = DateTime.fromLike(t);\n    d = new DateTime(d.time - 1, d.zone);\n    d = d.withDay(d.day - (d.weekday + 7 - this.day) % 7);\n    d = d.withHour(0, 0, 0, 0);\n    d = d.withDay(d.day + 7);\n    return d.withHour(0, 0, 0, 0);\n  }\n}\n\n/** @internal */\nexport class DayInterval extends UnitTimeInterval {\n  override offset(t: DateTimeLike, k?: number): DateTime {\n    const d = DateTime.fromLike(t);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    return d.withDay(d.day + k);\n  }\n\n  override next(t: DateTimeLike, k?: number): DateTime {\n    let d = DateTime.fromLike(t);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    d = d.withDay(d.day + k);\n    return d.withHour(0, 0, 0, 0);\n  }\n\n  override floor(t: DateTimeLike): DateTime {\n    const d = DateTime.fromLike(t);\n    return d.withHour(0, 0, 0, 0);\n  }\n\n  override ceil(t: DateTimeLike): DateTime {\n    let d = DateTime.fromLike(t);\n    d = new DateTime(d.time - 1, d.zone);\n    d = d.withHour(0, 0, 0, 0);\n    d = d.withDay(d.day + 1);\n    return d.withHour(0, 0, 0, 0);\n  }\n\n  override every(k: number): TimeInterval {\n    if (k === 1) {\n      return this;\n    } else if (isFinite(k) && k >= 1) {\n      return new FilterTimeInterval(this, DayInterval.modulo.bind(void 0, k));\n    }\n    throw new Error(\"\" + k);\n  }\n\n  /** @internal */\n  static modulo(k: number, d: DateTime): boolean {\n    const day = d.day;\n    return isFinite(day) && day % k === 0;\n  }\n}\n\n/** @internal */\nexport class HourInterval extends UnitTimeInterval {\n  override offset(d: DateTimeLike, k?: number): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    d += k * TimeInterval.MillisPerHour;\n    return new DateTime(d, z);\n  }\n\n  override next(d: DateTimeLike, k?: number): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    d += k * TimeInterval.MillisPerHour;\n    let dtz = z.offset * TimeInterval.MillisPerMinute % TimeInterval.MillisPerHour;\n    if (dtz < 0) {\n      dtz += TimeInterval.MillisPerHour;\n    }\n    d = Math.floor((d - dtz) / TimeInterval.MillisPerHour) * TimeInterval.MillisPerHour + dtz;\n    return new DateTime(d, z);\n  }\n\n  override floor(d: DateTimeLike): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    let dtz = z.offset * TimeInterval.MillisPerMinute % TimeInterval.MillisPerHour;\n    if (dtz < 0) {\n      dtz += TimeInterval.MillisPerHour;\n    }\n    d = Math.floor((d - dtz) / TimeInterval.MillisPerHour) * TimeInterval.MillisPerHour + dtz;\n    return new DateTime(d, z);\n  }\n\n  override ceil(d: DateTimeLike): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    d -= 1;\n    let dtz = z.offset * TimeInterval.MillisPerMinute % TimeInterval.MillisPerHour;\n    if (dtz < 0) {\n      dtz += TimeInterval.MillisPerHour;\n    }\n    d = (Math.floor((d - dtz) / TimeInterval.MillisPerHour) * TimeInterval.MillisPerHour + dtz) + TimeInterval.MillisPerHour;\n    d = Math.floor((d - dtz) / TimeInterval.MillisPerHour) * TimeInterval.MillisPerHour + dtz;\n    return new DateTime(d, z);\n  }\n\n  override every(k: number): TimeInterval {\n    if (k === 1) {\n      return this;\n    } else if (isFinite(k) && k >= 1) {\n      return new FilterTimeInterval(this, HourInterval.modulo.bind(void 0, k));\n    }\n    throw new Error(\"\" + k);\n  }\n\n  /** @internal */\n  static modulo(k: number, d: DateTime): boolean {\n    const hour = d.hour;\n    return isFinite(hour) && hour % k === 0;\n  }\n}\n\n/** @internal */\nexport class MinuteInterval extends UnitTimeInterval {\n  override offset(d: DateTimeLike, k?: number): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    d += k * TimeInterval.MillisPerMinute;\n    return new DateTime(d, z);\n  }\n\n  override next(d: DateTimeLike, k?: number): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    d = Math.floor((d + k * TimeInterval.MillisPerMinute) / TimeInterval.MillisPerMinute) * TimeInterval.MillisPerMinute;\n    return new DateTime(d, z);\n  }\n\n  override floor(d: DateTimeLike): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    d = Math.floor(d / TimeInterval.MillisPerMinute) * TimeInterval.MillisPerMinute;\n    return new DateTime(d, z);\n  }\n\n  override ceil(d: DateTimeLike): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    d = Math.floor(((Math.floor((d - 1) / TimeInterval.MillisPerMinute) * TimeInterval.MillisPerMinute) + TimeInterval.MillisPerMinute) / TimeInterval.MillisPerMinute) * TimeInterval.MillisPerMinute;\n    return new DateTime(d, z);\n  }\n\n  override every(k: number): TimeInterval {\n    if (k === 1) {\n      return this;\n    } else if (isFinite(k) && k >= 1) {\n      return new FilterTimeInterval(this, MinuteInterval.modulo.bind(void 0, k));\n    }\n    throw new Error(\"\" + k);\n  }\n\n  /** @internal */\n  static modulo(k: number, d: DateTime): boolean {\n    const minute = d.minute;\n    return isFinite(minute) && minute % k === 0;\n  }\n}\n\n/** @internal */\nexport class SecondInterval extends UnitTimeInterval {\n  override offset(d: DateTimeLike, k?: number): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    d += k * TimeInterval.MillisPerSecond;\n    return new DateTime(d, z);\n  }\n\n  override next(d: DateTimeLike, k?: number): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    d += k * TimeInterval.MillisPerSecond;\n    d = Math.floor(d / TimeInterval.MillisPerSecond) * TimeInterval.MillisPerSecond;\n    return new DateTime(d, z);\n  }\n\n  override floor(d: DateTimeLike): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    d = Math.floor(d / TimeInterval.MillisPerSecond) * TimeInterval.MillisPerSecond;\n    return new DateTime(d, z);\n  }\n\n  override ceil(d: DateTimeLike): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    d = Math.floor(((Math.floor((d - 1) / TimeInterval.MillisPerSecond) * TimeInterval.MillisPerSecond) + TimeInterval.MillisPerSecond) / TimeInterval.MillisPerSecond) * TimeInterval.MillisPerSecond;\n    return new DateTime(d, z);\n  }\n\n  override every(k: number): TimeInterval {\n    if (k === 1) {\n      return this;\n    } else if (isFinite(k) && k >= 1) {\n      return new FilterTimeInterval(this, SecondInterval.modulo.bind(void 0, k));\n    }\n    throw new Error('' + k);\n  }\n\n  /** @internal */\n  static modulo(k: number, d: DateTime): boolean {\n    const second = d.second;\n    return isFinite(second) && second % k === 0;\n  }\n}\n\n/** @internal */\nexport class MillisecondInterval extends UnitTimeInterval {\n  override offset(d: DateTimeLike, k?: number): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    d += k;\n    return new DateTime(d, z);\n  }\n\n  override next(d: DateTimeLike, k?: number): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    d += k;\n    return new DateTime(d, z);\n  }\n\n  override floor(d: DateTimeLike): DateTime {\n    return DateTime.fromLike(d);\n  }\n\n  override ceil(d: DateTimeLike): DateTime {\n    return DateTime.fromLike(d);\n  }\n\n  override every(k: number): TimeInterval {\n    if (k === 1) {\n      return this;\n    } else if (isFinite(k) && k >= 1) {\n      return new MillisecondsInterval(k);\n    }\n    throw new Error(\"\" + k);\n  }\n}\n\n/** @internal */\nexport class MillisecondsInterval extends TimeInterval {\n  private readonly stride: number;\n\n  constructor(stride: number) {\n    super();\n    if (!isFinite(stride)) {\n      stride = 1;\n    }\n    this.stride = stride;\n  }\n\n  override offset(d: DateTimeLike, k?: number): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    d += k * this.stride;\n    return new DateTime(d, z);\n  }\n\n  override next(d: DateTimeLike, k?: number): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    k = Math.max(1, typeof k === \"number\" ? Math.floor(k) : 1);\n    const stride = this.stride;\n    d = Math.floor((d + k * stride) / stride) * stride;\n    return new DateTime(d, z);\n  }\n\n  override floor(d: DateTimeLike): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    const stride = this.stride;\n    d = Math.floor(d / stride) * stride;\n    return new DateTime(d, z);\n  }\n\n  override ceil(d: DateTimeLike): DateTime {\n    const z = DateTime.zone(d);\n    d = DateTime.time(d);\n    const stride = this.stride;\n    d = Math.floor(((Math.floor((d - 1) / stride) * stride) + stride) / stride) * stride;\n    return new DateTime(d, z);\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Domain} from \"@swim/util\";\nimport type {Interpolate} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport type {DateTimeLike} from \"./DateTime\";\nimport {DateTime} from \"./DateTime\";\nimport {TimeRange} from \"./\"; // forward import\n\n/** @public */\nexport interface TimeDomain extends Domain<DateTime>, Interpolate<TimeDomain> {\n  /** @override */\n  readonly 0: DateTime;\n\n  /** @override */\n  readonly 1: DateTime;\n\n  readonly inverse: TimeRange;\n\n  /** @override */\n  contains(t: DateTimeLike): boolean;\n\n  /** @override */\n  union(that: Domain<DateTime>): TimeDomain;\n\n  /** @override */\n  interpolateTo(that: TimeDomain): Interpolator<TimeDomain>;\n  interpolateTo(that: unknown): Interpolator<TimeDomain> | null;\n\n  /** @override */\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const TimeDomain = (function (_super: typeof Domain) {\n  const TimeDomain = function (x0: DateTime, x1: DateTime): TimeDomain {\n    const domain = function (t: DateTime): number {\n      const t0 = domain[0].time;\n      const t1 = domain[1].time;\n      const dt = t1 - t0;\n      return dt !== 0 ? (t.time - t0) / dt : 0;\n    } as TimeDomain;\n    Object.setPrototypeOf(domain, TimeDomain.prototype);\n    (domain as Mutable<typeof domain>)[0] = x0;\n    (domain as Mutable<typeof domain>)[1] = x1;\n    return domain;\n  } as {\n    (x0: DateTime, x1: DateTime): TimeDomain;\n\n    /** @internal */\n    prototype: TimeDomain;\n  };\n\n  TimeDomain.prototype = Object.create(_super.prototype);\n  TimeDomain.prototype.constructor = TimeDomain;\n\n  Object.defineProperty(TimeDomain.prototype, \"inverse\", {\n    get(this: TimeDomain): TimeRange {\n      return TimeRange(this[0], this[1]);\n    },\n    configurable: true,\n  });\n\n  TimeDomain.prototype.contains = function (t: DateTimeLike): boolean {\n    t = DateTime.time(t);\n    return this[0].time <= t && t <= this[1].time;\n  };\n\n  TimeDomain.prototype.union = function (that: Domain<DateTime>): TimeDomain {\n    const t0Min = this[0];\n    const t0Max = this[1];\n    const t1Min = that[0];\n    const t1Max = that[1];\n    const tMin = t0Min.time <= t1Min.time ? t0Min : t1Min;\n    const tMax = t0Max.time >= t1Max.time ? t0Max : t1Max;\n    return TimeDomain(tMin, tMax);\n  };\n\n  TimeDomain.prototype.interpolateTo = function (this: TimeDomain, that: unknown): Interpolator<TimeDomain> | null {\n    if (that instanceof TimeDomain) {\n      return TimeDomainInterpolator(this, that);\n    }\n    return null;\n  } as typeof TimeDomain.prototype.interpolateTo;\n\n  TimeDomain.prototype.canEqual = function (that: unknown): boolean {\n    return that instanceof TimeDomain;\n  };\n\n  TimeDomain.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof TimeDomain) {\n      return that.canEqual(this) && this[0].equals(that[0]) && this[1].equals(that[1]);\n    }\n    return false;\n  };\n\n  TimeDomain.prototype.toString = function (): string {\n    return \"TimeDomain(\" + this[0] + \", \" + this[1] + \")\";\n  };\n\n  return TimeDomain;\n})(Domain);\n\n/** @internal */\nexport const TimeDomainInterpolator = (function (_super: typeof Interpolator) {\n  const TimeDomainInterpolator = function (x0: TimeDomain, x1: TimeDomain): Interpolator<TimeDomain> {\n    const interpolator = function (u: number): TimeDomain {\n      const x0 = interpolator[0];\n      const x00 = x0[0];\n      const x01 = x0[1];\n      const x1 = interpolator[1];\n      const x10 = x1[0];\n      const x11 = x1[1];\n      return TimeDomain(new DateTime(x00.time + u * (x10.time - x00.time), u === 0 ? x00.zone : x10.zone),\n                        new DateTime(x01.time + u * (x11.time - x01.time), u === 0 ? x01.zone : x11.zone));\n    } as Interpolator<TimeDomain>;\n    Object.setPrototypeOf(interpolator, TimeDomainInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = x0;\n    (interpolator as Mutable<typeof interpolator>)[1] = x1;\n    return interpolator;\n  } as {\n    (x0: TimeDomain, x1: TimeDomain): Interpolator<TimeDomain>;\n\n    /** @internal */\n    prototype: Interpolator<TimeDomain>;\n  };\n\n  TimeDomainInterpolator.prototype = Object.create(_super.prototype);\n  TimeDomainInterpolator.prototype.constructor = TimeDomainInterpolator;\n\n  return TimeDomainInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Range} from \"@swim/util\";\nimport type {Interpolate} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport {DateTime} from \"./DateTime\";\nimport {TimeDomain} from \"./TimeDomain\";\n/** @public */\nexport interface TimeRange extends Range<DateTime>, Interpolate<TimeRange> {\n  /** @override */\n  readonly 0: DateTime;\n\n  /** @override */\n  readonly 1: DateTime;\n\n  readonly inverse: TimeDomain;\n\n  /** @override */\n  union(that: Range<DateTime>): TimeRange;\n\n  /** @override */\n  interpolateTo(that: TimeRange): Interpolator<TimeRange>;\n  interpolateTo(that: unknown): Interpolator<TimeRange> | null;\n\n  /** @override */\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const TimeRange = (function (_super: typeof Range) {\n  const TimeRange = function (y0: DateTime, y1: DateTime): TimeRange {\n    const range = function (u: number): DateTime {\n      const t0 = range[0].time;\n      const t1 = range[1].time;\n      return new DateTime(t0 + u * (t1 - t0), u === 0 ? range[0].zone : range[1].zone);\n    } as TimeRange;\n    Object.setPrototypeOf(range, TimeRange.prototype);\n    (range as Mutable<typeof range>)[0] = y0;\n    (range as Mutable<typeof range>)[1] = y1;\n    return range;\n  } as {\n    (y0: DateTime, y1: DateTime): TimeRange;\n\n    /** @internal */\n    prototype: TimeRange;\n  };\n\n  TimeRange.prototype = Object.create(_super.prototype);\n  TimeRange.prototype.constructor = TimeRange;\n\n  Object.defineProperty(TimeRange.prototype, \"inverse\", {\n    get(this: TimeRange): TimeDomain {\n      return TimeDomain(this[0], this[1]);\n    },\n    configurable: true,\n  });\n\n  TimeRange.prototype.union = function (that: Range<DateTime>): TimeRange {\n    const t00 = this[0];\n    const t01 = this[1];\n    const t10 = that[0];\n    const t11 = that[1];\n    let t0: DateTime;\n    let t1: DateTime;\n    if (t00.time <= t01.time && t10.time <= t11.time) {\n      t0 = t00.time <= t10.time ? t00 : t10;\n      t1 = t01.time >= t11.time ? t01 : t11;\n    } else if (t00.time >= t01.time && t10.time >= t11.time) {\n      t0 = t00.time >= t10.time ? t00 : t10;\n      t1 = t01.time <= t11.time ? t01 : t11;\n    } else if (t00.time <= t01.time && t10.time >= t11.time) {\n      t0 = t00.time <= t11.time ? t00 : t11;\n      t1 = t01.time >= t10.time ? t01 : t10;\n    } else { // t00.time >= t01.time && t10.time <= t11.time\n      t0 = t01.time <= t10.time ? t01 : t10;\n      t1 = t00.time >= t11.time ? t00 : t11;\n    }\n    return TimeRange(t0, t1);\n  };\n\n  TimeRange.prototype.interpolateTo = function (this: TimeRange, that: unknown): Interpolator<TimeRange> | null {\n    if (that instanceof TimeRange) {\n      return TimeRangeInterpolator(this, that);\n    }\n    return null;\n  } as typeof TimeRange.prototype.interpolateTo;\n\n  TimeRange.prototype.canEqual = function (that: unknown): boolean {\n    return that instanceof TimeRange;\n  };\n\n  TimeRange.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof TimeRange) {\n      return that.canEqual(this) && this[0].equals(that[0]) && this[1].equals(that[1]);\n    }\n    return false;\n  };\n\n  TimeRange.prototype.toString = function (): string {\n    return \"TimeRange(\" + this[0] + \", \" + this[1] + \")\";\n  };\n\n  return TimeRange;\n})(Range);\n\n/** @internal */\nexport const TimeRangeInterpolator = (function (_super: typeof Interpolator) {\n  const TimeRangeInterpolator = function (y0: TimeRange, y1: TimeRange): Interpolator<TimeRange> {\n    const interpolator = function (u: number): TimeRange {\n      const y0 = interpolator[0];\n      const y00 = y0[0];\n      const y01 = y0[1];\n      const y1 = interpolator[1];\n      const y10 = y1[0];\n      const y11 = y1[1];\n      return TimeRange(new DateTime(y00.time + u * (y10.time - y00.time), u === 0 ? y00.zone : y10.zone),\n                       new DateTime(y01.time + u * (y11.time - y01.time), u === 0 ? y01.zone : y11.zone));\n    } as Interpolator<TimeRange>;\n    Object.setPrototypeOf(interpolator, TimeRangeInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = y0;\n    (interpolator as Mutable<typeof interpolator>)[1] = y1;\n    return interpolator;\n  } as {\n    (y0: TimeRange, y1: TimeRange): Interpolator<TimeRange>;\n\n    /** @internal */\n    prototype: Interpolator<TimeRange>;\n  };\n\n  TimeRangeInterpolator.prototype = Object.create(_super.prototype);\n  TimeRangeInterpolator.prototype.constructor = TimeRangeInterpolator;\n\n  return TimeRangeInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Equivalent} from \"@swim/util\";\nimport {Mapping} from \"@swim/util\";\nimport type {Interpolate} from \"@swim/util\";\nimport {Interpolator} from \"@swim/util\";\nimport {LinearRange} from \"@swim/util\";\nimport {ContinuousScale} from \"@swim/util\";\nimport type {DateTimeLike} from \"./DateTime\";\nimport {DateTime} from \"./DateTime\";\nimport {TimeDomain} from \"./TimeDomain\";\n\n/** @public */\nexport interface TimeScale extends ContinuousScale<DateTime, number>, Interpolate<TimeScale> {\n  /** @override */\n  readonly domain: TimeDomain;\n\n  /** @override */\n  readonly range: LinearRange;\n\n  /** @override */\n  readonly inverse: Mapping<number, DateTime>;\n\n  /** @override */\n  withDomain(domain: TimeDomain): TimeScale;\n  withDomain(x0: DateTimeLike, x1: DateTimeLike): TimeScale;\n\n  /** @override */\n  overRange(range: LinearRange): TimeScale;\n  overRange(y0: number, y1: number): TimeScale;\n\n  /** @override */\n  clampDomain(xMin: DateTime | undefined, xMax: DateTime | undefined,\n              zMin: number | undefined, zMax: number | undefined,\n              epsilon?: number): TimeScale;\n\n  /** @override */\n  solveDomain(x1: DateTime, y1: number, x2?: DateTime, y2?: number,\n              reflect?: boolean, epsilon?: number): TimeScale;\n\n  /** @override */\n  interpolateTo(that: TimeScale): Interpolator<TimeScale>;\n  interpolateTo(that: unknown): Interpolator<TimeScale> | null;\n\n  /** @override */\n  canEqual(that: unknown): boolean;\n\n  /** @override */\n  equals(that: unknown): boolean;\n\n  /** @override */\n  toString(): string;\n}\n\n/** @public */\nexport const TimeScale = (function (_super: typeof ContinuousScale) {\n  const TimeScale = function (domain: TimeDomain, range: LinearRange): TimeScale {\n    const scale = function (x: DateTime): number {\n      return scale.range(scale.domain(x));\n    } as TimeScale;\n    Object.setPrototypeOf(scale, TimeScale.prototype);\n    (scale as Mutable<typeof scale>).domain = domain;\n    (scale as Mutable<typeof scale>).range = range;\n    return scale;\n  } as {\n    (domain: TimeDomain, range: LinearRange): TimeScale;\n\n    /** @internal */\n    prototype: TimeScale;\n  };\n\n  TimeScale.prototype = Object.create(_super.prototype);\n  TimeScale.prototype.constructor = TimeScale;\n\n  Object.defineProperty(TimeScale.prototype, \"inverse\", {\n    get(this: TimeScale): Mapping<number, DateTime> {\n      return Mapping(this.range.inverse, this.domain.inverse);\n    },\n    configurable: true,\n  });\n\n  TimeScale.prototype.withDomain = function (x0: TimeDomain | DateTimeLike, x1?: DateTimeLike): TimeScale {\n    let domain: TimeDomain;\n    if (arguments.length === 1) {\n      domain = x0 as TimeDomain;\n    } else {\n      x0 = DateTime.fromLike(x0 as DateTimeLike);\n      x1 = DateTime.fromLike(x1!);\n      domain = TimeDomain(x0, x1);\n    }\n    return TimeScale(domain, this.range);\n  };\n\n  TimeScale.prototype.overRange = function (y0: LinearRange | number, y1?: number): TimeScale {\n    let range: LinearRange;\n    if (arguments.length === 1) {\n      range = y0 as LinearRange;\n    } else {\n      range = LinearRange(y0 as number, y1!);\n    }\n    return TimeScale(this.domain, range);\n  };\n\n  TimeScale.prototype.clampDomain = function (xMin: DateTime | undefined, xMax: DateTime | undefined,\n                                              zMin: number | undefined, zMax: number | undefined,\n                                              epsilon?: number): TimeScale {\n    if (epsilon === void 0) {\n      epsilon = Equivalent.Epsilon;\n    }\n    const x0 = this.domain[0];\n    const x1 = this.domain[1];\n    let t0 = x0.time;\n    let t1 = x1.time;\n    const tMin = xMin !== void 0 ? xMin.time : void 0;\n    const tMax = xMax !== void 0 ? xMax.time : void 0;\n    if (tMin !== void 0 && tMax !== void 0 && Math.abs(t1 - t0) > tMax - tMin) {\n      if (t0 < t1) {\n        t0 = tMin;\n        t1 = tMax;\n      } else {\n        t1 = tMin;\n        t0 = tMax;\n      }\n    } else if (tMin !== void 0) {\n      if (t0 < t1 && t0 < tMin) {\n        t1 += tMin - t0;\n        t0 = tMin;\n      } else if (t1 < t0 && t1 < tMin) {\n        t0 += tMin - t1;\n        t1 = tMin;\n      }\n    }\n    if (tMax !== void 0) {\n      if (t0 < t1 && t1 > tMax) {\n        t0 -= t1 - tMax;\n        t1 = tMax;\n      } else if (t1 < t0 && t0 > tMax) {\n        t1 -= t0 - tMax;\n        t0 = tMax;\n      }\n    }\n\n    const y0 = this(x0);\n    const y1 = this(x1);\n    const dy = y0 < y1 ? y1 - y0 : y0 - y1;\n    const z = Math.abs(dy / (t1 - t0));\n    if (zMin !== void 0 && z < 1 / zMin) {\n      const dz = dy * zMin;\n      const tSum = t0 + t1;\n      t0 = (tSum - dz) / 2;\n      t1 = (tSum + dz) / 2;\n    } else if (zMax !== void 0 && z > 1 / zMax) {\n      const dz = dy * zMax;\n      const tSum = t0 + t1;\n      t0 = (tSum - dz) / 2;\n      t1 = (tSum + dz) / 2;\n    }\n\n    if (Math.abs(t0 - x0.time) < epsilon && Math.abs(t1 - x1.time) < epsilon) {\n      return this;\n    }\n    return TimeScale(TimeDomain(new DateTime(t0, x0.zone), new DateTime(t1, x1.zone)), this.range);\n  };\n\n  TimeScale.prototype.solveDomain = function (x1: DateTime, y1: number, x2?: DateTime, y2?: number,\n                                              reflect?: boolean, epsilon?: number): TimeScale {\n    if (epsilon === void 0) {\n      epsilon = Equivalent.Epsilon;\n    }\n    const dt = this.domain[1].time - this.domain[0].time;\n    const y0 = this.range[0];\n    const y3 = this.range[1];\n    const t1 = x1.time;\n    const t2 = x2 !== void 0 ? x2.time : void 0;\n    let m: number;\n    if (t2 === void 0 || y2 === void 0 || Math.abs(t2 - t1) < epsilon || Math.abs(y2 - y1) < epsilon) {\n      m = (y3 - y0) / (dt !== 0 ? dt : epsilon);\n    } else {\n      m = (y2 - y1) / (t2 - t1);\n      if ((reflect === void 0 || !reflect) && (m < 0 !== (y3 - y0) / dt < 0)) {\n        m = -m;\n      }\n    }\n    const b = y1 - m * t1;\n    const t0 = (y0 - b) / m;\n    const t3 = (y3 - b) / m;\n\n    if (Math.abs(t0 - this.domain[0].time) < epsilon && Math.abs(t3 - this.domain[1].time) < epsilon) {\n      return this;\n    }\n    return TimeScale(TimeDomain(new DateTime(t0, this.domain[0].zone), new DateTime(t3, this.domain[1].zone)), this.range);\n  };\n\n  TimeScale.prototype.interpolateTo = function (this: TimeScale, that: unknown): Interpolator<TimeScale> | null {\n    if (that instanceof TimeScale) {\n      return TimeScaleInterpolator(this, that);\n    }\n    return null;\n  } as typeof TimeScale.prototype.interpolateTo;\n\n  TimeScale.prototype.canEqual = function (that: unknown): boolean {\n    return that instanceof TimeScale;\n  };\n\n  TimeScale.prototype.equals = function (that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof TimeScale) {\n      return this.domain.equals(that.domain) && this.range.equals(that.range);\n    }\n    return false;\n  };\n\n  TimeScale.prototype.toString = function (): string {\n    return \"TimeScale(\" + this.domain + \", \" + this.range + \")\";\n  };\n\n  return TimeScale;\n})(ContinuousScale);\n\n/** @internal */\nexport const TimeScaleInterpolator = (function (_super: typeof Interpolator) {\n  const TimeScaleInterpolator = function (s0: TimeScale, s1: TimeScale): Interpolator<TimeScale> {\n    const interpolator = function (u: number): TimeScale {\n      const s0 = interpolator[0];\n      const s1 = interpolator[1];\n      const x0 = s0.domain;\n      const x00 = x0[0].time;\n      const x01 = x0[1].time;\n      const x1 = s1.domain;\n      const x10 = x1[0].time;\n      const x11 = x1[1].time;\n      const domain = TimeDomain(new DateTime(x00 + u * (x10 - x00), u === 0 ? x0[0].zone : x1[0].zone),\n                                new DateTime(x01 + u * (x11 - x01), u === 0 ? x0[1].zone : x1[1].zone));\n      const y0 = s0.range;\n      const y00 = y0[0];\n      const y01 = y0[1];\n      const y1 = s1.range;\n      const y10 = y1[0];\n      const y11 = y1[1];\n      const range = LinearRange(y00 + u * (y10 - y00), y01 + u * (y11 - y01));\n      return TimeScale(domain, range);\n    } as Interpolator<TimeScale>;\n    Object.setPrototypeOf(interpolator, TimeScaleInterpolator.prototype);\n    (interpolator as Mutable<typeof interpolator>)[0] = s0;\n    (interpolator as Mutable<typeof interpolator>)[1] = s1;\n    return interpolator;\n  } as {\n    (s0: TimeScale, s1: TimeScale): Interpolator<TimeScale>;\n\n    /** @internal */\n    prototype: Interpolator<TimeScale>;\n  };\n\n  TimeScaleInterpolator.prototype = Object.create(_super.prototype);\n  TimeScaleInterpolator.prototype.constructor = TimeScaleInterpolator;\n\n  return TimeScaleInterpolator;\n})(Interpolator);\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport type {ConstraintExpressionLike} from \"./ConstraintExpression\";\nimport {ConstraintExpression} from \"./ConstraintExpression\";\nimport type {ConstraintRelation} from \"./Constraint\";\nimport type {ConstraintStrengthLike} from \"./Constraint\";\nimport {ConstraintStrength} from \"./Constraint\";\nimport {Constraint} from \"./Constraint\";\nimport type {ConstraintScope} from \"./ConstraintScope\";\n\n/** @beta */\nexport class ConstraintGroup {\n  constructor(scope: ConstraintScope) {\n    this.scope = scope;\n    this.constraints = [];\n    this.constrained = false;\n  }\n\n  readonly scope: ConstraintScope;\n\n  constraint(lhs: ConstraintExpressionLike, relation: ConstraintRelation,\n             rhs?: ConstraintExpressionLike, strength?: ConstraintStrengthLike): Constraint {\n    lhs = ConstraintExpression.fromLike(lhs);\n    rhs = ConstraintExpression.fromLike(rhs);\n    const expression = rhs !== void 0 ? lhs.minus(rhs) : lhs;\n    if (strength === void 0) {\n      strength = ConstraintStrength.Required;\n    } else {\n      strength = ConstraintStrength.fromLike(strength);\n    }\n    const constraint = new Constraint(this.scope, expression, relation, strength);\n    this.addConstraint(constraint);\n    return constraint;\n  }\n\n  readonly constraints: readonly Constraint[];\n\n  hasConstraint(constraint: Constraint): boolean {\n    const constraints = this.constraints;\n    return constraints.indexOf(constraint) >= 0;\n  }\n\n  addConstraint(constraint: Constraint): void {\n    const constraints = this.constraints as Constraint[];\n    if (constraints.indexOf(constraint) < 0) {\n      constraints.push(constraint);\n      constraint.constrain(this.constrained);\n    }\n  }\n\n  removeConstraint(constraint: Constraint): void {\n    const constraints = this.constraints as Constraint[];\n    if (constraints === void 0) {\n      return;\n    }\n    const index = constraints.indexOf(constraint);\n    if (index >= 0) {\n      constraints.splice(index, 1);\n      constraint.constrain(false);\n    }\n  }\n\n  /** @internal */\n  enableConstraints(): void {\n    const constraints = this.constraints;\n    for (let i = 0; i < constraints.length; i += 1) {\n      constraints[i]!.constrain(true);\n    }\n  }\n\n  /** @internal */\n  disableConstraints(): void {\n    const constraints = this.constraints;\n    for (let i = 0; i < constraints.length; i += 1) {\n      constraints[i]!.constrain(false);\n    }\n  }\n\n  /** @internal */\n  readonly constrained: boolean;\n\n  isConstrained(): boolean {\n    return this.constrained;\n  }\n\n  constrain(constrained: boolean = true): this {\n    if (constrained && !this.constrained) {\n      (this as Mutable<this>).constrained = true;\n      this.enableConstraints();\n    } else if (!constrained && this.constrained) {\n      (this as Mutable<this>).constrained = false;\n      this.disableConstraints();\n    }\n    return this;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {Mutable} from \"@swim/util\";\nimport {Equivalent} from \"@swim/util\";\nimport {ConstraintSymbol} from \"./ConstraintSymbol\";\nimport {ConstraintSlack} from \"./ConstraintSymbol\";\nimport {ConstraintError} from \"./ConstraintSymbol\";\nimport {ConstraintDummy} from \"./ConstraintSymbol\";\nimport type {ConstraintExpressionLike} from \"./ConstraintExpression\";\nimport {ConstraintExpression} from \"./ConstraintExpression\";\nimport type {ConstraintVariable} from \"./ConstraintVariable\";\nimport {ConstraintProperty} from \"./ConstraintProperty\";\nimport type {ConstraintRelation} from \"./Constraint\";\nimport type {ConstraintStrengthLike} from \"./Constraint\";\nimport {ConstraintStrength} from \"./Constraint\";\nimport {Constraint} from \"./Constraint\";\nimport type {ConstraintScope} from \"./ConstraintScope\";\nimport {ConstraintRow} from \"./ConstraintRow\";\n\n/** @internal */\nexport interface ConstraintTag {\n  readonly marker: ConstraintSymbol;\n  readonly other: ConstraintSymbol;\n}\n\n/** @internal */\nexport interface ConstraintVariableBinding {\n  readonly constraint: Constraint;\n  readonly tag: ConstraintTag;\n  state: number;\n}\n\n/** @public */\nexport class ConstraintSolver implements ConstraintScope {\n  constructor() {\n    this.constraints = new Map();\n    this.constraintVariables = new Map();\n    this.rows = new Map();\n    this.infeasible = [];\n    this.objective = new ConstraintRow(this, null, new Map(), 0);\n    this.artificial = null;\n    this.invalidated = new Map();\n  }\n\n  /** @internal */\n  readonly constraints: Map<Constraint, ConstraintTag>;\n\n  /** @internal */\n  readonly constraintVariables: Map<ConstraintVariable, ConstraintVariableBinding>;\n\n  /** @internal */\n  readonly rows: Map<ConstraintSymbol, ConstraintRow>;\n\n  /** @internal */\n  readonly infeasible: ConstraintSymbol[];\n\n  /** @internal */\n  readonly objective: ConstraintRow;\n\n  /** @internal */\n  readonly artificial: ConstraintRow | null;\n\n  /** @internal */\n  readonly invalidated: Map<ConstraintSymbol, ConstraintRow | null>;\n\n  constraint(lhs: ConstraintExpressionLike, relation: ConstraintRelation,\n             rhs?: ConstraintExpressionLike, strength?: ConstraintStrengthLike): Constraint {\n    lhs = ConstraintExpression.fromLike(lhs);\n    rhs = ConstraintExpression.fromLike(rhs);\n    const expression = rhs !== void 0 ? lhs.minus(rhs) : lhs;\n    if (strength === void 0) {\n      strength = ConstraintStrength.Required;\n    } else {\n      strength = ConstraintStrength.fromLike(strength);\n    }\n    const constraint = new Constraint(this, expression, relation, strength);\n    this.addConstraint(constraint);\n    return constraint;\n  }\n\n  hasConstraint(constraint: Constraint): boolean {\n    return this.constraints.has(constraint);\n  }\n\n  addConstraint(constraint: Constraint): void {\n    if (this.constraints.has(constraint)) {\n      return;\n    }\n\n    for (const variable of constraint.expression.terms.keys()) {\n      variable.addConstraintCondition(constraint, this);\n    }\n\n    // Creating a row causes symbols to be reserved for the variables in the constraint.\n    const {row, tag} = this.createRow(constraint);\n\n    this.addConstraintRow(constraint, row, tag);\n  }\n\n  /** @internal */\n  protected addConstraintRow(constraint: Constraint, row: ConstraintRow, tag: ConstraintTag): void {\n    this.willAddConstraint(constraint);\n\n    let subject = this.chooseSubject(row, tag);\n\n    // If chooseSubject couldn't find a valid entering symbol, one last option\n    // is available if the entire row is composed of dummy variables. If the\n    // constant of the row is zero, then this represents redundant constraints\n    // and the new dummy marker can enter the basis. If the constant is\n    // non-zero, then it represents an unsatisfiable constraint.\n    if (subject.isInvalid() && row.isDummy()) {\n      if (Math.abs(row.constant) >= Equivalent.Epsilon) {\n        throw new Error(\"unsatisfiable constraint\");\n      }\n      subject = tag.marker;\n    }\n\n    // If an entering symbol still isn't found, then the row must be added\n    // using an artificial variable. If that fails, then the row represents\n    // an unsatisfiable constraint.\n    if (subject.isInvalid()) {\n      if (!this.addWithArtificialVariable(row)) {\n        throw new Error(\"unsatisfiable constraint\");\n      }\n    } else {\n      row.setSymbol(subject);\n      row.solveFor(subject);\n      this.substitute(subject, row);\n      this.rows.set(subject, row);\n    }\n\n    this.constraints.set(constraint, tag);\n\n    // Optimizing after each constraint is added performs less aggregate work\n    // due to a smaller average system size. It also ensures the solver remains\n    // in a consistent state.\n    this.optimize(this.objective);\n\n    this.didAddConstraint(constraint);\n\n    this.updateSolution();\n  }\n\n  protected willAddConstraint(constraint: Constraint): void {\n    // hook\n  }\n\n  protected didAddConstraint(constraint: Constraint): void {\n    // hook\n  }\n\n  removeConstraint(constraint: Constraint): void {\n    const tag = this.constraints.get(constraint);\n    if (tag === void 0) {\n      return;\n    }\n\n    this.removeConstraintRow(constraint);\n\n    for (const variable of constraint.expression.terms.keys()) {\n      variable.removeConstraintCondition(constraint, this);\n    }\n  }\n\n  /** @internal */\n  protected removeConstraintRow(constraint: Constraint): void {\n    const tag = this.constraints.get(constraint);\n    if (tag === void 0) {\n      return;\n    }\n\n    this.willRemoveConstraint(constraint);\n\n    this.constraints.delete(constraint);\n\n    // Remove the error effects from the objective function *before* pivoting,\n    // or substitutions into the objective will lead to incorrect solver results.\n    this.removeConstraintEffects(constraint, tag);\n\n    // If the marker is basic, simply drop the row. Otherwise pivot the marker\n    // into the basis and then drop the row.\n    const marker = tag.marker;\n    if (!this.rows.delete(marker)) {\n      const leaving = this.getMarkerLeavingSymbol(marker);\n      if (leaving.isInvalid()) {\n        throw new Error(\"failed to find leaving row\");\n      }\n      const row = this.rows.get(leaving)!;\n      this.rows.delete(leaving);\n      row.solveForEx(leaving, marker);\n      this.substitute(marker, row);\n    }\n\n    // Optimizing after each constraint is removed ensures that the solver\n    // remains consistent. It makes the solver API easier to use at a small\n    // trade-off for speed.\n    this.optimize(this.objective);\n\n    this.didRemoveConstraint(constraint);\n\n    this.updateSolution();\n  }\n\n  protected willRemoveConstraint(constraint: Constraint): void {\n    // hook\n  }\n\n  protected didRemoveConstraint(constraint: Constraint): void {\n    // hook\n  }\n\n  constraintVariable(name: string, value?: number, strength?: ConstraintStrengthLike): ConstraintProperty<unknown, number> {\n    if (value === void 0) {\n      value = 0;\n    }\n    if (strength !== void 0) {\n      strength = ConstraintStrength.fromLike(strength);\n    } else {\n      strength = ConstraintStrength.Strong;\n    }\n    const property = ConstraintProperty.create(this) as ConstraintProperty<unknown, number>;\n    Object.defineProperty(property, \"name\", {\n      value: name,\n      configurable: true,\n    });\n    if (value !== void 0) {\n      property.setValue(value);\n    }\n    property.setStrength(strength);\n    property.mount();\n    return property;\n  }\n\n  hasConstraintVariable(variable: ConstraintVariable): boolean {\n    return this.constraintVariables.has(variable);\n  }\n\n  addConstraintVariable(variable: ConstraintVariable): void {\n    if (this.constraintVariables.has(variable)) {\n      return;\n    }\n\n    const strength = ConstraintStrength.clip(variable.strength);\n    if (strength === ConstraintStrength.Required) {\n      throw new Error(\"invalid variable strength\");\n    }\n\n    this.willAddConstraintVariable(variable);\n\n    const constraint = new Constraint(this, variable, \"eq\", strength);\n    const {row, tag} = this.createRow(constraint);\n    this.constraintVariables.set(variable, {constraint, tag, state: 0});\n\n    this.addConstraintRow(constraint, row, tag);\n\n    this.didAddConstraintVariable(variable);\n  }\n\n  protected willAddConstraintVariable(variable: ConstraintVariable): void {\n    // hook\n  }\n\n  protected didAddConstraintVariable(variable: ConstraintVariable): void {\n    // hook\n  }\n\n  removeConstraintVariable(variable: ConstraintVariable): void {\n    const binding = this.constraintVariables.get(variable);\n    if (binding === void 0) {\n      return;\n    }\n\n    this.willRemoveConstraintVariable(variable);\n\n    this.constraintVariables.delete(variable);\n    this.removeConstraintRow(binding.constraint);\n\n    this.didRemoveConstraintVariable(variable);\n  }\n\n  protected willRemoveConstraintVariable(variable: ConstraintVariable): void {\n    // hook\n  }\n\n  protected didRemoveConstraintVariable(variable: ConstraintVariable): void {\n    // hook\n  }\n\n  setConstraintVariable(variable: ConstraintVariable, newState: number): void {\n    const binding = this.constraintVariables.get(variable);\n    if (binding === void 0) {\n      throw new Error(\"unbound variable\");\n    }\n    const oldState = binding.state;\n    if (oldState === newState) {\n      return;\n    }\n\n    binding.state = newState;\n    const delta = newState - oldState;\n\n    this.willSetConstraintVariable(variable, newState, oldState);\n\n    // Check first if the positive error variable is basic.\n    const marker = binding.tag.marker;\n    let row = this.rows.get(marker);\n    if (row !== void 0) {\n      if (row.add(-delta) < 0) {\n        this.infeasible.push(marker);\n      }\n      this.dualOptimize();\n      return;\n    }\n\n    // Check next if the negative error variable is basic.\n    const other = binding.tag.other;\n    row = this.rows.get(other);\n    if (row !== void 0) {\n      if (row.add(delta) < 0) {\n        this.infeasible.push(other);\n      }\n      this.dualOptimize();\n      return;\n    }\n\n    // Otherwise update each row where the error variables exist.\n    for (const [symbol, row] of this.rows) {\n      const coefficient = row.coefficientFor(marker);\n      if (coefficient !== 0 && row.add(delta * coefficient) < 0 && !symbol.isExternal()) {\n        this.infeasible.push(symbol);\n      }\n    }\n    this.dualOptimize();\n\n    this.didSetConstraintVariable(variable, newState, oldState);\n\n    this.updateSolution();\n  }\n\n  protected willSetConstraintVariable(variable: ConstraintVariable, newState: number, oldState: number): void {\n    // hook\n  }\n\n  protected didSetConstraintVariable(variable: ConstraintVariable, newState: number, oldState: number): void {\n    // hook\n  }\n\n  /** @internal */\n  invalidate(symbol: ConstraintSymbol, row: ConstraintRow | null = null): void {\n    if (symbol.isExternal()) {\n      this.invalidated.set(symbol, row);\n    }\n  }\n\n  /** @internal */\n  updateSolution(): void {\n    const invalidated = this.invalidated;\n    if (invalidated.size === 0) {\n      return;\n    }\n    (this as Mutable<this>).invalidated = new Map();\n    for (const symbol of invalidated.keys()) {\n      const row = this.rows.get(symbol);\n      if (row !== void 0) {\n        symbol.updateConstraintSolution(row.constant);\n      }\n    }\n  }\n\n  // Returns a new row for the given constraint.\n  //\n  // The terms in the constraint will be converted to cells in the row.\n  // Any term in the constraint with a coefficient of zero is ignored.\n  // If the symbol for a given cell variable is basic, the cell variable\n  // will be substituted with the basic row.\n  //\n  // The necessary slack and error variables will be added to the row.\n  // If the constant for the row is negative, the sign for the row will\n  // be inverted so the constant becomes positive.\n  private createRow(constraint: Constraint): {row: ConstraintRow, tag: ConstraintTag} {\n    const expression = constraint.expression;\n    const row = new ConstraintRow(this, null, new Map(), expression.constant);\n\n    // Substitute the current basic variables into the row.\n    for (const [variable, coefficient] of expression.terms) {\n      if (Math.abs(coefficient) < Equivalent.Epsilon) {\n        continue;\n      }\n      const basic = this.rows.get(variable);\n      if (basic !== void 0) {\n        row.insertRow(basic, coefficient);\n      } else {\n        row.insertSymbol(variable, coefficient);\n      }\n    }\n\n    // Add the necessary slack, error, and dummy variables.\n    const objective = this.objective;\n    const relation = constraint.relation;\n    const strength = constraint.strength;\n    const tag = {marker: ConstraintSymbol.invalid(), other: ConstraintSymbol.invalid()};\n    if (relation === \"le\" || relation === \"ge\") {\n      const coefficient = relation === \"le\" ? 1 : -1;\n      const slack = new ConstraintSlack();\n      tag.marker = slack;\n      row.insertSymbol(slack, coefficient);\n      if (strength < ConstraintStrength.Required) {\n        const error = new ConstraintError();\n        tag.other = error;\n        row.insertSymbol(error, -coefficient);\n        objective.insertSymbol(error, strength);\n      }\n    } else if (strength < ConstraintStrength.Required) {\n      const eplus = new ConstraintError();\n      const eminus = new ConstraintError();\n      tag.marker = eplus;\n      tag.other = eminus;\n      row.insertSymbol(eplus, -1); // v = eplus - eminus\n      row.insertSymbol(eminus, 1); // v - eplus + eminus = 0\n      objective.insertSymbol(eplus, strength);\n      objective.insertSymbol(eminus, strength);\n    } else {\n      const dummy = new ConstraintDummy();\n      tag.marker = dummy;\n      row.insertSymbol(dummy);\n    }\n\n    // Ensure the row has a positive constant.\n    if (row.constant < 0) {\n      row.negate();\n    }\n\n    return {row, tag};\n  }\n\n  // Returns the symbol to use for solving for the row.\n  //\n  // This method will choose the best subject to use as the solve target for\n  // the row. An invalid symbol will be returned if there is no valid target.\n  //\n  // The symbols are chosen according to the following precedence:\n  //\n  // 1) The first symbol representing an external variable.\n  // 2) A negative slack or error tag variable.\n  //\n  // If a subject cannot be found, an invalid symbol will be returned.\n  private chooseSubject(row: ConstraintRow, tag: ConstraintTag): ConstraintSymbol {\n    for (const symbol of row.cells.keys()) {\n      if (symbol.isExternal()) {\n        return symbol;\n      }\n    }\n    if (tag.marker instanceof ConstraintSlack || tag.marker instanceof ConstraintError) {\n      if (row.coefficientFor(tag.marker) < 0) {\n        return tag.marker;\n      }\n    }\n    if (tag.other instanceof ConstraintSlack || tag.other instanceof ConstraintError) {\n      if (row.coefficientFor(tag.other) < 0) {\n        return tag.other;\n      }\n    }\n    return ConstraintSymbol.invalid();\n  }\n\n  // Adds the row to the tableau using an artificial variable; returns `false`\n  // if the constraint cannot be satisfied.\n  private addWithArtificialVariable(row: ConstraintRow): boolean {\n    // Create and add the artificial variable to the tableau.\n    const artificial = new ConstraintSlack();\n    this.rows.set(artificial, row.clone());\n    (this as Mutable<this>).artificial = row.clone();\n\n    // Optimize the artificial objective. This is successful\n    // only if the artificial objective is optimized to zero.\n    this.optimize(this.artificial!);\n    const success = Math.abs(this.artificial!.constant) < Equivalent.Epsilon;\n    (this as Mutable<this>).artificial = null;\n\n    // If the artificial variable is basic, pivot the row so that\n    // it becomes non-basic. If the row is constant, exit early.\n    const basic = this.rows.get(artificial);\n    if (basic !== void 0) {\n      this.rows.delete(artificial);\n      if (basic.isConstant()) {\n        return success;\n      }\n      const entering = this.anyPivotableSymbol(basic);\n      if (entering.isInvalid()) {\n        return false; // unsatisfiable (will this ever happen?)\n      }\n      basic.setSymbol(entering);\n      basic.solveForEx(artificial, entering);\n      this.substitute(entering, basic);\n      this.rows.set(entering, basic);\n    }\n\n    // Remove the artificial variable from the tableau.\n    for (const row of this.rows.values()) {\n      row.removeSymbol(artificial);\n    }\n    this.objective.removeSymbol(artificial);\n    return success;\n  }\n\n  // Substitutes all instances of the parametric symbol in the tableau\n  // and the objective function with the given row.\n  private substitute(symbol: ConstraintSymbol, row: ConstraintRow): void {\n    for (const [key, value] of this.rows) {\n      value.substitute(symbol, row);\n      if (value.constant < 0 && !key.isExternal()) {\n        this.infeasible.push(key);\n      }\n    }\n    this.objective.substitute(symbol, row);\n    if (this.artificial !== null) {\n      this.artificial.substitute(symbol, row);\n    }\n  }\n\n  // Optimizes the system for the given objective function.\n  //\n  // Performs iterations of Phase 2 of the simplex method until the objective\n  // function reaches a minimum.\n  private optimize(objective: ConstraintRow): void {\n    do {\n      const entering = this.getEnteringSymbol(objective);\n      if (entering.isInvalid()) {\n        return;\n      }\n      const leaving = this.getLeavingSymbol(entering);\n      if (leaving.isInvalid()) {\n        throw new Error(\"objective is unbounded\");\n      }\n      // Pivot the entering symbol into the basis.\n      const row = this.rows.get(leaving)!;\n      this.rows.delete(leaving);\n      row.setSymbol(entering);\n      row.solveForEx(leaving, entering);\n      this.substitute(entering, row);\n      this.rows.set(entering, row);\n    } while (true);\n  }\n\n  // Optimizes the system using the dual of the simplex method.\n  //\n  // The current state of the system should be such that the objective\n  // function is optimal, but not feasible. This method will perform\n  // an iteration of the dual simplex method to make the solution both\n  // optimal and feasible.\n  private dualOptimize(): void {\n    let leaving: ConstraintSymbol | undefined;\n    while ((leaving = this.infeasible.pop(), leaving !== void 0)) {\n      const row = this.rows.get(leaving);\n      if (row === void 0 || row.constant >= 0) {\n        continue;\n      }\n      const entering = this.getDualEnteringSymbol(row);\n      if (entering.isInvalid()) {\n        throw new Error(\"dual optimize failed\");\n      }\n      // Pivot the entering symbol into the basis.\n      this.rows.delete(leaving);\n      row.setSymbol(entering);\n      row.solveForEx(leaving, entering);\n      this.substitute(entering, row);\n      this.rows.set(entering, row);\n    }\n  }\n\n  // Returns the entering variable for a pivot operation.\n  //\n  // Returns the first symbol in the objective function which is non-dummy and\n  // has a coefficient less than zero. If no symbol meets the criteria then the\n  // objective function is at a minimum, and an invalid symbol is returned.\n  private getEnteringSymbol(objective: ConstraintRow): ConstraintSymbol {\n    for (const [symbol, value] of objective.cells) {\n      if (value < 0 && !symbol.isDummy()) {\n        return symbol;\n      }\n    }\n    return ConstraintSymbol.invalid();\n  }\n\n  // Returns the entering symbol for the dual optimize operation.\n  //\n  // Returns the symbol in the row which has a positive coefficient and yields\n  // the minimum ratio for its respective symbol in the objective function.\n  // The provided row *must* be infeasible. If no symbol is found which meets\n  // the criteria, an invalid symbol is returned.\n  private getDualEnteringSymbol(row: ConstraintRow): ConstraintSymbol {\n    let ratio = Number.MAX_VALUE;\n    let entering = ConstraintSymbol.invalid();\n    for (const [symbol, value] of row.cells) {\n      if (value <= 0 || symbol.isDummy()) {\n        continue;\n      }\n      const coefficient = this.objective.coefficientFor(symbol);\n      const coratio = coefficient / value;\n      if (coratio < ratio) {\n        ratio = coratio;\n        entering = symbol;\n      }\n    }\n    return entering;\n  }\n\n  // Returns the symbol for the pivot exit row. If no appropriate exit symbol\n  // is found, an invalid symbol will be returned, indicating that the\n  // objective function is unbounded.\n  private getLeavingSymbol(entering: ConstraintSymbol): ConstraintSymbol {\n    let ratio = Number.MAX_VALUE;\n    let found = ConstraintSymbol.invalid();\n    for (const [symbol, row] of this.rows) {\n      if (symbol.isExternal()) {\n        continue;\n      }\n      const coefficient = row.coefficientFor(entering);\n      if (coefficient >= 0) {\n        continue;\n      }\n      const coratio = -row.constant / coefficient;\n      if (coratio < ratio) {\n        ratio = coratio;\n        found = symbol;\n      }\n    }\n    return found;\n  }\n\n  // Returns a symbol corresponding to a basic row which holds the given marker\n  // variable. The row will be chosen according to the following precedence:\n  //\n  // 1) The row with a restricted basic variable and a negative coefficient\n  //    for the marker with the smallest ratio of `-constant / coefficient`.\n  // 2) The row with a restricted basic variable and the smallest ratio of\n  //    `constant / coefficient`.\n  // 3) The last unrestricted row which contains the marker.\n  //\n  // If the marker does not exist in any row, an invalid symbol will be\n  // returned, indicating an internal solver error since the marker *should*\n  // exist somewhere in the tableau.\n  private getMarkerLeavingSymbol(marker: ConstraintSymbol): ConstraintSymbol {\n    let r1 = Number.MAX_VALUE;\n    let r2 = Number.MAX_VALUE;\n    let first = ConstraintSymbol.invalid();\n    let second = ConstraintSymbol.invalid();\n    let third = ConstraintSymbol.invalid();\n    for (const [symbol, row] of this.rows) {\n      const coefficient = row.coefficientFor(marker);\n      if (coefficient === 0) {\n        continue;\n      }\n      if (symbol.isExternal()) {\n        third = symbol;\n      } else if (coefficient < 0) {\n        const ratio = -row.constant / coefficient;\n        if (ratio < r1) {\n          r1 = ratio;\n          first = symbol;\n        }\n      } else {\n        const ratio = row.constant / coefficient;\n        if (ratio < r2) {\n          r2 = ratio;\n          second = symbol;\n        }\n      }\n    }\n    if (!first.isInvalid()) {\n      return first;\n    } else if (!second.isInvalid()) {\n      return second;\n    } else {\n      return third;\n    }\n  }\n\n  // Removes the effects of a constraint on the objective function.\n  private removeConstraintEffects(constraint: Constraint, tag: ConstraintTag): void {\n    if (tag.marker instanceof ConstraintError) {\n      this.removeMarkerEffects(tag.marker, constraint.strength);\n    }\n    if (tag.other instanceof ConstraintError) {\n      this.removeMarkerEffects(tag.other, constraint.strength);\n    }\n  }\n\n  // Removes the effects of an error marker on the objective function.\n  private removeMarkerEffects(marker: ConstraintSymbol, strength: ConstraintStrength): void {\n    const row = this.rows.get(marker);\n    if (row !== void 0) {\n      this.objective.insertRow(row, -strength);\n    } else {\n      this.objective.insertSymbol(marker, -strength);\n    }\n  }\n\n  // Returns the first Slack or Error symbol in the row. If no such symbol\n  // is present, an invalid symbol will be returned.\n  private anyPivotableSymbol(row: ConstraintRow): ConstraintSymbol {\n    for (const symbol of row.cells.keys()) {\n      if (symbol instanceof ConstraintSlack || symbol instanceof ConstraintError) {\n        return symbol;\n      }\n    }\n    return ConstraintSymbol.invalid();\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport type {UriLike} from \"./Uri\";\nimport {Uri} from \"./Uri\";\n\n/** @public */\nexport class UriCache {\n  constructor(base: Uri, capacity: number = 128) {\n    this.base = base;\n    this.capacity = capacity;\n    this.resolveCache = new Map<string, Uri>();\n    this.unresolveCache = new Map<string, Uri>();\n  }\n\n  readonly base: Uri;\n\n  readonly capacity: number;\n\n  /** @internal */\n  readonly resolveCache: Map<string, Uri>;\n\n  /** @internal */\n  readonly unresolveCache: Map<string, Uri>;\n\n  resolve(relative: UriLike): Uri {\n    if (typeof relative !== \"string\") {\n      relative = Uri.fromLike(relative).toString();\n    }\n\n    const resolveCache = this.resolveCache;\n    let absolute = resolveCache.get(relative);\n    if (absolute === void 0) {\n      absolute = this.base.resolve(relative);\n    } else {\n      resolveCache.delete(relative);\n    }\n    resolveCache.set(relative, absolute);\n\n    const capacity = this.capacity;\n    let size = resolveCache.size;\n    if (size > capacity) {\n      const keys = resolveCache.keys();\n      let next: IteratorResult<string>;\n      while (size > capacity && (next = keys.next()).done !== true) {\n        resolveCache.delete(next.value);\n        size -= 1;\n      }\n    }\n\n    return absolute;\n  }\n\n  unresolve(absolute: UriLike): Uri {\n    if (typeof absolute !== \"string\") {\n      absolute = Uri.fromLike(absolute).toString();\n    }\n\n    const unresolveCache = this.unresolveCache;\n    let relative = unresolveCache.get(absolute);\n    if (relative === void 0) {\n      relative = this.base.unresolve(absolute);\n    } else {\n      unresolveCache.delete(absolute);\n    }\n    unresolveCache.set(absolute, relative);\n\n    const capacity = this.capacity;\n    let size = unresolveCache.size;\n    if (size > capacity) {\n      const keys = unresolveCache.keys();\n      let next: IteratorResult<string>;\n      while (size > capacity && (next = keys.next()).done !== true) {\n        unresolveCache.delete(next.value);\n        size -= 1;\n      }\n    }\n\n    return relative;\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport type {Value} from \"../Value\";\nimport type {Form} from \"../form/Form\";\n\n/** @internal */\nexport class ValueCursor<V> extends Cursor<V> {\n  constructor(cursor: Cursor<Value>, form: Form<V, unknown>) {\n    super();\n    this.cursor = cursor;\n    this.form = form;\n  }\n\n  /** @internal */\n  readonly cursor: Cursor<Value>;\n\n  /** @internal */\n  readonly form: Form<V, unknown>;\n\n  override isEmpty(): boolean {\n    return this.cursor.isEmpty();\n  }\n\n  override head(): V {\n    const value = this.cursor.head();\n    return value.coerce(this.form);\n  }\n\n  override step(): void {\n    this.cursor.step();\n  }\n\n  override skip(count: number): void {\n    this.cursor.skip(count);\n  }\n\n  override hasNext(): boolean {\n    return this.cursor.hasNext();\n  }\n\n  override nextIndex(): number {\n    return this.cursor.nextIndex();\n  }\n\n  override next(): IteratorResult<V> {\n    const next = this.cursor.next();\n    if (next.done === true) {\n      return next;\n    }\n    return {done: false, value: next.value.coerce(this.form)};\n  }\n\n  override hasPrevious(): boolean {\n    return this.cursor.hasPrevious();\n  }\n\n  override previousIndex(): number {\n    return this.cursor.previousIndex();\n  }\n\n  override previous(): IteratorResult<V> {\n    const previous = this.cursor.previous();\n    if (previous.done === true) {\n      return previous;\n    }\n    return {done: false, value: previous.value.coerce(this.form)};\n  }\n\n  override delete(): void {\n    this.cursor.delete();\n  }\n}\n","// Copyright 2015-2023 Nstream, inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport type {Value} from \"../Value\";\nimport type {Form} from \"../form/Form\";\n\n/** @internal */\nexport class ValueEntryCursor<K, V> extends Cursor<[K, V]> {\n  constructor(cursor: Cursor<[Value, Value]>, keyForm: Form<K, unknown>, valueForm: Form<V, unknown>) {\n    super();\n    this.cursor = cursor;\n    this.keyForm = keyForm;\n    this.valueForm = valueForm;\n  }\n\n  /** @internal */\n  readonly cursor: Cursor<[Value, Value]>;\n\n  /** @internal */\n  readonly keyForm: Form<K, unknown>;\n\n  /** @internal */\n  readonly valueForm: Form<V, unknown>;\n\n  override isEmpty(): boolean {\n    return this.cursor.isEmpty();\n  }\n\n  override head(): [K, V] {\n    const pair = this.cursor.head();\n    return [pair[0].coerce(this.keyForm), pair[1].coerce(this.valueForm)];\n  }\n\n  override step(): void {\n    this.cursor.step();\n  }\n\n  override skip(count: number): void {\n    this.cursor.skip(count);\n  }\n\n  override hasNext(): boolean {\n    return this.cursor.hasNext();\n  }\n\n  override nextIndex(): number {\n    return this.cursor.nextIndex();\n  }\n\n  override next(): IteratorResult<[K, V]> {\n    const next = this.cursor.next();\n    if (next.done === true) {\n      return next;\n    }\n    return {done: false, value: [next.value[0].coerce(this.keyForm), next.value[1].coerce(this.valueForm)]};\n  }\n\n  override hasPrevious(): boolean {\n    return this.cursor.hasPrevious();\n  }\n\n  override previousIndex(): number {\n    return this.cursor.previousIndex();\n  }\n\n  override previous(): IteratorResult<[K, V]> {\n    const previous = this.cursor.previous();\n    if (previous.done === true) {\n      return previous;\n    }\n    return {done: false, value: [previous.value[0].coerce(this.keyForm), previous.value[1].coerce(this.valueForm)]};\n  }\n\n  override delete(): void {\n    this.cursor.delete();\n  }\n}\n"],"names":["__esDecorate","ctor","descriptorIn","decorators","contextIn","initializers","extraInitializers","accept","f","TypeError","_","kind","key","target","prototype","descriptor","Object","getOwnPropertyDescriptor","name","done","i","length","context","p","access","addInitializer","push","result","get","set","init","unshift","defineProperty","__runInitializers","thisArg","value","useValue","arguments","call","SuppressedError","Random","fillBytes","window","crypto","array","getRandomValues","msCrypto","Int8Array","Math","round","random","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","ByteOrder","BigEndian","LittleEndian","NativeEndian","NativeOrder","this","bom","ArrayBuffer","b","Error","Murmur3","mix","code","rotl","mixUint8Array","mixUint8ArrayBE","mixUInt8ArrayLE","offset","limit","word","mixString","string","mixStringBE","mixStringLE","k","n","utf8Length","c","codePointAt","charCodeAt","Strings","offsetByCodePoints","mash","distance","Lazy","defined","Equals","x","y","Symbol","hasInstance","equals","instance","enumerable","configurable","HashCode","hashCode","Equivalent","epsilon","equivalentTo","Compare","compareTo","NaN","Identity","compare","xh","hash","yh","codes","nextCode","WeakMap","fromLike","Booleans","Boolean","Numbers","equal","isNaN","equivalent","abs","Epsilon","hashArrayBuffer","hashFloat64Array","hashInt32Array","Float64Array","Number","index","c1","c2","count","String","Identifiers","isStartChar","isPartChar","isValid","identifier","isReserved","Functions","Constructors","Arrays","empty","freeze","inserted","newElement","oldArray","newArray","Array","element","removed","oldElement","Values","q","order","min","Objects","isEmpty","hasOwnProperty","hasAnyKey","object","keys","hasAllKeys","newObject","oldKey","oldValue","getFirstKey","getFirstValue","getNextKey","mark","getNextValue","xKeys","yKeys","xKey","yKey","Date","getTime","isArray","FromLike","type","likeness","ToLike","toLike","Creatable","create","Observable","observe","unobserve","Consumable","consume","unconsume","Cursor","newValue","iterator","EmptyCursor","unary","UnaryCursor","ArrayCursor","cursor","KeysCursor","values","ValuesCursor","_a","_static_empty_decorators","static","private","has","obj","metadata","_metadata","_staticExtraInitializers","head","step","skip","hasNext","nextIndex","next","hasPrevious","previousIndex","previous","constructor","super","max","delete","Mapping","_super","domain","range","mapping","setPrototypeOf","canEqual","that","toString","Function","Piecewise","intervals","piecewise","interval","union","lo","hi","mid","u","s","Domain","x0","x1","Range","unit","contains","x00","x01","x10","x11","LinearDomain","y0","y1","y00","y01","y10","y11","y0Order","y1Order","LinearRange","Constant","Interpolate","interpolateTo","Interpolator","interpolator","IdentityInterpolator","NumberInterpolator","ArrayInterpolator","StepInterpolator","map","transform","InterpolatorMap","InterpolatorInterpolator","phase","interpolators","interpolatorCount","Timing","easing","t0","t1","timing","t","withDomain","withDuration","dt","overRange","Tweening","fromInit","Easing","linear","quadIn","quadOut","quadInOut","cubicIn","cubicOut","cubicInOut","quartIn","quartOut","quartInOut","expoIn","expoOut","expoInOut","circIn","circOut","circInOut","backIn","backOut","backInOut","elasticIn","elasticOut","elasticInOut","bounceIn","bounceOut","bounceInOut","v","pow","sqrt","st","m","PI","asin","sin","st1","invert","tweening","Scale","ContinuousScale","dx","LinearDomainInterpolator","LinearRangeInterpolator","LinearScale","scale","inverse","clampDomain","xMin","xMax","zMin","zMax","dy","z","dz","xSum","solveDomain","x2","y2","reflect","y3","x3","LinearScaleInterpolator","s0","s1","AssertException","message","Assert","condition","ok","notOk","lhs","rhs","notEqual","identical","notIdentical","lessThan","lessThanOrEqual","greaterThan","greaterThanOrEqual","notLessThan","notLessThanOrEqual","notGreaterThan","notGreaterThanOrEqual","instanceOf","notInstanceOf","compareLessThan","compareNotLessThan","compareLessThanOrEqual","compareNotLessThanOrEqual","compareEqual","compareNotEqual","compareGreaterThanOrEqual","compareNotGreaterThanOrEqual","compareGreaterThan","compareNotGreaterThan","Severity","level","label","isTrace","TraceLevel","isDebug","DebugLevel","isInfo","InfoLevel","isNote","NoteLevel","isWarning","WarningLevel","isError","ErrorLevel","isAlert","AlertLevel","isFatal","FatalLevel","localeCompare","trace","debug","info","note","warning","error","alert","fatal","TraceLabel","Trace","DebugLabel","Debug","InfoLabel","Info","NoteLabel","Note","WarningLabel","Warning","ErrorLabel","AlertLabel","Alert","FatalLabel","Fatal","Tag","Mark","_classSuper","line","column","withNote","at","start","end","Span","from","shift","display","output","Format","displayNumber","write","debugNumber","debugString","zero","_static_get_zero_decorators","tmp","OutputStyle","settings","isStyled","OutputSettings","lineSeparator","pretty","styled","precision","withLineSeparator","copy","isPretty","asPretty","asStyled","withPrecision","standard","prettyStyled","_static_standard_decorators","_static_pretty_decorators","_static_styled_decorators","_static_prettyStyled_decorators","InputException","InputSettings","stripped","isStripped","asStripped","_static_stripped_decorators","Input","trap","InputEmpty","InputDone","InputError","_static_done_decorators","id","isCont","isDone","isPart","asPart","part","seek","withId","withMark","withSettings","clone","StringInput","OutputException","Output","writeln","displayAny","debugAny","flush","tokens","full","OutputFull","OutputDone","OutputError","_static_full_decorators","StringOutput","isFull","token","fromCharCode","concat","bind","WriterException","Writer","feed","input","fork","asDone","asError","andThen","WriterSequence","WriterEnd","WriterDone","WriterError","_static_end_decorators","StringWriter","pull","Unicode","isSpace","isNewline","stringOutput","isFinite","floor","digits","decimal","debugChar","encodeHex","stringInput","prefix","prefixes","exponential","toExponential","exponentIndex","indexOf","exponent","slice","power","scaled","trimTrailingZeros","toFixed","i1","i0","duration","millis","separator","SECOND","MINUTE","HOUR","DAY","WEEK","weeks","days","hours","minutes","seconds","Base10","size","Base10NumberParser","parse","Base10IntegerWriter","Diagnostic","tag","severity","cause","lineDigits","countDigits","contextLines","displayMessage","displayAnchor","cont","displayContext","formatSeverity","reset","bold","displayLineLeadArrow","displayLineLead","causeOrder","displayLineLeadEllipsis","displayLines","displayNote","startLine","endLine","consumeLineText","displayLine","displayLineComment","displaySingleLine","displayStartLine","displayEndLine","displayMidLine","displayLineLeadNumber","displayLineText","comment","displayLineLeadComment","blueBold","padding","redBold","yellowBold","greenBold","cyanBold","magentaBold","source","unexpected","expected","InputBuffer","InputBufferEmpty","InputBufferDone","InputBufferError","withIndex","withLimit","capacity","remaining","tokenOrString","OutputBuffer","OutputBufferFull","OutputBufferDone","OutputBufferError","ParserException","diagnostic","Parser","ParserDone","ParserError","tail","ByteOutput","expand","toUint8Array","cloneArray","ByteOutputUint8Array","ByteOutputBuffer","buffer","Binary","initialCapacity","UtfErrorMode","isReplacement","UtfErrorModeFatal","fatalNonZero","replacement","UtfErrorModeReplacement","replacementNonZero","_static_fatal_decorators","_static_fatalNonZero_decorators","_static_replacement_decorators","_static_replacementNonZero_decorators","nonZero","replacementChar","isNonZero","asNonZero","Base16","alphabet","encodeDigit","uint8ArrayWriter","Base16Writer","writeUint8Array","writeInteger","width","Base16IntegerWriter","writeIntegerLiteral","writeLiteral","lowercase","uppercase","isDigit","decodeDigit","writeQuantum","parser","Base16Parser","parseUint8Array","_static_get_lowercase_decorators","_static_get_uppercase_decorators","Utf8DecodedOutput","errorMode","c3","have","c4","invalid","base16","Utf8EncodedOutput","Utf8","sizeOf","decodedOutput","sign","mode","Base10DecimalParser","Base64","w","Base64Parser","Base64Writer","standardPadded","Base64Standard","standardUnpadded","padded","urlPadded","Base64Url","urlUnpadded","url","_static_get_standardPadded_decorators","_static_get_standardUnpadded_decorators","_static_get_urlPadded_decorators","_static_get_urlUnpadded_decorators","isPadded","asPadded","base64","r","Affinity","Transient","Inherited","Intrinsic","Extrinsic","Reflexive","Shift","Mask","FastenerContext","metaclass","getMetaclass","contextMetaclass","FastenerContextMetaclass","classMap","slotMap","slots","getFastenerClass","fastenerName","fastenerClass","getFastenerSlot","tryFastener","owner","fastenerSlot","fastener","getOrCreate","superMetaclass","Fastener","template","classTemplate","decorate","fastenerType","binds","flagsInit","setFlags","flags","incrementVersion","version","setCoherentTime","coherentTime","parentType","parent","inheritName","getParentFastener","inheritInlet","inlet","InheritsFlag","willBindInlet","attachOutlet","inletVersion","onBindInlet","didBindInlet","bindInlet","setInherits","recohere","performance","now","uninheritInlet","willUnbindInlet","detachOutlet","onUnbindInlet","didUnbindInlet","unbindInlet","setDerived","outlet","inherits","willSetInherits","onSetInherits","didSetInherits","derived","DerivedFlag","affinity","hasAffinity","initAffinity","minAffinity","newAffinity","oldAffinity","willSetAffinity","onSetAffinity","didSetAffinity","setAffinity","decohere","coherent","DecoherentFlag","setCoherent","requireRecohere","decohereFastener","inletKeys","resolveInlets","inlets","inletKey","getFastener","attachInlets","inletVersions","detachInlets","contextType","attachFastener","mounted","mount","requireUpdate","updateFlags","getTransition","mountFasteners","fastenerSlots","unmountFasteners","unmount","MountedFlag","willMount","onMount","didMount","willUnmount","onUnmount","didUnmount","construct","declare","className","implement","extends","specialize","baseClass","refine","fastenerPrototype","extend","define","extendsClass","getter","decorateField","decorateGetter","fastenerSuperclass","initDecorators","superMetadata","getPrototypeOf","writable","defineField","fieldInitializers","instanceInitializers","defineGetter","initFasteners","FlagShift","FlagMask","Property","inletValue","getOutletValue","getInletValue","getInletValueOr","elseValue","outlets","Set","add","decohereOutlets","setValue","setIntrinsic","valueType","initValue","getValue","getValueOr","transformValue","equalValues","willSetValue","onSetValue","didSetValue","transition","deriveValue","inletValues","derivedValue","definedValue","tryValue","property","propertyClass","tryValueOr","propertyPrototype","valueDescriptor","Animator","inletState","getOutletState","getInletState","getInletStateOr","elseState","state","setState","getState","getStateOr","transformState","newState","oldState","tweened","willSetState","TweeningFlag","DivergedFlag","InterruptFlag","onSetState","didSetState","startTweening","didInterrupt","stopTweening","setInterpolatedValue","stateChanged","tweenInherited","tween","willTransition","didTransition","willStartTweening","onStartTweening","didStartTweening","willStopTweening","onStopTweening","didStopTweening","animator","animatorClass","animatorPrototype","transitionDescriptor","Timer","fire","delay","initDelay","setDelay","elapsed","deadline","scheduled","timeout","schedule","willSchedule","setTimeout","onSchedule","didSchedule","throttle","debounce","willCancel","clearTimeout","onCancel","didCancel","cancel","expire","willExpire","onExpire","didExpire","callback","EventHandler","bindsOwner","eventType","initEventType","initTarget","getTarget","setTarget","newTarget","oldTarget","willDetachTarget","onDetachTarget","didDetachTarget","willAttachTarget","onAttachTarget","didAttachTarget","EnabledFlag","attachEvents","detachEvents","options","attachEvent","addEventListener","detachEvent","removeEventListener","handle","event","enabled","willEnable","onEnable","didEnable","willDisable","onDisable","didDisable","bindComponent","component","detectComponent","unbindComponent","targetDescriptor","EventTimer","defer","Provider","serviceType","observes","creates","setService","service","inletService","getInletService","serviceKey","getService","newService","oldService","willDetachService","unmountService","onDetachService","deinitService","didDetachService","willAttachService","mountService","onAttachService","initService","didAttachService","parentService","parentProvider","insertChild","child","createService","global","Service","ManagedFlag","mountRootService","unmountRootService","remove","tryService","provider","providerClass","providerPrototype","serviceKeyDescriptor","Component","uid","nextSibling","previousSibling","firstChild","lastChild","childMap","decoherent","recohering","observers","componentType","setKey","attachParent","willAttachParent","setNextSibling","setPreviousSibling","setLastChild","setFirstChild","cascadeMount","onAttachParent","didAttachParent","detachParent","willDetachParent","cascadeUnmount","onDetachParent","didDetachParent","reattachParent","newNextSibling","oldNextSibling","oldPreviousSibling","newPreviousSibling","getNextSibling","siblingType","getPreviousSibling","getFirstChild","childType","getLastChild","forEachChild","insertChildMap","removeChildMap","getChild","setChild","newChild","oldChild","RemovingFlag","willRemoveChild","onRemoveChild","didRemoveChild","InsertingFlag","willInsertChild","onInsertChild","didInsertChild","cascadeInsert","appendChild","removeChild","prependChild","replaceChild","insertChildFlags","InsertChildFlags","inserting","bindChildFasteners","removeChildFlags","RemoveChildFlags","removing","unbindChildFasteners","removeChildren","reinsertChildFlags","ReinsertChildFlags","reinsertChild","willReinsertChild","onReinsertChild","didReinsertChild","sortChildren","comparator","children","sort","getTargetChild","getAncestor","ancestorType","ancestor","getRoot","rootType","base","isAncestorOf","descendant","commonAncestor","relative","mountFlags","MountFlags","mountChildren","unmountChildren","prev","immediate","bindFastener","bindChildFastener","ComponentRelation","unbindChildFastener","properties","enqueueFastener","recohereFasteners","observer","willObserve","onObserve","didObserve","willUnobserve","onUnobserve","didUnobserve","callObservers","args","method","componentClass","nextId","initComponent","willAttachComponent","onAttachComponent","didAttachComponent","deinitComponent","willDetachComponent","onDetachComponent","didDetachComponent","parentComponent","createComponent","ComponentRef","inletComponent","getInletComponent","setComponent","componentKey","getComponent","newComponent","oldComponent","attachComponent","detachComponent","insertComponent","removeComponent","deleteComponent","tryComponent","componentRef","componentKeyDescriptor","ComponentSet","insertComponentMap","components","OrderedFlag","removeComponentMap","hasComponent","addComponent","componentCount","addComponents","newComponents","componentId","setComponents","orderedComponents","targetComponent","attachComponents","detachComponents","insertComponents","removeComponents","deleteComponents","reinsertComponent","SortedFlag","ordered","sorted","willSort","onSort","didSort","compareChildren","compareTargetChild","a","Global","NodeCursor","pages","childIndex","childCursor","pageCursor","page","pageSize","reversePageCursor","BTreeContext","pageSplitSize","pageShouldSplit","arity","pageShouldMerge","BTree","root","BTreePage","getEntry","firstKey","entry","firstEntry","firstValue","lastKey","lastEntry","lastValue","nextKey","nextEntry","nextValue","previousKey","previousEntry","previousValue","oldRoot","newRoot","updated","balanced","drop","lower","take","upper","clear","cleared","reduced","identity","accumulator","combiner","fold","forEach","forEachKey","forEachValue","entries","reverseKeys","reverseValues","reverseEntries","tree","toStringTag","BTreeLeaf","minKey","maxKey","lookup","updatedSlot","insertedSlot","oldSlots","newSlots","removedSlot","split","newPages","newLeftPage","splitLeft","newRightPage","splitRight","newKnots","BTreeNode","slot","knots","oldPage","newPage","updatedPageSplit","updatedPage","oldKnots","newSize","oldPages","updatedPageMerge","midPages","midKnots","replacedPage","removedPage","newArity","newNode","BTreeNodeCursor","STreeContext","identify","STree","STreePage","RangeError","insert","newValues","pop","move","fromIndex","toIndex","splice","deleteCount","deleted","STreeLeaf","updatedItem","oldItems","oldSlot","insertedItem","STreeNode","subIndex","STreeNodeCursor","ConstraintSymbol","ConstraintInvalid","ConstraintSlack","isExternal","isDummy","isInvalid","addConstraintCondition","constraint","solver","removeConstraintCondition","updateConstraintSolution","ConstraintDummy","ConstraintError","ConstraintExpressionLike","ConstraintExpression","ConstraintConstant","constant","sum","expressions","terms","Map","expression","ConstraintTerm","variable","coefficient","ConstraintSum","product","ConstraintProduct","isConstant","plus","negative","minus","times","scalar","divide","ConstraintProperty","evaluateConstraintVariable","constrained","toNumber","initStrength","strength","ConstraintStrength","Strong","setStrength","ConstrainedFlag","constrain","conditionCount","stopConstraining","startConstraining","updateConstraintVariable","constraining","ConstrainingFlag","willStartConstraining","onStartConstraining","didStartConstraining","constraintScope","ConstraintScope","addConstraintVariable","willStopConstraining","onStopConstraining","didStopConstraining","removeConstraintVariable","setConstraintVariable","strengthDescriptor","ConstraintAnimator","Required","Medium","Weak","Unbound","clip","Constraint","scope","relation","isConstrained","hasConstraint","addConstraint","removeConstraint","ConstraintContext","ConstraintRow","symbol","cells","setSymbol","invalidate","setConstant","insertSymbol","insertRow","removeSymbol","negate","solveFor","solveForEx","coefficientFor","substitute","row","Item","record","Record","updatedAttr","setAttr","setSlot","appended","items","prepended","item","lt","Bool","absent","le","eq","ne","ge","gt","invoke","filter","predicate","selector","Selector","literal","evaluate","interpreter","cast","form","orElse","coerce","precedence","ItemInterpolator","extant","Extant","Absent","Value","globalScope","MathModule","commit","_static_globalScope_decorators","Field","isDefined","isDistinct","isDefinite","toValue","flattened","unflattened","of","header","headers","body","getAttr","getSlot","getField","getItem","conditional","thenTerm","elseTerm","or","and","lambda","stringValue","numberValue","booleanValue","FieldInterpolator","Text","Attr","Slot","field","$key","$value","ImmutableFlag","keyInterpolator","valueInterpolator","updatedValue","bitwiseOr","Expression","BitwiseOrOperator","bitwiseXor","BitwiseXorOperator","bitwiseAnd","BitwiseAndOperator","PlusOperator","MinusOperator","TimesOperator","DivideOperator","modulo","ModuloOperator","not","bitwiseNot","positive","Interpreter","isAliased","isMutable","alias","branch","AttrInterpolator","typeOrder","keyEquals","SlotInterpolator","LtOperator","LeOperator","EqOperator","NeOperator","GeOperator","GtOperator","LambdaFunc","builder","ValueBuilder","Num","Data","wrap","fromArray","fromObject","pushField","pushValue","build","fieldCount","isObject","valueCount","member","modified","lastIndexOf","subRecord","attr","pushScope","changed","oldItem","newItem","popScope","recordString","itemString","toArray","toObject","RecordCursor","RecordInterpolator","xs","ys","hashValue","RecordMap","AliasedFlag","direction","setItem","table","RecordMapView","hashTable","setAliased","pushAliased","setMutable","updateMutable","pushMutable","put","setAttrAliased","setAttrMutable","updateAttrMutable","setSlotAliased","setSlotMutable","updateSlotMutable","setItemAliased","setItemMutable","newItems","spliceAliased","spliceMutable","deleteAliased","deleteMutable","j","itemCount","clearAliased","clearMutable","l","getByte","setByte","setByteAliased","setByteMutable","addByte","addByteAliased","addByteMutable","addData","data","addUint8Array","addUint8ArrayAliased","addUint8ArrayMutable","asUint8Array","byteOffset","writeBase16","toBase16","writeBase64","toBase64","xn","yn","writer","fromBase16","fromBase64","DataOutput","valueOf","TextOutput","isInfinite","isUint32","Uint32Flag","isUint64","Uint64Flag","ceil","NumInterpolator","negativeZero","one","negativeOne","nan","uint32","uint64","Infinity","num","_static_zero_decorators","_static_negativeZero_decorators","_static_one_decorators","_static_negativeOne_decorators","_static_nan_decorators","TypeMask","true","false","_static_true_decorators","_static_false_decorators","_static_extant_decorators","_static_absent_decorators","ConditionalOperator","OrOperator","AndOperator","NotOperator","BitwiseNotOperator","NegativeOperator","PositiveOperator","Operator","binary","operand1","operator","operand2","operand","BinaryOperator","BinaryOperatorInterpolator","operand1Interpolator","operand2Interpolator","UnaryOperator","UnaryOperatorInterpolator","operandInterpolator","ifTerm","willOperate","didOperate","ConditionalOperatorInterpolator","ifTermInterpolator","thenTermInterpolator","elseTermInterpolator","InterpreterException","InterpreterSettings","maxScopeDepth","withMaxScopeDepth","scopeStack","scopeDepth","peekScope","getScope","oldScopeStack","newScopeStack","swapScope","newScope","oldScope","willSelect","didSelect","willTransform","didTransform","objects","scopes","argument1","argument2","InvokeOperator","func","Func","InvokeOperatorInterpolator","funcInterpolator","argsInterpolator","selected","forSelected","GetSelector","GetAttrSelector","GetItemSelector","descendants","FilterSelector","debugThen","IdentitySelector","KeysSelector","ValuesSelector","ChildrenSelector","DescendantsSelector","LiteralSelector","_static_identity_decorators","_static_keys_decorators","_static_values_decorators","_static_children_decorators","_static_descendants_decorators","then","mapSelected","oldField","newKey","filterSelected","bindings","params","binding","arg","BridgeFunc","MaxFunc","MinFunc","AbsFunc","CeilFunc","FloorFunc","RoundFunc","SqrtFunc","PowFunc","RateFunc","RandomFunc","rate","period","v0","dv","FormException","Form","withTag","TagForm","withUnit","UnitForm","forString","StringForm","forNumber","NumberForm","forBoolean","BooleanForm","forAny","AnyForm","forItem","ItemForm","forValue","ValueForm","_static_forString_decorators","_static_forNumber_decorators","_static_forBoolean_decorators","_static_forAny_decorators","_static_forItem_decorators","_static_forValue_decorators","mold","Recon","structureParser","ReconStructureParser","structureWriter","ReconStructureWriter","recon","parseBlockString","blockParser","sizeOfItem","sizeOfBlock","sizeOfBlockItem","writeItem","writeBlock","writeBlockItem","toBlockString","toData","encodedOutput","toBlockData","isWhitespace","isIdentStartChar","isIdentChar","toRecon","toReconBlock","parseRecon","BlockParser","keyParser","valueParser","block","valueBuilder","parseBlockExpression","AttrParser","parseString","parseIdent","parseBlock","BlockItemParser","fieldParser","parseAttr","recordBuilder","parseRecord","parseMarkup","parseRawString","parseNumber","parseData","parseSelector","InlineItemParser","RecordParser","MarkupParser","textOutput","parseInlineItem","DataParser","base64Parser","dataOutput","IdentParser","ident","StringParser","quote","RawStringParser","NumberParser","DecimalParser","HexadecimalParser","parseInteger","parseDecimal","LambdaFuncParser","bindingsParser","templateParser","parseConditionalOperator","ConditionalOperatorParser","ifParser","thenParser","elseParser","parseOrOperator","OrOperatorParser","lhsParser","rhsParser","parseAndOperator","AndOperatorParser","parseBitwiseOrOperator","BitwiseOrOperatorParser","parseBitwiseXorOperator","BitwiseXorOperatorParser","parseBitwiseAndOperator","BitwiseAndOperatorParser","parseComparisonOperator","ComparisonOperatorParser","parseAttrExpression","AttrExpressionParser","parseAdditiveOperator","AdditiveOperatorParser","parseMultiplicativeOperator","MultiplicativeOperatorParser","parsePrefixOperator","PrefixOperatorParser","operandParser","parseInvokeOperator","InvokeOperatorParser","exprParser","argsParser","parsePrimary","expr","PrimaryParser","parseLiteral","LiteralParser","SelectorParser","ReconParser","parseBlockItem","parseLambdaFunc","bool","AttrWriter","sizeOfValue","isExtant","sizeOfBlockValue","writeValue","writeBlockValue","SlotWriter","BlockWriter","inBlock","inMarkup","inBraces","inBrackets","first","markupSafe","isExpression","isAttr","isText","sizeOfMarkupText","isRecord","isMarkupSafe","isField","isBool","isValue","isIdent","isNum","sizeOfSlot","writeMarkupText","writeSlot","PrimaryWriter","inParens","MarkupTextWriter","text","escape","DataWriter","IdentWriter","LambdaFuncWriter","sizeOfPrimary","writePrimary","ConditionalOperatorWriter","InfixOperatorWriter","writeString","PrefixOperatorWriter","InvokeOperatorWriter","LiteralSelectorWriter","sizeOfThen","writeThen","GetSelectorWriter","GetAttrSelectorWriter","GetItemSelectorWriter","KeysSelectorWriter","ValuesSelectorWriter","ChildrenSelectorWriter","DescendantsSelectorWriter","FilterSelectorWriter","ReconWriter","sizeOfAttr","writeAttr","isBlockSafe","sizeOfRecord","writeRecord","sizeOfData","writeData","sizeOfText","writeText","sizeOfNum","writeNum","sizeOfUint32","writeUint32","sizeOfUint64","writeUint64","sizeOfBool","writeBool","sizeOfLambdaFunc","writeLambdaFunc","sizeOfConditionalOperator","writeConditionalOperator","sizeOfInfixOperator","writeInfixOperator","sizeOfPrefixOperator","writePrefixOperator","sizeOfInvokeOperator","writeInvokeOperator","sizeOfIdentitySelector","writeIdentitySelector","sizeOfThenIdentitySelector","writeThenIdentitySelector","sizeOfLiteralSelector","writeLiteralSelector","sizeOfThenLiteralSelector","writeThenLiteralSelector","sizeOfGetSelector","writeGetSelector","sizeOfThenGetSelector","writeThenGetSelector","sizeOfGetAttrSelector","writeGetAttrSelector","sizeOfThenGetAttrSelector","writeThenGetAttrSelector","sizeOfGetItemSelector","writeGetItemSelector","sizeOfThenGetItemSelector","writeThenGetItemSelector","sizeOfKeysSelector","writeKeysSelector","sizeOfThenKeysSelector","writeThenKeysSelector","sizeOfValuesSelector","writeValuesSelector","sizeOfThenValuesSelector","writeThenValuesSelector","sizeOfChildrenSelector","writeChildrenSelector","sizeOfThenChildrenSelector","writeThenChildrenSelector","sizeOfDescendantsSelector","writeDescendantsSelector","sizeOfThenDescendantsSelector","writeThenDescendantsSelector","sizeOfFilterSelector","writeFilterSelector","sizeOfThenFilterSelector","writeThenFilterSelector","sizeOfExtant","writeExtant","sizeOfAbsent","writeAbsent","isSlot","sizeOfSelector","sizeOfOperator","sizeOfFunc","writeSelector","writeOperator","writeFunc","UriLike","Uri","UriInit","scheme","authority","path","query","fragment","withScheme","UriScheme","schemePart","withSchemePart","schemeName","withSchemeName","withAuthority","UriAuthority","authorityPart","withAuthorityPart","user","withUser","userPart","withUserPart","username","withUsername","password","withPassword","host","withHost","hostPart","withHostPart","hostAddress","hostName","withHostName","hostIPv4","withHostIPv4","hostIPv6","withHostIPv6","port","withPort","portPart","withPortPart","portNumber","withPortNumber","withPath","UriPath","pathPart","withPathPart","pathName","withPathName","withName","parentPath","basePath","appendedPath","appendedSlash","appendedSegment","segment","prependedPath","prependedSlash","prependedSegment","withQuery","UriQuery","queryPart","withQueryPart","updatedQuery","removedQuery","appendedQuery","prependedQuery","withFragment","UriFragment","fragmentPart","withFragmentPart","fragmentIdentifier","withFragmentIdentifier","endpoint","resolve","removeDotSegments","isAbsolute","merge","unresolve","absolute","undefined","unmerge","uri","parseCache","UriParser","ParseCacheCapacity","pathBuilder","UriPathBuilder","queryBuilder","UriQueryBuilder","UriForm","isUnreservedChar","isSubDelimChar","isSchemeChar","isUserInfoChar","isUserChar","isHostChar","isPathChar","isQueryChar","isParamChar","isFragmentChar","isAlpha","toLowerCase","writeScheme","writeUserInfo","userInfo","writeEncoded","writeUser","writeHost","address","writeHostLiteral","writePathSegment","writeQuery","writeParam","param","writeFragment","writePctEncoded","_static_parseCache_decorators","_static_form_decorators","schemeParser","authorityParser","pathParser","queryParser","fragmentParser","look","UriSchemeParser","addSlash","UriPathParser","slash","UriAuthorityParser","UriQueryParser","UriFragmentParser","UriSchemeLike","_static_undefined_decorators","decodedString","UriAuthorityLike","UriAuthorityInit","UriUser","UriHost","hostname","ipv4","ipv6","hostIPv5","UriPort","number","userParser","hostParser","portParser","UriUserParser","UriHostParser","UriPortParser","UriUserLike","UriUserInit","usernameOutput","passwordOutput","UriHostLike","UriHostUndefined","UriHostName","UriHostIPv4","UriHostIPv6","UriHostLiteralParser","UriHostAddressParser","UriPortLike","UriPathLike","isRelative","addPath","addSegment","isSegment","foot","isSubpathOf","UriPathSlash","rest","relativeTo","difference","commonSlash","UriPathEmpty","UriPathSegment","pathForm","UriPathForm","_static_pathForm_decorators","setTail","dealias","_static_slash_decorators","last","aliased","xi","UriQueryLike","addParam","addQuery","UriQueryUndefined","UriQueryParam","keyOutput","valueOutput","UriFragmentLike","LengthLike","Length","units","basis","combine","emValue","pxValue","emUnit","remValue","remUnit","pctValue","pctUnit","px","PxLength","em","EmLength","rem","RemLength","pct","PctLength","to","LengthInterpolator","UnitlessLength","unitless","fromCssValue","CSSUnitValue","defaultUnits","fromValue","LengthParser","LengthForm","Node","node","Element","fontSize","getComputedStyle","parseFloat","parentNode","document","documentElement","toCssValue","l0","l1","e","unitsOutput","AngleLike","Angle","norm","total","deg","DegAngle","degValue","rad","RadAngle","radValue","grad","GradAngle","gradValue","turn","TurnAngle","turnValue","AngleInterpolator","AngleParser","AngleForm","a0","a1","angle","R2VectorLike","R2Vector","R2VectorInit","R2VectorInterpolator","v1","R2ShapeLike","R2Shape","R2PointInit","R2PointTuple","R2SegmentInit","R2BoxInit","R2Circle","R2Box","yMin","yMax","bounds","R2Point","fromTuple","R2Segment","R2CircleInit","R2Path","R2PointLike","vector","intersects","transformX","transformY","R2PointInterpolator","origin","tuple","_static_origin_decorators","p0","p1","R2Curve","draw","drawMove","drawRest","transformDraw","transformDrawMove","transformDrawRest","writePath","writeMove","writeRest","toPathString","outputSettings","quadratic","R2QuadraticCurve","cubic","R2CubicCurve","elliptic","cx","cy","rx","ry","phi","da","R2EllipticCurve","R2CurveParser","R2BezierCurve","x0Parser","y0Parser","command","R2SegmentParser","R2QuadraticCurveParser","R2CubicCurveParser","R2EllipticCurveParser","parseRest","R2SegmentLike","interpolateX","interpolateY","interpolate","containsPoint","containsSegment","ax","ay","bx","by","intersectsPoint","intersectsSegment","py","qx","qy","sx","sy","pqx","pqy","pqr","rs","rr","sr","moveTo","lineTo","R2SegmentInterpolator","x1Parser","y1Parser","x12","y12","x02","y02","quadraticCurveTo","x2Parser","y2Parser","x23","y23","x13","y13","x03","y03","bezierCurveTo","x3Parser","y3Parser","cos","a0x","a0y","a1x","a1y","b0x","b0y","b1x","b1y","b0","atan2","b1","db","toEndpoints","ellipse","ccw","large","sweep","cosPhi","sinPhi","cosA0","sinA0","cosA1","sinA1","fromEndpoints","x0p","y0p","rx2","ry2","x0p2","y0p2","sp","cxp","cyp","ux","uy","vx","vy","uv","uu","vv","acos","rxParser","ryParser","phiParser","R2Spline","curves","closed","boundingBox","pathString","isClosed","c0","curves0","curves1","subdivide","oldCurves","newCurves","curve","closePath","R2SplineBuilder","open","R2SplineParser","arcTo","dx01","dy01","dx12","dy12","r0x","r0y","r1x","r1y","r0x0","r0y0","r0x1","r0y1","r1x1","r1y1","r1x2","r1y2","intersection","arc","rect","h","xParser","yParser","curveParser","prevCurve","R2PathLike","splines","splines0","splines1","oldSplines","newSplines","spline","toAttributeString","R2PathBuilder","R2PathParser","splineParser","R2CircleLike","containsBox","containsCircle","dx0","dy0","dx1","dy1","r2","dxMin","dyMin","dxMax","dyMax","intersectsBox","intersectsCircle","unitX","unitY","d","dcx0","dcy0","dcx1","dcy1","uc","u0","u1","R2CircleInterpolator","R2BoxLike","height","top","right","bottom","left","center","hitY","hitX","d0","d1","R2BoxInterpolator","R2Group","shapes","oldShapes","newShapes","shape","TransformLike","Transform","translate","translateX","translateY","scaleX","scaleY","rotate","skew","skewX","skewY","toMatrix","toAffine","toCssTransformComponent","CSSTransformValue","AffineTransformInterpolator","IdentityTransform","TranslateTransform","ScaleTransform","RotateTransform","SkewTransform","affine","tx","ty","AffineTransform","list","transforms","TransformList","fromCssTransform","fromCssTransformComponent","CSSTranslate","CSSRotate","CSSScale","CSSSkew","CSSMatrixComponent","TransformListParser","TransformForm","TransformParser","identOutput","TranslateTransformParser","ScaleTransformParser","RotateTransformParser","SkewTransformParser","AffineTransformParser","CSSKeywordValue","conformsTo","TranslateTransformLike","TranslateTransformInterpolator","f0","f1","zParser","ScaleTransformLike","ScaleTransformInterpolator","RotateTransformLike","cosA","sinA","RotateTransformInterpolator","angleParser","SkewTransformLike","tan","SkewTransformInterpolator","AffineTransformLike","multiply","m00","m10","m01","m11","m02","m12","det","MIN_VALUE","DOMMatrix","fromMatrix","matrix","entryParser","TransformListLike","yi","inverseTransforms","TransformListInterpolator","transforms0","transforms1","transformParser","GeoProjection","GeoShapeLike","GeoShape","GeoPointInit","GeoPointTuple","GeoSegmentInit","GeoSplinePoints","GeoPathSplines","GeoTileInit","GeoTileTuple","GeoBoxInit","GeoBox","lngMin","latMin","lngMax","latMax","GeoPoint","GeoSegment","GeoSpline","fromPoints","GeoPath","fromSplines","GeoTile","GeoPointLike","lng","lat","project","normalized","oldLng","oldLat","newLng","normalizeLng","newLat","normalizeLat","GeoPointInterpolator","lng0","lat0","lng1","lat1","uw","ue","GeoCurve","GeoSegmentLike","interpolateLng","interpolateLat","lng01","lat01","forEachCoord","forEachCoordRest","GeoSegmentInterpolator","GeoSplineLike","GeoSplineBuilder","points","p2","GeoPathLike","centroid","lngSum","latSum","GeoPathBuilder","GeoTileLike","unprojectX","unprojectY","west","south","east","north","southWest","northWest","southEast","northEast","southWestTile","northWestTile","southEastTile","northEastTile","parentTile","containsTile","GeoBoxLike","intersectsTile","bottomLeft","topRight","atan","exp","_static_root_decorators","GeoBoxInterpolator","globe","_static_globe_decorators","GeoGroup","GeoJsonPosition","GeoJson","toShape","GeoJsonFeature","GeoJsonFeatureCollection","toShapes","GeoJsonGeometry","GeoJsonPoint","GeoJsonMultiPoint","GeoJsonLineString","GeoJsonMultiLineString","GeoJsonPolygon","GeoJsonMultiPolygon","GeoJsonGeometryCollection","position","coordinates","positions","lineString","multiLineString","polygons","polygon","multiPolygon","o","geometries","feature","geometry","features","TimeZoneLike","TimeZone","isUTC","isLocal","getTimezoneOffset","utc","local","forOffset","forName","zone","TimeZoneForm","_static_utc_decorators","_static_local_decorators","DateTimeLike","DateTime","DateTimeInit","time","year","toUTCLocalDate","getUTCFullYear","withYear","month","day","hour","minute","second","millisecond","date","setUTCFullYear","setUTCMonth","setUTCDate","setUTCHours","setUTCMinutes","setUTCSeconds","setUTCMilliseconds","fromUTCLocalDate","getUTCMonth","withMonth","getUTCDate","withDay","getUTCHours","withHour","getUTCMinutes","withMinute","getUTCSeconds","withSecond","getUTCMilliseconds","withMillisecond","weekday","getUTCDay","toDate","DateTimeInterpolator","format","DateTimeFormat","iso8601","writeDate","current","UTC","positional","DateTimeForm","DateTimeParser","dateParser","DateTimeLocale","periods","Periods","weekdays","Weekdays","shortWeekdays","ShortWeekdays","months","Months","shortMonths","ShortMonths","DateTimeSpecifiers","locale","specifiers","Y","monthOfYear","B","shortMonth","dayOfMonth","A","shortWeekday","H","hour24","I","hour12","M","S","L","withLocale","parseDate","parseDateTime","Year","YearFormat","MonthOfYear","MonthOfYearFormat","MonthFormat","Month","ShortMonthFormat","ShortMonth","padChar","DayOfMonthZeroPadded","DayOfMonthFormat","DayOfMonthSpacePadded","WeekdayFormat","Weekday","ShortWeekdayFormat","ShortWeekday","Hour24","Hour24Format","Hour12ZeroPadded","Hour12Format","Hour12SpacePadded","PeriodFormat","Period","Minute","MinuteFormat","Second","SecondFormat","Millisecond","MillisecondFormat","pattern","PatternFormat","Iso8601","parseDateNumber","factory","desc","minDigits","maxDigits","term","parseDateString","writeDateNumber2","writeDateNumber3","writeDateNumber4","YearParser","MonthOfYearParser","MonthParser","ShortMonthParser","DayOfMonthParser","WeekdayParser","ShortWeekdayParser","Hour24Parser","Hour12Parser","PeriodParser","MinuteParser","SecondParser","MillisecondParser","charAt","PatternParser","TimeInterval","ds","FilterTimeInterval","YearInterval","MonthInterval","week","Week","WeekInterval","Day","DayInterval","Hour","HourInterval","MinuteInterval","SecondInterval","MillisecondInterval","years","milliseconds","MillisPerSecond","MillisPerMinute","MillisPerHour","UnitTimeInterval","every","YearsInterval","stride","dtz","MillisecondsInterval","TimeDomain","TimeRange","t0Min","t0Max","t1Min","t1Max","tMin","tMax","TimeDomainInterpolator","t00","t01","t10","t11","TimeRangeInterpolator","TimeScale","tSum","t2","t3","TimeScaleInterpolator","ConstraintGroup","constraints","enableConstraints","disableConstraints","ConstraintSolver","constraintVariables","rows","infeasible","objective","artificial","invalidated","createRow","addConstraintRow","willAddConstraint","subject","chooseSubject","marker","addWithArtificialVariable","optimize","didAddConstraint","updateSolution","removeConstraintRow","willRemoveConstraint","removeConstraintEffects","leaving","getMarkerLeavingSymbol","didRemoveConstraint","constraintVariable","hasConstraintVariable","willAddConstraintVariable","didAddConstraintVariable","willRemoveConstraintVariable","didRemoveConstraintVariable","delta","willSetConstraintVariable","dualOptimize","other","didSetConstraintVariable","basic","slack","eplus","eminus","dummy","success","entering","anyPivotableSymbol","getEnteringSymbol","getLeavingSymbol","getDualEnteringSymbol","ratio","MAX_VALUE","coratio","found","r1","third","removeMarkerEffects","UriCache","resolveCache","unresolveCache","keyForm","valueForm","pair"],"mappings":"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","x_google_ignoreList":[0]}