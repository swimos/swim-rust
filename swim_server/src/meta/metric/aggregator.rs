// Copyright 2015-2020 SWIM.AI inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::agent::lane::model::supply::supplier::TrySupplyError;
use crate::agent::lane::model::supply::SupplyLane;
use crate::meta::metric::{AggregatorError, AggregatorErrorKind, MetricStage};
use crate::meta::metric::{STOP_CLOSED, STOP_OK};
use futures::FutureExt;
use futures::StreamExt;
use futures::{select, Stream};
use std::collections::{HashMap, HashSet};
use std::num::NonZeroUsize;
use std::time::{Duration, Instant};
use swim_common::warp::path::RelativePath;
use tokio::sync::mpsc;
use tokio::sync::mpsc::error::TrySendError;
use tracing::{event, Level};
use utilities::sync::trigger;

const LANE_NOT_FOUND: &str = "Lane not found";
const REMOVING_LANE: &str = "Lane closed, removing";

/// A trait for defining a metric which is keyed by a relative path and has a value of some kind.
/// This allows for abstractions over the various metric types that are reported on a server: node,
/// lane, uplink pulses etc.
pub trait AddressedMetric {
    /// A metric payload.
    type Metric: Send + Sync + Clone + Default;

    /// Consume this addressed metric and return an origin address and the metric itself.
    fn unpack(self) -> (RelativePath, Self::Metric);

    /// Create an instance of this addressed metric from its payload and address.
    fn pack(payload: Self::Metric, path: RelativePath) -> Self;
}

/// A trait for abstracting over metrics. Metrics are fed forward in the accumulation pipeline,
/// accumulating the metric with the previous stage: `In`.
pub trait Metric<In>: Clone {
    /// The stage in the pipeline that this metric is.
    const METRIC_STAGE: MetricStage;

    /// The type of pulse that is generated by this metric.
    type Pulse: Send + Sync + 'static;

    /// Accumulate a new `In` that has been received and update this metric.
    fn accumulate(&mut self, new: In);

    /// Collect an updated instance of this metric for forwarding to the next stage in the pipeline
    /// and a pulse; resetting the inner state ready for the next `In` to be accumulated.
    fn collect(&mut self) -> (Self, Self::Pulse);
}

/// Represents the state of a metric and its pulse lane.
pub struct MetricState<M, In>
where
    In: AddressedMetric,
    M: Metric<In::Metric>,
{
    /// Whether the metric has had data reported since its last report time.
    requires_flush: bool,
    /// The time that this metric was last reported.
    last_report: Instant,
    /// The inner metric.
    inner: M,
    /// The metric's pulse lane.
    lane: SupplyLane<M::Pulse>,
}

impl<M, In> MetricState<M, In>
where
    In: AddressedMetric,
    M: Metric<In::Metric>,
{
    pub fn new(profile: M, lane: SupplyLane<M::Pulse>) -> MetricState<M, In> {
        MetricState {
            requires_flush: true,
            last_report: Instant::now(),
            inner: profile,
            lane,
        }
    }

    /// Accumulate `profile` and then flush the profile and its pulse
    fn flush(&mut self, profile: In::Metric) -> M {
        let MetricState {
            inner,
            lane,
            requires_flush,
            ..
        } = self;

        *requires_flush = false;
        inner.accumulate(profile);

        let (profile, pulse) = inner.collect();
        let _ = lane.try_send(pulse);

        profile
    }

    /// Flush the profile.
    fn flush_pulse(&mut self) {
        let MetricState { inner, lane, .. } = self;

        let (_, pulse) = inner.collect();
        let _ = lane.try_send(pulse);
    }

    /// Accumulate `profile`, flush the pulse if the last report time is greater than `sample_rate`.
    /// Returns a result with an optional profile if the report time is greater than `sample_rate`,
    /// or an error if the pulse lane is closed.
    fn report(&mut self, profile: In::Metric, sample_rate: Duration) -> Result<Option<M>, ()> {
        let MetricState {
            last_report,
            inner,
            lane,
            requires_flush,
        } = self;

        inner.accumulate(profile);

        if last_report.elapsed() > sample_rate {
            let (profile, pulse) = inner.collect();

            match lane.try_send(pulse) {
                Ok(_) | Err(TrySupplyError::Capacity) => {
                    *last_report = Instant::now();
                    *requires_flush = false;

                    Ok(Some(profile))
                }
                Err(TrySupplyError::Closed) => Err(()),
            }
        } else {
            *requires_flush = true;
            Ok(None)
        }
    }
}

/// An aggregator for an addressed metric.
pub struct AggregatorTask<In, M, S>
where
    In: AddressedMetric,
    S: Stream<Item = In> + Unpin,
    M: Metric<In::Metric>,
{
    /// A stop signal for consuming and producing metrics. When this is triggered, all pending
    /// messages are flushed regardless of their last report time.
    stop_rx: trigger::Receiver,
    /// The rate at which profiles and pulses will be reported.
    sample_rate: Duration,
    /// A map keyed by lane URIs and has a corresponding state for its metrics.
    pulse_lanes: HashMap<RelativePath, MetricState<M, In>>,
    /// A stream of profiles which this aggregator will accumulate and generate pulses and profiles
    /// from.
    input: S,
    /// A channel for sending accumulated profiles to.
    output: mpsc::Sender<M>,
}

impl<In, M, S> AggregatorTask<In, M, S>
where
    In: AddressedMetric,
    S: Stream<Item = In> + Unpin,
    M: Metric<In::Metric>,
{
    pub fn new(
        pulse_lanes: HashMap<RelativePath, MetricState<M, In>>,
        sample_rate: Duration,
        stop_rx: trigger::Receiver,
        input: S,
        output: mpsc::Sender<M>,
    ) -> AggregatorTask<In, M, S> {
        AggregatorTask {
            stop_rx,
            sample_rate,
            pulse_lanes,
            input,
            output,
        }
    }

    /// Runs the aggregator and yields executing back to the runtime every `yield_after`.
    pub async fn run(self, yield_after: NonZeroUsize) -> Result<(), AggregatorError> {
        let AggregatorTask {
            stop_rx,
            sample_rate,
            mut pulse_lanes,
            input,
            output,
        } = self;

        let mut removed_lanes = HashSet::new();
        let mut fused_metric_rx = input.fuse();
        let mut fused_trigger = stop_rx.fuse();
        let mut iteration_count: usize = 0;

        let yield_mod = yield_after.get();

        let error = loop {
            let event: Option<In> = select! {
                _ = fused_trigger => {
                    event!(Level::DEBUG, STOP_OK);

                    drain(&mut fused_metric_rx, &mut pulse_lanes, &output);

                    return Ok(());
                },
                metric = fused_metric_rx.next() => metric,
            };
            match event {
                None => {
                    event!(Level::WARN, STOP_CLOSED);
                    break AggregatorErrorKind::AbnormalStop;
                }
                Some(profile) => {
                    let (path, payload) = profile.unpack();

                    let did_error = match pulse_lanes.get_mut(&path) {
                        Some(state) => match state.report(payload, sample_rate) {
                            Ok(Some(pulse)) => {
                                if let Err(TrySendError::Closed(_)) = output.try_send(pulse) {
                                    break AggregatorErrorKind::ForwardChannelClosed;
                                }
                                false
                            }
                            Ok(None) => false,
                            Err(_) => true,
                        },
                        None => {
                            if removed_lanes.get(&path).is_none() {
                                event!(Level::ERROR, ?path, LANE_NOT_FOUND);
                            }

                            false
                        }
                    };

                    if did_error {
                        event!(Level::DEBUG, ?path, REMOVING_LANE);
                        let _ = pulse_lanes.remove(&path);
                        removed_lanes.insert(path);
                    }
                }
            }

            iteration_count = iteration_count.wrapping_add(1);
            if iteration_count % yield_mod == 0 {
                tokio::task::yield_now().await;
            }
        };

        event!(Level::ERROR, %error, STOP_CLOSED);

        return Err(AggregatorError {
            aggregator: M::METRIC_STAGE,
            error,
        });
    }
}

/// Drains all the pending messages from `stream` and flushes any pending pulses and profiles.
fn drain<In, M, S>(
    stream: &mut S,
    pulse_lanes: &mut HashMap<RelativePath, MetricState<M, In>>,
    output: &mpsc::Sender<M>,
) where
    In: AddressedMetric,
    S: Stream<Item = In> + Unpin,
    M: Metric<In::Metric>,
{
    while let Some(profile) = stream.next().now_or_never().flatten() {
        let (path, payload) = profile.unpack();

        if let Some(item) = pulse_lanes.get_mut(&path) {
            let pulse = item.flush(payload);
            let _ = output.try_send(pulse);
        }
    }

    pulse_lanes
        .iter_mut()
        .filter(|(_k, v)| v.requires_flush)
        .for_each(|(_k, item)| {
            item.flush_pulse();
        });
}
