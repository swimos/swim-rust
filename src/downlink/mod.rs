// Copyright 2015-2020 SWIM.AI inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::pin::Pin;

use futures::{future, stream, Stream, StreamExt};
use futures_util::select_biased;
use pin_utils::pin_mut;
use tokio::sync::mpsc;
use tokio::sync::oneshot;
use tokio::task::JoinHandle;

use crate::sink::item;
use crate::sink::item::ItemSink;
use futures::stream::FusedStream;
use std::fmt::Debug;
use tokio::sync::watch;

pub mod map;
pub mod raw;
pub mod value;

pub(self) use self::raw::create_downlink;

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum DownlinkError {
    DroppedChannel,
    TaskPanic,
    OperationStreamEnded,
    TransitionError,
}

impl<T> From<mpsc::error::SendError<T>> for DownlinkError {
    fn from(_: mpsc::error::SendError<T>) -> Self {
        DownlinkError::DroppedChannel
    }
}

impl<T> From<mpsc::error::TrySendError<T>> for DownlinkError {
    fn from(_: mpsc::error::TrySendError<T>) -> Self {
        DownlinkError::DroppedChannel
    }
}

impl<T> From<watch::error::SendError<T>> for DownlinkError {
    fn from(_: watch::error::SendError<T>) -> Self {
        DownlinkError::DroppedChannel
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
enum DownlinkState {
    Unlinked,
    Linked,
    Synced,
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub enum Message<M> {
    Linked,
    Synced,
    Action(M),
    Unlinked,
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub enum Command<A> {
    Sync,
    Action(A),
    Unlink,
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct Event<A>(pub A, pub bool);

#[derive(Clone, PartialEq, Eq, Debug)]
pub enum Operation<M, A> {
    Start,
    Message(Message<M>),
    Action(A),
    Close,
}

/// The state of a downlink and the receivers of events that can be generated by it.
#[derive(Clone, Debug)]
struct Model<State> {
    state: DownlinkState,
    data_state: State,
}

impl<State> Model<State> {
    fn new(init: State) -> Model<State> {
        Model {
            state: DownlinkState::Unlinked,
            data_state: init,
        }
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
struct Response<Ev, Cmd> {
    event: Option<Event<Ev>>,
    command: Option<Command<Cmd>>,
    error: Option<TransitionError>,
    terminate: bool,
}

impl<Ev, Cmd> Response<Ev, Cmd> {
    fn none() -> Response<Ev, Cmd> {
        Response {
            event: None,
            command: None,
            error: None,
            terminate: false,
        }
    }

    fn for_event(event: Event<Ev>) -> Response<Ev, Cmd> {
        Response {
            event: Some(event),
            command: None,
            error: None,
            terminate: false,
        }
    }

    fn for_command(command: Command<Cmd>) -> Response<Ev, Cmd> {
        Response {
            event: None,
            command: Some(command),
            error: None,
            terminate: false,
        }
    }

    fn of(event: Event<Ev>, command: Command<Cmd>) -> Response<Ev, Cmd> {
        Response {
            event: Some(event),
            command: Some(command),
            error: None,
            terminate: false,
        }
    }

    fn then_terminate(mut self) -> Self {
        self.terminate = true;
        self
    }

    fn with_error(mut self, err: TransitionError) -> Self {
        self.error = Some(err);
        self
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub enum TransitionError {
    ReceiverDropped,
    SideEffectFailed,
    IllegalTransition(String),
}

/// This trait defines the interface that must be implemented for the state type of a downlink.
trait StateMachine<M, A>: Sized {
    /// Type of events that will be issued to the owner of the downlink.
    type Ev: Unpin;
    /// Type of commands that will be sent out to the Warp connection.
    type Cmd: Unpin;

    /// For an operation on the downlink, generate output messages.
    fn handle_operation(
        model: &mut Model<Self>,
        op: Operation<M, A>,
    ) -> Response<Self::Ev, Self::Cmd>;
}
